ca65 V2.9.2 - (C) Copyright 1998-2000 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; Common AGD engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ;----------------------------------------------
000000r 1               	.DEFINE asm_code $0220
000000r 1               	.DEFINE header   1		; Header Wouter Ras emulator
000000r 1               	.DEFINE filenaam "AGD"
000000r 1               
000000r 1               .org asm_code-22*header
00020A  1               
00020A  1               .IF header
00020A  1               ;********************************************************************
00020A  1               ; ATM Header for Atom emulator Wouter Ras
00020A  1               
00020A  1               name_start:
00020A  1  41 47 44     	.byte filenaam			; Filename
00020D  1               name_end:
00020D  1  00 00 00 00  	.repeat 16-name_end+name_start	; Fill with 0 till 16 chars
000211  1  00 00 00 00  
000215  1  00 00 00 00  
00021A  1               	  .byte $0
00021A  1               	.endrep
00021A  1               
00021A  1  20 02        	.word asm_code			; 2 bytes startaddress
00021C  1  20 02        	.word exec			; 2 bytes linkaddress
00021E  1  2A 21        	.word eind_asm-start_asm	; 2 bytes filelength
000220  1               
000220  1               ;********************************************************************
000220  1               .ENDIF
000220  1               
000220  1               exec:
000220  1               start_asm:
000220  1               	.include "z80-zp.inc"
000220  1               	.include "game.inc"
000220  2               .segment "ZEROPAGE"
000220  2               
000220  2               ws	 = $60
000220  2               
000220  2               z80_f	 = ws+$00
000220  2               z80_a	 = ws+$01
000220  2               z80_af	 = z80_f
000220  2               
000220  2               z80_c	 = ws+$02
000220  2               z80_b	 = ws+$03
000220  2               z80_bc	 = z80_c
000220  2               
000220  2               z80_e	 = ws+$04
000220  2               z80_d	 = ws+$05
000220  2               z80_de	 = z80_e
000220  2               
000220  2               z80_l	 = ws+$06
000220  2               z80_h	 = ws+$07
000220  2               z80_hl	 = z80_l
000220  2               
000220  2               z80_x    = ws+$08
000220  2               z80_i    = ws+$09
000220  2               z80_ix	 = z80_x
000220  2               
000220  2               z80_iy	 = ws+$0a
000220  2               
000220  2               z80_fp	 = ws+$0c
000220  2               z80_ap	 = ws+$0d
000220  2               
000220  2               z80_cp	 = ws+$0e
000220  2               z80_bp	 = ws+$0f
000220  2               z80_bcp	 = z80_cp
000220  2               
000220  2               z80_ep	 = ws+$10
000220  2               z80_dp	 = ws+$11
000220  2               z80_dep	 = z80_ep
000220  2               
000220  2               z80_lp	 = ws+$12
000220  2               z80_hp	 = ws+$13
000220  2               z80_hlp	 = z80_lp
000220  2               
000220  2               z80_sp   = ws+$14
000220  2               
000220  2               z80_reg0 = ws+$16
000220  2               z80_reg1 = ws+$17
000220  2               z80_reg2 = ws+$18
000220  2               z80_reg3 = ws+$19
000220  2               
000220  2               z80_r	 = ws+$1a
000220  2               
000220  2               
000220  1               	.include "z80.asm"
000220  2               .include "testdiv.inc" 
000220  2               
000220  3               ; Game engine code --------------------------------------------------------------
000220  3               
000220  3               ; Arcade Game Designer.
000220  3               ; (C) 2008 Jonathan Cauldwell.
000220  3               ; ZX Spectrum Next Engine v0.1.
000220  3               
000220  3               ; Global definitions ------------------------------------------------------------
000220  3               
000220  3               	FONT = font		; Font address
000220  3               
000220  3               ; Block characteristics.
000220  3               
000220  3               	PLATFM = 1		; platform.
000220  3               	WALL = PLATFM + 1	; solid wall.
000220  3               	LADDER = WALL + 1	; ladder.
000220  3               	FODDER = LADDER + 1	; fodder block.
000220  3               	DEADLY = FODDER + 1	; deadly block.
000220  3               	CUSTOM = DEADLY + 1	; custom block.
000220  3               	WATER  = CUSTOM + 1	; water block.
000220  3                       COLECT = WATER + 1      ; collectable block.
000220  3                       NUMTYP = COLECT + 1     ; number of types.
000220  3               
000220  3               ; Sprites.
000220  3               
000220  3               	NUMSPR = 12		; number of sprites.
000220  3               	TABSIZ = 17		; size of each entry.
000220  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
000220  3               	NMESIZ = 4		; bytes stored in nmetab for each sprite.
000220  3               	var_X  = 8		; new x coordinate of sprite.
000220  3               	var_Y  = var_X + 1	; new y coordinate of sprite.
000220  3               	PAM1ST = 5		; first sprite parameter, old x (ix+5).
000220  3               
000220  3               ; Particle engine.
000220  3               
000220  3               	NUMSHR = 55		; pieces of shrapnel.
000220  3               	SHRSIZ = 6		; bytes per particle.
000220  3               
000220  3               ; Local vars
000220  3               
000220  3               	scraddr	= $80
000220  3               	fntaddr	= $82
000220  3               	tileaddr= $84
000220  3               	bufaddr	= $86
000220  3               	tmp     = $88
000220  3               
000220  3               	scr_l	= $90
000220  3               	scr_r	= $92
000220  3               	scr_txt	= $94
000220  3               
000220  3               ; System constants
000220  3               
000220  3               	ScreenAddr  = $8000	; Startaddress video RAM
000220  3               	ScrSelAddr  = $b000	; Screen selection address
000220  3               	KeyRowAddr  = $b000	; PIA key matrix row
000220  3               	KeyColAddr  = $b001	; PIA key matrix column
000220  3               	SpeakerBit  = $b002	; Speaker bit
000220  3               	CmdReg      = $b400	; Command register AtoMMC
000220  3               	DatReg      = $b401	; Data register AtoMMC 
000220  3               	Timer2_Low  = $b808	; Timer 2 low byte
000220  3               	Timer2_High = $b809	; Timer 2 high byte
000220  3               
000220  3               ; System calls
000220  3               
000220  3               	SCRSYNC	 = $fe66	; wait for next CRT field flyback 60 Hz
000220  3               	SCRSYNC1 = $fe6b	; wait for CRT field flyback 60 Hz
000220  3               	OSRDCH   = $fe94	; get key subroutine
000220  3                       READKEY  = $fe71	; scan key matrix subroutine
000220  3               
000220  3               ; Conditional compilation flags
000220  3               ; Flags are set in commandline assembly
000220  3               
000220  3               ;	mflag = 0 		; MENU + INV
000220  3               ;	pflag = 0		; Particle engine
000220  3               ;	sflag = 0		; scrollytext
000220  3               ;	fflag = 1		; Fontflag
000220  3               .if iflag
000220  3               	TxtInvert   = $ff	; Invert byte for character printing
000220  3               	ScrFillByte = $ff	; Screen fill byte for CLS
000220  3               .else
000220  3               	TxtInvert   = $00	; Invert byte for character printing
000220  3               	ScrFillByte = $00	; Screen fill byte for CLS
000220  3               .endif
000220  3               	ScrMode     = $f0	; Screen mode:
000220  3               				;  $d0 = CLEAR4a colour
000220  3               				;  $f0 = CLEAR4  mono
000220  3               
000220  3               ;===============================================================
000220  3               ; Game starts here
000220  3               ;===============================================================
000220  3               
000220  3               .segment "CODE"
000220  3               
000220  3               ;--------------------------------------------------------------
000220  3               ; If a font is required...
000220  3               ;--------------------------------------------------------------
000220  3               
000220  3  A9 F6        	lda #<(FONT-256)	; address of font.
000222  3  8D 55 18     	sta FontPtr
000225  3  A9 1E        	lda #>(FONT-256)
000227  3  8D 56 18     	sta FontPtr+1
00022A  3               
00022A  3  20 AF 03     	jsr game	 	; start the game.
00022D  3  A9 0C        	lda #12			; Clear screen + exit to Basic
00022F  3  4C F4 FF     	jmp $fff4
000232  3               	
000232  3  00           contrl:	.byte 0			; control, 0 = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000233  3  00           joyval:	.byte 0			; joystick reading.
000234  3  00           frmno:	.byte 0			; selected frame.
000235  3               
000235  3               ; Don't change the order of these four.  
000235  3               ; Menu routine relies on winlft following wintop.
000235  3               
000235  3  01           wintop:	.byte WINDOWTOP		; top of window.
000236  3  01           winlft:	.byte WINDOWLFT		; left edge.
000237  3  16           winhgt:	.byte WINDOWHGT		; window height.
000238  3  1E           winwid:	.byte WINDOWWID		; window width.
000239  3  01           numob:	.byte NUMOBJ		; number of objects in game.
00023A  3               
00023A  3               ; Variables start here.
00023A  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00023A  3               
00023A  3  08           wntopx:	.byte (8 * WINDOWTOP)
00023B  3  08           wnlftx:	.byte (8 * WINDOWLFT)
00023C  3  A8           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00023D  3  E6           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
00023E  3               
00023E  3  00           scno:	.byte 0			; present screen number.
00023F  3  03           numlif:	.byte 3			; number of lives.
000240  3               
000240  3  00           vara:	.byte 0			; general-purpose variable.
000241  3  00           varb:	.byte 0			; general-purpose variable.
000242  3  00           varc:	.byte 0			; general-purpose variable.
000243  3  00           vard:	.byte 0			; general-purpose variable.
000244  3  00           vare:	.byte 0			; general-purpose variable.
000245  3  00           varf:	.byte 0			; general-purpose variable.
000246  3  00           varg:	.byte 0			; general-purpose variable.
000247  3  00           varh:	.byte 0			; general-purpose variable.
000248  3  00           vari:	.byte 0			; general-purpose variable.
000249  3  00           varj:	.byte 0			; general-purpose variable.
00024A  3  00           vark:	.byte 0			; general-purpose variable.
00024B  3  00           varl:	.byte 0			; general-purpose variable.
00024C  3  00           varm:	.byte 0			; general-purpose variable.
00024D  3  00           varn:	.byte 0			; general-purpose variable.
00024E  3  00           varo:	.byte 0			; general-purpose variable.
00024F  3  00           varp:	.byte 0			; general-purpose variable.
000250  3  00           varq:	.byte 0			; general-purpose variable.
000251  3  00           varr:	.byte 0			; general-purpose variable.
000252  3  00           vars:	.byte 0			; general-purpose variable.
000253  3  00           vart:	.byte 0			; general-purpose variable.
000254  3  00           varu:	.byte 0			; general-purpose variable.
000255  3  00           varv:	.byte 0			; general-purpose variable.
000256  3  00           varw:	.byte 0			; general-purpose variable.
000257  3  00           varz:	.byte 0			; general-purpose variable.
000258  3               
000258  3  00           charx:	.byte 0			; cursor x position.
000259  3  00           chary:	.byte 0			; cursor y position.
00025A  3               
00025A  3  00           clock:	.byte 0			; last clock reading.
00025B  3  FF           varrnd:	.byte 255		; last random number.
00025C  3  FE           varobj:	.byte 254		; last object number.
00025D  3  FF           varopt:	.byte 255		; last option chosen from menu.
00025E  3  FF           varblk:	.byte 255		; block type.
00025F  3  00           nexlev:	.byte 0			; next level flag.
000260  3  00           restfl:	.byte 0			; restart screen flag.
000261  3  00           deadf:	.byte 0			; dead flag.
000262  3  00           gamwon:	.byte 0			; game won flag.
000263  3  00           dispx:	.byte 0			; cursor x position.
000264  3  00           dispy:	.byte 0			; cursor y position.
000265  3               
000265  3               ; Make sure pointers are arranged in the same order as the data itself.
000265  3               
000265  3  BB 1F        frmptr:	.word frmlst         ; sprite frames.
000267  3               
000267  3               ; Assorted game routines which can go in contended memory.
000267  3               
000267  3               ;--------------------------------------------------------------
000267  3               ; Modify for inventory.
000267  3               ; called by the INV command
000267  3               ;
000267  3               ; Input:
000267  3               ;  X   = message nr with objects seperated with ,
000267  3               ;
000267  3               ; Output:
000267  3               ;  OPT = selected line nr of INV menu
000267  3               ;--------------------------------------------------------------
000267  3               
000267  3               .if mflag
000267  3               minve:
000267  3               	lda #<(invdis)		; routine address.
000267  3               	sta mod0+1		; set up menu routine.
000267  3               	sta mod2+1		; set up count routine.
000267  3               	lda #>(invdis)
000267  3               	sta mod0+2
000267  3               	sta mod2+2
000267  3               	lda #<(fopt)		; find option from available objects.
000267  3               	sta mod1+1		; set up routine.
000267  3               	lda #>(fopt)
000267  3               	sta mod1+1+1
000267  3               	jmp dbox		; do menu routine.
000267  3               
000267  3               ;--------------------------------------------------------------
000267  3               ; Modify for menu.
000267  3               ; called by the MENU command
000267  3               ;
000267  3               ; Input:
000267  3               ;  X   = message nr with menu items seperated with ,
000267  3               ;
000267  3               ; Output:
000267  3               ;  OPT = selected line nr of MENU menu
000267  3               ;--------------------------------------------------------------
000267  3               
000267  3               mmenu:
000267  3               	lda #<(always)		; routine address.
000267  3               	sta mod0+1		; set up routine.
000267  3               	sta mod2+1		; set up count routine.
000267  3               	lda #>(always)
000267  3               	sta mod0+2
000267  3               	sta mod2+2
000267  3               
000267  3               	lda #<(fstd)		; standard option selection.
000267  3               	sta mod1+1		; set up routine.
000267  3               	lda #>(fstd)
000267  3               	sta mod1+2
000267  3               
000267  3               ; Drop through into box routine.
000267  3               
000267  3               ;--------------------------------------------------------------
000267  3               ; Work out size of box for message or menu.
000267  3               ;--------------------------------------------------------------
000267  3               
000267  3               dbox:
000267  3               	lda #<(msgdat)		; pointer to messages.
000267  3               	sta z80_l
000267  3               	lda #>(msgdat)
000267  3               	sta z80_h
000267  3               	
000267  3               	jsr getwrd		; get message number.
000267  3               
000267  3               	lda z80_h		; store pointer to message.
000267  3               	sta TmpAddr
000267  3               	lda z80_l
000267  3               	sta TmpAddr+1
000267  3               
000267  3               	lda #1			; height.
000267  3               	sta z80_d
000267  3               	lda #0			; start at object zero.
000267  3               	sta combyt		; store number of object in combyt.
000267  3               	sta z80_e		; maximum width.
000267  3               dbox5:
000267  3               	lda #0			; this line"s width.
000267  3               	sta z80_b
000267  3               mod2:
000267  3               	jsr always		; item in player"s possession?
000267  3               	cmp #255
000267  3               	bne dbox6		; not in inventory, skip this line.
000267  3               	inc z80_d		; add to tally.
000267  3               dbox6:
000267  3               	ldy #0			; get character.
000267  3               	lda (z80_hl),y
000267  3               	sta z80_a
000267  3               	inc z80_l		; next character.
000267  3               	bne :+
000267  3               	inc z80_h
000267  3               :
000267  3               	lda z80_a		; reached end of line?
000267  3               	cmp #','
000267  3               	beq dbox3		; yes.
000267  3               	cmp #13
000267  3               	beq dbox3		; yes.
000267  3               	inc z80_b		; add to this line"s width.
000267  3               	lda z80_a
000267  3               	bmi dbox4		; end of message? yes, end count.
000267  3               	jmp dbox6		; repeat until we find the end.
000267  3               dbox3:
000267  3               	lda z80_e		; maximum line width.
000267  3               	cmp z80_b		; have we exceeded longest so far?
000267  3               	bpl dbox5		; no, carry on looking.
000267  3               	lda z80_b		; make this the widest so far.
000267  3               	sta z80_e
000267  3               	jmp dbox5		; keep looking.
000267  3               dbox4:
000267  3               	lda z80_e		; maximum line width.
000267  3               	cmp z80_b		; have we exceeded longest so far?
000267  3               	bpl dbox8		; no, carry on looking.
000267  3               	lda z80_b		; final line is the longest so far.
000267  3               	sta z80_e
000267  3               dbox8:
000267  3               	dec z80_d		; decrement items found.
000267  3               	bne :+			; total was zero.
000267  3               	jmp dbox15		
000267  3               :
000267  3               	lda z80_e		; longest line.
000267  3               	bne :+			; was it zero?
000267  3               	jmp dbox15		; total was zero.
000267  3               :
000267  3               	sta bwid		; set up size.
000267  3               	lda z80_d
000267  3               	sta blen
000267  3               
000267  3               ;--------------------------------------------------------------
000267  3               ; That's set up our box size.
000267  3               ;--------------------------------------------------------------
000267  3               
000267  3               	lda winhgt		; window height in characters.
000267  3               	sec
000267  3               	sbc z80_d		; subtract height of box.
000267  3               	lsr a			; divide by 2.
000267  3               	clc
000267  3               	adc wintop		; add top edge of window.
000267  3               	sta btop		; set up box top.
000267  3               
000267  3               	lda winwid		; window width in characters.
000267  3               	sec	
000267  3               	sbc z80_e		; subtract box width.
000267  3               	lsr a			; divide by 2.
000267  3               	clc
000267  3               	adc winlft		; add left edge of window.
000267  3               	sta blft		; box left.
000267  3               
000267  3               	lda FontPtr		; font.
000267  3               	sta grbase		; set up for text display.
000267  3               	lda FontPtr+1
000267  3               	sta grbase+1
000267  3               
000267  3               	lda TmpAddr+1		; restore message pointer.
000267  3               	sta z80_l
000267  3               	lda TmpAddr
000267  3               	sta z80_h
000267  3               
000267  3               	lda btop		; box top.
000267  3               	sta dispy		; set display coordinate.
000267  3               	lda #0			; start at object zero.
000267  3               	sta combyt		; store number of object in combyt.
000267  3               dbox2:
000267  3               	lda combyt		; get object number.
000267  3               	sta z80_a
000267  3               mod0:
000267  3               	jsr always		; check inventory for display.
000267  3               	cmp #255
000267  3               	beq :+			
000267  3               	jmp dbox13		; not in inventory, skip this line.
000267  3               :
000267  3               	lda blft		; box left.
000267  3               	sta dispx		; set left display position.
000267  3               	lda bwid		; box width.
000267  3               	sta z80_b		; store width.
000267  3               dbox0:
000267  3               	ldy #0			; get character.
000267  3               	lda (z80_hl),y
000267  3               	cmp #','		; end of line?
000267  3               	beq dbox1		; yes, next one.
000267  3               	cmp #13			; end of line?
000267  3               	beq dbox1		; yes, next one.
000267  3               
000267  3               	dec z80_b		; one less to display.
000267  3               	and #127		; remove terminator.
000267  3               
000267  3               	jsr pchr		; display on screen.
000267  3               
000267  3               	ldy #0
000267  3               	lda (z80_hl),y		; get character.
000267  3               	sta z80_a
000267  3               	inc z80_l		; next character.
000267  3               	bne :+
000267  3               	inc z80_h
000267  3               :
000267  3               	lda z80_a
000267  3               	cmp #128		; end of message?
000267  3               	bmi :+
000267  3               	jmp dbox7		; yes, job done.
000267  3               :
000267  3               	lda z80_b		; chars remaining.
000267  3               	beq :+			; are any left?
000267  3               	jmp dbox0		; yes, continue.
000267  3               :
000267  3               ;---------------------------------------------------
000267  3               ; Reached limit of characters per line.
000267  3               ;---------------------------------------------------
000267  3               
000267  3               dbox9:
000267  3               	ldy #0
000267  3               	lda (z80_hl),y		; get character.
000267  3               	inc z80_l		; next one.
000267  3               	bne :+
000267  3               	inc z80_h
000267  3               :
000267  3               	cmp #','		; another line?
000267  3               	beq dbox10		; yes, do next line.
000267  3               	cmp #13			; another line?
000267  3               	beq dbox10		; yes, do next line.
000267  3               	cmp #128		; end of message?
000267  3               	bcs :+
000267  3               	jmp dbox11		; yes, finish message.
000267  3               :
000267  3               	jmp dbox9
000267  3               
000267  3               ;---------------------------------------------------
000267  3               ; Fill box to end of line.
000267  3               ;---------------------------------------------------
000267  3               
000267  3               dboxf:
000267  3               	lda #32			; space character.
000267  3               	jsr pchr		; display character.
000267  3               	dec z80_b
000267  3               	beq :+
000267  3               	jmp dboxf		; repeat for remaining chars on line.
000267  3               :
000267  3               	rts
000267  3               dbox1:
000267  3               	inc z80_l		; skip character.
000267  3               	bne :+
000267  3               	inc z80_h
000267  3               :
000267  3               	jsr dboxf		; fill box out to right side.
000267  3               dbox10:
000267  3               	inc dispy		; y coordinate down a line next position.
000267  3               	jmp dbox2		; next line.
000267  3               dbox7:
000267  3               	lda z80_b		; chars remaining.
000267  3               	bne :+			; are any left?
000267  3               	jmp dbox11		; no, nothing to draw.
000267  3               :
000267  3               	jsr dboxf		; fill message to line.
000267  3               
000267  3               ;------------------------------------------------------
000267  3               ; Drawn the box menu, now select option.
000267  3               ;------------------------------------------------------
000267  3               
000267  3               dbox11:
000267  3               	lda btop		; box top.
000267  3               	sta dispy		; set bar position.
000267  3               dbox14:
000267  3               	jsr joykey		; get controls.
000267  3               	cmp #$7f		; anything pressed?
000267  3               	bne dbox14		; yes, debounce it.
000267  3               	jsr dbar		; draw bar.
000267  3               dbox12:
000267  3               	jsr joykey		; get controls.
000267  3               	cmp #$7f		; anything pressed?
000267  3               	beq dbox12		; no, nothing.
000267  3               	and #16			; fire button pressed?
000267  3               	bne :+
000267  3               mod1:
000267  3               	jmp fstd		; yes, job done.
000267  3               :
000267  3               	jsr dbar		; delete bar.
000267  3               
000267  3               	lda joyval		; joystick reading.
000267  3               	and #8			; going up?
000267  3               	beq dboxu		; yes, go up.
000267  3               
000267  3               	ldx dispy		; vertical position of bar.
000267  3               	inx			; look down.
000267  3               	txa
000267  3               	sec
000267  3               	sbc btop		; find distance from top.
000267  3               	cmp blen		; top of box.
000267  3               	bne :+
000267  3               	jmp dbox14		; yes, go no further.
000267  3               :
000267  3               	inc dispy		; move bar.
000267  3               	jmp dbox14		; continue.
000267  3               dboxu:
000267  3               	lda dispy		; vertical position of bar.
000267  3               	cmp btop		; are we at the top?
000267  3               	bne :+
000267  3               	jmp dbox14		; yes, go no further.
000267  3               :
000267  3               	dec dispy		; move bar.
000267  3               	jmp dbox14		; continue.
000267  3               fstd:
000267  3               	lda dispy		; bar position.
000267  3               	sec
000267  3               	sbc btop		; find selected option.
000267  3               	sta varopt		; store the option.
000267  3               	jmp redraw		; redraw the screen.
000267  3               
000267  3               ;------------------------------------------------------
000267  3               ; Option not available.  Skip this line.
000267  3               ;------------------------------------------------------
000267  3               
000267  3               dbox13:
000267  3               	ldy #0
000267  3               	lda (z80_hl),y		; get character.
000267  3               	inc z80_l		; next one.
000267  3               	bne :+
000267  3               	inc z80_h
000267  3               :
000267  3               	cmp #','		; another line?
000267  3               	bne :+
000267  3               	jmp dbox2		; yes, do next line.
000267  3               :
000267  3               	cmp #13			; another line?
000267  3               	bne :+
000267  3               	jmp dbox2		; yes, do next line.
000267  3               :
000267  3               
000267  3               	bpl :+			; end of message?
000267  3               	jmp dbox11		; yes, finish message.
000267  3               :
000267  3               	jmp dbox13
000267  3               dbox15:
000267  3               	lda TmpAddr		; pop message pointer from the stack.
000267  3               	sta z80_h
000267  3               	lda TmpAddr+1
000267  3               	sta z80_l
000267  3               	rts
000267  3               
000267  3               ;------------------------------------------------------
000267  3               ; Invert bar
000267  3               ;------------------------------------------------------
000267  3               
000267  3               dbar:
000267  3               	lda blft		; box left.
000267  3               	sta dispx		; set display coordinate.
000267  3               	jsr gprad		; get printing address.
000267  3               
000267  3               	lda bwid		; box width.
000267  3               	sta z80_c		; loop counter in c.
000267  3               	lda z80_h		
000267  3               	sta z80_d		; store screen address high byte.
000267  3               dbar1:
000267  3               	ldx #7			; pixel height in b.
000267  3               dbar0:
000267  3               	ldy scrtab,x
000267  3               	lda (scraddr),y		; get screen byte.
000267  3               	eor #255		; reverse all bits.
000267  3               	sta (scraddr),y		; write back to screen.
000267  3               	dex			; next line down.
000267  3               	bpl dbar0		; draw rest of character.
000267  3               
000267  3               	inc scraddr		; one char right.
000267  3               	dec z80_c		; decrement character counter.
000267  3               	beq :+
000267  3               	jmp dbar1		; repeat for whole line.
000267  3               :
000267  3               	rts
000267  3               
000267  3               ;------------------------------------------------------
000267  3               ; Point to object
000267  3               ;
000267  3               ; Input:
000267  3               ;  -
000267  3               ;
000267  3               ; Output:
000267  3               ;  A = object number, A=255 if already in possession
000267  3               ;------------------------------------------------------
000267  3               
000267  3               invdis:
000267  3               	lda z80_l		; store message text pointer.
000267  3               	pha
000267  3               	lda z80_h
000267  3               	pha
000267  3               	lda combyt		; object number.
000267  3               	inc combyt		; ready for next one.
000267  3               	jsr gotob		; check if we have object.
000267  3               	tay
000267  3               	pla
000267  3               	sta z80_h
000267  3               	pla
000267  3               	sta z80_l
000267  3               	tya
000267  3               	rts
000267  3               
000267  3               ;------------------------------------------------------
000267  3               ; Find option selected.
000267  3               ;
000267  3               ; Input:
000267  3               ;  -
000267  3               ;
000267  3               ; Output:
000267  3               ;  OPT = selected object
000267  3               ;------------------------------------------------------
000267  3               
000267  3               fopt:
000267  3               	lda dispy
000267  3               	sec
000267  3               	sbc btop		; find selected option.
000267  3               	sta tmp+2		; option selected in b register.
000267  3               	inc tmp+2
000267  3               
000267  3               	lda #0			; set to first item.
000267  3               	sta combyt		; object number.
000267  3               fopt0:
000267  3               	jsr fobj		; find next object in inventory.
000267  3               	dec tmp+2
000267  3               	bne fopt0		; repeat for relevant steps down the list.
000267  3               
000267  3               	lda combyt		; get option.
000267  3               	sta varopt		; store the option.
000267  3               	dec varopt		; one less, due to where we increment combyt.
000267  3               	jmp redraw		; redraw the screen.
000267  3               fobj:
000267  3               	ldy combyt		; object number.
000267  3               	inc combyt		; ready for next item.
000267  3               	tya
000267  3               	jsr gotob		; do we have this item?
000267  3               	cmp #255
000267  3               	bne :+
000267  3               	rts
000267  3               :
000267  3               	jmp fobj		; yes, it's on the list.
000267  3               
000267  3               bwid:	.byte 0              ; box/menu width.
000267  3               blen:	.byte 0              ; box/menu height.
000267  3               btop:	.byte 0              ; box coordinates.
000267  3               blft:	.byte 0
000267  3               .endif
000267  3               
000267  3               ;----------------------------------------------------
000267  3               ; Wait for keypress.
000267  3               ;----------------------------------------------------
000267  3               
000267  3               prskey:
000267  3  98           	tya
000268  3  48           	pha
000269  3               prsloop:
000269  3  20 CC 02     	jsr vsync
00026C  3  20 71 FE     	jsr READKEY
00026F  3  C0 FF        	cpy #255
000271  3  F0 F6        	beq prsloop		; wait until key pressed
000273  3  68           	pla
000274  3  A8           	tay
000275  3  60           	rts
000276  3               
000276  3               ;----------------------------------------------------
000276  3               ; Delay routine 1/50 sec
000276  3               ;
000276  3               ; Wait 1/60 sec = 16666 usec
000276  3               ; Wait 208 x 16 =  3328 usec
000276  3               ;                 19994 usec
000276  3               ; rts           =     6 usec
000276  3               ; Total         = 20000 usec
000276  3               ;----------------------------------------------------
000276  3               
000276  3               delay:
000276  3  8D 6B 0A     	sta xtmp
000279  3               del_loop:
000279  3  20 66 FE     	jsr SCRSYNC		; wait for flyback
00027C  3               
00027C  3  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
00027E  3               delay1:
00027E  3  61 80        	adc ($80,x)		;	 6 usec
000280  3  61 80        	adc ($80,x)		;	 6 usec
000282  3  88           	dey			;	 2 usec
000283  3  D0 F9        	bne delay1		;	 2 usec
000285  3  EA           	nop			; 2 usec
000286  3  EA           	nop			; 2 usec
000287  3               				; tot: 20000 usec
000287  3  CE 6B 0A     	dec xtmp
00028A  3  D0 ED        	bne del_loop
00028C  3  60           	rts
00028D  3               
00028D  3               ;----------------------------------------------------
00028D  3               ; Clear sprite table.
00028D  3               ;
00028D  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
00028D  3               ;----------------------------------------------------
00028D  3               
00028D  3               xspr:
00028D  3  A9 FF        	lda #255		; clear byte.
00028F  3  A2 00        	ldx #0			; length of table.
000291  3               xspr0:
000291  3  9D 76 17     	sta sprtab,x		; sprite table.
000294  3  E8           	inx			; move to next byte.
000295  3  E0 CC        	cpx #SPRBUF
000297  3  D0 F8        	bne xspr0		; repeat for rest of table.
000299  3  60           	rts
00029A  3               
00029A  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00029A  3               ; Sound, NOT IMPLEMENTED!!!
00029A  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00029A  3               ;
00029A  3               ;silenc:
00029A  3               ;	jsr silen1 		; silence channel 1.
00029A  3               ;	jsr silen2 		; silence channel 2.
00029A  3               ;	jsr silen3 		; silence channel 3.
00029A  3               ;	jmp plsnd 		; play all channels to switch them off.
00029A  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00029A  3               
00029A  3               ;-------------------------------------------------------------
00029A  3               ; Initialise all objects.
00029A  3               ;
00029A  3               ; Reset current room,y,x to start room,y,x for all objects
00029A  3               ;-------------------------------------------------------------
00029A  3               
00029A  3               iniob:
00029A  3  A9 D0        	lda #<objdta 		; objects table.
00029C  3  85 68        	sta z80_x
00029E  3  A9 1F        	lda #>objdta
0002A0  3  85 69        	sta z80_i
0002A2  3               
0002A2  3  AE 39 02     	ldx numob 		; number of objects in the game.
0002A5  3               iniob0:
0002A5  3  A0 23        	ldy #35
0002A7  3  B1 68        	lda (z80_ix),y 		; start screen.
0002A9  3  A0 20        	ldy #32
0002AB  3  91 68        	sta (z80_ix),y 		; set start screen.
0002AD  3               
0002AD  3  A0 24        	ldy #36
0002AF  3  B1 68        	lda (z80_ix),y 		; find start y.
0002B1  3  A0 21        	ldy #33
0002B3  3  91 68        	sta (z80_ix),y 		; set start y.
0002B5  3               
0002B5  3  A0 25        	ldy #37
0002B7  3  B1 68        	lda (z80_ix),y 		; get initial x.
0002B9  3  A0 22        	ldy #34
0002BB  3  91 68        	sta (z80_ix),y 		; set x coord.
0002BD  3               
0002BD  3  18           	clc 			; point to next object.
0002BE  3  A5 68        	lda z80_x
0002C0  3  69 26        	adc #38			; distance between objects.
0002C2  3  85 68        	sta z80_x
0002C4  3  90 02        	bcc :+
0002C6  3  E6 69        	inc z80_i
0002C8  3               :
0002C8  3  CA           	dex 			; repeat.
0002C9  3  D0 DA        	bne iniob0
0002CB  3               
0002CB  3  60           	rts
0002CC  3               
0002CC  3               ;-------------------------------------------------------------
0002CC  3               ; Screen synchronisation.
0002CC  3               ;
0002CC  3               ;  - read joystick/keyboard
0002CC  3               ;  - handle sound
0002CC  3               ;  - sync framerate with clock
0002CC  3               ;  - handle shrapnel every even frame
0002CC  3               ;-------------------------------------------------------------
0002CC  3               
0002CC  3               vsync:
0002CC  3  48           	pha
0002CD  3  98           	tya
0002CE  3  48           	pha
0002CF  3  8A           	txa
0002D0  3  48           	pha
0002D1  3  20 3F 0E     	jsr joykey		; read joystick/keyboard.
0002D4  3               vsync1:
0002D4  3  AD 09 B8     	lda Timer2_High		; sync framerate with clock
0002D7  3  D0 FB        	bne vsync1
0002D9  3  A9 C3        	lda #>50000
0002DB  3  8D 09 B8     	sta Timer2_High
0002DE  3  A9 50        	lda #<50000
0002E0  3  8D 08 B8     	sta Timer2_Low
0002E3  3               
0002E3  3  AD 5A 02     	lda clock
0002E6  3  29 01        	and #1
0002E8  3  D0 03        	bne:+
0002EA  3  20 AE 03     	jsr proshr		; handle shrapnel every even frame
0002ED  3               :
0002ED  3  AD 0B 03     	lda sndtyp
0002F0  3  F0 13        	beq sndskip
0002F2  3               sndloop:
0002F2  3  AD 02 B0     	lda SpeakerBit		; handle sound
0002F5  3  AC 0B 03     	ldy sndtyp
0002F8  3               sndwait:
0002F8  3  88           	dey
0002F9  3  D0 FD        	bne sndwait
0002FB  3  49 04        	eor #4
0002FD  3  8D 02 B0     	sta SpeakerBit
000300  3  CE 0B 03     	dec sndtyp
000303  3  D0 ED        	bne sndloop
000305  3               sndskip: 
000305  3  68           	pla
000306  3  AA           	tax
000307  3  68           	pla
000308  3  A8           	tay
000309  3  68           	pla
00030A  3  60           	rts
00030B  3               
00030B  3  00           sndtyp:	.byte 0
00030C  3               
00030C  3               ;-----------------------------------------------
00030C  3               ; Redraw the screen.
00030C  3               ;
00030C  3               ; Remove old copy of all sprites for redraw.
00030C  3               ;-----------------------------------------------
00030C  3               
00030C  3               redraw:
00030C  3  A5 69        	lda z80_i 		; place sprite pointer on stack.
00030E  3  48           	pha
00030F  3  A5 68        	lda z80_x
000311  3  48           	pha
000312  3               
000312  3  20 A2 0A     	jsr droom		; show screen layout.
000315  3  20 BE 05     	jsr shwob		; draw objects.
000318  3               numsp0:
000318  3  A9 0C        	lda #NUMSPR		; sprites to draw.
00031A  3  85 88        	sta tmp
00031C  3               
00031C  3  A9 76        	lda #<sprtab		; sprite table.
00031E  3  85 68        	sta z80_x
000320  3  A9 17        	lda #>sprtab
000322  3  85 69        	sta z80_i
000324  3               redrw0:
000324  3  A0 00        	ldy #0
000326  3  B1 68        	lda (z80_ix),y		; old sprite type.
000328  3  C9 FF        	cmp #255		; is it enabled?
00032A  3  F0 0B        	beq redrw1 		; no, find next one.
00032C  3               
00032C  3  A0 03        	ldy #3
00032E  3  B1 68        	lda (z80_ix),y 		; sprite y.
000330  3  C9 B1        	cmp #177		; beyond maximum?
000332  3  B0 03        	bcs redrw1		; yes, nothing to draw.
000334  3               
000334  3  20 9B 12     	jsr sspria		; show single sprite.
000337  3               redrw1:
000337  3  18           	clc			; next sprite.
000338  3  A5 68        	lda z80_x
00033A  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
00033C  3  85 68        	sta z80_x
00033E  3  90 02        	bcc :+
000340  3  E6 69        	inc z80_i
000342  3               :
000342  3  C6 88        	dec tmp			; repeat for remaining sprites.
000344  3  D0 DE        	bne redrw0
000346  3               rpblc1:
000346  3               ;	jsr dshrp		; redraw shrapnel.
000346  3               
000346  3  68           	pla			; retrieve sprite pointer.
000347  3  85 68        	sta z80_x
000349  3  68           	pla
00034A  3  85 69        	sta z80_i
00034C  3               
00034C  3  60           	rts
00034D  3               
00034D  3               ;----------------------------------------------------------------------
00034D  3               ; Clear screen routine.
00034D  3               ;
00034D  3               ; Fill screenmem $8000-$97ff with ScrFillByte
00034D  3               ;----------------------------------------------------------------------
00034D  3               
00034D  3               cls:
00034D  3  A9 80        	lda #>ScreenAddr		; screen address.
00034F  3  8D 58 03     	sta clsloop+2
000352  3  A9 00        	lda #ScrFillByte
000354  3  A0 00        	ldy #0
000356  3               clsloop:
000356  3  99 00 80     	sta ScreenAddr,y
000359  3  C8           	iny
00035A  3  D0 FA        	bne clsloop
00035C  3  EE 58 03     	inc clsloop+2
00035F  3  AE 58 03     	ldx clsloop+2
000362  3  E0 98        	cpx #>(ScreenAddr+$1800)
000364  3  D0 F0        	bne clsloop
000366  3  60           	rts
000367  3               
000367  3               ;----------------------------------------------------------------------
000367  3               ; Atomic palette is static 
000367  3               ;----------------------------------------------------------------------
000367  3               
000367  3               setpal:
000367  3  60           	rts
000368  3               
000368  3               ;----------------------------------------------------------------------
000368  3               ; FODDER check
000368  3               ;----------------------------------------------------------------------
000368  3               
000368  3               fdchk:
000368  3  A0 00        	ldy #0
00036A  3  B1 66        	lda (z80_hl),y	 	; fetch cell.
00036C  3  C9 04        	cmp #FODDER 		; is it fodder?
00036E  3  F0 01        	beq :+
000370  3  60           	rts 			; no.
000371  3               :
000371  3  A9 00        	lda #0
000373  3  A0 00        	ldy #0
000375  3  91 66        	sta (z80_hl),y 		; rewrite block type.
000377  3               
000377  3  A5 67        	lda z80_h		; store pointer to block.
000379  3  48           	pha
00037A  3  A5 66        	lda z80_l
00037C  3  48           	pha
00037D  3               
00037D  3  38           	sec			; set carry flag for subtraction.
00037E  3  A5 66        	lda z80_l 		; find simple displacement for block.
000380  3  E9 00        	sbc #<MAP
000382  3  85 66        	sta z80_l
000384  3  A5 67        	lda z80_h
000386  3  E9 98        	sbc #>MAP
000388  3  85 67        	sta z80_h
00038A  3               
00038A  3  A5 66        	lda z80_l		; low byte is y coordinate.
00038C  3  29 1F        	and #31 		; column position 0 - 31.
00038E  3  8D 63 02     	sta dispx		; set up x position.
000391  3               
000391  3  06 66        	asl z80_l		; multiply displacement by 8.
000393  3  26 67        	rol z80_h
000395  3  06 66        	asl z80_l
000397  3  26 67        	rol z80_h
000399  3  06 66        	asl z80_l
00039B  3  26 67        	rol z80_h
00039D  3               
00039D  3  A5 67        	lda z80_h		; x coordinate now in h.
00039F  3  8D 64 02     	sta dispy		; set the display coordinate.
0003A2  3               
0003A2  3  A9 00        	lda #0 			; block to write.
0003A4  3  20 6F 09     	jsr pattr 		; write block.
0003A7  3               
0003A7  3  68           	pla 			; restore block pointer.
0003A8  3  85 66        	sta z80_l
0003AA  3  68           	pla
0003AB  3  85 67        	sta z80_h
0003AD  3               
0003AD  3  60           	rts
0003AE  3               
0003AE  3               ;----------------------------------------------------
0003AE  3               ; Scrolly text and puzzle variables.
0003AE  3               ;----------------------------------------------------
0003AE  3               
0003AE  3               .if sflag
0003AE  3               txtbit:	.byte 128		; bit to write.
0003AE  3               txtwid:	.byte 16		; width of ticker message.
0003AE  3               txtpos:	.word msgdat
0003AE  3               txtini:	.word msgdat
0003AE  3               txtscr:	.word ScreenAddr
0003AE  3               .endif
0003AE  3               
0003AE  3               ;----------------------------------------------------
0003AE  3               ; Specialist routines.
0003AE  3               ; Process shrapnel.
0003AE  3               ;----------------------------------------------------
0003AE  3               proshr:
0003AE  3               .if pflag
0003AE  3               	lda #<SHRAPN		; table.
0003AE  3               	sta z80_x
0003AE  3               	lda #>SHRAPN
0003AE  3               	sta z80_i
0003AE  3               
0003AE  3               	lda #NUMSHR		; shrapnel pieces to process.
0003AE  3               	sta shrctr
0003AE  3               prosh0:
0003AE  3               	ldy #0
0003AE  3               	lda (z80_ix),y		; on/off marker.
0003AE  3               	asl a
0003AE  3               proshx:
0003AE  3               	bcs :+
0003AE  3               	jsr prosh1 		; on, so process it.
0003AE  3               :
0003AE  3               	clc
0003AE  3               	lda z80_x
0003AE  3               	adc #SHRSIZ
0003AE  3               	sta z80_x
0003AE  3               	bcc :+
0003AE  3               	inc z80_i
0003AE  3               :
0003AE  3               	dec shrctr		; round again.
0003AE  3               	bne prosh0
0003AE  3               .endif
0003AE  3               .if sflag
0003AE  3               	jsr scrly
0003AE  3               .endif
0003AE  3  60           	rts
0003AF  3               
0003AF  3               .if pflag
0003AF  3               shrctr:	.byte 0
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Proces shrapnel piece
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               prosh1:
0003AF  3               	jsr plot 		; delete the pixel.
0003AF  3               
0003AF  3               	lda #<shrptr		; shrapnel routine pointers.
0003AF  3               	sta z80_l
0003AF  3               	lda #>shrptr
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	ldy #0
0003AF  3               	lda (z80_ix),y		; restore shrapnel type.
0003AF  3               	jsr prosh2 		; run the routine.
0003AF  3               	jsr chkxy		; check x and y are good before we redisplay.
0003AF  3               
0003AF  3               	lda #<SHRSIZ 		; distance to next.
0003AF  3               	sta z80_e
0003AF  3               	lda #>SHRSIZ
0003AF  3               	sta z80_d
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Run the routine
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               prosh2:
0003AF  3               	asl a 			; 2 bytes per address.
0003AF  3               	tay
0003AF  3               	lda shrptr,y
0003AF  3               	sta z80_l
0003AF  3               	lda shrptr+1,y 		; fetch high byte from table.
0003AF  3               	sta z80_h
0003AF  3               	jmp (z80_hl) 		; jump to routine.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Paricle routine table
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               shrptr:	.word laser		; laser.
0003AF  3               	.word trail		; vapour trail.
0003AF  3               	.word shrap		; shrapnel from explosion.
0003AF  3               	.word dotl		; horizontal starfield left.
0003AF  3               	.word dotr		; horizontal starfield right.
0003AF  3               	.word dotu		; vertical starfield up.
0003AF  3               	.word dotd		; vertical starfield down.
0003AF  3               	.word ptcusr		; user particle.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Explosion shrapnel.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               shrap:
0003AF  3               	ldy #1
0003AF  3               	lda (z80_ix),y 		; get the angle.
0003AF  3               	clc
0003AF  3               	adc #<shrsin		; shrapnel sine table.
0003AF  3               	sta z80_l
0003AF  3               	lda #>shrsin
0003AF  3               	adc #0
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	ldy #0
0003AF  3               	lda (z80_hl),y 		; fetch value from table.
0003AF  3               	sta z80_e
0003AF  3               	inc z80_l 		; next byte of table.
0003AF  3               	bne :+
0003AF  3               	inc z80_h
0003AF  3               :
0003AF  3               	ldy #0
0003AF  3               	lda (z80_hl),y		; fetch value from table.
0003AF  3               	sta z80_d
0003AF  3               	inc z80_l		; next byte of table.
0003AF  3               	bne :+
0003AF  3               	inc z80_h
0003AF  3               :
0003AF  3               	ldy #0
0003AF  3               	lda (z80_hl),y 		; fetch value from table.
0003AF  3               	sta z80_c
0003AF  3               	inc z80_l 		; next byte of table.
0003AF  3               	bne :+
0003AF  3               	inc z80_h
0003AF  3               :
0003AF  3               	ldy #0
0003AF  3               	lda (z80_hl),y 		; fetch value from table.
0003AF  3               	sta z80_b
0003AF  3               
0003AF  3               	ldy #2
0003AF  3               	lda (z80_ix),y 		; x coordinate in hl.
0003AF  3               	clc
0003AF  3               	adc z80_e		; add sine lb
0003AF  3               	sta (z80_ix),y		; store new coordinate lb.
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y
0003AF  3               	adc z80_d		; add sine hb
0003AF  3               	sta (z80_ix),y		; store new coordinate hb.
0003AF  3               
0003AF  3               	ldy #4
0003AF  3               	lda (z80_ix),y	 	; y coordinate in hl.
0003AF  3               	clc
0003AF  3               	adc z80_c		; add cosine lb
0003AF  3               	sta (z80_ix),y		; store new coordinate lb.
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y
0003AF  3               	adc z80_b		; add cosine lb
0003AF  3               	sta (z80_ix),y		; store new coordinate hb.
0003AF  3               
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Move dots
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               dotl:
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y
0003AF  3               	sec
0003AF  3               	sbc #1		 	; move left.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               dotr:
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y
0003AF  3               	clc
0003AF  3               	adc #1		 	; move left.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               dotu:
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y
0003AF  3               	sec
0003AF  3               	sbc #1		 	; move up.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               dotd:
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y
0003AF  3               	clc
0003AF  3               	adc #1			; move down.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Check if coordinates are ok before redrawing at new position.
0003AF  3               ;
0003AF  3               ; left:   X>L		X=L	Ok
0003AF  3               ; right:  R+15>X	X=R	Ok
0003AF  3               ; top:    Y>T		Y=T	Ok
0003AF  3               ; bottom: B+15>Y	Y=B	Ok
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               chkxy:
0003AF  3               
0003AF  3               ; top:    Y>T		Y=T	Ok
0003AF  3               
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0003AF  3               	cmp wntopx		; window top.
0003AF  3               	bcs :+			; compare with top window limit.
0003AF  3               	jmp kilshr		; out of window, kill shrapnel.
0003AF  3               :
0003AF  3               ; left:   X>L		X=L	Ok
0003AF  3               
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0003AF  3               	cmp wnlftx		; left edge.
0003AF  3               	bcs :+			; compare with left window limit.
0003AF  3               	jmp kilshr		; out of window, kill shrapnel.
0003AF  3               :
0003AF  3               ; bottom: B+15>Y	Y=B	Ok
0003AF  3               
0003AF  3               	lda wnbotx		; point to bottom.
0003AF  3               	clc
0003AF  3               	adc #15
0003AF  3               	ldy #3
0003AF  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0003AF  3               	bcs :+			; compare with shrapnel x coordinate.
0003AF  3               	jmp kilshr		; off screen, kill shrapnel..
0003AF  3               :
0003AF  3               ; right:  R+15>X	X=R	Ok
0003AF  3               
0003AF  3               	lda wnrgtx		; point to right edge.
0003AF  3               	clc
0003AF  3               	adc #15
0003AF  3               	ldy #5
0003AF  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0003AF  3               	bcs :+			; compare with window limit.
0003AF  3               	jmp kilshr		; off screen, kill shrapnel.
0003AF  3               :
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Drop through.
0003AF  3               ; Display shrapnel.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               plot:
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y		; y integer.
0003AF  3               	sta dispy	 	; workspace coordinates.
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y	 	; x integer.
0003AF  3               	sta dispx 		; workspace coordinates.
0003AF  3               
0003AF  3               	ldy #0
0003AF  3               	lda (z80_ix),y 		; type.
0003AF  3               	bne :+			; is it a laser?
0003AF  3               	jmp plot1 		; yes, draw laser instead.
0003AF  3               :
0003AF  3               plot0:
0003AF  3               	lda dispx		; which pixel within byte do we
0003AF  3               	and #7			; want to set first?
0003AF  3               	tay
0003AF  3               	lda dots,y 		; table of small pixel positions.
0003AF  3               	sta z80_e 		; get value.
0003AF  3               
0003AF  3               	jsr scadd 		; screen address.
0003AF  3               	ldy #0
0003AF  3               	lda (scraddr),y		; see what's already there.
0003AF  3               	eor z80_e
0003AF  3               	sta (scraddr),y 	; put back on screen.
0003AF  3               	rts
0003AF  3               
0003AF  3               plot1:
0003AF  3               	jsr scadd 		; screen address.
0003AF  3               	ldy #0
0003AF  3               	lda (scraddr),y 	; fetch byte there.
0003AF  3               	eor #255 		; toggle all bits.
0003AF  3               	sta (scraddr),y 	; new byte.
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Switch off shrapnel
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               kilshr:
0003AF  3               	lda #128
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y	; switch off shrapnel.
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Sine/cosine table
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               shrsin:	.word 0,1024,391,946,724,724,946,391
0003AF  3               	.word 1024,0,946,65144,724,64811,391,64589
0003AF  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0003AF  3               	.word 64512,0,64589,391,64811,724,65144,946
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create trail
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               trail:
0003AF  3               	ldy #1
0003AF  3               	lda (z80_ix),y 	; time remaining.
0003AF  3               	sec
0003AF  3               	sbc #1
0003AF  3               	sta (z80_ix),y
0003AF  3               	bne :+
0003AF  3               	jmp trailk		; time to switch it off.
0003AF  3               :
0003AF  3               	jsr qrand		; get a random number.
0003AF  3               	lsr a 			; x or y axis?
0003AF  3               	bcc :+
0003AF  3               	jmp trailv		; use y.
0003AF  3               :
0003AF  3               ; Trail horizontal
0003AF  3               
0003AF  3               	lsr a 			; which direction?
0003AF  3               	bcc :+
0003AF  3               	jmp traill		; go left.
0003AF  3               :
0003AF  3               ; Trail right
0003AF  3               
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y
0003AF  3               	clc
0003AF  3               	adc #1	 		; go right.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ; Trail left
0003AF  3               
0003AF  3               traill:
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y
0003AF  3               	sec
0003AF  3               	sbc #1 			; go left.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ; Trail vertical
0003AF  3               
0003AF  3               trailv:
0003AF  3               	lsr a		 	; which direction?
0003AF  3               	bcc :+
0003AF  3               	jmp trailu		; go up.
0003AF  3               :
0003AF  3               ; Trail down
0003AF  3               
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y
0003AF  3               	clc
0003AF  3               	adc #1 			; go down.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ; Trail up
0003AF  3               
0003AF  3               trailu:
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y
0003AF  3               	sec
0003AF  3               	sbc #1 			; go up.
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ; Kill trail
0003AF  3               
0003AF  3               trailk:
0003AF  3               	lda #200		; set off-screen to kill vapour trail.
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create laser beam
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               laser:
0003AF  3               	ldy #1
0003AF  3               	lda (z80_ix),y 		; direction.
0003AF  3               	ror a 			; left or right?
0003AF  3               	bcs :+
0003AF  3               	jmp laserl		; move left.
0003AF  3               :
0003AF  3               ; Laser right
0003AF  3               
0003AF  3               	lda #8			; distance to travel.
0003AF  3               	sta z80_b
0003AF  3               	jmp laserm		; move laser.
0003AF  3               
0003AF  3               ; Laser left
0003AF  3               
0003AF  3               laserl:
0003AF  3               	lda #248		; distance to travel.
0003AF  3               	sta z80_b
0003AF  3               laserm:
0003AF  3               	ldy #5
0003AF  3               	lda (z80_ix),y		; x position.
0003AF  3               	clc
0003AF  3               	adc z80_b		; add distance.
0003AF  3               	sta (z80_ix),y		; set new x coordinate.
0003AF  3               
0003AF  3               ; Test new block.
0003AF  3               
0003AF  3               	sta dispx 		; set x for block collision detection purposes.
0003AF  3               	ldy #3
0003AF  3               	lda (z80_ix),y 		; get y.
0003AF  3               	sta dispy		; set coordinate for collision test.
0003AF  3               	jsr tstbl 		; get block type there.
0003AF  3               	cmp #WALL		; is it solid?
0003AF  3               	bne :+
0003AF  3               	jmp trailk		; yes, it cannot pass.
0003AF  3               :
0003AF  3                       cmp #FODDER             ; is it fodder?
0003AF  3                       bne :+
0003AF  3                       jsr fdchk               ; remove fodder block.
0003AF  3                       jmp trailk              ; destroy laser.
0003AF  3               :
0003AF  3                       rts                     ; no, ignore it.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Dots mask
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               dots:	.byte 128,64,32,16,8,4,2,1
0003AF  3               
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Plot, preserving de.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               plotde:
0003AF  3               	lda z80_d 		; put de on stack.
0003AF  3               	pha
0003AF  3               	lda z80_e
0003AF  3               	pha
0003AF  3               
0003AF  3               	jsr plot 		; plot pixel.
0003AF  3               
0003AF  3               	pla			; restore de from stack.
0003AF  3               	sta z80_e
0003AF  3               	pla
0003AF  3               	sta z80_d
0003AF  3               
0003AF  3               	rts
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Shoot a laser.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               shoot:
0003AF  3               	sta z80_c		; store direction in c register.
0003AF  3               	ldy #8
0003AF  3               	lda (z80_ix),y 		; y coordinate.
0003AF  3               shoot1:
0003AF  3               	clc
0003AF  3               	adc #7 			; down 7 pixels.
0003AF  3               	sta z80_l 		; puty y coordinate in l.
0003AF  3               
0003AF  3               	ldy #9
0003AF  3               	lda (z80_ix),y 		; x coordinate in h.
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	lda z80_i		; store pointer to sprite.
0003AF  3               	pha
0003AF  3               	lda z80_x
0003AF  3               	pha
0003AF  3               
0003AF  3               	jsr fpslot 		; find particle slot.
0003AF  3               	bcs :+
0003AF  3               	jmp vapou2		; failed, restore ix.
0003AF  3               :
0003AF  3               	lda #0
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y 		; set up a laser.
0003AF  3               
0003AF  3               	lda z80_c
0003AF  3               	ldy #1
0003AF  3               	sta (z80_ix),y 		; set the direction.
0003AF  3               
0003AF  3               	lda z80_l
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y		; set y coordinate.
0003AF  3               
0003AF  3               	ror z80_c		; check direction we want.
0003AF  3               	bcc :+
0003AF  3               	jmp shootr		; shoot right.
0003AF  3               :
0003AF  3               	lda z80_h		; X position.
0003AF  3               shoot0:
0003AF  3               	and #248		; align on character boundary.
0003AF  3               	ldy #5
0003AF  3               	sta (z80_ix),y		; set x coordinate.
0003AF  3               	jmp vapou0 		; draw first image.
0003AF  3               shootr:
0003AF  3               	lda z80_h		; x position.
0003AF  3               	clc
0003AF  3               	adc #15			; look right.
0003AF  3               	jmp shoot0		; align and continue.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create a bit of vapour trail.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               vapour:
0003AF  3               	lda z80_i		; store pointer to sprite.
0003AF  3               	pha
0003AF  3               	lda z80_x
0003AF  3               	pha
0003AF  3               
0003AF  3               	ldy #8
0003AF  3               	lda (z80_ix),y 		; y coordinate.
0003AF  3               	clc
0003AF  3               	adc #7			; mid-point of sprite.
0003AF  3               	sta z80_l
0003AF  3               
0003AF  3               	ldy #9
0003AF  3               	lda (z80_ix),y 		; x coordinate.
0003AF  3               	adc #7
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	jsr fpslot 		; find particle slot.
0003AF  3               	bcc :+
0003AF  3               	jmp vapou1		; no, we can use it.
0003AF  3               :
0003AF  3               vapou2:
0003AF  3               	pla
0003AF  3               	sta z80_x
0003AF  3               	pla
0003AF  3               	sta z80_i
0003AF  3               	rts
0003AF  3               vapou1:
0003AF  3               	lda z80_l
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y		; set up y.
0003AF  3               
0003AF  3               	lda z80_h
0003AF  3               	ldy #5
0003AF  3               	sta (z80_ix),y 		; set up x coordinate.
0003AF  3               
0003AF  3               	jsr qrand		; get quick random number.
0003AF  3               	and #15			; random time.
0003AF  3               	clc
0003AF  3               	adc #15			; minimum time on screen.
0003AF  3               	ldy #1
0003AF  3               	sta (z80_ix),y		; set time on screen.
0003AF  3               
0003AF  3               	lda #1
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y		; define particle as vapour trail.
0003AF  3               vapou0:
0003AF  3               	jsr chkxy		; plot first position.
0003AF  3               	jmp vapou2
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create a user particle.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               ptusr:
0003AF  3               	sta z80_f		; store timer.
0003AF  3               
0003AF  3               	ldy #8
0003AF  3               	lda (z80_ix),y 		; y coordinate.
0003AF  3               	clc
0003AF  3               	adc #7			; mid-point of sprite.
0003AF  3               	sta z80_l
0003AF  3               
0003AF  3               	ldy #9
0003AF  3               	lda (z80_ix),y 		; x coordinate.
0003AF  3               	clc
0003AF  3               	adc #7			; mid-point of sprite.
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	jsr fpslot 		; find particle slot.
0003AF  3               	bcs ptusr1
0003AF  3               	rts 			; out of slots, can't generate anything.
0003AF  3               ptusr1:
0003AF  3               	lda z80_l
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y 		; set up y.
0003AF  3               
0003AF  3               	lda z80_h
0003AF  3               	ldy #5
0003AF  3               	sta (z80_ix),y		; set up x coordinate.
0003AF  3               
0003AF  3               	lda z80_f 		; restore timer.
0003AF  3               	ldy #1
0003AF  3               	sta (z80_ix),y		; set time on screen.
0003AF  3               
0003AF  3               	lda #7
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y		; define particle as user particle.
0003AF  3               
0003AF  3               	jmp chkxy		; plot first position.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create a vertical or horizontal star.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               star:
0003AF  3               	lda z80_i		; store pointer to sprite.
0003AF  3               	pha
0003AF  3               	lda z80_x
0003AF  3               	pha
0003AF  3               
0003AF  3               	jsr fpslot 		; find particle slot.
0003AF  3               	bcs star7		; found one we can use.
0003AF  3               star0:
0003AF  3               	pla 			; restore sprite pointer.
0003AF  3               	sta z80_x
0003AF  3               	pla
0003AF  3               	sta z80_i
0003AF  3               	rts 			; out of slots, can't generate anything.
0003AF  3               star7:
0003AF  3               	lda z80_c		; direction.
0003AF  3               	and #3 			; is it left?
0003AF  3               	bne :+
0003AF  3               	jmp star1 		; yes, it's left.
0003AF  3               :
0003AF  3               	cmp #1 			; is it right?
0003AF  3               	bne :+
0003AF  3               	jmp star2 		; yes, it's right.
0003AF  3               :
0003AF  3               	cmp #2 			; is it up?
0003AF  3               	bne :+
0003AF  3               	jmp star3 		; yes, it's up.
0003AF  3               :
0003AF  3               	ldy wntopx 		; get edge of screen.
0003AF  3               	iny			; down one pixel.
0003AF  3               	tya
0003AF  3               star8:
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y 		; set y coord.
0003AF  3               	jsr qrand 		; get quick random number.
0003AF  3               star9:
0003AF  3               	ldy #5
0003AF  3               	sta (z80_ix),y		; set x position.
0003AF  3               
0003AF  3               	lda z80_c		; direction.
0003AF  3               	and #3			; zero to three.
0003AF  3               	clc
0003AF  3               	adc #3			; 3 to 6 for starfield.
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y		; define particle as star.
0003AF  3               	jsr chkxy		; plot first position.
0003AF  3               	jmp star0
0003AF  3               star1:
0003AF  3               	jsr qrand		; get quick random number.
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y 		; set y coord.
0003AF  3               
0003AF  3               	lda wnrgtx 		; get edge of screen.
0003AF  3               	clc
0003AF  3               	adc #15			; add width of sprite minus 1.
0003AF  3               	jmp star9
0003AF  3               star2:
0003AF  3               	jsr qrand 		; get quick random number.
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y		; set y coord.
0003AF  3               
0003AF  3               	lda wnlftx		; get edge of screen.
0003AF  3               	jmp star9
0003AF  3               star3:
0003AF  3               	lda wnbotx 		; get edge of screen.
0003AF  3               	clc
0003AF  3               	adc #15 		; height of sprite minus one pixel.
0003AF  3               	jmp star8
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Find particle slot for lasers or vapour trail.
0003AF  3               ; can't use alternate accumulator.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               fpslot:
0003AF  3               	lda #<SHRAPN 		; shrapnel table.
0003AF  3               	sta z80_x
0003AF  3               	lda #>SHRAPN
0003AF  3               	sta z80_i
0003AF  3               
0003AF  3               	lda #NUMSHR		; number of pieces in table.
0003AF  3               	sta z80_b
0003AF  3               fpslt0:
0003AF  3               	ldy #0
0003AF  3               	lda (z80_ix),y		; get type.
0003AF  3               	asl a  			; is this slot in use?
0003AF  3               	bcc :+
0003AF  3               	rts			; no, we can use it.
0003AF  3               :
0003AF  3               	clc			; point to more shrapnel.
0003AF  3               	lda z80_x
0003AF  3               	adc #SHRSIZ
0003AF  3               	sta z80_x
0003AF  3               	bcc :+
0003AF  3               	inc z80_i
0003AF  3               :
0003AF  3               	dec z80_b		; repeat for all shrapnel.
0003AF  3               	bne fpslt0
0003AF  3               
0003AF  3               	clc
0003AF  3               	rts 			; out of slots, can't generate anything.
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Create an explosion at sprite position.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               explod:
0003AF  3               	sta z80_c 		; particles to create.
0003AF  3               
0003AF  3               	lda z80_i 		; store pointer to sprite.
0003AF  3               	pha
0003AF  3               	lda z80_x
0003AF  3               	pha
0003AF  3               
0003AF  3               	ldy #8
0003AF  3               	lda (z80_ix),y 		; y coordinate.
0003AF  3               	sta z80_l
0003AF  3               	ldy #9
0003AF  3               	lda (z80_ix),y		; x coordinate.
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	lda #<SHRAPN		; shrapnel table.
0003AF  3               	sta z80_x
0003AF  3               	lda #>SHRAPN
0003AF  3               	sta z80_i
0003AF  3               
0003AF  3               	lda #NUMSHR		; number of pieces in table.
0003AF  3               	sta explcnt
0003AF  3               expld0:
0003AF  3               	ldy #0
0003AF  3               	lda (z80_ix),y		; get type.
0003AF  3               	asl a 			; is this slot in use?
0003AF  3               	bcs expld1		; no, we can use it.
0003AF  3               expld2:
0003AF  3               	clc
0003AF  3               	lda z80_x
0003AF  3               	adc #SHRSIZ
0003AF  3               	sta z80_x
0003AF  3               	bcc :+
0003AF  3               	inc z80_i
0003AF  3               :
0003AF  3               	dec explcnt		; repeat for all shrapnel.
0003AF  3               	bne expld0
0003AF  3               expld3:
0003AF  3               	pla			; restore sprite pointer.
0003AF  3               	sta z80_x
0003AF  3               	pla
0003AF  3               	sta z80_i
0003AF  3               	rts 			; out of slots, can't generate any more.
0003AF  3               
0003AF  3               expld1:
0003AF  3               	lda z80_c		; shrapnel counter.
0003AF  3               	and #15			; 0 to 15.
0003AF  3               	clc			; add to x.
0003AF  3               	adc z80_l
0003AF  3               	ldy #3
0003AF  3               	sta (z80_ix),y		; y coord.
0003AF  3               
0003AF  3               	lda seed3 		; crap random number.
0003AF  3               	and #15			; 0 to 15.
0003AF  3               	clc 			; add to y.
0003AF  3               	adc z80_h
0003AF  3               	ldy #5
0003AF  3               	sta (z80_ix),y		; x coord.
0003AF  3               
0003AF  3               	lda #2
0003AF  3               	ldy #0
0003AF  3               	sta (z80_ix),y		; switch it on.
0003AF  3               
0003AF  3               	jsr chkxy		; plot first position.
0003AF  3               	jsr qrand		; quick random angle.
0003AF  3               	and #60 		; keep within range.
0003AF  3               	ldy #1
0003AF  3               	sta (z80_ix),y		; angle.
0003AF  3               
0003AF  3               	dec z80_c		; one less piece of shrapnel to generate.
0003AF  3               	bne expld2 		; back to main explosion loop.
0003AF  3               	jmp expld3 		; restore sprite pointer and exit.
0003AF  3               
0003AF  3               explcnt:	.byte 0
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Quick random
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               qrand:
0003AF  3               	jsr random		; r register.
0003AF  3               	eor seed3		; combine with seed.
0003AF  3               	sta seed3 		; new seed.
0003AF  3               	rts
0003AF  3               
0003AF  3               seed3:	.byte 0
0003AF  3               
0003AF  3               ;----------------------------------------------------
0003AF  3               ; Display all shrapnel.
0003AF  3               ;----------------------------------------------------
0003AF  3               
0003AF  3               dshrp:
0003AF  3               	lda #<plotde		; display routine.
0003AF  3               	sta proshx+1
0003AF  3               	lda #>plotde
0003AF  3               	sta proshx+2
0003AF  3               	jsr proshr		; process shrapnel.
0003AF  3               
0003AF  3               	lda #<prosh1		; processing routine.
0003AF  3               	sta proshx+1
0003AF  3               	lda #>prosh1
0003AF  3               	sta proshx+2
0003AF  3               	rts
0003AF  3               
0003AF  3               ;------------------------------------------------------
0003AF  3               ; Particle engine.
0003AF  3               ;
0003AF  3               ; Init particle data for 55 particles in SHRAPN table.
0003AF  3               ; Every particle has 6 bytes.
0003AF  3               ;
0003AF  3               ; global:	-
0003AF  3               ; local:	x,y,hl
0003AF  3               ; calls:	-
0003AF  3               ;------------------------------------------------------
0003AF  3               
0003AF  3               inishr:
0003AF  3               	lda #<SHRAPN 		; table.
0003AF  3               	sta z80_l
0003AF  3               	lda #>SHRAPN
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	ldy #0
0003AF  3               	ldx #NUMSHR		; shrapnel pieces to process.
0003AF  3               inish0:
0003AF  3               	lda #255 		; kill the shrapnel.
0003AF  3               	sta (z80_hl),y
0003AF  3               
0003AF  3               	clc 			; point there.
0003AF  3               	lda z80_l
0003AF  3               	adc #SHRSIZ		; distance to next.
0003AF  3               	sta z80_l
0003AF  3               	bcc :+
0003AF  3               	inc z80_h
0003AF  3               :
0003AF  3               	dex
0003AF  3               	bne inish0 		; round again.
0003AF  3               	rts
0003AF  3               
0003AF  3               ;------------------------------------------------------
0003AF  3               ; Check for collision between laser and sprite.
0003AF  3               ;------------------------------------------------------
0003AF  3               
0003AF  3               lcol:
0003AF  3               	lda #<SHRAPN		; shrapnel table.
0003AF  3               	sta z80_l
0003AF  3               	lda #>SHRAPN
0003AF  3               	sta z80_h
0003AF  3               
0003AF  3               	lda #NUMSHR		; number of pieces in table.
0003AF  3               	sta z80_b
0003AF  3               lcol0:
0003AF  3               	ldy #0
0003AF  3               	lda (z80_hl),y 		; get type.
0003AF  3               	beq lcol1		; yes, check collision.
0003AF  3               lcol3:
0003AF  3               	clc			; point to more shrapnel.
0003AF  3               	lda z80_l
0003AF  3               	adc #SHRSIZ
0003AF  3               	sta z80_l
0003AF  3               	bcc :+
0003AF  3               	inc z80_h
0003AF  3               :
0003AF  3               	dec z80_b		; repeat for all shrapnel.
0003AF  3               	bne lcol0
0003AF  3               	rts 			; no collision, carry not set.
0003AF  3               lcol1:
0003AF  3               	ldy #3
0003AF  3               	lda (z80_hl),y		; get y.
0003AF  3               	sec
0003AF  3               	ldy #8
0003AF  3               	sbc (z80_ix),y		; subtract sprite y.
0003AF  3               lcolh:
0003AF  3               	cmp #16 		; within range?
0003AF  3               	bcc :+
0003AF  3               	jmp lcol2		; no, missed.
0003AF  3               :
0003AF  3               	ldy #5
0003AF  3               	lda (z80_hl),y 		; get x.
0003AF  3               	sec
0003AF  3               	ldy #9
0003AF  3               	sbc (z80_ix),y 		; subtract sprite y.
0003AF  3               	cmp #16			; within range?
0003AF  3               	bcs :+
0003AF  3               	jmp lcol4 		; yes, collision occurred.
0003AF  3               :
0003AF  3               lcol2:
0003AF  3               	jmp lcol3
0003AF  3               lcol4:
0003AF  3               	sec
0003AF  3               	rts 			; return with carry set for collision.
0003AF  3               .endif
0003AF  3               
0003AF  3               ;------------------------------------------------------
0003AF  3               ; Main game engine code starts here.
0003AF  3               ; After initialisation, mloop is the main loop
0003AF  3               ;------------------------------------------------------
0003AF  3               
0003AF  3               game:
0003AF  3               
0003AF  3               ; Set up screen address table.
0003AF  3               
0003AF  3               setsat:
0003AF  3  A9 00        	lda #<ScreenAddr		; start of screen.
0003B1  3  85 80        	sta scraddr
0003B3  3  A9 80        	lda #>ScreenAddr
0003B5  3  85 81        	sta scraddr+1
0003B7  3               
0003B7  3  A0 00        	ldy #0			; vertical lines on screen.
0003B9  3               setsa0:
0003B9  3  A5 80        	lda scraddr
0003BB  3  99 00 9B     	sta SCADTB_lb,y		; write low byte.
0003BE  3  A5 81        	lda scraddr+1
0003C0  3  C0 C0        	cpy #192		; vertical lines on screen.
0003C2  3  90 02        	bcc :+
0003C4  3  09 F0        	ora #$F0		; plot sprites in rom if of screen
0003C6  3               :
0003C6  3  99 00 9C     	sta SCADTB_hb,y		; write high byte.
0003C9  3  20 02 13     	jsr nline		; next line down.
0003CC  3  C8           	iny			; next position in table.
0003CD  3  D0 EA        	bne setsa0
0003CF  3               	
0003CF  3               ; Init graphics mode
0003CF  3               
0003CF  3  A9 F0        	lda #ScrMode		; graphics mode
0003D1  3  8D 00 B0     	sta ScrSelAddr 		; screen selection address
0003D4  3  20 67 03     	jsr setpal 		; set up palette.
0003D7  3               
0003D7  3               ; Init AtoMMC joystick
0003D7  3  20 7B 0E     	jsr joyinit		; AtoMMC joystick on PORT B
0003DA  3               
0003DA  3               rpblc2:
0003DA  3               .if pflag
0003DA  3               	jsr inishr 		; initialise particle engine.
0003DA  3               .endif
0003DA  3               evintr:
0003DA  3  20 B3 1D     	jsr evnt12 		; call intro/menu event.
0003DD  3               
0003DD  3  A9 02        	lda #WALL 		; write default property.
0003DF  3  A2 00        	ldx #0
0003E1  3               clrmap:
0003E1  3  9D 00 98     	sta MAP,x 		; block properties.
0003E4  3  9D 00 99     	sta MAP+256,x
0003E7  3  9D 00 9A     	sta MAP+512,x
0003EA  3  E8           	inx			; next byte.
0003EB  3  D0 F4        	bne clrmap
0003ED  3               
0003ED  3  20 9A 02     	jsr iniob 		; initialise objects.
0003F0  3               
0003F0  3  A9 00        	lda #0			; put zero in accumulator.
0003F2  3  8D 62 02     	sta gamwon		; reset game won flag.
0003F5  3               
0003F5  3  20 6E 05     	jsr inisc 		; init the score.
0003F8  3               mapst:
0003F8  3  AD 65 18     	lda stmap 		; start position on map.
0003FB  3  8D 53 18     	sta roomtb		; set up position in table, if there is one.
0003FE  3               
0003FE  3               inipbl:
0003FE  3  20 22 14     	jsr initsc 		; set up first screen.
000401  3               
000401  3  A9 42        	lda #<ssprit 		; default to spare sprite in table.
000403  3  85 68        	sta z80_x
000405  3  A9 18        	lda #>ssprit
000407  3  85 69        	sta z80_i
000409  3               evini:
000409  3  20 B7 1D     	jsr evnt13 		; initialisation.
00040C  3               
00040C  3               ; Two restarts.
00040C  3               ; First restart - clear all sprites and initialise everything.
00040C  3               
00040C  3               rstrt:
00040C  3  20 07 05     	jsr rsevt 		; restart events.
00040F  3  20 8D 02     	jsr xspr 		; clear sprite table.
000412  3  20 94 15     	jsr sprlst 		; fetch pointer to screen sprites.
000415  3  20 22 16     	jsr ispr 		; initialise sprite table.
000418  3               
000418  3  4C 27 04     	jmp rstrt0
00041B  3               
00041B  3               ; Second restart - clear all but player, and don't initialise him.
00041B  3               
00041B  3               rstrtn:
00041B  3  20 07 05     	jsr rsevt		; restart events.
00041E  3  20 C2 15     	jsr nspr 		; clear all non-player sprites.
000421  3  20 94 15     	jsr sprlst 		; fetch pointer to screen sprites.
000424  3  20 62 16     	jsr kspr 		; initialise sprite table, no more players.
000427  3               
000427  3               ; Set up the player and/or enemy sprites.
000427  3               
000427  3               rstrt0:
000427  3  A9 00        	lda #0 			; zero in accumulator.
000429  3  8D 5F 02     	sta nexlev 		; reset next level flag.
00042C  3  8D 60 02     	sta restfl 		; reset restart flag.
00042F  3  8D 61 02     	sta deadf 		; reset dead flag.
000432  3  20 A2 0A     	jsr droom 		; show screen layout.
000435  3               rpblc0:
000435  3               .if pflag
000435  3               	jsr inishr 		; initialise particle engine.
000435  3               .endif
000435  3  20 BE 05     	jsr shwob		; draw objects.
000438  3               
000438  3  A9 76        	lda #<sprtab 		; address of sprite table, even sprites.
00043A  3  85 68        	sta z80_x
00043C  3  A9 17        	lda #>sprtab
00043E  3  85 69        	sta z80_i
000440  3  20 73 11     	jsr dspr 		; display sprites.
000443  3               
000443  3  A9 87        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
000445  3  85 68        	sta z80_x
000447  3  A9 17        	lda #>(sprtab+TABSIZ)
000449  3  85 69        	sta z80_i
00044B  3  20 73 11     	jsr dspr 		; display sprites.
00044E  3               mloop:
00044E  3  20 CC 02     	jsr vsync 		; synchronise with display.
000451  3               
000451  3  A9 76        	lda #<sprtab 		; address of sprite table, even sprites.
000453  3  85 68        	sta z80_x
000455  3  A9 17        	lda #>sprtab
000457  3  85 69        	sta z80_i
000459  3  20 73 11     	jsr dspr 		; display even sprites.
00045C  3               
00045C  3  20 BD 05     	jsr plsnd 		; play sounds.
00045F  3               
00045F  3  A9 87        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
000461  3  85 68        	sta z80_x
000463  3  A9 17        	lda #>(sprtab+TABSIZ)
000465  3  85 69        	sta z80_i
000467  3  20 73 11     	jsr dspr 		; display odd sprites.
00046A  3               
00046A  3  A9 42        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
00046C  3  85 68        	sta z80_x
00046E  3  A9 18        	lda #>(ssprit)
000470  3  85 69        	sta z80_i
000472  3               evlp1:
000472  3  20 70 18     	jsr evnt10 		; called once per main loop.
000475  3  20 E8 10     	jsr pspr 		; process sprites.
000478  3               
000478  3               ; Main loop events.
000478  3               
000478  3  A9 42        	lda #<ssprit 		; point to spare sprite for spawning purposes.
00047A  3  85 68        	sta z80_x
00047C  3  A9 18        	lda #>ssprit
00047E  3  85 69        	sta z80_i
000480  3               evlp2:
000480  3  20 B2 1D     	jsr evnt11 		; called once per main loop.
000483  3               bsortx:
000483  3  20 5B 10     	jsr bsort 		; sort sprites.
000486  3               
000486  3  AD 5F 02     	lda nexlev		; finished level flag.
000489  3  D0 24        	bne newlev		; is set, go to next level.
00048B  3  AD 62 02     	lda gamwon		; finished game flag.
00048E  3  D0 30        	bne evwon		; is set, finish the game.
000490  3  AD 60 02     	lda restfl 		; finished level flag.
000493  3  C9 01        	cmp #1			; has it been set?
000495  3  D0 03        	bne :+
000497  3  4C 0C 04     	jmp rstrt		; yes, go to next level.
00049A  3               :
00049A  3  C9 02        	cmp #2			; has it been set?
00049C  3  D0 03        	bne :+
00049E  3  4C 1B 04     	jmp rstrtn		; yes, go to next level.
0004A1  3               :
0004A1  3  AD 61 02     	lda deadf 		; dead flag.
0004A4  3  D0 20        	bne pdead		; yes, player dead.
0004A6  3               
0004A6  3               ; back to start of main loop.
0004A6  3               
0004A6  3  EE 34 02     	inc frmno
0004A9  3  EE 5A 02     	inc clock
0004AC  3  4C 4E 04     	jmp mloop		; switched to a jmp mloop during test mode.
0004AF  3               
0004AF  3               ;----------------------------------------------------------
0004AF  3               ; New level
0004AF  3               ;----------------------------------------------------------
0004AF  3               
0004AF  3               newlev:
0004AF  3  AD 3E 02     	lda scno 			; current screen.
0004B2  3  18           	clc
0004B3  3  69 01        	adc #1				; next screen.
0004B5  3  CD CA 1F     	cmp numsc			; total number of screens.
0004B8  3  B0 06        	bcs evwon			; yes, game finished.
0004BA  3  8D 3E 02     	sta scno			; set new level number.
0004BD  3  4C 0C 04     	jmp rstrt			; restart, clearing all aliens.
0004C0  3               
0004C0  3               evwon:
0004C0  3  20 BC 1D     	jsr evnt18		 	; game completed.
0004C3  3  4C DC 04     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0004C6  3               
0004C6  3               ;----------------------------------------------------------
0004C6  3               ; Player dead.
0004C6  3               ;----------------------------------------------------------
0004C6  3               
0004C6  3               pdead:
0004C6  3  A9 00        	lda #0				; zeroise accumulator.
0004C8  3  8D 61 02     	sta deadf			; reset dead flag.
0004CB  3               evdie:
0004CB  3  20 BA 1D     	jsr evnt16 			; death subroutine.
0004CE  3  AD 3F 02     	lda numlif			; number of lives.
0004D1  3  F0 03        	beq :+
0004D3  3  4C 0C 04     	jmp rstrt 			; restart game.
0004D6  3               :
0004D6  3               evfail:
0004D6  3  20 BB 1D     	jsr evnt17 			; failure event.
0004D9  3  4C AF 03     	jmp game			; restart game
0004DC  3               
0004DC  3               ;----------------------------------------------------------
0004DC  3               ; Tidy things up
0004DC  3               ;----------------------------------------------------------
0004DC  3               
0004DC  3               tidyup:
0004DC  3  A0 00        	ldy #0				; digits to check.
0004DE  3               tidyu2:
0004DE  3  B9 97 07     	lda score,y 			; get score digit.
0004E1  3  CD 9D 07     	cmp hiscor 			; are we larger than high score digit?
0004E4  3  90 07        	bcc tidyu0			; high score is bigger.
0004E6  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
0004E8  3  C8           	iny				; next digit of high score.
0004E9  3  C0 06        	cpy #6
0004EB  3  D0 F1        	bne tidyu2			; repeat for all digits
0004ED  3               tidyu0:
0004ED  3  A9 97        	lda #<score			; return pointing to score.
0004EF  3  85 62        	sta z80_c
0004F1  3  A9 07        	lda #>score
0004F3  3  85 63        	sta z80_b
0004F5  3  60           	rts
0004F6  3               tidyu1:
0004F6  3  A0 05        	ldy #5
0004F8  3               tidyu3:
0004F8  3  B9 97 07     	lda score,y			; score.
0004FB  3  99 9D 07     	sta hiscor,y			; high score.
0004FE  3  88           	dey
0004FF  3  10 F7        	bpl tidyu3 			; copy score to high score.
000501  3               evnewh:
000501  3  20 BD 1D     	jsr evnt19			; new high score event.
000504  3  4C ED 04     	jmp tidyu0			; tidy up.
000507  3               
000507  3               ;--------------------------------------------------
000507  3               ; Restart event.
000507  3               ;--------------------------------------------------
000507  3               
000507  3               rsevt:
000507  3  A9 42        	lda #<ssprit 			; default to spare element in table.
000509  3  85 68        	sta z80_x
00050B  3  A9 18        	lda #>ssprit
00050D  3  85 69        	sta z80_i
00050F  3               evrs:
00050F  3  4C B8 1D     	jmp evnt14	 		; call restart event.
000512  3               
000512  3               ;------------------------------------------------------------------
000512  3               ; Copy number passed in a to string position bc, right-justified.
000512  3               ;
000512  3               ; Input:
000512  3               ;  A  = number
000512  3               ;  BC = string address
000512  3               ;
000512  3               ; Output:
000512  3               ;  BC = string with number
000512  3               ;-----------------------------------------------------------------
000512  3               
000512  3               num2ch:
000512  3  85 65        	sta z80_d		; Save number
000514  3               
000514  3  A9 00        	lda #0
000516  3  8D 6D 05     	sta flag
000519  3               numdg3:
000519  3  A2 64        	ldx #100		; hundreds column.
00051B  3  86 64        	stx z80_e
00051D  3  20 2E 05     	jsr numdg		; show digit.
000520  3               numdg2:
000520  3  A2 0A        	ldx #10			; tens column.
000522  3  86 64        	stx z80_e
000524  3  20 2E 05     	jsr numdg		; show digit.
000527  3               
000527  3  EE 6D 05     	inc flag
00052A  3  A2 01        	ldx #1			; units column.
00052C  3  86 64        	stx z80_e
00052E  3               numdg:
00052E  3  A9 30        	lda #48			; clear digit.
000530  3  85 61        	sta z80_a
000532  3               numdg1:
000532  3  A5 65        	lda z80_d
000534  3  C5 64        	cmp z80_e
000536  3  90 0F        	bcc numdg0		; nothing to show.
000538  3  38           	sec
000539  3  A5 65        	lda z80_d
00053B  3  E5 64        	sbc z80_e		; subtract from column.
00053D  3  85 65        	sta z80_d
00053F  3  E6 61        	inc z80_a		; increment digit.
000541  3  EE 6D 05     	inc flag
000544  3  4C 32 05     	jmp numdg1		; repeat until column is zero.
000547  3               numdg0:
000547  3  A0 00        	ldy #0
000549  3  A5 61        	lda z80_a
00054B  3  91 62        	sta (z80_bc),y		; write digit to buffer.
00054D  3  AD 6D 05     	lda flag
000550  3  F0 06        	beq :+
000552  3  E6 62        	inc z80_c		; next buffer position.
000554  3  D0 02        	bne :+
000556  3  E6 63        	inc z80_b
000558  3               :
000558  3  60           	rts
000559  3               num2dd:
000559  3  85 65        	sta z80_d		; Save number
00055B  3               
00055B  3  A9 01        	lda #1
00055D  3  8D 6D 05     	sta flag
000560  3               
000560  3  4C 20 05     	jmp numdg2
000563  3               num2td:
000563  3  85 65        	sta z80_d		; Save number
000565  3               
000565  3  A9 01        	lda #1
000567  3  8D 6D 05     	sta flag
00056A  3  4C 19 05     	jmp numdg3
00056D  3               
00056D  3  00           flag:	.byte 0
00056E  3               
00056E  3               ;---------------------------------------------------------
00056E  3               ; Reset score to "000000"
00056E  3               ;---------------------------------------------------------
00056E  3               
00056E  3               inisc:
00056E  3  A9 30        	lda #'0'
000570  3  A2 05        	ldx #5			; digits to initialise.
000572  3               inisc0:
000572  3  9D 97 07     	sta score,x 		; write zero digit.
000575  3  CA           	dex			; next column.
000576  3  10 FA        	bpl inisc0		; repeat for all digits.
000578  3               
000578  3  60           	rts
000579  3               
000579  3               ;-----------------------------------------------------
000579  3               ; Multiply h by d and return in hl.
000579  3               ;
000579  3               ; Input:
000579  3               ;  H = first number
000579  3               ;  D = second number
000579  3               ;
000579  3               ; Output:
000579  3               ;  HL = result H x D
000579  3               ;-----------------------------------------------------
000579  3               
000579  3               imul:
000579  3  A5 65        	lda z80_d		; HL = H * D
00057B  3  85 64        	sta z80_e
00057D  3  A5 67        	lda z80_h
00057F  3  85 62        	sta z80_c		; make c first multiplier.
000581  3               imul0:
000581  3  A9 00        	lda #0			; zeroise total.
000583  3  85 66        	sta z80_l
000585  3  85 67        	sta z80_h
000587  3               
000587  3  A5 67        	lda z80_h
000589  3  85 65        	sta z80_d		; zeroise high byte.
00058B  3               
00058B  3  A9 08        	lda #8			; repeat 8 times.
00058D  3  85 63        	sta z80_b
00058F  3               imul1:
00058F  3  46 62        	lsr z80_c		; rotate rightmost bit into carry.
000591  3  90 0E        	bcc imul2		; wasn't set.
000593  3  18           	clc			; bit was set, so add de.
000594  3  A5 66        	lda z80_l
000596  3  65 64        	adc z80_e
000598  3  85 66        	sta z80_l
00059A  3  A5 67        	lda z80_h
00059C  3  65 65        	adc z80_d
00059E  3  85 67        	sta z80_h
0005A0  3  18           	clc 			; reset carry.
0005A1  3               imul2:
0005A1  3  06 64        	asl z80_e 		; shift de 1 bit left.
0005A3  3  26 65        	rol z80_d
0005A5  3  C6 63        	dec z80_b
0005A7  3  D0 E6        	bne imul1		; repeat 8 times.
0005A9  3               
0005A9  3  60           	rts
0005AA  3               
0005AA  3               ;-----------------------------------------------
0005AA  3               ; Divide d by e and return in d, remainder in a.
0005AA  3               ;
0005AA  3               ; Input:
0005AA  3               ;  D = first number
0005AA  3               ;  E = second number
0005AA  3               ;
0005AA  3               ; Output:
0005AA  3               ;  D = result D/E
0005AA  3               ;  A = remainder
0005AA  3               ;-----------------------------------------------
0005AA  3               
0005AA  3               idiv:
0005AA  3  A9 00        	lda #0
0005AC  3  A0 08        	ldy #8		 	; bits to shift.
0005AE  3  06 65        	asl z80_d
0005B0  3               idiv0:
0005B0  3  2A           	rol a 			; multiply d by 2.
0005B1  3  C5 64        	cmp z80_e 		; test if e is smaller.
0005B3  3  90 02        	bcc idiv1		; e is greater, no division this time.
0005B5  3  E5 64        	sbc z80_e		; subtract it.
0005B7  3               idiv1:
0005B7  3  26 65        	rol z80_d		; rotate into d.
0005B9  3  88           	dey
0005BA  3  D0 F4        	bne idiv0		; repeat
0005BC  3  60           	rts
0005BD  3               
0005BD  3               ;---------------------------------------------------
0005BD  3               ; Play AY sound effect
0005BD  3               ;---------------------------------------------------
0005BD  3               
0005BD  3               plsnd:
0005BD  3  60           	rts
0005BE  3               
0005BE  3               ;---------------------------------------------------
0005BE  3               ; Objects handling.
0005BE  3               ; 32 bytes for image
0005BE  3               ; 3 for room, y and x
0005BE  3               ; 3 for starting room, y and x.
0005BE  3               ; 254 = disabled.
0005BE  3               ; 255 = object in player"s pockets.
0005BE  3               ;---------------------------------------------------
0005BE  3               
0005BE  3               ;---------------------------------------------------
0005BE  3               ; Show items present.
0005BE  3               ;---------------------------------------------------
0005BE  3               
0005BE  3               shwob:
0005BE  3  A9 D0        	lda #<objdta 			; objects table.
0005C0  3  85 66        	sta z80_l
0005C2  3  A9 1F        	lda #>objdta
0005C4  3  85 67        	sta z80_h
0005C6  3               
0005C6  3  AD 39 02     	lda numob 			; number of objects in the game.
0005C9  3  8D 06 12     	sta sprcnt
0005CC  3               shwob0:
0005CC  3  A0 20        	ldy #32 			; distance to room number.
0005CE  3  B1 66        	lda (z80_hl),y 			; same as an item?
0005D0  3  CD 3E 02     	cmp scno 			; current location.
0005D3  3  D0 03        	bne :+
0005D5  3  20 EB 05     	jsr dobj 			; yes, display object.
0005D8  3               :
0005D8  3  18           	clc
0005D9  3  A5 66        	lda z80_l
0005DB  3  69 26        	adc #38 			; distance to next item.
0005DD  3  85 66        	sta z80_l
0005DF  3  A5 67        	lda z80_h
0005E1  3  69 00        	adc #0
0005E3  3  85 67        	sta z80_h	 		; point to it.
0005E5  3  CE 06 12     	dec sprcnt
0005E8  3  D0 E2        	bne shwob0 			; repeat for others.
0005EA  3  60           	rts
0005EB  3               
0005EB  3               ;---------------------------------------------------
0005EB  3               ; Display object.
0005EB  3               ; hl must point to object's start address.
0005EB  3               ;
0005EB  3               ; Input:
0005EB  3               ;  HL = object address
0005EB  3               ;---------------------------------------------------
0005EB  3               
0005EB  3               dobj:
0005EB  3  A0 21        	ldy #33
0005ED  3  B1 66        	lda (z80_hl),y 			; point to y.
0005EF  3  8D 64 02     	sta dispy
0005F2  3  C8           	iny
0005F3  3  B1 66        	lda (z80_hl),y 			; point to x.
0005F5  3  8D 63 02     	sta dispx
0005F8  3               dobj1:
0005F8  3  4C E5 09     	jmp sprite 			; draw this sprite.
0005FB  3               
0005FB  3               ;--------------------------------------
0005FB  3               ; Remove an object.
0005FB  3               ;
0005FB  3               ; Input:
0005FB  3               ;  A = object number
0005FB  3               ;--------------------------------------
0005FB  3               
0005FB  3               remob:
0005FB  3  CD 39 02     	cmp numob			; number of objects in game.
0005FE  3  90 01        	bcc :+				; are we checking past the end?
000600  3  60           	rts				; yes, can't get non-existent item.
000601  3               :
000601  3  48           	pha				; remember object.
000602  3  20 10 06     	jsr getob			; pick it up if we haven't already got it.
000605  3  68           	pla				; retrieve object number.
000606  3  20 42 06     	jsr gotob			; get its address.
000609  3  A9 FE        	lda #254
00060B  3  A0 20        	ldy #32
00060D  3  91 66        	sta (z80_hl),y			; remove it.
00060F  3  60           	rts
000610  3               
000610  3               ;---------------------------------------------------
000610  3               ; Pick up object number held in the accumulator.
000610  3               ;
000610  3               ; Input:
000610  3               ;  A = object number
000610  3               ;---------------------------------------------------
000610  3               
000610  3               getob:
000610  3  CD 39 02     	cmp numob 		; number of objects in game.
000613  3  90 01        	bcc :+			; are we checking past the end?
000615  3  60           	rts			; yes, can't get non-existent item.
000616  3               :
000616  3  20 42 06     	jsr gotob 		; check if we already have it.
000619  3  C9 FF        	cmp #255
00061B  3  D0 01        	bne :+
00061D  3  60           	rts			; we already do.
00061E  3               :
00061E  3  A0 20        	ldy #32
000620  3  B1 66        	lda (z80_hl),y		; is it on this screen?
000622  3  CD 3E 02     	cmp scno 		; current screen.
000625  3  D0 16        	bne getob0		; not on screen, so nothing to delete.
000627  3               
000627  3  A9 FF        	lda #255
000629  3  91 66        	sta (z80_hl),y		; pick it up.
00062B  3  C8           	iny 			; point to y coord.
00062C  3               getob1:
00062C  3  A0 21        	ldy #33
00062E  3  B1 66        	lda (z80_hl),y		; y coord.
000630  3  8D 64 02     	sta dispy
000633  3  A0 22        	ldy #34
000635  3  B1 66        	lda (z80_hl),y 		; x coord.
000637  3  8D 63 02     	sta dispx
00063A  3  4C F8 05     	jmp dobj1 		; delete object sprite.
00063D  3               getob0:
00063D  3  A9 FF        	lda #255
00063F  3  91 66        	sta (z80_hl),y 		; pick it up.
000641  3  60           	rts
000642  3               
000642  3               ;-----------------------------------------------------------------
000642  3               ; Got object check.
000642  3               ; Call with object in accumulator, returns zero set if in pockets.
000642  3               ;
000642  3               ; Input:
000642  3               ;  A = object number
000642  3               ;-----------------------------------------------------------------
000642  3               
000642  3               gotob:
000642  3  CD 39 02     	cmp numob 		; number of objects in game.
000645  3  90 03        	bcc :+ 			; are we checking past the end?
000647  3  4C 4E 06     	jmp gotob0 		; yes, we can't have a non-existent object.
00064A  3               :
00064A  3  20 53 06     	jsr findob		; find the object.
00064D  3               gotob1:
00064D  3  60           	rts
00064E  3               
00064E  3               gotob0:
00064E  3  A9 FE        	lda #254 		; missing.
000650  3  4C 4D 06     	jmp gotob1
000653  3               
000653  3               findob:
000653  3  48           	pha			; save object number
000654  3  A9 D0        	lda #<objdta 		; objects.
000656  3  85 66        	sta z80_l
000658  3  A9 1F        	lda #>objdta
00065A  3  85 67        	sta z80_h
00065C  3  68           	pla			; retreive object number
00065D  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
00065F  3  AA           	tax 			; loop counter
000660  3               fndob2:
000660  3  18           	clc
000661  3  A5 66        	lda z80_l
000663  3  69 26        	adc #38 		; size of each object.
000665  3  85 66        	sta z80_l
000667  3  90 02        	bcc :+
000669  3  E6 67        	inc z80_h
00066B  3               :
00066B  3  CA           	dex 			; repeat until we find address.
00066C  3  D0 F2        	bne fndob2
00066E  3               fndob1:
00066E  3  A0 20        	ldy #32			; distance to room it's in.
000670  3  B1 66        	lda (z80_hl),y		; fetch status.
000672  3  60           	rts
000673  3               
000673  3               ;---------------------------------------------
000673  3               ; Drop object number at (dispx, dispy).
000673  3               ;
000673  3               ; Input:
000673  3               ;  A = object number
000673  3               ;---------------------------------------------
000673  3               
000673  3               drpob:
000673  3  CD 39 02     	cmp numob 		; are we checking past the end?
000676  3  90 01        	bcc :+
000678  3  60           	rts			; yes, can't drop non-existent item.
000679  3               :
000679  3  20 42 06     	jsr gotob		; make sure object is in inventory.
00067C  3  CD 3E 02     	cmp scno		; already on this screen?
00067F  3  D0 01        	bne :+
000681  3  60           	rts			; yes, nothing to do.
000682  3               :
000682  3  A0 20        	ldy #32
000684  3  AD 3E 02     	lda scno
000687  3  91 66        	sta (z80_hl),y		; bring onto screen.
000689  3  AD 64 02     	lda dispy		; sprite y coordinate.
00068C  3  C8           	iny 
00068D  3  91 66        	sta (z80_hl),y		; point to object y.
00068F  3  AD 63 02     	lda dispx 		; sprite x coordinate.
000692  3  C8           	iny
000693  3  91 66        	sta (z80_hl),y 		; point to object x
000695  3  4C EB 05     	jmp dobj		; draw the object sprite.
000698  3               
000698  3               ;-----------------------------------------------
000698  3               ; Seek objects at sprite position.
000698  3               ;
000698  3               ; Output:
000698  3               ;  A = object number, if not found A=255
000698  3               ;-----------------------------------------------
000698  3               
000698  3               skobj:
000698  3  A9 D0        	lda #<objdta 		; pointer to objects.
00069A  3  85 66        	sta z80_l
00069C  3  A9 1F        	lda #>objdta
00069E  3  85 67        	sta z80_h
0006A0  3               
0006A0  3  AD 39 02     	lda numob 		; number of objects in game.
0006A3  3  85 63        	sta z80_b 		; set up the loop counter.
0006A5  3               skobj0:
0006A5  3  AD 3E 02     	lda scno		; current room number.
0006A8  3  A0 20        	ldy #32
0006AA  3  D1 66        	cmp (z80_hl),y		; is object in here?
0006AC  3  D0 03        	bne :+
0006AE  3  20 C3 06     	jsr skobj1		; yes, check coordinates.
0006B1  3               :
0006B1  3  18           	clc			; point to next object in table.
0006B2  3  A5 66        	lda z80_l
0006B4  3  69 26        	adc #38			; size of each object.
0006B6  3  85 66        	sta z80_l
0006B8  3  90 02        	bcc :+
0006BA  3  E6 67        	inc z80_h
0006BC  3               :
0006BC  3  C6 63        	dec z80_b
0006BE  3  D0 E5        	bne skobj0		; repeat for all objects.
0006C0  3               
0006C0  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
0006C2  3  60           	rts
0006C3  3               
0006C3  3               skobj1:
0006C3  3  A0 21        	ldy #33			; point to y coordinate.
0006C5  3  B1 66        	lda (z80_hl),y		; point to y coordinate.
0006C7  3  38           	sec
0006C8  3  A0 08        	ldy #8
0006CA  3  F1 68        	sbc (z80_ix),y 		; subtract sprite y.
0006CC  3  18           	clc
0006CD  3  69 0F        	adc #15			; add sprite height minus one.
0006CF  3  C9 1F        	cmp #31			; within range?
0006D1  3  90 03        	bcc :+
0006D3  3  4C F1 06     	jmp skobj2		; no, ignore object.
0006D6  3               :
0006D6  3  A0 22        	ldy #34			; point to x coordinate now.
0006D8  3  B1 66        	lda (z80_hl),y 		; get coordinate.
0006DA  3  38           	sec
0006DB  3  A0 09        	ldy #9
0006DD  3  F1 68        	sbc (z80_ix),y 		; subtract the sprite x.
0006DF  3  18           	clc			; add sprite width minus one.
0006E0  3  69 0F        	adc #15
0006E2  3  C9 1F        	cmp #31			; within range?
0006E4  3  90 03        	bcc :+
0006E6  3  4C F1 06     	jmp skobj2		; no, ignore object.
0006E9  3               :
0006E9  3  68           	pla			; remove return address from stack.
0006EA  3  68           	pla
0006EB  3               
0006EB  3  AD 39 02     	lda numob 		; objects in game.
0006EE  3  38           	sec
0006EF  3  E5 63        	sbc z80_b		; subtract loop counter.
0006F1  3               skobj2:
0006F1  3  60           	rts			; accumulator now points to object.
0006F2  3               
0006F2  3               
0006F2  3               ;---------------------------------------------------------------------
0006F2  3               ; Spawn a new sprite.
0006F2  3               ;---------------------------------------------------------------------
0006F2  3               
0006F2  3               spawn:
0006F2  3  A9 76        	lda #<sprtab		; sprite table.
0006F4  3  85 66        	sta z80_l
0006F6  3  A9 17        	lda #>sprtab
0006F8  3  85 67        	sta z80_h
0006FA  3               numsp1:
0006FA  3  A9 0C        	lda #NUMSPR		; number of sprites.
0006FC  3  8D 93 07     	sta spcnt
0006FF  3               spaw0:
0006FF  3  A0 00        	ldy #0
000701  3  B1 66        	lda (z80_hl),y		; get sprite type.
000703  3  C9 FF        	cmp #255		; is it an unused slot?
000705  3  F0 10        	beq spaw1 		; yes, we can use this one.
000707  3               
000707  3  18           	clc 			; point to next sprite in table.
000708  3  A5 66        	lda z80_l
00070A  3  69 11        	adc #TABSIZ		; size of each entry.
00070C  3  85 66        	sta z80_l
00070E  3  90 02        	bcc :+
000710  3  E6 67        	inc z80_h
000712  3               :
000712  3  CE 93 07     	dec spcnt		; one less iteration.
000715  3  D0 E8        	bne spaw0		; keep going until we find a slot.
000717  3               
000717  3               ; Didn't find one but drop through and set up a dummy sprite instead.
000717  3               
000717  3               spaw1:
000717  3  A5 69        	lda z80_i		; address of original sprite.
000719  3  48           	pha
00071A  3  A5 68        	lda z80_x
00071C  3  48           	pha
00071D  3               
00071D  3  A5 66        	lda z80_l		; store spawned sprite address.
00071F  3  8D 94 07     	sta spptr
000722  3  A5 67        	lda z80_h
000724  3  8D 95 07     	sta spptr+1
000727  3               
000727  3  A5 62        	lda z80_c
000729  3  A0 00        	ldy #0
00072B  3  91 66        	sta (z80_hl),y 		; set the type.
00072D  3  A0 05        	ldy #5
00072F  3  91 66        	sta (z80_hl),y		; copy
000731  3               
000731  3  A5 63        	lda z80_b
000733  3  A0 01        	ldy #1
000735  3  91 66        	sta (z80_hl),y		; set the image.
000737  3  A0 06        	ldy #6
000739  3  91 66        	sta (z80_hl),y		; copy
00073B  3               
00073B  3  A9 00        	lda #0 			; frame zero.
00073D  3  A0 02        	ldy #2
00073F  3  91 66        	sta (z80_hl),y		; set frame.
000741  3  A0 07        	ldy #7
000743  3  91 66        	sta (z80_hl),y		; copy
000745  3               
000745  3  A0 08        	ldy #8
000747  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000749  3  A0 03        	ldy #3
00074B  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
00074D  3  A0 08        	ldy #8
00074F  3  91 66        	sta (z80_hl),y		; copy
000751  3               
000751  3  A0 09        	ldy #9
000753  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000755  3  A0 04        	ldy #4
000757  3  91 66        	sta (z80_hl),y		; set sprite coordinate.
000759  3  A0 09        	ldy #9
00075B  3  91 66        	sta (z80_hl),y		; copy
00075D  3               
00075D  3  A0 0A        	ldy #10			; direction of original.
00075F  3  B1 68        	lda (z80_ix),y
000761  3  91 66        	sta (z80_hl),y		; direction
000763  3               
000763  3  A9 00        	lda #0
000765  3  A0 0B        	ldy #11
000767  3  91 66        	sta (z80_hl),y		; reset parameter.
000769  3  C8           	iny
00076A  3  91 66        	sta (z80_hl),y		; reset parameter.
00076C  3  C8           	iny
00076D  3  91 66        	sta (z80_hl),y		; reset parameter.
00076F  3  C8           	iny
000770  3  91 66        	sta (z80_hl),y		; reset parameter.
000772  3               rtssp:
000772  3  AD 94 07     	lda spptr		; address of new sprite.
000775  3  85 68        	sta z80_x
000777  3  AD 95 07     	lda spptr+1
00077A  3  85 69        	sta z80_i
00077C  3               evis1:
00077C  3  20 6F 18     	jsr evnt09 		; call sprite initialisation event.
00077F  3               
00077F  3  AD 94 07     	lda spptr 		; address of new sprite.
000782  3  85 68        	sta z80_x
000784  3  AD 95 07     	lda spptr+1
000787  3  85 69        	sta z80_i
000789  3  20 9B 12     	jsr sspria 		; display the new sprite.
00078C  3               
00078C  3  68           	pla			; address of original sprite.
00078D  3  85 68        	sta z80_x
00078F  3  68           	pla
000790  3  85 69        	sta z80_i
000792  3               
000792  3  60           	rts
000793  3               
000793  3  00           spcnt:	.byte 0
000794  3  00 00        spptr:	.word 0			; spawned sprite pointer.
000796  3  00           seed:	.byte 0			; seed for random numbers.
000797  3  30 30 30 30  score:	.byte "000000"		; player"s score.
00079B  3  30 30        
00079D  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
0007A1  3  30 30        
0007A3  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0007A7  3  30 30        
0007A9  3  00 80        grbase:	.word ScreenAddr	; graphics base address.
0007AB  3               
0007AB  3               ;----------------------------------------------------
0007AB  3               ; Check y-pos
0007AB  3               ;----------------------------------------------------
0007AB  3               
0007AB  3               checkx:
0007AB  3  AD 64 02     	lda dispy		; y position.
0007AE  3  C9 18        	cmp #24			; off screen?
0007B0  3  B0 01        	bcs :+
0007B2  3  60           	rts			; no, it's okay.
0007B3  3               :
0007B3  3  68           	pla			; remove return address from stack.
0007B4  3  85 66        	sta z80_l
0007B6  3  68           	pla
0007B7  3  85 67        	sta z80_h
0007B9  3  60           	rts
0007BA  3               
0007BA  3               ;-----------------------------------------------
0007BA  3               ; Displays the current high score.
0007BA  3               ;-----------------------------------------------
0007BA  3               
0007BA  3               dhisc:
0007BA  3  A9 9D        	lda #<hiscor 		; high score text.
0007BC  3  85 66        	sta z80_l
0007BE  3  A9 07        	lda #>hiscor
0007C0  3  85 67        	sta z80_h
0007C2  3  4C CD 07     	jmp dscor1		; check in printable range then show 6 digits.
0007C5  3               
0007C5  3               ;------------------------------------------------------
0007C5  3               ; Displays the current score.
0007C5  3               ;------------------------------------------------------
0007C5  3               
0007C5  3               dscor:
0007C5  3  A9 97        	lda #<score		; score text.
0007C7  3  85 66        	sta z80_l
0007C9  3  A9 07        	lda #>score
0007CB  3  85 67        	sta z80_h
0007CD  3               dscor1:
0007CD  3  20 29 10     	jsr preprt		; set up font and print position.
0007D0  3  20 AB 07     	jsr checkx		; make sure we're in a printable range.
0007D3  3               
0007D3  3  A9 06        	lda #6			; digits to display.
0007D5  3  85 63        	sta z80_b
0007D7  3  AD 6B 0F     	lda prtmod		; get print mode.
0007DA  3  F0 03        	beq :+			; standard size text?
0007DC  3  4C 00 08     	jmp bscor0		; no, show double-height.
0007DF  3               :
0007DF  3               dscor0:
0007DF  3  A0 00        	ldy #0
0007E1  3  B1 66        	lda (z80_hl),y 		; fetch character.
0007E3  3  20 2B 09     	jsr pchar 		; display character.
0007E6  3  EE 63 02     	inc dispx		; move along x coordinate
0007E9  3               
0007E9  3  E6 66        	inc z80_l		; next score column.
0007EB  3  D0 02        	bne :+
0007ED  3  E6 67        	inc z80_h
0007EF  3               :
0007EF  3  C6 63        	dec z80_b
0007F1  3  D0 EC        	bne dscor0 		; repeat for all digits.
0007F3  3               dscor2:
0007F3  3  AD 63 02     	lda dispx 		; set up display coordinates.
0007F6  3  8D 58 02     	sta charx
0007F9  3  AD 64 02     	lda dispy
0007FC  3  8D 59 02     	sta chary
0007FF  3  60           	rts
000800  3               
000800  3               ;------------------------------------------------------
000800  3               ; Displays the current score in double-height characters.
000800  3               ;
000800  3               ; Input:
000800  3               ;  B  = digit number
000800  3               ;  HL = score string
000800  3               ;------------------------------------------------------
000800  3               
000800  3               bscor0:
000800  3  A0 00        	ldy #0
000802  3               
000802  3  B1 66        	lda (z80_hl),y 		; fetch character.
000804  3  20 A3 0F     	jsr bchar 		; display big char.
000807  3               
000807  3  E6 66        	inc z80_l 		; next score column.
000809  3  D0 02        	bne :+
00080B  3  E6 67        	inc z80_h
00080D  3               :
00080D  3  C6 63        	dec z80_b
00080F  3  F0 03        	beq :+
000811  3  4C 00 08     	jmp bscor0 		; repeat for all digits.
000814  3               :
000814  3  4C F3 07     	jmp dscor2 		; tidy up line and column variables.
000817  3               
000817  3               ;-----------------------------------------------------
000817  3               ; Adds number in the hl pair to the score.
000817  3               ;-----------------------------------------------------
000817  3               
000817  3               addsc:
000817  3  A9 98        	lda #<(score+1) 	; ten thousands column.
000819  3  85 64        	sta z80_e
00081B  3  A9 07        	lda #>(score+1)
00081D  3  85 65        	sta z80_d
00081F  3  A9 10        	lda #<10000		; amount to add each time.
000821  3  85 62        	sta z80_c
000823  3  A9 27        	lda #>10000
000825  3  85 63        	sta z80_b
000827  3  20 6B 08     	jsr incsc		; add to score.
00082A  3               
00082A  3  E6 64        	inc z80_e		; thousands column.
00082C  3  D0 02        	bne :+
00082E  3  E6 65        	inc z80_d
000830  3               :
000830  3  A9 E8        	lda #<1000		; amount to add each time.
000832  3  85 62        	sta z80_c
000834  3  A9 03        	lda #>1000
000836  3  85 63        	sta z80_b
000838  3  20 6B 08     	jsr incsc 		; add to score.
00083B  3               
00083B  3  E6 64        	inc z80_e		; hundreds column.
00083D  3  D0 02        	bne :+
00083F  3  E6 65        	inc z80_d
000841  3               :
000841  3  A9 64        	lda #<100		; amount to add each time.
000843  3  85 62        	sta z80_c
000845  3  A9 00        	lda #>100
000847  3  85 63        	sta z80_b
000849  3  20 6B 08     	jsr incsc		; add to score.
00084C  3               
00084C  3  E6 64        	inc z80_e 		; tens column.
00084E  3  D0 02        	bne :+
000850  3  E6 65        	inc z80_d
000852  3               :
000852  3  A9 0A        	lda #<10		; amount to add each time.
000854  3  85 62        	sta z80_c
000856  3  A9 00        	lda #>10
000858  3  85 63        	sta z80_b
00085A  3  20 6B 08     	jsr incsc 		; add to score.
00085D  3               
00085D  3  E6 64        	inc z80_e		; units column.
00085F  3  D0 02        	bne :+
000861  3  E6 65        	inc z80_d
000863  3               :
000863  3  A9 01        	lda #<1			; units.
000865  3  85 62        	sta z80_c
000867  3  A9 00        	lda #>1
000869  3  85 63        	sta z80_b
00086B  3               incsc:
00086B  3  A5 67        	lda z80_h		; store amount to add.
00086D  3  48           	pha
00086E  3  A5 66        	lda z80_l
000870  3  48           	pha
000871  3               
000871  3  38           	sec			; subtract from amount to add.
000872  3  A5 66        	lda z80_l
000874  3  E5 62        	sbc z80_c
000876  3  85 66        	sta z80_l
000878  3  A5 67        	lda z80_h
00087A  3  E5 63        	sbc z80_b
00087C  3  85 67        	sta z80_h
00087E  3  90 14        	bcc incsc0		; too much, restore value.
000880  3               
000880  3  68           	pla			; delete the previous amount from the stack.
000881  3  68           	pla
000882  3               
000882  3  A5 65        	lda z80_d 		; store column position.
000884  3  48           	pha
000885  3  A5 64        	lda z80_e
000887  3  48           	pha
000888  3  20 9B 08     	jsr incsc2		; do the increment.
00088B  3               
00088B  3  68           	pla			; restore column.
00088C  3  85 64        	sta z80_e
00088E  3  68           	pla
00088F  3  85 65        	sta z80_d
000891  3  4C 6B 08     	jmp incsc		; repeat until all added.
000894  3               
000894  3               incsc0:
000894  3  68           	pla			; restore previous value.
000895  3  85 66        	sta z80_l
000897  3  68           	pla
000898  3  85 67        	sta z80_h
00089A  3  60           	rts
00089B  3               incsc2:
00089B  3  A0 00        	ldy #0
00089D  3  B1 64        	lda (z80_de),y 		; get amount.
00089F  3  18           	clc
0008A0  3  69 01        	adc #1			; add one to column.
0008A2  3  91 64        	sta (z80_de),y		; write new column total.
0008A4  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
0008A6  3  B0 01        	bcs :+
0008A8  3  60           	rts			; no, carry on.
0008A9  3               :
0008A9  3  A9 30        	lda #'0'		; make it zero.
0008AB  3  91 64        	sta (z80_de),y		; write new column total.
0008AD  3  C6 64        	dec z80_e		; back one column.
0008AF  3  D0 02        	bne :+
0008B1  3  C6 65        	dec z80_d
0008B3  3               :
0008B3  3  4C 9B 08     	jmp incsc2
0008B6  3               
0008B6  3               ;------------------------------------
0008B6  3               ; Add bonus to score and reset bonus
0008B6  3               ;------------------------------------
0008B6  3               
0008B6  3               addbo:
0008B6  3  A2 05        	ldx #5			; last digit.
0008B8  3  18           	clc			; clear carry.
0008B9  3               addbo0:
0008B9  3  BD 97 07     	lda score,x		; get score.
0008BC  3  7D A3 07     	adc bonus,x		; add bonus.
0008BF  3  38           	sec			; 0 to 18.
0008C0  3  E9 30        	sbc #48
0008C2  3  48           	pha
0008C3  3  A9 30        	lda #'0'
0008C5  3  9D A3 07     	sta bonus,x		; zeroise bonus.
0008C8  3  68           	pla
0008C9  3  C9 3A        	cmp #58			; carried?
0008CB  3  B0 07        	bcs addbo2		; no, do next one.
0008CD  3  38           	sec
0008CE  3  E9 0A        	sbc #10			; subtract 10.
0008D0  3  38           	sec
0008D1  3  4C D5 08     	jmp addbo1
0008D4  3               addbo2:
0008D4  3  18           	clc
0008D5  3               addbo1:
0008D5  3  9D 97 07     	sta score,x		; write new score.
0008D8  3  CA           	dex			; next digit.
0008D9  3  10 DE        	bpl addbo0		; repeat for all 6 digits.
0008DB  3  60           	rts
0008DC  3               
0008DC  3               ;------------------------------------
0008DC  3               ; Swap score and bonus.
0008DC  3               ;------------------------------------
0008DC  3               
0008DC  3               swpsb:
0008DC  3  A2 05        	ldx #5			; digits to add.
0008DE  3               swpsb0:
0008DE  3  BD 97 07     	lda score,x 		; get score digits.
0008E1  3  48           	pha			; save digit
0008E2  3  BD A3 07     	lda bonus,x 		; get bonus digits.
0008E5  3  9D 97 07     	sta score,x		; switch score-bonus
0008E8  3  68           	pla
0008E9  3  9D A3 07     	sta bonus,x
0008EC  3  CA           	dex 			; repeat for all 6 digits.
0008ED  3  10 EF        	bpl swpsb0
0008EF  3  60           	rts
0008F0  3               
0008F0  3               ;----------------------------------------------------
0008F0  3               ; Get print address.
0008F0  3               ;----------------------------------------------------
0008F0  3               
0008F0  3               gprad:
0008F0  3  AD 63 02     	lda dispx		; get x
0008F3  3  85 80        	sta scraddr		; store lb address
0008F5  3  AD 64 02     	lda dispy		; get y
0008F8  3  09 80        	ora #$80		; add $80
0008FA  3  85 81        	sta scraddr+1		; store hb address
0008FC  3  60           	rts
0008FD  3               
0008FD  3               ;--------------------------------------------------------------
0008FD  3               ; Get property buffer address of char at (dispx, dispy) in hl.
0008FD  3               ; 
0008FD  3               ; Output:
0008FD  3               ;  bufaddr = MAP + dispy*32 + dispx
0008FD  3               ;--------------------------------------------------------------
0008FD  3               
0008FD  3               pradd:
0008FD  3  AD 64 02     	lda dispy 		; y coordinate.
000900  3  85 86        	sta bufaddr
000902  3  A9 00        	lda #0
000904  3  85 87        	sta bufaddr+1
000906  3  06 86        	asl bufaddr  		; multiply char by 32
000908  3  26 87        	rol bufaddr+1
00090A  3  06 86        	asl bufaddr
00090C  3  26 87        	rol bufaddr+1
00090E  3  06 86        	asl bufaddr
000910  3  26 87        	rol bufaddr+1
000912  3  06 86        	asl bufaddr
000914  3  26 87        	rol bufaddr+1
000916  3  06 86        	asl bufaddr
000918  3  26 87        	rol bufaddr+1
00091A  3  18           	clc			; add address of MAP graphics.
00091B  3  A5 86        	lda bufaddr
00091D  3  6D 63 02     	adc dispx
000920  3  69 00        	adc #<MAP
000922  3  85 86        	sta bufaddr
000924  3  A5 87        	lda bufaddr+1
000926  3  69 98        	adc #>MAP
000928  3  85 87        	sta bufaddr+1
00092A  3  60           	rts
00092B  3               
00092B  3               ;----------------------------------------------------
00092B  3               ; Display character in A at dispx,dispy.
00092B  3               ;
00092B  3               ; Input:
00092B  3               ;  A 	   = character to print
00092B  3               ;----------------------------------------------------
00092B  3               
00092B  3               pchar:
00092B  3  85 82        	sta fntaddr
00092D  3  A9 00        	lda #0
00092F  3  85 83        	sta fntaddr+1
000931  3  06 82        	asl fntaddr  		; multiply char by 8.
000933  3  26 83        	rol fntaddr+1
000935  3  06 82        	asl fntaddr
000937  3  26 83        	rol fntaddr+1
000939  3  06 82        	asl fntaddr
00093B  3  26 83        	rol fntaddr+1
00093D  3               
00093D  3  A5 82        	lda fntaddr
00093F  3  18           	clc
000940  3  6D 55 18     	adc FontPtr
000943  3  85 82        	sta fntaddr		; that's the low byte.
000945  3  A5 83        	lda fntaddr+1
000947  3  6D 56 18     	adc FontPtr+1
00094A  3  85 83        	sta fntaddr+1		; add displacement.
00094C  3               pchark:
00094C  3  20 F0 08     	jsr gprad		; get screen address.
00094F  3  A2 07        	ldx #7			; lines to write.
000951  3               pchar0:
000951  3  A0 00        	ldy #0
000953  3  B1 82        	lda (fntaddr),y 	; get image byte.
000955  3  BC 66 09     	ldy scrtab,x		; Get rowoffset
000958  3               
000958  3  49 00        	eor #TxtInvert		; Invert
00095A  3               
00095A  3  91 80        	sta (scraddr),y 	; copy to screen.
00095C  3  E6 82        	inc fntaddr		; next image byte.
00095E  3  D0 02        	bne :+
000960  3  E6 83        	inc fntaddr+1
000962  3               :
000962  3  CA           	dex			; next screen row down.
000963  3  10 EC        	bpl pchar0		; repeat.
000965  3  60           	rts
000966  3               
000966  3  E0 C0 A0 80  scrtab:		.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
00096A  3  60 40 20 00  
00096E  3               
00096E  3               ;----------------------------------------------
00096E  3               ; Print attributes, properties and pixels.
00096E  3               ;
00096E  3               ; Input:
00096E  3               ;  A	= tile number
00096E  3               ;----------------------------------------------
00096E  3               
00096E  3  00           colpatt:	.byte 0
00096F  3               
00096F  3               pattr:
00096F  3  85 63        	sta z80_b		; store cell in b register for now.
000971  3  AA           	tax
000972  3  BD 3A 1F     	lda bprop,x 		; block properties.
000975  3  85 62        	sta z80_c
000977  3  C9 08        	cmp #COLECT
000979  3  D0 05        	bne :+
00097B  3  A5 63        	lda z80_b
00097D  3  8D 6E 09     	sta colpatt
000980  3               :
000980  3  20 FD 08     	jsr pradd 		; get property buffer address.
000983  3  A5 62        	lda z80_c
000985  3  A0 00        	ldy #0
000987  3  91 86        	sta (bufaddr),y 	; write property.
000989  3  A5 63        	lda z80_b 		; restore cell.
00098B  3               
00098B  3               ; Print attributes, no properties.
00098B  3               
00098B  3               panp:
00098B  3  85 64        	sta z80_e		; displacement in e.
00098D  3  A9 00        	lda #0
00098F  3  85 65        	sta z80_d		; no high byte.
000991  3  06 64        	asl z80_e  		; multiply char by 8.
000993  3  26 65        	rol z80_d
000995  3  06 64        	asl z80_e
000997  3  26 65        	rol z80_d
000999  3  06 64        	asl z80_e
00099B  3  26 65        	rol z80_d
00099D  3  18           	clc
00099E  3  A5 64        	lda z80_e
0009A0  3  69 32        	adc #<chgfx 		; address of graphics.
0009A2  3  85 84        	sta tileaddr
0009A4  3  A5 65        	lda z80_d
0009A6  3  69 1F        	adc #>chgfx
0009A8  3  85 85        	sta tileaddr+1
0009AA  3  20 F0 08     	jsr gprad 		; get screen address.
0009AD  3  A2 07        	ldx #7			; number of pixel rows to write.
0009AF  3               panp0:
0009AF  3  A0 00        	ldy #0
0009B1  3  B1 84        	lda (tileaddr),y 	; get image byte.
0009B3  3  49 00        	eor #TxtInvert		; Invert
0009B5  3  BC 66 09     	ldy scrtab,x
0009B8  3  91 80        	sta (scraddr),y 	; copy to screen.
0009BA  3  E6 84        	inc tileaddr 		; next image byte.
0009BC  3  D0 02        	bne :+
0009BE  3  E6 85        	inc tileaddr+1
0009C0  3               :
0009C0  3  CA           	dex	 		; repeat for 8 pixel rows.
0009C1  3  10 EC        	bpl panp0
0009C3  3  EE 63 02     	inc dispx 		; move along one.
0009C6  3  EE 58 02     	inc charx
0009C9  3  60           	rts
0009CA  3               
0009CA  3               ;----------------------------------------------
0009CA  3               ; Print character pixels, no more.
0009CA  3               ;
0009CA  3               ; Input:
0009CA  3               ;  A	= character to print
0009CA  3               ;----------------------------------------------
0009CA  3               
0009CA  3               pchr:
0009CA  3  20 2B 09     	jsr pchar 		; show character in accumulator.
0009CD  3  EE 63 02     	inc dispx		; move along one.
0009D0  3  60           	rts
0009D1  3               
0009D1  3               ;----------------------------------------------------
0009D1  3               ; Shifter sprite routine for objects.
0009D1  3               ;----------------------------------------------------
0009D1  3               
0009D1  3               sprit7:
0009D1  3  A5 63        	lda z80_b
0009D3  3  F0 0F        	beq sprit0
0009D5  3  85 61        	sta z80_a
0009D7  3               sprit3:
0009D7  3  4E 68 0A     	lsr spr			; shift into position.
0009DA  3  6E 69 0A     	ror spr+1
0009DD  3  6E 6A 0A     	ror spr+2
0009E0  3  C6 61        	dec z80_a		; one less iteration.
0009E2  3  D0 F3        	bne sprit3
0009E4  3               sprit0:
0009E4  3  60           	rts 			; now apply to screen.
0009E5  3               
0009E5  3               ;----------------------------------------------------
0009E5  3               ; Draw sprite
0009E5  3               ;----------------------------------------------------
0009E5  3               
0009E5  3               sprite:
0009E5  3  8E 6B 0A     	stx xtmp		; Save X-reg
0009E8  3  20 78 12     	jsr scadd 		; get screen address in scraddr.
0009EB  3               
0009EB  3  AD 63 02     	lda dispx 		; x position.
0009EE  3  29 07        	and #7 			; position straddling cells.
0009F0  3  85 63        	sta z80_b		; store in b register.
0009F2  3               
0009F2  3  A5 66        	lda z80_l		; store sprite graphic address.
0009F4  3  8D 07 0A     	sta sprit1+1
0009F7  3  8D 0E 0A     	sta sprit2+1
0009FA  3  A5 67        	lda z80_h
0009FC  3  8D 08 0A     	sta sprit1+2
0009FF  3  8D 0F 0A     	sta sprit2+2
000A02  3               
000A02  3  A2 00        	ldx #0			; pixel height.
000A04  3  A0 00        	ldy #0
000A06  3               sprit1:
000A06  3  BD D0 1F     	lda objdta,x		; fetch first byte.
000A09  3  8D 68 0A     	sta spr
000A0C  3  E8           	inx
000A0D  3               sprit2:
000A0D  3  BD D0 1F     	lda objdta,x
000A10  3  8D 69 0A     	sta spr+1
000A13  3               
000A13  3  A9 00        	lda #0
000A15  3  8D 6A 0A     	sta spr+2
000A18  3  20 D1 09     	jsr sprit7		; shift sprite
000A1B  3               
000A1B  3  CA           	dex
000A1C  3  AD 68 0A     	lda spr			; fetch graphic.
000A1F  3  BC 48 0A     	ldy spritetab,x
000A22  3  51 80        	eor (scraddr),y		; merge with screen image.
000A24  3  91 80        	sta (scraddr),y		; write to screen.
000A26  3  E8           	inx			; next screen byte.
000A27  3               
000A27  3  AD 69 0A     	lda spr+1		; fetch graphic.
000A2A  3  BC 48 0A     	ldy spritetab,x
000A2D  3  51 80        	eor (scraddr),y		; merge with screen image.
000A2F  3  91 80        	sta (scraddr),y		; write to screen.
000A31  3  C8           	iny
000A32  3               
000A32  3  AD 6A 0A     	lda spr+2		; fetch graphic.
000A35  3  51 80        	eor (scraddr),y		; merge with screen image.
000A37  3  91 80        	sta (scraddr),y		; write to screen.
000A39  3               
000A39  3  E8           	inx			; next source byte.
000A3A  3  E0 10        	cpx #16
000A3C  3  D0 02        	bne :+
000A3E  3  E6 81        	inc scraddr+1
000A40  3               :
000A40  3  E0 20        	cpx #32
000A42  3  D0 C2        	bne sprit1		; repeat
000A44  3               
000A44  3  AE 6B 0A     	ldx xtmp		; retreive X-reg
000A47  3  60           	rts
000A48  3               
000A48  3               spritetab:
000A48  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
000A4C  3  40 41 60 61  
000A50  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000A54  3  C0 C1 E0 E1  
000A58  3  00 01 20 21  	.byte $00,$01,$20,$21,$40,$41,$60,$61
000A5C  3  40 41 60 61  
000A60  3  80 81 A0 A1  	.byte $80,$81,$a0,$a1,$c0,$c1,$e0,$e1
000A64  3  C0 C1 E0 E1  
000A68  3               
000A68  3  00 00 00     spr:	.byte 0,0,0
000A6B  3               
000A6B  3  00           xtmp:	.byte 0
000A6C  3               
000A6C  3               ;-----------------------------------------------------------
000A6C  3               ; Get room address.
000A6C  3               ;-----------------------------------------------------------
000A6C  3               
000A6C  3               groom:
000A6C  3  AE 3E 02     	ldx scno 		; screen number.
000A6F  3  A0 00        	ldy #0
000A71  3               groomx:
000A71  3  A9 BF        	lda #<scdat 		; pointer to screens.
000A73  3  85 66        	sta z80_l
000A75  3  A9 1F        	lda #>scdat
000A77  3  85 67        	sta z80_h
000A79  3               groom1:
000A79  3  E0 00        	cpx #0			; is it the first one?
000A7B  3  F0 15        	beq groom0 		; no more screens to skip.
000A7D  3               
000A7D  3  18           	clc
000A7E  3  A5 66        	lda z80_l
000A80  3  79 BF 1F     	adc scdat,y 		; low byte of screen size.
000A83  3  85 66        	sta z80_l
000A85  3  C8           	iny			; point to high byte.
000A86  3  A5 67        	lda z80_h
000A88  3  79 BF 1F     	adc scdat,y 		; high byte of screen size.
000A8B  3  85 67        	sta z80_h
000A8D  3  C8           	iny			; next address.
000A8E  3               
000A8E  3  CA           	dex 			; one less iteration.
000A8F  3  4C 79 0A     	jmp groom1 		; loop until we reach the end.
000A92  3               groom0:
000A92  3  AD CA 1F     	lda numsc 		; add displacement.
000A95  3  0A           	asl a
000A96  3  18           	clc			; add double displacement to address.
000A97  3  65 66        	adc z80_l
000A99  3  85 66        	sta z80_l
000A9B  3  A5 67        	lda z80_h
000A9D  3  69 00        	adc #0
000A9F  3  85 67        	sta z80_h
000AA1  3  60           	rts
000AA2  3               
000AA2  3               ;-----------------------------------------------------------
000AA2  3               ; Draw present room.
000AA2  3               ;-----------------------------------------------------------
000AA2  3               
000AA2  3               droom:
000AA2  3  AD 35 02     	lda wintop 		; window top.
000AA5  3  8D 64 02     	sta dispy		; set cursor y position.
000AA8  3               droom2:
000AA8  3  20 6C 0A     	jsr groom 		; get address of current room.
000AAB  3  A9 00        	lda #0	 		; zero in accumulator.
000AAD  3  8D 0A 0B     	sta comcnt 		; reset compression counter.
000AB0  3  AD 37 02     	lda winhgt 		; height of window.
000AB3  3  8D D7 0A     	sta rrow		; set row counter
000AB6  3               droom0:
000AB6  3  AD 36 02     	lda winlft 		; window left edge.
000AB9  3  8D 63 02     	sta dispx 		; set cursor x position.
000ABC  3  AD 38 02     	lda winwid 		; width of window.
000ABF  3  8D D6 0A     	sta rcol		; set column counter
000AC2  3               droom1:
000AC2  3  20 D8 0A     	jsr flbyt 		; decompress next byte on the fly.
000AC5  3  20 6F 09     	jsr pattr 		; show attributes and block.
000AC8  3  CE D6 0A     	dec rcol		; one less column.
000ACB  3  D0 F5        	bne droom1 		; repeat for entire line.
000ACD  3  EE 64 02     	inc dispy		; move down one line.
000AD0  3  CE D7 0A     	dec rrow 		; one less row.
000AD3  3  D0 E1        	bne droom0 		; repeat for all rows.
000AD5  3  60           	rts
000AD6  3               
000AD6  3  00           rcol:	.byte 0
000AD7  3  00           rrow:	.byte 0
000AD8  3               
000AD8  3               ;----------------------------------------------
000AD8  3               ; Decompress bytes on-the-fly.
000AD8  3               ;----------------------------------------------
000AD8  3               
000AD8  3               flbyt:
000AD8  3  AD 0A 0B     	lda comcnt 		; compression counter.
000ADB  3  D0 22        	bne flbyt1		; any more to decompress?  yes.
000ADD  3               
000ADD  3  A0 00        	ldy #0
000ADF  3  B1 66        	lda (z80_hl),y 		; fetch next byte.
000AE1  3  E6 66        	inc z80_l 		; point to next cell.
000AE3  3  D0 02        	bne :+
000AE5  3  E6 67        	inc z80_h
000AE7  3               :
000AE7  3  C9 FF        	cmp #255 		; is this byte a control code?
000AE9  3  F0 01        	beq :+
000AEB  3  60           	rts 			; no, this byte is uncompressed.
000AEC  3               :
000AEC  3  B1 66        	lda (z80_hl),y 		; fetch byte type.
000AEE  3  8D 09 0B     	sta combyt 		; set up the type.
000AF1  3  E6 66        	inc z80_l 		; point to quantity.
000AF3  3  D0 02        	bne :+
000AF5  3  E6 67        	inc z80_h
000AF7  3               :
000AF7  3  B1 66        	lda (z80_hl),y 		; get quantity.
000AF9  3  E6 66        	inc z80_l 		; point to next byte.
000AFB  3  D0 02        	bne :+
000AFD  3  E6 67        	inc z80_h
000AFF  3               :
000AFF  3               flbyt1:
000AFF  3  8D 0A 0B     	sta comcnt 		; store new quantity.
000B02  3  CE 0A 0B     	dec comcnt		; one less.
000B05  3  AD 09 0B     	lda combyt 		; byte to expand.
000B08  3  60           	rts
000B09  3               
000B09  3  00           combyt:	.byte 0			; byte type compressed.
000B0A  3  00           comcnt:	.byte 0			; compression counter.
000B0B  3               
000B0B  3               ;------------------------------------------
000B0B  3               ; Ladder down check.
000B0B  3               ;
000B0B  3               ; Input:
000B0B  3               ;  IX = sprite pointer
000B0B  3               ;------------------------------------------
000B0B  3               
000B0B  3               laddd:
000B0B  3  A0 09        	ldy #9
000B0D  3  B1 68        	lda (z80_ix),y		; x coordinate.
000B0F  3  8D 63 02     	sta dispx
000B12  3               
000B12  3  A0 08        	ldy #8
000B14  3  B1 68        	lda (z80_ix),y		; y coordinate.
000B16  3  29 FE        	and #254		; make it even.
000B18  3  91 68        	sta (z80_ix),y 		; reset it.
000B1A  3               numsp5:
000B1A  3  18           	clc 			; look down 16 pixels.
000B1B  3  69 10        	adc #16
000B1D  3  8D 64 02     	sta dispy		; coords in dispx,dispy.
000B20  3  4C 38 0B     	jmp laddv
000B23  3               
000B23  3               ;------------------------------------------
000B23  3               ; Ladder up check.
000B23  3               ;
000B23  3               ; Input:
000B23  3               ;  IX = sprite pointer
000B23  3               ;
000B23  3               ; Output:
000B23  3               ;  A  = 0 is ok, A <>0 is not ok
000B23  3               ;------------------------------------------
000B23  3               
000B23  3               laddu:
000B23  3  A0 09        	ldy #9
000B25  3  B1 68        	lda (z80_ix),y		; x coordinate.
000B27  3  8D 63 02     	sta dispx
000B2A  3               
000B2A  3  A0 08        	ldy #8
000B2C  3  B1 68        	lda (z80_ix),y		; y coordinate.
000B2E  3  29 FE        	and #254 		; make it even.
000B30  3  91 68        	sta (z80_ix),y		; reset it.
000B32  3               numsp6:
000B32  3  18           	clc 			; look 2 pixels above feet.
000B33  3  69 0E        	adc #14
000B35  3  8D 64 02     	sta dispy		; coords in dispx,dispy.
000B38  3               laddv:
000B38  3  20 99 0D     	jsr tstbl 		; get map address.
000B3B  3  20 52 0C     	jsr ldchk 		; standard ladder check.
000B3E  3  F0 01        	beq :+
000B40  3  60           	rts 			; no way through.
000B41  3               :
000B41  3  E6 86        	inc bufaddr 		; look right one cell.
000B43  3  D0 02        	bne :+
000B45  3  E6 87        	inc bufaddr+1
000B47  3               :
000B47  3  20 52 0C     	jsr ldchk 		; do the check.
000B4A  3  F0 01        	beq :+
000B4C  3  60           	rts 			; impassable.
000B4D  3               :
000B4D  3  AD 63 02     	lda dispx 		; y coordinate.
000B50  3  29 07        	and #7 			; position straddling block cells.
000B52  3  D0 01        	bne :+
000B54  3  60           	rts 			; no more checks needed.
000B55  3               :
000B55  3  E6 86        	inc bufaddr 		; look to third cell.
000B57  3  D0 02        	bne :+
000B59  3  E6 87        	inc bufaddr+1
000B5B  3               :
000B5B  3  20 52 0C     	jsr ldchk 		; do the check.
000B5E  3  60           	rts  			; return with zero flag set accordingly.
000B5F  3               
000B5F  3               ;---------------------------------------------------------
000B5F  3               ; Can go up check.
000B5F  3               ;
000B5F  3               ; Input:
000B5F  3               ;  IX = sprite pointer
000B5F  3               ;
000B5F  3               ; Output:
000B5F  3               ;  A  = 0 is ok, A <>0 is not ok
000B5F  3               ;---------------------------------------------------------
000B5F  3               
000B5F  3               cangu:
000B5F  3  A0 09        	ldy #9
000B61  3  B1 68        	lda (z80_ix),y		; x coordinate.
000B63  3  8D 63 02     	sta dispx
000B66  3  A0 08        	ldy #8
000B68  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000B6A  3  38           	sec
000B6B  3  E9 02        	sbc #2
000B6D  3  8D 64 02     	sta dispy		; coords in dispx,dispy.
000B70  3  20 99 0D     	jsr tstbl 		; get map address.
000B73  3  20 1C 0C     	jsr lrchk 		; standard left/right check.
000B76  3  F0 01        	beq :+
000B78  3  60           	rts			; no way through.
000B79  3               :
000B79  3  E6 86        	inc bufaddr		; look right one cell.
000B7B  3  D0 02        	bne :+
000B7D  3  E6 87        	inc bufaddr+1
000B7F  3               :
000B7F  3  20 1C 0C     	jsr lrchk 		; do the check.
000B82  3  F0 01        	beq :+
000B84  3  60           	rts			; impassable.
000B85  3               :
000B85  3  AD 63 02     	lda dispx		; x coordinate.
000B88  3  29 07        	and #7			; position straddling block cells.
000B8A  3  D0 01        	bne :+
000B8C  3  60           	rts			; no more checks needed.
000B8D  3               :
000B8D  3  E6 86        	inc bufaddr		; look to third cell.
000B8F  3  D0 02        	bne :+
000B91  3  E6 87        	inc bufaddr+1
000B93  3               :
000B93  3  20 1C 0C     	jsr lrchk		; do the check.
000B96  3  60           	rts 			; return with zero flag set accordingly.
000B97  3               
000B97  3               ;---------------------------------------------------------
000B97  3               ; Can go down check.
000B97  3               ;
000B97  3               ; Input:
000B97  3               ;  IX = sprite pointer
000B97  3               ;
000B97  3               ; Output:
000B97  3               ;  A  = 0 is ok, A <>0 is not ok
000B97  3               ;---------------------------------------------------------
000B97  3               
000B97  3               cangd:
000B97  3  A0 09        	ldy #9
000B99  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000B9B  3  8D 63 02     	sta dispx
000B9E  3  A0 08        	ldy #8
000BA0  3  B1 68        	lda (z80_ix),y		; y coordinate.
000BA2  3               numsp3:
000BA2  3  18           	clc
000BA3  3  69 10        	adc #16 		; look down 16 pixels.
000BA5  3  8D 64 02     	sta dispy		; coords in dispx,dispy.
000BA8  3  20 99 0D     	jsr tstbl 		; get map address.
000BAB  3  20 31 0C     	jsr plchk 		; block, platform check.
000BAE  3  F0 01        	beq :+
000BB0  3  60           	rts			; no way through.
000BB1  3               :
000BB1  3  E6 86        	inc bufaddr		; look right one cell.
000BB3  3  D0 02        	bne :+
000BB5  3  E6 87        	inc bufaddr+1
000BB7  3               :
000BB7  3  20 31 0C     	jsr plchk		; block, platform check.
000BBA  3  F0 01        	beq :+
000BBC  3  60           	rts			; impassable.
000BBD  3               :
000BBD  3  AD 63 02     	lda dispx		; x coordinate.
000BC0  3  29 07        	and #7			; position straddling block cells.
000BC2  3  D0 01        	bne :+
000BC4  3  60           	rts			; no more checks needed.
000BC5  3               :
000BC5  3  E6 86        	inc bufaddr		; look to third cell.
000BC7  3  D0 02        	bne :+
000BC9  3  E6 87        	inc bufaddr+1
000BCB  3               :
000BCB  3  20 31 0C     	jsr plchk		; block, platform check.
000BCE  3  60           	rts			; return with zero flag set accordingly.
000BCF  3               
000BCF  3               ;---------------------------------------------------------
000BCF  3               ; Can go left check.
000BCF  3               ;
000BCF  3               ; Input:
000BCF  3               ;  IX = sprite pointer
000BCF  3               ;
000BCF  3               ; Output:
000BCF  3               ;  A  = 0 is ok, A <>0 is not ok
000BCF  3               ;---------------------------------------------------------
000BCF  3               
000BCF  3               cangl:
000BCF  3  A0 08        	ldy #8
000BD1  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000BD3  3  8D 64 02     	sta dispy
000BD6  3  A0 09        	ldy #9
000BD8  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000BDA  3  38           	sec
000BDB  3  E9 02        	sbc #2			; look left 2 pixels.
000BDD  3  8D 63 02     	sta dispx		; coords in dispx,dispy.
000BE0  3  4C F4 0B     	jmp cangh		; test if we can go there.
000BE3  3               
000BE3  3               ;---------------------------------------------------------
000BE3  3               ; Can go right check.
000BE3  3               ;
000BE3  3               ; Input:
000BE3  3               ;  IX = sprite pointer
000BE3  3               ;
000BE3  3               ; Output:
000BE3  3               ;  A  = 0 is ok, A <>0 is not ok
000BE3  3               ;---------------------------------------------------------
000BE3  3               
000BE3  3               cangr:
000BE3  3  A0 08        	ldy #8
000BE5  3  B1 68        	lda (z80_ix),y		; y coordinate.
000BE7  3  8D 64 02     	sta dispy
000BEA  3  A0 09        	ldy #9
000BEC  3  B1 68        	lda (z80_ix),y		; x coordinate.
000BEE  3  18           	clc
000BEF  3  69 10        	adc #16			; look right 16 pixels.
000BF1  3  8D 63 02     	sta dispx		; coords in dispx,dispy.
000BF4  3               cangh:
000BF4  3               cangh2:
000BF4  3  A9 03        	lda #3			; default rows to write.
000BF6  3  85 63        	sta z80_b
000BF8  3  AD 64 02     	lda dispy		; y position.
000BFB  3  29 07        	and #7			; does x straddle cells?
000BFD  3  D0 02        	bne cangh0		; yes, loop counter is good.
000BFF  3  C6 63        	dec z80_b		; one less row to write.
000C01  3               cangh0:
000C01  3  20 99 0D     	jsr tstbl		; get map address.
000C04  3               cangh1:
000C04  3  20 1C 0C     	jsr lrchk		; standard left/right check.
000C07  3  F0 01        	beq :+
000C09  3  60           	rts			; no way through.
000C0A  3               :
000C0A  3  48           	pha
000C0B  3  18           	clc
000C0C  3  A5 86        	lda bufaddr
000C0E  3  69 20        	adc #32			; look down.
000C10  3  85 86        	sta bufaddr
000C12  3  90 02        	bcc :+
000C14  3  E6 87        	inc bufaddr+1
000C16  3               :
000C16  3  68           	pla
000C17  3               
000C17  3  C6 63        	dec z80_b
000C19  3  D0 E9        	bne cangh1
000C1B  3  60           	rts
000C1C  3               
000C1C  3               ;-------------------------------------
000C1C  3               ; Check left/right movement is okay.
000C1C  3               ;
000C1C  3               ; Input:
000C1C  3               ;  bufaddr = MAP + x/8 + y/8*32
000C1C  3               ;
000C1C  3               ; Output:
000C1C  3               ;  A  = 0 is ok, A <>0 is not ok
000C1C  3               ;-------------------------------------
000C1C  3               
000C1C  3               lrchk:
000C1C  3  A0 00        	ldy #0
000C1E  3  B1 86        	lda (bufaddr),y		; fetch map cell.
000C20  3  C9 02        	cmp #WALL 		; is it passable?
000C22  3  F0 0A        	beq lrchkx		; no.
000C24  3               
000C24  3  C9 04        	cmp #FODDER		; fodder has to be dug.
000C26  3  F0 06        	beq lrchkx		; not passable.
000C28  3  A9 00        	lda #0
000C2A  3  60           	rts
000C2B  3               
000C2B  3               ;--------------------------------------------------------------
000C2B  3               ; Called by mmenu
000C2B  3               ;--------------------------------------------------------------
000C2B  3               
000C2B  3               always:
000C2B  3  A9 FF        	lda #255		; report it as okay.
000C2D  3  60           	rts
000C2E  3               
000C2E  3               lrchkx:
000C2E  3  A9 01        	lda #1 			; reset all bits.
000C30  3  60           	rts
000C31  3               
000C31  3               
000C31  3               ;--------------------------------------------------------------
000C31  3               ; Check platform or solid item is not in way.
000C31  3               ;
000C31  3               ; Input:
000C31  3               ;  bufaddr = MAP + x/8 + y/8*32
000C31  3               ;
000C31  3               ; Output:
000C31  3               ;  A  = 0 is ok, A <>0 is not ok
000C31  3               ;--------------------------------------------------------------
000C31  3               
000C31  3               plchk:
000C31  3  A0 00        	ldy #0
000C33  3  B1 86        	lda (bufaddr),y 	; fetch map cell.
000C35  3  C9 02        	cmp #WALL 		; is it passable?
000C37  3  F0 F5        	beq lrchkx		; no.
000C39  3               
000C39  3  C9 04        	cmp #FODDER		; fodder has to be dug.
000C3B  3  F0 F1        	beq lrchkx		; not passable.
000C3D  3               
000C3D  3  C9 01        	cmp #PLATFM		; platform is solid.
000C3F  3  F0 07        	beq plchkx		; not passable.
000C41  3               
000C41  3  C9 03        	cmp #LADDER		; is it a ladder?
000C43  3  F0 E9        	beq lrchkx		; on ladder, deny movement.
000C45  3               plchk0:
000C45  3  A9 00        	lda #0			; report as ok
000C47  3  60           	rts
000C48  3               plchkx:
000C48  3  AD 64 02     	lda dispy		; x coordinate.
000C4B  3  29 07        	and #7			; position straddling blocks.
000C4D  3  F0 DF        	beq lrchkx		; on platform, deny movement.
000C4F  3  4C 45 0C     	jmp plchk0
000C52  3               
000C52  3               ;--------------------------------------------------------------
000C52  3               ; Check ladder is available.
000C52  3               ;
000C52  3               ; Input:
000C52  3               ;  bufaddr = MAP + x/8 + y/8*32
000C52  3               ;
000C52  3               ; Output:
000C52  3               ;  A  = 0 is ok, A <>0 is not ok
000C52  3               ;--------------------------------------------------------------
000C52  3               
000C52  3               ldchk:
000C52  3  A0 00        	ldy #0
000C54  3  B1 86        	lda (bufaddr),y 	; fetch cell.
000C56  3  C9 03        	cmp #LADDER 		; is it a ladder?
000C58  3  F0 03        	beq :+
000C5A  3  A9 01        	lda #1
000C5C  3  60           	rts  			; return with zero flag set accordingly.
000C5D  3               :
000C5D  3  A9 00        	lda #0
000C5F  3  60           	rts
000C60  3               
000C60  3               ;--------------------------------------------------------------
000C60  3               ; Get collectables.
000C60  3               ;--------------------------------------------------------------
000C60  3               
000C60  3               getcol:
000C60  3  A9 08                lda #COLECT             ; collectable blocks.
000C62  3  85 63                sta z80_b
000C64  3  20 DA 0C             jsr tded                ; test for collectable blocks.
000C67  3  C5 63                cmp z80_b               ; did we find one?
000C69  3  F0 01                beq :+
000C6B  3  60                   rts                     ; none were found, job done.
000C6C  3               :
000C6C  3  20 75 0C             jsr gtblk               ; get block.
000C6F  3  20 BE 1D             jsr evnt20              ; collected block event.
000C72  3  4C 60 0C             jmp getcol              ; repeat until none left.
000C75  3               
000C75  3               ; Get collectable block.
000C75  3               
000C75  3               gtblk:
000C75  3  A0 00        	ldy #0
000C77  3  B1 86        	lda (bufaddr),y
000C79  3  85 61        	sta z80_a
000C7B  3  A9 00                lda #0
000C7D  3  91 86                sta (bufaddr),y		; make it empty now.
000C7F  3                      
000C7F  3  A5 86        	lda bufaddr		; set dispx
000C81  3  29 1F        	and #31
000C83  3  8D 63 02     	sta dispx
000C86  3               
000C86  3  A5 87        	lda bufaddr+1		; Set dispy
000C88  3  38           	sec
000C89  3  E9 98        	sbc #>MAP
000C8B  3  85 87        	sta bufaddr+1
000C8D  3  06 86        	asl bufaddr
000C8F  3  26 87        	rol bufaddr+1
000C91  3  06 86        	asl bufaddr
000C93  3  26 87        	rol bufaddr+1
000C95  3  06 86        	asl bufaddr
000C97  3  26 87        	rol bufaddr+1
000C99  3  A5 87        	lda bufaddr+1
000C9B  3  8D 64 02     	sta dispy
000C9E  3                
000C9E  3  AD 6E 09     	lda colpatt		; get blocknr
000CA1  3  85 64        	sta z80_e		; displacement in e.
000CA3  3  A9 00        	lda #0
000CA5  3  85 65        	sta z80_d		; no high byte.
000CA7  3  06 64        	asl z80_e  		; multiply char by 8.
000CA9  3  26 65        	rol z80_d
000CAB  3  06 64        	asl z80_e
000CAD  3  26 65        	rol z80_d
000CAF  3  06 64        	asl z80_e
000CB1  3  26 65        	rol z80_d
000CB3  3  18           	clc
000CB4  3  A5 64        	lda z80_e
000CB6  3  69 32        	adc #<chgfx 		; address of graphics.
000CB8  3  85 84        	sta tileaddr
000CBA  3  A5 65        	lda z80_d
000CBC  3  69 1F        	adc #>chgfx
000CBE  3  85 85        	sta tileaddr+1
000CC0  3  20 F0 08     	jsr gprad 		; get screen address.
000CC3  3  A2 07        	ldx #7			; number of pixel rows to write.
000CC5  3               gtblk0:
000CC5  3  A0 00        	ldy #0
000CC7  3  B1 84        	lda (tileaddr),y 	; get image byte.
000CC9  3  BC 66 09     	ldy scrtab,x
000CCC  3  51 80        	eor (scraddr),y 	; XOR tile on screen
000CCE  3  91 80        	sta (scraddr),y 	; copy to screen.
000CD0  3  E6 84        	inc tileaddr 		; next image byte.
000CD2  3  D0 02        	bne :+
000CD4  3  E6 85        	inc tileaddr+1
000CD6  3               :
000CD6  3  CA           	dex	 		; repeat for 8 pixel rows.
000CD7  3  10 EC        	bpl gtblk0
000CD9  3  60           	rts
000CDA  3               
000CDA  3               ;--------------------------------------------------------------
000CDA  3               ; Touched deadly block check.
000CDA  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
000CDA  3               ;
000CDA  3               ; Input:
000CDA  3               ;  IX = sprite address
000CDA  3               ;
000CDA  3               ; Output:
000CDA  3               ;  A  = 0 is ok, A=5 is not ok
000CDA  3               ;--------------------------------------------------------------
000CDA  3               
000CDA  3               tded:
000CDA  3  A0 08        	ldy #8
000CDC  3  B1 68        	lda (z80_ix),y 		; y coordinate.
000CDE  3  8D 64 02     	sta dispy
000CE1  3  C8           	iny
000CE2  3  B1 68        	lda (z80_ix),y 		; x coordinate.
000CE4  3  8D 63 02     	sta dispx		; coords in dispx,dispy.
000CE7  3  20 99 0D     	jsr tstbl		; get map address.
000CEA  3  48           	pha
000CEB  3  A9 1F        	lda #31			; default distance to next line down.
000CED  3  85 64        	sta z80_e
000CEF  3  68           	pla
000CF0  3  C5 63        	cmp z80_b		; is this the required block?
000CF2  3  D0 01        	bne :+
000CF4  3  60           	rts			; yes.
000CF5  3               :
000CF5  3  E6 86        	inc bufaddr 		; next cell.
000CF7  3  D0 02        	bne :+
000CF9  3  E6 87        	inc bufaddr+1
000CFB  3               :
000CFB  3  A0 00        	ldy #0
000CFD  3  B1 86        	lda (bufaddr),y		; fetch type.
000CFF  3  C5 63        	cmp z80_b 		; is this deadly/custom?
000D01  3  D0 01        	bne :+
000D03  3  60           	rts			; yes.
000D04  3               :
000D04  3  AD 63 02     	lda dispx		; horizontal position.
000D07  3  85 62        	sta z80_c 		; store column in c register.
000D09  3  29 07        	and #7			; is it straddling cells?
000D0B  3  D0 03        	bne :+
000D0D  3  4C 21 0D     	jmp tded0		; no.
000D10  3               :
000D10  3  E6 86        	inc bufaddr 		; last cell.
000D12  3  D0 02        	bne :+
000D14  3  E6 87        	inc bufaddr+1
000D16  3               :
000D16  3  A0 00        	ldy #0
000D18  3  B1 86        	lda (bufaddr),y 	; fetch type.
000D1A  3  C5 63        	cmp z80_b		; is this the block?
000D1C  3  D0 01        	bne :+
000D1E  3  60           	rts			; yes.
000D1F  3               :
000D1F  3  C6 64        	dec z80_e		; one less cell to next row down.
000D21  3               tded0:
000D21  3  18           	clc 			; point to next row.
000D22  3  A5 86        	lda bufaddr
000D24  3  65 64        	adc z80_e
000D26  3  85 86        	sta bufaddr
000D28  3  90 02        	bcc :+
000D2A  3  E6 87        	inc bufaddr+1
000D2C  3               :
000D2C  3  A0 00        	ldy #0
000D2E  3  B1 86        	lda (bufaddr),y		; fetch left cell block.
000D30  3  C5 63        	cmp z80_b		; is this fatal?
000D32  3  D0 01        	bne :+
000D34  3  60           	rts			; yes.
000D35  3               :
000D35  3  E6 86        	inc bufaddr 		; next cell.
000D37  3  D0 02        	bne :+
000D39  3  E6 87        	inc bufaddr+1
000D3B  3               :
000D3B  3  A0 00        	ldy #0
000D3D  3  B1 86        	lda (bufaddr),y 	; fetch type.
000D3F  3  C5 63        	cmp z80_b		; is this fatal?
000D41  3  D0 01        	bne :+
000D43  3  60           	rts			; yes.
000D44  3               :
000D44  3  A5 62        	lda z80_c		; horizontal position.
000D46  3  29 07        	and #7			; is it straddling cells?
000D48  3  D0 03        	bne :+
000D4A  3  4C 5C 0D     	jmp tded1 		; no.
000D4D  3               :
000D4D  3  E6 86        	inc bufaddr		; last cell.
000D4F  3  D0 02        	bne :+
000D51  3  E6 87        	inc bufaddr+1
000D53  3               :
000D53  3  A0 00        	ldy #0
000D55  3  B1 86        	lda (bufaddr),y		; fetch type.
000D57  3  C5 63        	cmp z80_b		; is this fatal?
000D59  3  D0 01        	bne :+
000D5B  3  60           	rts			; yes.
000D5C  3               :
000D5C  3               tded1:
000D5C  3  AD 64 02     	lda dispy		; vertical position.
000D5F  3  29 07        	and #7 			; is it straddling cells?
000D61  3  D0 01        	bne :+
000D63  3  60           	rts			; no, job done.
000D64  3               :
000D64  3  18           	clc			; point to next row.
000D65  3  A5 86        	lda bufaddr
000D67  3  65 64        	adc z80_e
000D69  3  85 86        	sta bufaddr
000D6B  3  90 02        	bcc :+
000D6D  3  E6 87        	inc bufaddr+1
000D6F  3               :
000D6F  3  A0 00        	ldy #0
000D71  3  B1 86        	lda (bufaddr),y 	; fetch left cell block.
000D73  3  C5 63        	cmp z80_b		; is this fatal?
000D75  3  D0 01        	bne :+
000D77  3  60           	rts			; yes.
000D78  3               :
000D78  3  E6 86        	inc bufaddr		; next cell.
000D7A  3  D0 02        	bne :+
000D7C  3  E6 87        	inc bufaddr+1
000D7E  3               :
000D7E  3  A0 00        	ldy #0
000D80  3  B1 86        	lda (bufaddr),y 	; fetch type.
000D82  3  C5 63        	cmp z80_b		; is this fatal?
000D84  3  D0 01        	bne :+
000D86  3  60           	rts			; yes.
000D87  3               :
000D87  3  A5 62        	lda z80_c		; horizontal position.
000D89  3  29 07        	and #7			; is it straddling cells?
000D8B  3  D0 01        	bne :+
000D8D  3  60           	rts			; no.
000D8E  3               :
000D8E  3  E6 86        	inc bufaddr		; last cell.
000D90  3  D0 02        	bne :+
000D92  3  E6 87        	inc bufaddr+1
000D94  3               :
000D94  3  A0 00        	ldy #0
000D96  3  B1 86        	lda (bufaddr),y		; fetch final type.
000D98  3  60           	rts 			; return with final type in accumulator.
000D99  3               
000D99  3               ;---------------------------------------------------
000D99  3               ; Fetch block type at (dispx, dispy).
000D99  3               ;
000D99  3               ; Output:
000D99  3               ;  A = block type
000D99  3               ;---------------------------------------------------
000D99  3               
000D99  3               tstbl:
000D99  3  AD 64 02     	lda dispy 		; fetch y coord.
000D9C  3  4A           	lsr a			; bufaddr = y/8
000D9D  3  4A           	lsr a
000D9E  3  4A           	lsr a
000D9F  3  85 86        	sta bufaddr
000DA1  3  A9 00        	lda #0
000DA3  3  85 87        	sta bufaddr+1
000DA5  3               
000DA5  3  06 86        	asl bufaddr  		; bufaddr = y/8 * 32
000DA7  3  26 87        	rol bufaddr+1
000DA9  3  06 86        	asl bufaddr
000DAB  3  26 87        	rol bufaddr+1
000DAD  3  06 86        	asl bufaddr
000DAF  3  26 87        	rol bufaddr+1
000DB1  3  06 86        	asl bufaddr
000DB3  3  26 87        	rol bufaddr+1
000DB5  3  06 86        	asl bufaddr
000DB7  3  26 87        	rol bufaddr+1
000DB9  3               
000DB9  3  AD 63 02     	lda dispx		; x/8
000DBC  3  4A           	lsr a
000DBD  3  4A           	lsr a
000DBE  3  4A           	lsr a
000DBF  3               
000DBF  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
000DC0  3  65 86        	adc bufaddr
000DC2  3  69 00        	adc #<MAP
000DC4  3  85 86        	sta bufaddr
000DC6  3  A5 87        	lda bufaddr+1
000DC8  3  69 98        	adc #>MAP
000DCA  3  85 87        	sta bufaddr+1
000DCC  3               
000DCC  3  A0 00        	ldy #0
000DCE  3  B1 86        	lda (bufaddr),y 	; fetch byte there.
000DD0  3  60           	rts
000DD1  3               
000DD1  3               
000DD1  3               ;-------------------------------------------------------------------
000DD1  3               ; Jump - if we can.
000DD1  3               ; Requires initial speed to be set up in accumulator prior to call.
000DD1  3               ;
000DD1  3               ; Input:
000DD1  3               ;  IX = sprite address
000DD1  3               ;-------------------------------------------------------------------
000DD1  3               
000DD1  3               jump:
000DD1  3  A0 0D        	ldy #13
000DD3  3  B1 68        	lda (z80_ix),y		; jump table low.
000DD5  3  A0 0E        	ldy #14
000DD7  3  11 68        	ora (z80_ix),y		; jump table high.
000DD9  3  F0 01        	beq :+
000DDB  3  60           	rts			; already in the air.
000DDC  3               :
000DDC  3  A9 0D        	lda #>jtab
000DDE  3  A0 0E        	ldy #14
000DE0  3  91 68        	sta (z80_ix),y		; set jump high.
000DE2  3  A9 E9        	lda #<jtab		; jump table start.
000DE4  3  A0 0D        	ldy #13
000DE6  3  91 68        	sta (z80_ix),y		; set jump low.
000DE8  3  60           	rts
000DE9  3               
000DE9  3               ; Jump table.
000DE9  3               
000DE9  3               jtab:
000DE9  3  F8 FA FC     	.byte 248,250,252
000DEC  3  FE FE FF     	.byte 254,254,255
000DEF  3  FF FF 00 00  	.byte 255,255,0,0
000DF3  3  00 01 01 01  	.byte 0,1,1,1,2,2
000DF7  3  02 02        
000DF9  3  04 06 08 08  	.byte 4,6,8,8,8,99
000DFD  3  08 63        
000DFF  3               
000DFF  3               ;------------------------------------------------
000DFF  3               ; Random numbers code.
000DFF  3               ; Pseudo-random number generator, 8-bit.
000DFF  3               ;
000DFF  3               ; Output:
000DFF  3               ;  RND = random number
000DFF  3               ;------------------------------------------------
000DFF  3               
000DFF  3               random:
000DFF  3  AD 96 07     	lda seed		; get last random number.
000E02  3  0A           	asl a
000E03  3  0A           	asl a
000E04  3  18           	clc
000E05  3  6D 96 07     	adc seed
000E08  3  18           	clc
000E09  3  69 45        	adc #$45
000E0B  3  8D 96 07     	sta seed		; store new seed.
000E0E  3  8D 5B 02     	sta varrnd		; return number in variable.
000E11  3  60           	rts
000E12  3               
000E12  3               ;--------------------------------------------------------
000E12  3               ; Keys
000E12  3               ;
000E12  3               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000E12  3               ;             ||||||||
000E12  3               ;             |||||||+> Right    KEY 0  - X
000E12  3               ;             ||||||+-> Left     KEY 1  - Z
000E12  3               ;             |||||+--> Down     KEY 2  - .
000E12  3               ;             ||||+---> Up       KEY 3  - ;
000E12  3               ;             |||+----> Fire1    KEY 4  - SPC
000E12  3               ;             ||+-----> Fire2    KEY 5  - Q
000E12  3               ;             |+------> Fire3    KEY 6  - P
000E12  3               ;             +-------> Not used
000E12  3               ;
000E12  3               ;                       Option1  KEY 7  - 1
000E12  3               ;                       Option2  KEY 8  - 2
000E12  3               ;                       Option3  KEY 9  - 3
000E12  3               ;                       Option4  KEY 10 - 4
000E12  3               ;--------------------------------------------------------
000E12  3               
000E12  3               ;              X   Z   .   ;  SPC  Q   P
000E12  3               ;keys:   .byte $35,$15,$93,$22,$90,$04,$14       ; Keys defined by game designer.
000E12  3               ;        .byte $21,$11,$01,$92                   ; menu options.
000E12  3  03 01 02 04  jkeys:  .byte $03,$01,$02,$04,$00,$04,$14       ; Joykey keys
000E16  3  00 04 14     
000E19  3  21 11 01 92          .byte $21,$11,$01,$92                   ; menu options.
000E1D  3               
000E1D  3               ;--------------------------------------------------------
000E1D  3               ; Keyboard test routine.
000E1D  3               ;
000E1D  3               ; Input:
000E1D  3               ;  A = key to read, high nibble=row and low nibble=col
000E1D  3               ;
000E1D  3               ; Output:
000E1D  3               ;  carry clr = key pressed
000E1D  3               ;  carry set = key not pressed
000E1D  3               ;--------------------------------------------------------
000E1D  3               
000E1D  3               ktest:
000E1D  3  85 61        	sta z80_a		; save key
000E1F  3               
000E1F  3  4A           	lsr a			; set row
000E20  3  4A           	lsr a
000E21  3  4A           	lsr a
000E22  3  4A           	lsr a
000E23  3  09 F0        	ora #ScrMode		; don't flip screenmode
000E25  3  8D 00 B0     	sta KeyRowAddr
000E28  3               
000E28  3  A5 61        	lda z80_a
000E2A  3  29 0F        	and #$0f
000E2C  3  AA           	tax
000E2D  3  AD 01 B0     	lda KeyColAddr		; read column
000E30  3               
000E30  3  3D 39 0E     	and keymask,x		; check key pressed
000E33  3  F0 02        	beq pressed
000E35  3  38           	sec			; key not pressed
000E36  3  60           	rts
000E37  3               pressed:
000E37  3  18           	clc			; key pressed
000E38  3  60           	rts
000E39  3               
000E39  3  01 02 04 08  keymask:	.byte $01,$02,$04,$08,$10,$20
000E3D  3  10 20        
000E3F  3               
000E3F  3               ;-------------------------------------------------------
000E3F  3               ; Joystick and keyboard reading routines.
000E3F  3               ;
000E3F  3               ; contrl = 0, Keyboard
000E3F  3               ;          1, JoyKeyb
000E3F  3               ;          2, JoyMMC
000E3F  3               ;-------------------------------------------------------
000E3F  3               
000E3F  3               joykey:
000E3F  3  AD 32 02     	lda contrl 		; control flag.
000E42  3  C9 01        	cmp #1
000E44  3  D0 03        	bne :+
000E46  3  4C 64 0E     	jmp joyjoy 		; read keyboard joystick
000E49  3               :
000E49  3  C9 02        	cmp #2
000E4B  3  D0 03        	bne :+
000E4D  3  4C 8E 0E     	jmp joysin 		; read MMC joystick.
000E50  3               :
000E50  3               ; Keyboard controls.
000E50  3               
000E50  3  A9 00        	lda #0		 	; zero reading.
000E52  3  85 64        	sta z80_e
000E54  3               
000E54  3  A0 06        	ldy #6	 		; address of last key.
000E56  3               joyke0:
000E56  3  B9 F6 22     	lda keys,y 		; get key from table.
000E59  3  20 1D 0E     	jsr ktest		; being pressed?
000E5C  3  26 64        	rol z80_e 		; rotate into reading.
000E5E  3               
000E5E  3  88           	dey		 	; next key.
000E5F  3  10 F5        	bpl joyke0 		; repeat for all keys.
000E61  3  4C 75 0E     	jmp joyjo1 		; store the value.
000E64  3               
000E64  3               ; Keyboard joystick controls.
000E64  3               
000E64  3               joyjoy:
000E64  3  A9 00        	lda #0		 	; zero reading.
000E66  3  85 64        	sta z80_e
000E68  3               
000E68  3  A0 06        	ldy #6	 		; address of last key.
000E6A  3               joyjo3:
000E6A  3  B9 12 0E     	lda jkeys,y 		; get key from table.
000E6D  3  20 1D 0E     	jsr ktest		; being pressed?
000E70  3  26 64        	rol z80_e 		; rotate into reading.
000E72  3               
000E72  3  88           	dey		 	; next key.
000E73  3  10 F5        	bpl joyjo3 		; repeat for all keys.
000E75  3               joyjo1:
000E75  3  A5 64        	lda z80_e 		; copy e register to accumulator.
000E77  3               joyjo2:
000E77  3  8D 33 02     	sta joyval		; remember value.
000E7A  3  60           	rts
000E7B  3               
000E7B  3               
000E7B  3               ; AtoMMC joystick controls.
000E7B  3               
000E7B  3               ; Set PORTB direction
000E7B  3               
000E7B  3               joyinit:
000E7B  3  A9 FF        	lda #$ff   		; Write value to latch, bits 0-7 input
000E7D  3  8D 01 B4     	sta DatReg
000E80  3  20 C1 0E     	jsr interwritedelay
000E83  3  A9 A1        	lda #$a1   		; Write direction in latch to PORTB
000E85  3  8D 00 B4     	sta CmdReg
000E88  3               
000E88  3               wait_until_not_busy:
000E88  3  AD 00 B4     	lda CmdReg
000E8B  3  30 FB        	bmi wait_until_not_busy
000E8D  3  60           	rts
000E8E  3               
000E8E  3               ; Get PORTB value
000E8E  3               
000E8E  3               joysin:
000E8E  3  A9 A2        	lda #$a2   		; Read value PORTB in latch
000E90  3  8D 00 B4     	sta CmdReg
000E93  3  20 C1 0E     	jsr interwritedelay
000E96  3               
000E96  3  AD 01 B4     	lda DatReg		; Read joystick status
000E99  3  29 7F        	and #$7f
000E9B  3  8D 33 02     	sta joyval
000E9E  3  85 F0        	sta $f0
000EA0  3               
000EA0  3  AD FB 22     	lda keys+5		; check fire2
000EA3  3  20 1D 0E     	jsr ktest
000EA6  3  B0 08        	bcs :+
000EA8  3  AD 33 02     	lda joyval
000EAB  3  29 DF        	and #$df
000EAD  3  8D 33 02     	sta joyval
000EB0  3               :
000EB0  3  AD FC 22     	lda keys+6		; check fire3
000EB3  3  20 1D 0E     	jsr ktest
000EB6  3  B0 08        	bcs :+
000EB8  3  AD 33 02     	lda joyval
000EBB  3  29 BF        	and #$bf
000EBD  3  8D 33 02     	sta joyval
000EC0  3               :
000EC0  3  60           	rts
000EC1  3               
000EC1  3               ; Short delay
000EC1  3               ; Enough to intersperse 2 writes to the FATPIC.
000EC1  3               
000EC1  3               interwritedelay:
000EC1  3  A9 08        	lda  #8
000EC3  3  38           	sec
000EC4  3               loop:
000EC4  3  E9 01        	sbc  #1
000EC6  3  D0 FC        	bne  loop
000EC8  3  60           	rts
000EC9  3               
000EC9  3               ;tmp_byte:   .byte 0
000EC9  3               
000EC9  3               ;---------------------------------------------------------------
000EC9  3               ; Getkey in column,row format
000EC9  3               ;
000EC9  3               ; Output:
000EC9  3               ;  A = high nibble=row and low nibble=column key in matrix
000EC9  3               ;---------------------------------------------------------------
000EC9  3               
000EC9  3               kget:
000EC9  3  A9 F0        	lda #ScrMode		; high-mono mode.
000ECB  3  8D 00 B0     	sta ScrSelAddr		; screen select port
000ECE  3  8E 6B 0A     	stx xtmp
000ED1  3               kget4:
000ED1  3  20 71 FE     	jsr READKEY		; read key until pressed
000ED4  3  C0 FF        	cpy #255
000ED6  3  F0 F9        	beq kget4
000ED8  3  8D D6 0A     	sta rcol		; save column
000EDB  3  8E D7 0A     	stx rrow		; determine row
000EDE  3               kget3:
000EDE  3  20 71 FE     	jsr READKEY		; wait until key released
000EE1  3  C0 FF        	cpy #255
000EE3  3  D0 F9        	bne kget3
000EE5  3               
000EE5  3  38           	sec			; calculate matrix row
000EE6  3  A9 0A        	lda #10
000EE8  3  ED D7 0A     	sbc rrow
000EEB  3  0A           	asl a
000EEC  3  0A           	asl a
000EED  3  0A           	asl a
000EEE  3  0A           	asl a
000EEF  3  8D D7 0A     	sta rrow
000EF2  3               
000EF2  3  A0 FF        	ldy #255		; find column mask
000EF4  3               kget1:
000EF4  3  C8           	iny
000EF5  3  B9 39 0E     	lda keymask,y
000EF8  3  CD D6 0A     	cmp rcol
000EFB  3  F0 03        	beq kget2
000EFD  3  4C F4 0E     	jmp kget1
000F00  3               kget2:
000F00  3  98           	tya			; determine column
000F01  3  18           	clc
000F02  3  6D D7 0A     	adc rrow
000F05  3  AE 6B 0A     	ldx xtmp
000F08  3  60           	rts
000F09  3               
000F09  3               ;---------------------------------------------------------------
000F09  3               ; Display message.
000F09  3               ;
000F09  3               ; Input:
000F09  3               ;  A = message number
000F09  3               ;---------------------------------------------------------------
000F09  3               
000F09  3               dmsg:
000F09  3  AA           	tax
000F0A  3  A9 C0        	lda #<msgdat		; pointer to messages.
000F0C  3  85 66        	sta z80_l
000F0E  3  A9 1D        	lda #>msgdat
000F10  3  85 67        	sta z80_h
000F12  3  20 42 10     	jsr getwrd		; get message number.
000F15  3               dmsg3:
000F15  3  20 29 10     	jsr preprt		; pre-printing stuff.
000F18  3  20 AB 07     	jsr checkx		; make sure we"re in a printable range.
000F1B  3  AD 6B 0F     	lda prtmod		; print mode.
000F1E  3  D0 4C        	bne bmsg1		; no, double-height text.
000F20  3               dmsg0:
000F20  3  A5 67        	lda z80_h		; store string pointer.
000F22  3  48           	pha
000F23  3  A5 66        	lda z80_l
000F25  3  48           	pha
000F26  3               
000F26  3  A0 00        	ldy #0
000F28  3  B1 66        	lda (z80_hl),y		; fetch byte to display.
000F2A  3  29 7F        	and #127		; remove any end marker.
000F2C  3  C9 0D        	cmp #13
000F2E  3  F0 24        	beq dmsg1
000F30  3  20 2B 09     	jsr pchar		; display character.
000F33  3  20 0F 10     	jsr nexpos 		; display position.
000F36  3  D0 03        	bne dmsg2		; not on a new line.
000F38  3  20 18 10     	jsr nexlin		; next line down.
000F3B  3               dmsg2:
000F3B  3  68           	pla			; retrieve string pointer
000F3C  3  85 66        	sta z80_l
000F3E  3  68           	pla
000F3F  3  85 67        	sta z80_h
000F41  3               
000F41  3  A0 00        	ldy #0
000F43  3  B1 66        	lda (z80_hl),y		; fetch last character.
000F45  3  0A           	asl a  			; was it the end?
000F46  3  90 03        	bcc :+
000F48  3  4C F3 07     	jmp dscor2		; yes, job done.
000F4B  3               :
000F4B  3  E6 66        	inc z80_l		; next character to display.
000F4D  3  D0 02        	bne :+
000F4F  3  E6 67        	inc z80_h
000F51  3               :
000F51  3  4C 20 0F     	jmp dmsg0
000F54  3               dmsg1:
000F54  3  EE 64 02     	inc dispy
000F57  3  AD 64 02     	lda dispy
000F5A  3  C9 18        	cmp #24
000F5C  3  90 05        	bcc dmsg4
000F5E  3  A9 00        	lda #0
000F60  3  8D 64 02     	sta dispy
000F63  3               dmsg4:
000F63  3  A9 00        	lda #0
000F65  3  8D 63 02     	sta dispx
000F68  3  4C 3B 0F     	jmp dmsg2
000F6B  3               
000F6B  3  00           prtmod:	.byte 0            	; print mode, 0 = standard, 1 = double-height.
000F6C  3               
000F6C  3               ;----------------------------------------------------------
000F6C  3               ; Display message in big text.
000F6C  3               ;
000F6C  3               ; Input:
000F6C  3               ;  HL = string pointer
000F6C  3               ;----------------------------------------------------------
000F6C  3               
000F6C  3               bmsg1:
000F6C  3  A0 00        	ldy #0
000F6E  3  B1 66        	lda (z80_hl),y 		; get character to display.
000F70  3  29 7F        	and #127		; only want 7 bits.
000F72  3  C9 0D        	cmp #13
000F74  3  F0 13        	beq bmsg2
000F76  3  20 A3 0F     	jsr bchar 		; display big char.
000F79  3               bmsg3:
000F79  3  A0 00        	ldy #0
000F7B  3  B1 66        	lda (z80_hl),y 		; look at last character.
000F7D  3  48           	pha
000F7E  3  E6 66        	inc z80_l 		; next character in list.
000F80  3  D0 02        	bne :+
000F82  3  E6 67        	inc z80_h
000F84  3               :
000F84  3  68           	pla
000F85  3  0A           	asl a  			; was terminator flag set?
000F86  3  90 E4        	bcc bmsg1		; no, keep going.
000F88  3               :
000F88  3  60           	rts
000F89  3               bmsg2:
000F89  3  A9 00        	lda #0
000F8B  3  8D 63 02     	sta dispx
000F8E  3  EE 64 02     	inc dispy
000F91  3  EE 64 02     	inc dispy
000F94  3  AD 64 02     	lda dispy
000F97  3  C9 17        	cmp #23
000F99  3  90 DE        	bcc bmsg3
000F9B  3  A9 00        	lda #0
000F9D  3  8D 64 02     	sta dispy
000FA0  3  4C 79 0F     	jmp bmsg3
000FA3  3               
000FA3  3               ;----------------------------------------------------------
000FA3  3               ; Big character display.
000FA3  3               ;
000FA3  3               ; Input:
000FA3  3               ;  A = character
000FA3  3               ;----------------------------------------------------------
000FA3  3               
000FA3  3               bchar:
000FA3  3  85 64        	sta z80_e		; save char in lb
000FA5  3  A9 00        	lda #0
000FA7  3  85 65        	sta z80_d		; reset hb
000FA9  3               
000FA9  3  06 64        	asl z80_e 		; multiply char by 8.
000FAB  3  26 65        	rol z80_d
000FAD  3  06 64        	asl z80_e
000FAF  3  26 65        	rol z80_d
000FB1  3  06 64        	asl z80_e
000FB3  3  26 65        	rol z80_d		; de = a*8
000FB5  3               
000FB5  3  18           	clc			; de = FontPtr + a*8
000FB6  3  A5 64        	lda z80_e
000FB8  3  6D 55 18     	adc FontPtr 		; address of font.
000FBB  3  85 64        	sta z80_e
000FBD  3  A5 65        	lda z80_d
000FBF  3  6D 56 18     	adc FontPtr+1
000FC2  3  85 65        	sta z80_d
000FC4  3               
000FC4  3  20 F0 08     	jsr gprad 		; get screen address.
000FC7  3               
000FC7  3  A2 00        	ldx #0			; height of character in font.
000FC9  3               bchar0:
000FC9  3  A0 00        	ldy #0
000FCB  3  B1 64        	lda (z80_de),y 		; get a bit of the font.
000FCD  3               
000FCD  3  49 00        	eor #TxtInvert		; Invert
000FCF  3               
000FCF  3  91 80        	sta (scraddr),y
000FD1  3  48           	pha
000FD2  3  20 02 13     	jsr nline 		; next line down.
000FD5  3  68           	pla
000FD6  3  91 80        	sta (scraddr),y
000FD8  3  20 02 13     	jsr nline 		; next line down.
000FDB  3               
000FDB  3  18           	clc
000FDC  3  E6 64        	inc z80_e 		; next line of font.
000FDE  3  D0 02        	bne :+
000FE0  3  E6 65        	inc z80_d
000FE2  3               :
000FE2  3  E8           	inx
000FE3  3  E0 08        	cpx #8
000FE5  3  D0 E2        	bne bchar0
000FE7  3               	
000FE7  3  20 0F 10     	jsr nexpos		; display position.
000FEA  3  D0 06        	bne bchar2 		; not on a new line.
000FEC  3               bchar3:
000FEC  3  EE 64 02     	inc dispy
000FEF  3  20 18 10     	jsr nexlin 		; next line check.
000FF2  3               bchar2:
000FF2  3  4C F3 07     	jmp dscor2		; tidy up line and column variables.
000FF5  3               
000FF5  3               
000FF5  3               ;-------------------------------------------------
000FF5  3               ; Display a character.
000FF5  3               ;
000FF5  3               ; Input:
000FF5  3               ;  A = character
000FF5  3               ;-------------------------------------------------
000FF5  3               
000FF5  3               achar:
000FF5  3  85 63        	sta z80_b 		; copy to b.
000FF7  3  20 29 10     	jsr preprt 		; get ready to print.
000FFA  3  A5 63        	lda z80_b		; character in accumulator.
000FFC  3  AE 6B 0F     	ldx prtmod 		; print mode.
000FFF  3  F0 03        	beq :+
001001  3  4C A3 0F     	jmp bchar 		; no, double-height text.
001004  3               :
001004  3  20 2B 09     	jsr pchar 		; display character.
001007  3  20 0F 10     	jsr nexpos 		; display position.
00100A  3  F0 E0        	beq bchar3		; next line down.
00100C  3  4C F2 0F     	jmp bchar2 		; tidy up.
00100F  3               
00100F  3               
00100F  3               ;-------------------------------------------------
00100F  3               ; Get next print column position.
00100F  3               ;-------------------------------------------------
00100F  3               
00100F  3               nexpos:
00100F  3  EE 63 02     	inc dispx		; move along one position.
001012  3  AD 63 02     	lda dispx 		; get coordinate.
001015  3  29 1F        	and #31
001017  3  60           	rts 			; return with status in zero flag.
001018  3               
001018  3               ;-------------------------------------------------
001018  3               ; Get next print line position.
001018  3               ;-------------------------------------------------
001018  3               
001018  3               nexlin:
001018  3  EE 64 02     	inc dispy 		; newline.
00101B  3  AD 64 02     	lda dispy		; vertical position.
00101E  3  C9 18        	cmp #24			; past screen edge?
001020  3  B0 01        	bcs :+
001022  3  60           	rts			; no, still okay.
001023  3               :
001023  3  A9 00        	lda #0			; restart at top.
001025  3  8D 64 02     	sta dispy
001028  3  60           	rts
001029  3               
001029  3               ;--------------------------------------------------------
001029  3               ; Pre-print preliminaries.
001029  3               ;--------------------------------------------------------
001029  3               
001029  3               preprt:
001029  3  AD 55 18     	lda FontPtr		; font pointer.
00102C  3  8D A9 07     	sta grbase		; set up graphics base.
00102F  3  AD 56 18     	lda FontPtr+1
001032  3  8D AA 07     	sta grbase+1
001035  3               prescr:
001035  3  AD 58 02     	lda charx 		; display coordinates.
001038  3  8D 63 02     	sta dispx		; set up general coordinates.
00103B  3  AD 59 02     	lda chary
00103E  3  8D 64 02     	sta dispy
001041  3  60           	rts
001042  3               
001042  3               ;--------------------------------------------------------------
001042  3               ; Get messagenr x in hl
001042  3               ;
001042  3               ; Input:
001042  3               ;  HL = pointer to message list
001042  3               ;  X  = message number.
001042  3               ;--------------------------------------------------------------
001042  3               
001042  3               getwrd:
001042  3  E0 00        	cpx #0
001044  3  D0 01        	bne:+ 			; first word in list?
001046  3  60           	rts 			; yep, don't search.
001047  3               :
001047  3  A0 00        	ldy #0
001049  3               getwd0:
001049  3  B1 66        	lda (z80_hl),y
00104B  3  48           	pha
00104C  3  E6 66        	inc z80_l
00104E  3  D0 02        	bne :+
001050  3  E6 67        	inc z80_h
001052  3               :
001052  3  68           	pla
001053  3  C9 80        	cmp #128		; found end?
001055  3  30 F2        	bmi getwd0		; no, carry on.
001057  3  CA           	dex			; until we have right number.
001058  3  D0 EF        	bne getwd0
00105A  3  60           	rts
00105B  3               
00105B  3               ;-----------------------------------------------------------
00105B  3               ; Bubble sort.
00105B  3               ;-----------------------------------------------------------
00105B  3               
00105B  3               bsort:
00105B  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
00105D  3  8D 93 10     	sta qscnt
001060  3               
001060  3  A9 76        	lda #<sprtab 		; sprite table.
001062  3  85 68        	sta z80_x
001064  3  A9 17        	lda #>sprtab
001066  3  85 69        	sta z80_i
001068  3               bsort0:
001068  3  A0 00        	ldy #0
00106A  3  B1 68        	lda (z80_ix),y 		; first sprite type.
00106C  3  C9 FF        	cmp #255 		; is it switched off?
00106E  3  F0 32        	beq swemp		; yes, may need to switch another in here.
001070  3               
001070  3  A0 11        	ldy #TABSIZ
001072  3  B1 68        	lda (z80_ix),y 		; check next slot exists.
001074  3  C9 FF        	cmp #255 		; is it enabled?
001076  3  F0 0A        	beq bsort2 		; no, nothing to swap.
001078  3               
001078  3  A0 14        	ldy #TABSIZ+3
00107A  3  B1 68        	lda (z80_ix),y 		; fetch next sprite's coordinate.
00107C  3  A0 03        	ldy #3
00107E  3  D1 68        	cmp (z80_ix),y 		; compare with this x coordinate.
001080  3  90 12        	bcc bsort1		; next sprite is higher - may need to switch.
001082  3               bsort2:
001082  3  18           	clc
001083  3  A5 68        	lda z80_x
001085  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001087  3  85 68        	sta z80_x
001089  3  90 02        	bcc :+
00108B  3  E6 69        	inc z80_i
00108D  3               :
00108D  3  CE 93 10     	dec qscnt 
001090  3  D0 D6        	bne bsort0		; repeat for remaining sprites.
001092  3  60           	rts
001093  3               
001093  3  00           qscnt:	.byte 0
001094  3               
001094  3               bsort1:
001094  3  A0 11        	ldy #TABSIZ
001096  3  B1 68        	lda (z80_ix),y		; sprite on/off flag.
001098  3  C9 FF        	cmp #255		; is it enabled?
00109A  3  F0 E6        	beq bsort2		; no, nothing to swap.
00109C  3  20 B0 10     	jsr swspr		; swap positions.
00109F  3  4C 82 10     	jmp bsort2
0010A2  3               swemp:
0010A2  3  A0 11        	ldy #TABSIZ
0010A4  3  B1 68        	lda (z80_ix),y		; next table entry.
0010A6  3  C9 FF        	cmp #255		; is that one on?
0010A8  3  F0 D8        	beq bsort2		; no, nothing to swap.
0010AA  3  20 B0 10     	jsr swspr		; swap positions.
0010AD  3  4C 82 10     	jmp bsort2
0010B0  3               
0010B0  3               ; Swap sprites.
0010B0  3               
0010B0  3               swspr:
0010B0  3  A5 68        	lda z80_x		; table address 
0010B2  3  85 64        	sta z80_e		; copy to de pair.
0010B4  3  85 66        	sta z80_l		; copy to hl pair.
0010B6  3  A5 69        	lda z80_i
0010B8  3  85 67        	sta z80_h
0010BA  3  85 65        	sta z80_d
0010BC  3               
0010BC  3  18           	clc
0010BD  3  A5 66        	lda z80_l
0010BF  3  69 11        	adc #TABSIZ		; distance to second entry.
0010C1  3  85 66        	sta z80_l
0010C3  3  90 02        	bcc :+
0010C5  3  E6 67        	inc z80_h
0010C7  3               :
0010C7  3  A9 11        	lda #TABSIZ		; bytes to swap.
0010C9  3  85 63        	sta z80_b
0010CB  3  A0 00        	ldy #0
0010CD  3               swspr0:
0010CD  3  B1 66        	lda (z80_hl),y		; fetch second byte.
0010CF  3  48           	pha
0010D0  3  B1 64        	lda (z80_de),y 		; fetch first byte.
0010D2  3  91 66        	sta (z80_hl),y 		; copy to second.
0010D4  3  68           	pla
0010D5  3  91 64        	sta (z80_de),y 		; copy to first sprite entry.
0010D7  3               
0010D7  3  E6 64        	inc z80_e 		; next byte.
0010D9  3  D0 02        	bne :+	
0010DB  3  E6 65        	inc z80_d
0010DD  3               :
0010DD  3  E6 66        	inc z80_l 		; next byte.
0010DF  3  D0 02        	bne :+
0010E1  3  E6 67        	inc z80_h
0010E3  3               :
0010E3  3  C6 63        	dec z80_b
0010E5  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
0010E7  3  60           	rts
0010E8  3               
0010E8  3               ;----------------------------------------------------
0010E8  3               ; Process sprites.
0010E8  3               ;----------------------------------------------------
0010E8  3               
0010E8  3               pspr:
0010E8  3  A9 0C        	lda #NUMSPR		; sprites to process.
0010EA  3  8D 11 11     	sta sprptr
0010ED  3               
0010ED  3  A9 76        	lda #<sprtab 		; sprite table.
0010EF  3  85 68        	sta z80_x
0010F1  3  A9 17        	lda #>sprtab
0010F3  3  85 69        	sta z80_i
0010F5  3               pspr1:
0010F5  3  A0 00        	ldy #0
0010F7  3  B1 68        	lda (z80_ix),y		; fetch sprite type.
0010F9  3  C9 09        	cmp #9 			; within range of sprite types?
0010FB  3  B0 03        	bcs :+
0010FD  3  20 12 11     	jsr pspr2 		; yes, process this one.
001100  3               :
001100  3  18           	clc
001101  3  A5 68        	lda z80_x
001103  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001105  3  85 68        	sta z80_x
001107  3  90 02        	bcc :+
001109  3  E6 69        	inc z80_i		; next sprite.
00110B  3               :
00110B  3  CE 11 11     	dec sprptr 		; repeat for remaining sprites.
00110E  3  D0 E5        	bne pspr1
001110  3  60           	rts
001111  3               
001111  3  00           sprptr:	.byte 0
001112  3               
001112  3               pspr2:
001112  3  A5 68        	lda z80_x 		; store original sprite pointer.
001114  3  8D 5F 11     	sta ogptr
001117  3  A5 69        	lda z80_i
001119  3  8D 60 11     	sta ogptr+1
00111C  3  20 2A 11     	jsr pspr3		; do the routine.
00111F  3               rtorg:
00111F  3  AD 5F 11     	lda ogptr 		; restore original pointer to sprite.
001122  3  85 68        	sta z80_x
001124  3  AD 60 11     	lda ogptr+1
001127  3  85 69        	sta z80_i
001129  3               rtorg0:
001129  3  60           	rts
00112A  3               
00112A  3               pspr3:
00112A  3  A9 61        	lda #<evtyp0		; sprite type events list.
00112C  3  85 66        	sta z80_l
00112E  3  A9 11        	lda #>evtyp0
001130  3  85 67        	sta z80_h
001132  3               pspr4:
001132  3  B1 68        	lda (z80_ix),y
001134  3  0A           	asl a			; double accumulator.
001135  3  18           	clc
001136  3  65 66        	adc z80_l
001138  3  85 66        	sta z80_l
00113A  3  90 02        	bcc :+
00113C  3  E6 67        	inc z80_h
00113E  3               :
00113E  3  B1 66        	lda (z80_hl),y
001140  3  85 64        	sta z80_e 		; copy to de.
001142  3  48           	pha
001143  3               
001143  3  E6 66        	inc z80_l 		; next byte of address.
001145  3  D0 02        	bne :+
001147  3  E6 67        	inc z80_h
001149  3               :
001149  3  B1 66        	lda (z80_hl),y 		; address high.
00114B  3  85 65        	sta z80_d
00114D  3               
00114D  3  48           	pha	 		; swap address into hl.
00114E  3  A5 67        	lda z80_h
001150  3  85 65        	sta z80_d
001152  3  68           	pla
001153  3  85 67        	sta z80_h
001155  3  68           	pla
001156  3  85 66        	sta z80_l
001158  3  A5 66        	lda z80_l
00115A  3  85 64        	sta z80_e
00115C  3               	
00115C  3  6C 66 00     	jmp (z80_hl) 		; go there.
00115F  3               
00115F  3  00 00        ogptr:	.word 0			; original sprite pointer.
001161  3               
001161  3               ; Address of each sprite type's routine.
001161  3               
001161  3  66 18        evtyp0:	.word evnt00
001163  3  67 18        evtyp1:	.word evnt01
001165  3  68 18        evtyp2:	.word evnt02
001167  3  69 18        evtyp3:	.word evnt03
001169  3  6A 18        evtyp4:	.word evnt04
00116B  3  6B 18        evtyp5:	.word evnt05
00116D  3  6C 18        evtyp6:	.word evnt06
00116F  3  6D 18        evtyp7:	.word evnt07
001171  3  6E 18        evtyp8:	.word evnt08
001173  3               
001173  3               ;--------------------------------------------------------------
001173  3               ; Display sprites.
001173  3               ;
001173  3               ; Input:
001173  3               ;  IX = sprite table
001173  3               ;--------------------------------------------------------------
001173  3               
001173  3               dspr:
001173  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
001175  3  8D 06 12     	sta sprcnt
001178  3               dspr0:
001178  3  A0 00        	ldy #0
00117A  3  B1 68        	lda (z80_ix),y 		; get sprite type.
00117C  3  C9 FF        	cmp #255 		; is it enabled?
00117E  3  D0 43        	bne dspr1 		; yes, it needs deleting.
001180  3               dspr5:
001180  3  A0 05        	ldy #5
001182  3  B1 68        	lda (z80_ix),y 		; new type.
001184  3  C9 FF        	cmp #255		; is it enabled?
001186  3  D0 78        	bne dspr3 		; yes, it needs drawing.
001188  3               dspr2:
001188  3  A0 05        	ldy #5
00118A  3  B1 68        	lda (z80_ix),y 		; copy new type.
00118C  3  A0 00        	ldy #0
00118E  3  91 68        	sta (z80_ix),y
001190  3  A0 06        	ldy #6
001192  3  B1 68        	lda (z80_ix),y 		; copy new image number.
001194  3  A0 01        	ldy #1
001196  3  91 68        	sta (z80_ix),y
001198  3  A0 07        	ldy #7
00119A  3  B1 68        	lda (z80_ix),y 		; copy new frame.
00119C  3  A0 02        	ldy #2
00119E  3  91 68        	sta (z80_ix),y
0011A0  3  A0 08        	ldy #8
0011A2  3  B1 68        	lda (z80_ix),y 		; copy new y.
0011A4  3  A0 03        	ldy #3
0011A6  3  91 68        	sta (z80_ix),y
0011A8  3  A0 09        	ldy #9
0011AA  3  B1 68        	lda (z80_ix),y 		; copy new x.
0011AC  3  A0 04        	ldy #4
0011AE  3  91 68        	sta (z80_ix),y
0011B0  3               
0011B0  3  18           	clc
0011B1  3  A5 68        	lda z80_x
0011B3  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
0011B5  3  85 68        	sta z80_x
0011B7  3  A5 69        	lda z80_i
0011B9  3  69 00        	adc #0
0011BB  3  85 69        	sta z80_i 		; next sprite.
0011BD  3  CE 06 12     	dec sprcnt
0011C0  3  D0 B6        	bne dspr0		; repeat for remaining sprites.
0011C2  3  60           	rts
0011C3  3               dspr1:
0011C3  3  A0 05        	ldy #5
0011C5  3  B1 68        	lda (z80_ix),y 		; type of new sprite.
0011C7  3  C9 FF        	cmp #255		; is this enabled?
0011C9  3  D0 06        	bne dspr4 		; yes, display both.
0011CB  3               dspr6:
0011CB  3  20 9B 12     	jsr sspria 		; show single sprite.
0011CE  3  4C 88 11     	jmp dspr2
0011D1  3               
0011D1  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
0011D1  3               
0011D1  3               dspr4:
0011D1  3  A0 04        	ldy #4
0011D3  3  B1 68        	lda (z80_ix),y		; old x.
0011D5  3  A0 09        	ldy #9
0011D7  3  D1 68        	cmp (z80_ix),y 		; compare with new value.
0011D9  3  D0 1F        	bne dspr7 		; they differ, need to redraw.
0011DB  3               
0011DB  3  A0 03        	ldy #3
0011DD  3  B1 68        	lda (z80_ix),y		; old y.
0011DF  3  A0 08        	ldy #8
0011E1  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
0011E3  3  D0 15        	bne dspr7		; they differ, need to redraw.
0011E5  3               
0011E5  3  A0 02        	ldy #2
0011E7  3  B1 68        	lda (z80_ix),y 		; old frame.
0011E9  3  A0 07        	ldy #7
0011EB  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
0011ED  3  4C FA 11     	jmp dspr7 		; they differ, need to redraw.
0011F0  3               
0011F0  3  A0 01        	ldy #1
0011F2  3  B1 68        	lda (z80_ix),y 		; old image.
0011F4  3  A0 06        	ldy #6
0011F6  3  D1 68        	cmp (z80_ix),y 		; compare against new value.
0011F8  3  F0 8E        	beq dspr2		; everything is the same, don't redraw.
0011FA  3               dspr7:
0011FA  3  20 B3 12     	jsr sspric 		; delete old sprite, draw new one simultaneously.
0011FD  3  4C 88 11     	jmp dspr2
001200  3               dspr3:
001200  3  20 AD 12     	jsr ssprib 		; show single sprite.
001203  3  4C 88 11     	jmp dspr2
001206  3               
001206  3  00           sprcnt:	.byte 0
001207  3               
001207  3               ;-----------------------------------------
001207  3               ; Get sprite address calculations.
001207  3               ; gspran = new sprite, gsprad = old sprite.
001207  3               ;
001207  3               ; Input:
001207  3               ;  IX = sprite address
001207  3               ;-----------------------------------------
001207  3               
001207  3               gspran:
001207  3  A0 08        	ldy #8
001209  3  B1 68        	lda (z80_ix),y 		; new y coordinate.
00120B  3  8D 64 02     	sta dispy
00120E  3  A0 09        	ldy #9
001210  3  B1 68        	lda (z80_ix),y 		; new x coordinate.
001212  3  8D 63 02     	sta dispx
001215  3  A0 06        	ldy #6
001217  3  B1 68        	lda (z80_ix),y 		; new sprite image.
001219  3  20 85 15     	jsr gfrm		; fetch start frame for this sprite.
00121C  3               
00121C  3  A0 00        	ldy #0
00121E  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
001220  3  A0 07        	ldy #7
001222  3  18           	clc
001223  3  71 68        	adc (z80_ix),y 		; new add frame number.
001225  3  4C 46 12     	jmp gspra0
001228  3               
001228  3               ;-----------------------------------------
001228  3               ; Calculate old sprite address
001228  3               ;
001228  3               ; Input:
001228  3               ;  IX = sprite address
001228  3               ;
001228  3               ; Output:
001228  3               ;  B  = right byte mask
001228  3               ;  C  = left byte mask
001228  3               ;  DE = spriteframe address
001228  3               ;  scraddr = screenaddress(dispx,dispy)
001228  3               ;-----------------------------------------
001228  3               
001228  3               gsprad:
001228  3  A0 03        	ldy #3
00122A  3  B1 68        	lda (z80_ix),y		; y coordinate.
00122C  3  8D 64 02     	sta dispy
00122F  3  A0 04        	ldy #4
001231  3  B1 68        	lda (z80_ix),y		; x coordinate.
001233  3  8D 63 02     	sta dispx
001236  3  A0 01        	ldy #1
001238  3  B1 68        	lda (z80_ix),y 		; sprite image.
00123A  3  20 85 15     	jsr gfrm 		; fetch start frame for this sprite.
00123D  3               
00123D  3  A0 00        	ldy #0
00123F  3  B1 66        	lda (z80_hl),y 		; frame in accumulator.
001241  3  A0 02        	ldy #2
001243  3  18           	clc
001244  3  71 68        	adc (z80_ix),y 		; add frame number.
001246  3               gspra0:
001246  3  4A           	lsr a	  		; multiply by 128.
001247  3  85 65        	sta z80_d 		; store in d.
001249  3  A9 00        	lda #0
00124B  3  6A           	ror a
00124C  3  85 64        	sta z80_e 		; got low byte.
00124E  3               
00124E  3  18           	clc 			; address of play sprites.
00124F  3  A5 64        	lda z80_e
001251  3  69 3B        	adc #<sprgfx
001253  3  85 64        	sta z80_e
001255  3  A5 65        	lda z80_d
001257  3  69 1F        	adc #>sprgfx
001259  3  85 65        	sta z80_d
00125B  3               
00125B  3  AD 63 02     	lda dispx 		; y coordinate.
00125E  3  29 06        	and #6 			; position within byte boundary.
001260  3  AA           	tax	 		; low byte of table displacement.
001261  3               
001261  3  0A           	asl a	  		; multiply by 32.
001262  3  0A           	asl a  			; already a multiple
001263  3  0A           	asl a  			; of 2, so just 4
001264  3  0A           	asl a  			; shifts needed.
001265  3               
001265  3  18           	clc 			; add to sprite address.
001266  3  65 64        	adc z80_e
001268  3  85 64        	sta z80_e
00126A  3  90 02        	bcc :+
00126C  3  E6 65        	inc z80_d
00126E  3               :
00126E  3  BD 93 12     	lda spmask,x		 ; pointer to mask table.
001271  3  85 62        	sta z80_c 		; left mask.
001273  3  BD 94 12     	lda spmask+1,x
001276  3  85 63        	sta z80_b 		; right mask.
001278  3               
001278  3               ;------------------------------------------------------------------
001278  3               ; Drop into screen address routine.
001278  3               ; This routine returns a screen address for (dispx, dispy) in scraddr.
001278  3               ;------------------------------------------------------------------
001278  3               
001278  3               scadd:
001278  3  AE 64 02     	ldx dispy
00127B  3  E0 C0        	cpx #192
00127D  3  90 02        	bcc :+
00127F  3  A2 C0        	ldx #192
001281  3               :
001281  3  AD 63 02     	lda dispx
001284  3  4A           	lsr a
001285  3  4A           	lsr a
001286  3  4A           	lsr a
001287  3  18           	clc
001288  3  7D 00 9B     	adc SCADTB_lb,x
00128B  3  85 80        	sta scraddr
00128D  3  BD 00 9C     	lda SCADTB_hb,x
001290  3  85 81        	sta scraddr+1
001292  3  60           	rts
001293  3               
001293  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
001297  3  0F F0 03 FC  
00129B  3               
00129B  3               
00129B  3               ;-----------------------------------------------------------------
00129B  3               ; These are the sprite routines.
00129B  3               ; sspria = single sprite, old (ix).
00129B  3               ; ssprib = single sprite, new (ix+5).
00129B  3               ; sspric = both sprites, old (ix) and new (ix+5).
00129B  3               ;-----------------------------------------------------------------
00129B  3               
00129B  3               sspria:
00129B  3  20 28 12     	jsr gsprad		; get old sprite address.
00129E  3               sspri2:
00129E  3  A9 10        	lda #16			; vertical lines.
0012A0  3  8D AC 12     	sta acnt
0012A3  3               sspri0:
0012A3  3  20 D6 12     	jsr dline		; draw a line.
0012A6  3  CE AC 12     	dec acnt
0012A9  3  D0 F8        	bne sspri0		; repeat 16 times
0012AB  3  60           	rts
0012AC  3               
0012AC  3  00           acnt:	.byte 0
0012AD  3               
0012AD  3               ;-----------------------------------------------------------------
0012AD  3               
0012AD  3               ssprib:
0012AD  3  20 07 12     	jsr gspran 		; get new sprite address.
0012B0  3  4C 9E 12     	jmp sspri2
0012B3  3               
0012B3  3               ;-----------------------------------------------------------------
0012B3  3               
0012B3  3               ccnt = $7c
0012B3  3               
0012B3  3               sspric:
0012B3  3  20 28 12     	jsr gsprad 		; get old sprite address.
0012B6  3  20 0E 23     	jsr exx  		; store addresses.
0012B9  3  20 07 12     	jsr gspran 		; get new sprite addresses.
0012BC  3               
0012BC  3  A9 0F        	lda #15
0012BE  3  85 7C        	sta ccnt
0012C0  3               lloop:
0012C0  3  20 D6 12     	jsr dline 		; draw a line.
0012C3  3  20 0E 23     	jsr exx  		; restore old addresses.
0012C6  3  20 D6 12     	jsr dline 		; delete a line.
0012C9  3  20 0E 23     	jsr exx  		; flip to new sprite addresses.
0012CC  3  C6 7C        	dec ccnt
0012CE  3  D0 F0        	bne lloop
0012D0  3               
0012D0  3  20 D6 12     	jsr dline		; draw a line.
0012D3  3  20 0E 23     	jsr exx 		; restore old addresses.
0012D6  3               
0012D6  3               ;-------------------------------------------------------------
0012D6  3               ; Drop through.
0012D6  3               ; Line drawn, now work out next target address.
0012D6  3               ;
0012D6  3               ; Input:
0012D6  3               ;  B  = right mask
0012D6  3               ;  C  = left mask
0012D6  3               ;  DE = spriteaddress
0012D6  3               ;  scraddr = screen address
0012D6  3               ;-------------------------------------------------------------
0012D6  3               
0012D6  3               dline:
0012D6  3  A0 00        	ldy #0
0012D8  3  B1 64        	lda (z80_de),y 		; graphic data.
0012DA  3  25 62        	and z80_c 		; mask away what's not needed.
0012DC  3  51 80        	eor (scraddr),y 	; XOR with what's there.
0012DE  3  91 80        	sta (scraddr),y 	; bung it in.
0012E0  3               
0012E0  3  E6 80        	inc scraddr 		; next screen address.
0012E2  3  E6 80        	inc scraddr 		; next screen address.
0012E4  3               
0012E4  3  B1 64        	lda (z80_de),y 		; fetch data.
0012E6  3  25 63        	and z80_b 		; mask away unwanted bits.
0012E8  3  51 80        	eor (scraddr),y 	; XOR with what's there.
0012EA  3  91 80        	sta (scraddr),y 	; bung it in.
0012EC  3               
0012EC  3  E6 64        	inc z80_e 		; next graphic.
0012EE  3  D0 02        	bne :+
0012F0  3  E6 65        	inc z80_d
0012F2  3               :
0012F2  3  C6 80        	dec scraddr 		; one character cell to the left.
0012F4  3               
0012F4  3  B1 64        	lda (z80_de),y 		; second bit of data.
0012F6  3  51 80        	eor (scraddr),y 	; XOR with what's there.
0012F8  3  91 80        	sta (scraddr),y 	; bung it in.
0012FA  3               
0012FA  3  E6 64        	inc z80_e 		; point to next line of data.
0012FC  3  D0 02        	bne :+
0012FE  3  E6 65        	inc z80_d
001300  3               :
001300  3  C6 80        	dec scraddr 		; another char left.
001302  3               
001302  3               ;----------------------------------------------------------------------
001302  3               ; Line drawn, now work out next target address.
001302  3               ;----------------------------------------------------------------------
001302  3               
001302  3               nline:
001302  3  18           	clc
001303  3  A5 80        	lda scraddr 		; get low byte of address.
001305  3  69 20        	adc #$20
001307  3  85 80        	sta scraddr 		; new low byte of address.
001309  3  90 02        	bcc :+
00130B  3  E6 81        	inc scraddr+1 		; new high byte of address.
00130D  3               :
00130D  3  60           	rts
00130E  3               
00130E  3               ;-----------------------------------------------------------
00130E  3               ; Animates a sprite.
00130E  3               ;
00130E  3               ; Input:
00130E  3               ;  IX = sprite address
00130E  3               ;  HL = last sprite address
00130E  3               ;-----------------------------------------------------------
00130E  3               
00130E  3               animsp:
00130E  3  2D 34 02     	and frmno
001311  3  F0 01        	beq :+
001313  3  60           	rts
001314  3               :
001314  3  A0 06        	ldy #6
001316  3  B1 68        	lda (z80_ix),y		; sprite image
001318  3  20 85 15     	jsr gfrm		; get frame data.
00131B  3               
00131B  3  E6 66        	inc z80_l		; point to frames.
00131D  3  D0 02        	bne :+
00131F  3  E6 67        	inc z80_h
001321  3               :
001321  3  A0 07        	ldy #7
001323  3  B1 68        	lda (z80_ix),y		; sprite frame.
001325  3  18           	clc
001326  3  69 01        	adc #1			; next one along.
001328  3  A0 00        	ldy #0
00132A  3  D1 66        	cmp (z80_hl),y		; reached the last frame?
00132C  3  90 02        	bcc anims0		; no, not yet.
00132E  3  A9 00        	lda #0			; start at first frame.
001330  3               anims0:
001330  3  A0 07        	ldy #7
001332  3  91 68        	sta (z80_ix),y		; new frame.
001334  3  60           	rts
001335  3               
001335  3               ;--------------------------------------------------------------
001335  3               ; Animate back
001335  3               ;
001335  3               ; Input:
001335  3               ;  IX = sprite address
001335  3               ;  HL = last sprite address
001335  3               ;--------------------------------------------------------------
001335  3               
001335  3               animbk:
001335  3  2D 34 02     	and frmno
001338  3  F0 01        	beq :+
00133A  3  60           	rts
00133B  3               :
00133B  3  A0 06        	ldy #6
00133D  3  B1 68        	lda (z80_ix),y		; sprite image.
00133F  3  20 85 15     	jsr gfrm		; get frame data.
001342  3               
001342  3  E6 66        	inc z80_l 		; point to frames.
001344  3  D0 02        	bne :+
001346  3  E6 67        	inc z80_h
001348  3               :
001348  3  A0 07        	ldy #7
00134A  3  B1 68        	lda (z80_ix),y 		; sprite frame.
00134C  3  F0 03        	beq :+
00134E  3  4C 55 13     	jmp rtanb0 		; yes, start at end.
001351  3               :
001351  3  A0 00        	ldy #0
001353  3  B1 66        	lda (z80_hl),y 		; last sprite.
001355  3               rtanb0:
001355  3  38           	sec
001356  3  E9 01        	sbc #1			; next one along.
001358  3  4C 30 13     	jmp anims0		; set new frame.
00135B  3               
00135B  3               ;--------------------------------------------------------------
00135B  3               ; Check for collision with other sprite, strict enforcement.
00135B  3               ;
00135B  3               ; Input:
00135B  3               ;  b		= sprite to test for
00135B  3               ;  ix		= current sprite pointer
00135B  3               ;
00135B  3               ; global:	b
00135B  3               ; local:	x,y,hl,de,skptr
00135B  3               ; calls:	-
00135B  3               ;--------------------------------------------------------------
00135B  3               
00135B  3               sktyp:
00135B  3  A9 76        	lda #<sprtab				; sprite table.
00135D  3  85 66        	sta z80_l
00135F  3  A9 17        	lda #>sprtab
001361  3  85 67        	sta z80_h
001363  3               numsp2:
001363  3  A9 0C        	lda #NUMSPR				; number of sprites.
001365  3  8D 9E 13     	sta sktptr
001368  3               sktyp0:
001368  3  A5 66        	lda z80_l 				; store pointer to sprite.
00136A  3  8D 9C 13     	sta skptr
00136D  3  A5 67        	lda z80_h
00136F  3  8D 9D 13     	sta skptr+1
001372  3               
001372  3  A0 00        	ldy #0
001374  3  B1 66        	lda (z80_hl),y 				; get sprite type.
001376  3  C5 63        	cmp z80_b				; is it the type we seek?
001378  3  F0 25        	beq coltyp				; yes, we can use this one.
00137A  3               :
00137A  3               sktyp1:
00137A  3  18           	clc
00137B  3  AD 9C 13     	lda skptr				; retrieve sprite pointer.
00137E  3  69 11        	adc #TABSIZ				; size of each entry.
001380  3  85 66        	sta z80_l
001382  3  AD 9D 13     	lda skptr+1
001385  3  69 00        	adc #0
001387  3  85 67        	sta z80_h
001389  3  CE 9E 13     	dec sktptr					; one less iteration.
00138C  3  D0 DA        	bne sktyp0				; keep going until we find a slot.
00138E  3               :
00138E  3  A9 00        	lda #0					; default to ROM address - no sprite.
001390  3  85 66        	sta z80_l
001392  3  85 67        	sta z80_h
001394  3  8D 9C 13     	sta skptr				; store pointer to sprite.
001397  3  8D 9D 13     	sta skptr+1
00139A  3               
00139A  3  18           	clc					; don't return with zero flag set.
00139B  3  60           	rts 					; didn't find one.
00139C  3               
00139C  3  00 00        skptr:	.word 0					; search pointer.
00139E  3  00           sktptr:	.byte 0
00139F  3               
00139F  3               coltyp:
00139F  3  A0 00        	ldy #0
0013A1  3  B1 68        	lda (z80_ix),y				; current sprite type.
0013A3  3  C5 63        	cmp z80_b				; seeking sprite of same type?
0013A5  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
0013A7  3               colty0:
0013A7  3  A0 09        	ldy #9					; distance to x position in table.
0013A9  3  B1 66        	lda (z80_hl),y				; fetch x coordinate.
0013AB  3  85 64        	sta z80_e
0013AD  3  88           	dey
0013AE  3  B1 66        	lda (z80_hl),y				; fetch y coordinate.
0013B0  3  85 65        	sta z80_d
0013B2  3               
0013B2  3               ; Drop into collision detection.
0013B2  3               
0013B2  3               colc16:
0013B2  3  A0 09        	ldy #9
0013B4  3  B1 68        	lda (z80_ix),y			 	; x coord.
0013B6  3  38           	sec					; subtract x.
0013B7  3  E5 64        	sbc z80_e
0013B9  3  B0 05        	bcs  colc1a 				; result is positive.
0013BB  3  49 FF        	eor #$ff				; make negative positive.
0013BD  3  18           	clc
0013BE  3  69 01        	adc #1
0013C0  3               colc1a:
0013C0  3  C9 10        	cmp #16 				; within x range?
0013C2  3  B0 B6        	bcs sktyp1				; no - they"ve missed.
0013C4  3  85 62        	sta z80_c				; store difference.
0013C6  3               
0013C6  3  A0 08        	ldy #8
0013C8  3  B1 68        	lda (z80_ix),y				; y coord.
0013CA  3  38           	sec
0013CB  3  E5 65        	sbc z80_d				; subtract y.
0013CD  3  B0 05        	bcs colc1b				; result is positive.
0013CF  3  49 FF        	eor #$ff				; make negative positive.
0013D1  3  18           	clc
0013D2  3  69 01        	adc #1
0013D4  3               colc1b:
0013D4  3  C9 10        	cmp #16					; within y range?
0013D6  3  B0 A2        	bcs sktyp1 				; no - they've missed.
0013D8  3  18           	clc					; add x difference.
0013D9  3  65 62        	adc z80_c
0013DB  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
0013DD  3  B0 02        	bcs :+
0013DF  3  38           	sec
0013E0  3  60           	rts 					; carry set if there's a collision.
0013E1  3               :
0013E1  3  4C 7A 13     	jmp sktyp1				; try next sprite in table.
0013E4  3               colty1:
0013E4  3  A5 68        	lda z80_x  				; compare the two.
0013E6  3  C5 66        	cmp z80_l
0013E8  3  D0 09        	bne end_col
0013EA  3  A5 69        	lda z80_i
0013EC  3  C5 67        	cmp z80_h
0013EE  3  D0 03        	bne end_col
0013F0  3  4C 7A 13     	jmp sktyp1 				; addresses are identical.
0013F3  3               end_col:
0013F3  3  4C A7 13     	jmp colty0
0013F6  3               
0013F6  3               ;-----------------------------------------------------------
0013F6  3               ; Display number, left aligned
0013F6  3               ; 
0013F6  3               ; Input:
0013F6  3               ;  a		= number
0013F6  3               ;
0013F6  3               ; global:	-
0013F6  3               ; local:	a,y,bc,hl,displ0
0013F6  3               ; calls:	num2ch,dmsg3
0013F6  3               ;-----------------------------------------------------------
0013F6  3               
0013F6  3               disply:
0013F6  3  85 61        	sta z80_a
0013F8  3  A9 1E        	lda #<displ0				; display workspace.
0013FA  3  85 62        	sta z80_c
0013FC  3  A9 14        	lda #>displ0
0013FE  3  85 63        	sta z80_b
001400  3  A5 61        	lda z80_a
001402  3  20 12 05     	jsr num2ch				; convert accumulator to string.
001405  3               displ1:
001405  3  C6 62        	dec z80_c				; back one character.
001407  3  D0 02        	bne :+
001409  3  C6 63        	dec z80_b
00140B  3               :
00140B  3  A0 00        	ldy #0
00140D  3  B1 62        	lda (z80_bc),y				; fetch digit.
00140F  3  09 80        	ora #128				; insert end marker.
001411  3  91 62        	sta (z80_bc),y				; new value.
001413  3               
001413  3  A9 1E        	lda #<displ0				; display space.
001415  3  85 66        	sta z80_l
001417  3  A9 14        	lda #>displ0
001419  3  85 67        	sta z80_h
00141B  3  4C 15 0F     	jmp dmsg3				; display the string.
00141E  3               
00141E  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
001422  3               
001422  3               ;----------------------------------------------------------------
001422  3               ; Initialise screen.
001422  3               ;
001422  3               ; global:	roomtb,scno
001422  3               ; local:	-
001422  3               ; calls:	tstcs
001422  3               ;----------------------------------------------------------------
001422  3               
001422  3               initsc:
001422  3  AD 53 18     	lda roomtb 			; whereabouts in the map are we?
001425  3  20 30 14     	jsr tstsc 			; find displacement.
001428  3  C9 FF        	cmp #255 			; is it valid?
00142A  3  F0 03        	beq init_end 			; no, it's rubbish.
00142C  3  8D 3E 02     	sta scno			; store new room number.
00142F  3               init_end:
00142F  3  60           	rts
001430  3               
001430  3               ;----------------------------------------------------------------
001430  3               ; Test screen.
001430  3               ;
001430  3               ; global:	-
001430  3               ; local:	x
001430  3               ; calls:	-
001430  3               ;----------------------------------------------------------------
001430  3               
001430  3               tstsc:
001430  3  8D 3B 14     	sta tmproom
001433  3  18           	clc
001434  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
001436  3  AA           	tax 				; add displacement to map data.
001437  3  BD 5C 18     	lda mapdat-MAPWID,x 		; find room number there.
00143A  3  60           	rts
00143B  3               
00143B  3  00           tmproom:	.byte 0
00143C  3               
00143C  3               ;--------------------------
00143C  3               ; Screen left.
00143C  3               ;--------------------------
00143C  3               
00143C  3               scrl:
00143C  3  AD 53 18     	lda roomtb 			; present room table pointer.
00143F  3  38           	sec
001440  3  E9 01        	sbc #1				; room left.
001442  3               scrl0:
001442  3  20 30 14     	jsr tstsc			; test screen.
001445  3  C9 FF        	cmp #255			; is there a screen this way?
001447  3  D0 01        	bne :+
001449  3  60           	rts				; no, return to loop.
00144A  3               :
00144A  3  AD 3B 14     	lda tmproom			; restore room displacement.
00144D  3  8D 53 18     	sta roomtb			; new room table position.
001450  3               scrl1:
001450  3  20 22 14     	jsr initsc 			; set new screen.
001453  3  A9 02        	lda #2
001455  3  8D 60 02     	sta restfl 			; set it.
001458  3  60           	rts
001459  3               scrr:
001459  3  AD 53 18     	lda roomtb 			; room table pointer.
00145C  3  18           	clc
00145D  3  69 01        	adc #1				; room right.
00145F  3  4C 42 14     	jmp scrl0
001462  3               scru:
001462  3  AD 53 18     	lda roomtb 			; room table pointer.
001465  3  38           	sec
001466  3  E9 03        	sbc #MAPWID 			; room up.
001468  3  4C 42 14     	jmp scrl0
00146B  3               scrd:
00146B  3  AD 53 18     	lda roomtb 			; room table pointer.
00146E  3  18           	clc
00146F  3  69 03        	adc #MAPWID 			; room down.
001471  3  4C 42 14     	jmp scrl0
001474  3               
001474  3               ;-----------------------------------------
001474  3               ; Jump to new screen.
001474  3               ;-----------------------------------------
001474  3               
001474  3               nwscr:
001474  3  A2 00        	ldx #0				; start of map data.
001476  3               nwscr0:
001476  3  DD 5F 18     	cmp mapdat,x
001479  3  F0 06        	beq nwscr1			; have we found a match for screen?
00147B  3  E8           	inx 				; next room.
00147C  3  E0 50        	cpx #80				; zero room count, 80 to search.
00147E  3  D0 F6        	bne nwscr0			; keep looking.
001480  3  60           	rts
001481  3               nwscr1:
001481  3  8E 53 18     	stx roomtb			; set the map position.
001484  3  4C 50 14     	jmp scrl1			; draw new room.
001487  3               
001487  3               
001487  3               ;----------------------------------------------------------
001487  3               ; Gravity processing.
001487  3               ;----------------------------------------------------------
001487  3               
001487  3               grav:
001487  3  A0 0D        	ldy #13
001489  3  B1 68        	lda (z80_ix),y			; jump pointer low.
00148B  3  85 66        	sta z80_l
00148D  3  A0 0E        	ldy #14
00148F  3  B1 68        	lda (z80_ix),y			; jump pointer high.
001491  3  85 67        	sta z80_h
001493  3  05 66        	ora z80_l			; merge in low byte.
001495  3  D0 01        	bne :+
001497  3  60           	rts				; if neither is set, we're not in the air.
001498  3               :
001498  3  A0 00        	ldy #0
00149A  3  B1 66        	lda (z80_hl),y			; pixels to move.
00149C  3  85 61        	sta z80_a
00149E  3  C9 63        	cmp #99				; reached the end?
0014A0  3  D0 0A        	bne grav0			; no, continue.
0014A2  3               grav2:
0014A2  3  C6 66        	dec z80_l			; go back to previous value.
0014A4  3  90 02        	bcc :+
0014A6  3  C6 67        	dec z80_h
0014A8  3               :
0014A8  3  B1 66        	lda (z80_hl),y			; fetch that from table.
0014AA  3  85 61        	sta z80_a
0014AC  3               grav0:
0014AC  3  E6 66        	inc z80_l			; point to next table entry.
0014AE  3  D0 02        	bne :+
0014B0  3  E6 67        	inc z80_h
0014B2  3               :
0014B2  3  A5 66        	lda z80_l
0014B4  3  A0 0D        	ldy #13
0014B6  3  91 68        	sta (z80_ix),y			; store new pointer low.
0014B8  3  A5 67        	lda z80_h
0014BA  3  A0 0E        	ldy #14
0014BC  3  91 68        	sta (z80_ix),y			; store new pointer high.
0014BE  3               grav1:
0014BE  3  A5 61        	lda z80_a
0014C0  3  D0 01        	bne :+				; any movement required?
0014C2  3  60           	rts				; no, not this time.
0014C3  3               :
0014C3  3  A5 61        	lda z80_a
0014C5  3  C9 80        	cmp #128			; is it up or down?
0014C7  3  B0 15        	bcs gravu			; it's up.
0014C9  3               gravd:
0014C9  3  85 63        	sta z80_b			; set pixels to move.
0014CB  3               gravd0:
0014CB  3  20 97 0B     	jsr cangd			; can we go down?
0014CE  3  D0 28        	bne gravst			; can't move down, so stop.
0014D0  3  A0 08        	ldy #8
0014D2  3  B1 68        	lda (z80_ix),y			; adjust new x coord.
0014D4  3  18           	clc
0014D5  3  69 01        	adc #1
0014D7  3  91 68        	sta (z80_ix),y
0014D9  3  C6 63        	dec z80_b
0014DB  3  D0 EE        	bne gravd0
0014DD  3  60           	rts
0014DE  3               gravu:
0014DE  3  49 FF        	eor #$ff			; flip the sign so it's positive.
0014E0  3  18           	clc
0014E1  3  69 01        	adc #1
0014E3  3  85 63        	sta z80_b			; set pixels to move.
0014E5  3               gravu0:
0014E5  3  20 5F 0B     	jsr cangu			; can we go up?
0014E8  3  D0 71        	bne ifalls			; can't move up, go down next.
0014EA  3  A0 08        	ldy #8
0014EC  3  B1 68        	lda (z80_ix),y
0014EE  3  38           	sec
0014EF  3  E9 01        	sbc #1
0014F1  3  91 68        	sta (z80_ix),y			; adjust new x coord.
0014F3  3  C6 63        	dec z80_b
0014F5  3  D0 EE        	bne gravu0
0014F7  3  60           	rts
0014F8  3               gravst:
0014F8  3  A0 0D        	ldy #13
0014FA  3  B1 68        	lda (z80_ix),y			; jump pointer low.
0014FC  3  85 66        	sta z80_l
0014FE  3  A0 0E        	ldy #14
001500  3  B1 68        	lda (z80_ix),y			; jump pointer high.
001502  3  85 67        	sta z80_h
001504  3               
001504  3  A9 00        	lda #0				; null value in pointer.
001506  3  A0 0D        	ldy #13
001508  3  91 68        	sta (z80_ix),y			; store new pointer low.
00150A  3  C8           	iny
00150B  3  91 68        	sta (z80_ix),y			; store new pointer high.
00150D  3               
00150D  3  A0 00        	ldy #0
00150F  3  B1 66        	lda (z80_hl),y			; fetch byte from table.
001511  3  C9 63        	cmp #99				; is it the end marker?
001513  3               evftf:
001513  3  F0 01        	beq :+				; yes, fallen too far.
001515  3  60           	rts
001516  3               :
001516  3  4C B9 1D     	jmp evnt15			; EVENT FELLTOOFAR
001519  3               
001519  3               ;------------------------------------------------
001519  3               ; Initiate fall check.
001519  3               ;------------------------------------------------
001519  3               
001519  3               ifall:
001519  3  A0 0D        	ldy #13
00151B  3  B1 68        	lda (z80_ix),y 			; jump pointer low.
00151D  3  85 66        	sta z80_l
00151F  3  A0 0E        	ldy #14
001521  3  B1 68        	lda (z80_ix),y 			; jump pointer high.
001523  3  85 67        	sta z80_h			; high byte in accumulator.
001525  3  05 66        	ora z80_l			; merge in low byte.
001527  3  F0 01        	beq :+
001529  3  60           	rts				; if either is set, we're already in the air.
00152A  3               :
00152A  3  A0 09        	ldy #9
00152C  3  B1 68        	lda (z80_ix),y			; y coordinate.
00152E  3  8D 63 02     	sta dispx
001531  3               numsp7:
001531  3  A0 08        	ldy #8
001533  3  B1 68        	lda (z80_ix),y			; look x coordinate.
001535  3  18           	clc
001536  3  69 10        	adc #16				; add 16 pixels.
001538  3  8D 64 02     	sta dispy			; set up test coordinates.
00153B  3  20 99 0D     	jsr tstbl			; get map address.
00153E  3  20 31 0C     	jsr plchk			; block, platform check.
001541  3  F0 01        	beq :+
001543  3  60           	rts				; it's solid, don't fall.
001544  3               :
001544  3  E6 86        	inc bufaddr			; look right one cell.
001546  3  20 31 0C     	jsr plchk			; block, platform check.
001549  3  F0 01        	beq :+
00154B  3  60           	rts				; it's solid, don't fall.
00154C  3               :
00154C  3  AD 63 02     	lda dispx			; y coordinate.
00154F  3  29 07        	and #7				; position straddling block cells.
001551  3  F0 08        	beq ifalls			; no more checks needed.
001553  3  E6 86        	inc bufaddr			; look to third cell.
001555  3  20 31 0C     	jsr plchk			; block, platform check.
001558  3  F0 01        	beq :+
00155A  3  60           	rts				; it's solid, don't fall.
00155B  3               :
00155B  3               ifalls:
00155B  3  A9 E9        	lda #<jtab			; jump table start.
00155D  3  85 66        	sta z80_l
00155F  3  A9 0D        	lda #>jtab
001561  3  85 67        	sta z80_h
001563  3               ifal0:
001563  3  E6 66        	inc z80_l			; point to next value.
001565  3  D0 02        	bne :+
001567  3  E6 67        	inc z80_h
001569  3               :
001569  3  A0 00        	ldy #0
00156B  3  B1 66        	lda (z80_hl),y			; fetch value.
00156D  3  F0 F4        	beq ifal0			; no, get next value.
00156F  3  C9 63        	cmp #99				; reached end of table?
001571  3  D0 01        	bne :+
001573  3  60           	rts				; yes, don't fall.
001574  3               :
001574  3  C9 80        	cmp #128			; is it going up?
001576  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
001578  3               
001578  3  A0 0D        	ldy #13
00157A  3  A5 66        	lda z80_l
00157C  3  91 68        	sta (z80_ix),y 			; set jump low.
00157E  3  A0 0E        	ldy #14
001580  3  A5 67        	lda z80_h
001582  3  91 68        	sta (z80_ix),y 			; set jump high.
001584  3  60           	rts
001585  3               
001585  3               
001585  3               ;----------------------------------------------------
001585  3               ; Get frame data for a particular sprite.
001585  3               ; Input:
001585  3               ;  a		= framenumer
001585  3               ; Output:
001585  3               ;  hl		= frame address
001585  3               ;
001585  3               ; global:	hl,frmptr
001585  3               ; local:	-
001585  3               ; calls:	-
001585  3               ;----------------------------------------------------
001585  3               
001585  3               gfrm:
001585  3  0A           	asl a	 		 	; multiple of 2.
001586  3  18           	clc
001587  3  6D 65 02     	adc frmptr 			; frames used by game.
00158A  3  85 66        	sta z80_l
00158C  3  AD 66 02     	lda frmptr+1
00158F  3  69 00        	adc #0
001591  3  85 67        	sta z80_h 			; point to frame start.
001593  3  60           	rts
001594  3               
001594  3               ;----------------------------------------------------
001594  3               ; Find sprite list for current room.
001594  3               ;
001594  3               ; global:	hl
001594  3               ; local:	x,y
001594  3               ; calls:	-
001594  3               ;----------------------------------------------------
001594  3               
001594  3               sprlst:
001594  3  A9 CB        	lda #<nmedat 			; list of enemy sprites.
001596  3  85 66        	sta z80_l
001598  3  A9 1F        	lda #>nmedat
00159A  3  85 67        	sta z80_h
00159C  3  AE 3E 02     	ldx scno 			; screen number.
00159F  3  D0 01        	bne sprls2 			; is it the first screen?
0015A1  3  60           	rts 				; yes, don't need to search data.
0015A2  3               sprls2:
0015A2  3  A0 00        	ldy #0
0015A4  3               sprls1:
0015A4  3  B1 66        	lda (z80_hl),y 			; fetch type of sprite.
0015A6  3  C9 FF        	cmp #255			; is it an end marker?
0015A8  3  F0 0E        	beq sprls0 			; yes, end of this room.
0015AA  3               
0015AA  3  18           	clc 				; point to next sprite in list.
0015AB  3  A5 66        	lda z80_l
0015AD  3  69 04        	adc #NMESIZ
0015AF  3  85 66        	sta z80_l
0015B1  3  90 02        	bcc :+
0015B3  3  E6 67        	inc z80_h
0015B5  3               :
0015B5  3  4C A4 15     	jmp sprls1 			; continue until end of room.
0015B8  3               sprls0:
0015B8  3  E6 66        	inc z80_l 			; point to start of next screen.s
0015BA  3  D0 02        	bne :+
0015BC  3  E6 67        	inc z80_h
0015BE  3               :
0015BE  3  CA           	dex
0015BF  3  D0 E3        	bne sprls1 			; continue until room found.
0015C1  3  60           	rts
0015C2  3               
0015C2  3               
0015C2  3               ;----------------------------------------------------
0015C2  3               ; Clear all but a single player sprite.
0015C2  3               ;
0015C2  3               ; global:	-
0015C2  3               ; local:	x,y,ix
0015C2  3               ; calls:	-
0015C2  3               ;----------------------------------------------------
0015C2  3               
0015C2  3               nspr:
0015C2  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0015C4  3  8D 06 12     	sta sprcnt
0015C7  3  A9 76        	lda #<sprtab 			; sprite table.
0015C9  3  85 68        	sta z80_x
0015CB  3  A9 17        	lda #>sprtab
0015CD  3  85 69        	sta z80_i
0015CF  3               nspr0:
0015CF  3  A0 00        	ldy #0 				; fetch sprite type.
0015D1  3  B1 68        	lda (z80_ix),y 			; is it a player?
0015D3  3  F0 1B        	beq nspr1 			; yes, keep this one.
0015D5  3               
0015D5  3  A9 FF        	lda #255
0015D7  3  A0 00        	ldy #0 				; fetch sprite type.
0015D9  3  91 68        	sta (z80_ix),y 			; delete sprite.
0015DB  3  A0 05        	ldy #5
0015DD  3  91 68        	sta (z80_ix),y 			; remove next type.
0015DF  3               
0015DF  3  18           	clc	 			; next sprite.
0015E0  3  A5 68        	lda z80_x
0015E2  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0015E4  3  85 68        	sta z80_x
0015E6  3  90 02        	bcc :+
0015E8  3  E6 69        	inc z80_i
0015EA  3               :
0015EA  3  CE 06 12     	dec sprcnt	 			; one less space in the table.
0015ED  3  D0 E0        	bne nspr0
0015EF  3  60           	rts
0015F0  3               nspr1:
0015F0  3  A9 FF        	lda #255
0015F2  3  A0 00        	ldy #0
0015F4  3  91 68        	sta (z80_ix),y 			; delete sprite.
0015F6  3               
0015F6  3  18           	clc	 			; point to next sprite.
0015F7  3  A5 68        	lda z80_x
0015F9  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0015FB  3  85 68        	sta z80_x
0015FD  3  90 02        	bcc :+
0015FF  3  E6 69        	inc z80_i
001601  3               :
001601  3  CE 06 12     	dec sprcnt	 			; one less to do.
001604  3  D0 01        	bne nspr2
001606  3  60           	rts
001607  3               nspr2:
001607  3  A9 FF        	lda #255
001609  3  A0 00        	ldy #0
00160B  3  91 68        	sta (z80_ix),y 			; delete sprite.
00160D  3  A0 05        	ldy #5
00160F  3  91 68        	sta (z80_ix),y 			; remove next type.
001611  3               
001611  3  18           	clc	 			; next sprite.
001612  3  A5 68        	lda z80_x
001614  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
001616  3  85 68        	sta z80_x
001618  3  90 02        	bcc :+
00161A  3  E6 69        	inc z80_i
00161C  3               :
00161C  3  CE 06 12     	dec sprcnt	 			; one less space in table.
00161F  3  D0 E6        	bne nspr2
001621  3  60           	rts
001622  3               
001622  3               ;----------------------------------------------------------
001622  3               ; Two initialisation routines.
001622  3               ; Initialise sprites - copy everything from list to table.
001622  3               ;
001622  3               ; global:	-
001622  3               ; local:	x,y,ix
001622  3               ; calls:	cpsp
001622  3               ;----------------------------------------------------------
001622  3               
001622  3               ispr:
001622  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
001624  3  8D 06 12     	sta sprcnt
001627  3  A9 76        	lda #<sprtab			; sprite table.
001629  3  85 68        	sta z80_x
00162B  3  A9 17        	lda #>sprtab
00162D  3  85 69        	sta z80_i
00162F  3               ispr2:
00162F  3  A0 00        	ldy #0
001631  3  B1 66        	lda (z80_hl),y 			; fetch byte.
001633  3  C9 FF        	cmp #255 			; is it an end marker?
001635  3  D0 01        	bne :+
001637  3  60           	rts 				; yes, no more to do.
001638  3               :
001638  3               ispr1:
001638  3  A0 00        	ldy #0
00163A  3  B1 68        	lda (z80_ix),y 			; fetch sprite type.
00163C  3  C9 FF        	cmp #255 			; is it enabled yet?
00163E  3  D0 08        	bne ispr4			; yes, try another slot.
001640  3               
001640  3  A0 05        	ldy #5
001642  3  B1 68        	lda (z80_ix),y		 	; next type.
001644  3  C9 FF        	cmp #255 			; is it enabled yet?
001646  3  F0 11        	beq ispr3 			; no, process this one.
001648  3               ispr4:
001648  3  18           	clc 				; next sprite.
001649  3  A5 68        	lda z80_x
00164B  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00164D  3  85 68        	sta z80_x
00164F  3  90 02        	bcc :+
001651  3  E6 69        	inc z80_i
001653  3               :
001653  3  CE 06 12     	dec sprcnt
001656  3  D0 E0        	bne ispr1 			; repeat for remaining sprites.
001658  3  60           	rts  				; no more room in table.
001659  3               ispr3:
001659  3  20 AD 16     	jsr cpsp			; initialise a sprite.
00165C  3  CE 06 12     	dec sprcnt			; one less space in the table.
00165F  3  D0 CE        	bne ispr2
001661  3  60           	rts
001662  3               
001662  3               
001662  3               ;-----------------------------------------------------------------------
001662  3               ; Initialise sprites - but not player, we're keeping the old one.
001662  3               ;
001662  3               ; global:	-
001662  3               ; local:	x,y,ix
001662  3               ; calls:	cpsp
001662  3               ;-----------------------------------------------------------------------
001662  3               
001662  3               kspr:
001662  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
001664  3  A9 76        	lda #<sprtab 			; sprite table.
001666  3  85 68        	sta z80_x
001668  3  A9 17        	lda #>sprtab
00166A  3  85 69        	sta z80_i
00166C  3               kspr2:
00166C  3  A0 00        	ldy #0
00166E  3  B1 66        	lda (z80_hl),y 			; fetch byte.
001670  3  C9 FF        	cmp #255 			; is it an end marker?
001672  3  D0 01        	bne :+
001674  3  60           	rts 				; yes, no more to do.
001675  3               :
001675  3  C9 00        	cmp #0
001677  3  D0 0E        	bne kspr1 			; no, add to table as normal.
001679  3               
001679  3  18           	clc 				; next sprite.
00167A  3  A5 66        	lda z80_l
00167C  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
00167E  3  85 66        	sta z80_l
001680  3  90 02        	bcc :+
001682  3  E6 67        	inc z80_h
001684  3               :
001684  3  4C 6C 16     	jmp kspr2
001687  3               kspr1:
001687  3  A0 00        	ldy #0 				; fetch sprite type.
001689  3  B1 68        	lda (z80_ix),y
00168B  3  C9 FF        	cmp #255 			; is it enabled yet?
00168D  3  D0 08        	bne kspr4 			; yes, try another slot.
00168F  3               
00168F  3  A0 05        	ldy #5 				; next type.
001691  3  B1 68        	lda (z80_ix),y
001693  3  C9 FF        	cmp #255 			; is it enabled yet?
001695  3  F0 0F        	beq kspr3 			; no, process this one.
001697  3               kspr4:
001697  3  18           	clc 				; next sprite.
001698  3  A5 68        	lda z80_x
00169A  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00169C  3  85 68        	sta z80_x
00169E  3  90 02        	bcc :+
0016A0  3  E6 69        	inc z80_i
0016A2  3               :
0016A2  3  CA           	dex	 			; repeat for remaining sprites.
0016A3  3  D0 E2        	bne kspr1
0016A5  3  60           	rts  				; no more room in table.
0016A6  3               kspr3:
0016A6  3  20 AD 16     	jsr cpsp 			; copy sprite to table.
0016A9  3  CA           	dex	 			; one less space in the table.
0016AA  3  D0 C0        	bne kspr2
0016AC  3  60           	rts
0016AD  3               
0016AD  3               ;----------------------------------------------
0016AD  3               ; Copy sprite from list to table.
0016AD  3               ;
0016AD  3               ; global:	hl,ix
0016AD  3               ; local:	y
0016AD  3               ; calls:	evnt09
0016AD  3               ;----------------------------------------------
0016AD  3               
0016AD  3               cpsp:
0016AD  3  A0 00        	ldy #0				; fetch byte from table.
0016AF  3  B1 66        	lda (z80_hl),y
0016B1  3  91 68        	sta (z80_ix),y			; set up type.
0016B3  3  A0 05        	ldy #PAM1ST
0016B5  3  91 68        	sta (z80_ix),y 			; set up type.
0016B7  3               
0016B7  3  E6 66        	inc z80_l 			; move to next byte.
0016B9  3  D0 02        	bne :+
0016BB  3  E6 67        	inc z80_h
0016BD  3               :
0016BD  3  A0 00        	ldy #0 				; fetch byte from table.
0016BF  3  B1 66        	lda (z80_hl),y
0016C1  3  A0 06        	ldy #6
0016C3  3  91 68        	sta (z80_ix),y			; set up image.
0016C5  3               
0016C5  3  E6 66        	inc z80_l 			; move to next byte.
0016C7  3  D0 02        	bne :+
0016C9  3  E6 67        	inc z80_h
0016CB  3               :
0016CB  3  A0 00        	ldy #0
0016CD  3  B1 66        	lda (z80_hl),y 			; fetch byte from table.
0016CF  3  A0 08        	ldy #8
0016D1  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0016D3  3               
0016D3  3  A9 C8        	lda #200 			; set initial coordinate off screen.
0016D5  3  A0 03        	ldy #3
0016D7  3  91 68        	sta (z80_ix),y
0016D9  3               
0016D9  3  E6 66        	inc z80_l 			; move to next byte.
0016DB  3  D0 02        	bne :+
0016DD  3  E6 67        	inc z80_h
0016DF  3               :
0016DF  3  A0 00        	ldy #0 				; fetch byte from table.
0016E1  3  B1 66        	lda (z80_hl),y
0016E3  3  A0 09        	ldy #9
0016E5  3  91 68        	sta (z80_ix),y 			; set up coordinate.
0016E7  3               
0016E7  3  E6 66        	inc z80_l 			; move to next byte.
0016E9  3  D0 02        	bne :+
0016EB  3  E6 67        	inc z80_h
0016ED  3               :
0016ED  3  A9 00        	lda #0				; zeroes in accumulator.
0016EF  3  A0 07        	ldy #7 				; reset frame number.
0016F1  3  91 68        	sta (z80_ix),y
0016F3  3  A0 0A        	ldy #10 			; reset direction.
0016F5  3  91 68        	sta (z80_ix),y
0016F7  3  A0 0D        	ldy #13				; reset jump pointer low.
0016F9  3  91 68        	sta (z80_ix),y
0016FB  3  A0 0E        	ldy #14	 			; reset jump pointer high.
0016FD  3  91 68        	sta (z80_ix),y
0016FF  3               
0016FF  3  A9 FF        	lda #255 			; reset data pointer to auto-restore.
001701  3  A0 10        	ldy #16
001703  3  91 68        	sta (z80_ix),y
001705  3               evis0:
001705  3  A5 69        	lda z80_i
001707  3  48           	pha
001708  3  A5 68        	lda z80_x
00170A  3  48           	pha
00170B  3  A5 67        	lda z80_h
00170D  3  48           	pha
00170E  3  A5 66        	lda z80_l
001710  3  48           	pha
001711  3               
001711  3  20 6F 18     	jsr evnt09 			; perform event.
001714  3               
001714  3  68           	pla
001715  3  85 66        	sta z80_l
001717  3  68           	pla
001718  3  85 67        	sta z80_h
00171A  3  68           	pla
00171B  3  85 68        	sta z80_x
00171D  3  68           	pla
00171E  3  85 69        	sta z80_i
001720  3               
001720  3  18           	clc
001721  3  A5 68        	lda z80_x 			; distance to next odd/even entry.
001723  3  69 11        	adc #TABSIZ		 	; next sprite.
001725  3  85 68        	sta z80_x
001727  3  90 02        	bcc :+
001729  3  E6 69        	inc z80_i
00172B  3               :
00172B  3  60           	rts
00172C  3               
00172C  3               
00172C  3               ;-------------------------------------
00172C  3               ; Clear the play area window.
00172C  3               ;-------------------------------------
00172C  3               
00172C  3               clw:
00172C  3  AD 35 02     	lda wintop			; get coordinates of window.
00172F  3  8D 64 02     	sta dispy			; put into dispx for calculation.
001732  3  AD 36 02     	lda winlft
001735  3  8D 63 02     	sta dispx
001738  3               
001738  3  AD 37 02     	lda winhgt			; height of window.
00173B  3  8D D7 0A     	sta rrow			; copy to b register.
00173E  3               clw3:
00173E  3  AD 38 02     	lda winwid 			; width of window.
001741  3  8D D6 0A     	sta rcol
001744  3               clw2:
001744  3  20 F0 08     	jsr gprad 			; get print address.
001747  3  A9 00        	lda #0				; zero byte to write.
001749  3  A2 07        	ldx #7				; pixel height of each cell.
00174B  3               clw1:
00174B  3  BC 66 09     	ldy scrtab,x
00174E  3  91 80        	sta (scraddr),y 			; copy to screen.
001750  3  CA           	dex				; next screen row down.
001751  3  10 F8        	bpl clw1
001753  3               
001753  3  EE 63 02     	inc dispx			; next column.
001756  3  CE D6 0A     	dec rcol			; one less to do.
001759  3  D0 E9        	bne clw2			; repeat for remaining columns.
00175B  3               
00175B  3  AD 36 02     	lda winlft			; get left edge.
00175E  3  8D 63 02     	sta dispx 			; reset x.
001761  3  EE 64 02     	inc dispy 			; next line down.
001764  3               
001764  3  CE D7 0A     	dec rrow
001767  3  D0 D5        	bne clw3			; repeat down the screen.
001769  3               
001769  3  AD 35 02     	lda wintop			; get coordinates of window.
00176C  3  8D 59 02     	sta chary			; put into display position.
00176F  3  AD 36 02     	lda winlft
001772  3  8D 58 02     	sta charx
001775  3  60           	rts
001776  3               
001776  3               
001776  3               ;----------------------------------------------------------
001776  3               ; Effects code.
001776  3               ; Ticker routine is called 25 times per second.
001776  3               ;
001776  3               ; HL = txtscr = left text screen address
001776  3               ; DE = txtscr+txtwid-1 = right text screen address
001776  3               ; BC = txtpos = text scroller position
001776  3               ;
001776  3               ;----------------------------------------------------------
001776  3               
001776  3               .if sflag
001776  3               scrly:
001776  3               	rts
001776  3               	.word txtscr         	; get left screen address.
001776  3               	sta scr_l
001776  3               	lda txtscr+1
001776  3               	sta scr_l+1
001776  3               	sta scr_r+1
001776  3               	
001776  3               	stx xtmp
001776  3               
001776  3               	clc         		; get right screen address.
001776  3               	lda scr_l
001776  3               	adc txtwid
001776  3               	sta scr_r
001776  3               	dec scr_r
001776  3               scrly1:
001776  3               	ldy txtwid		; set txtwide
001776  3               	dey
001776  3               	clc
001776  3               scrly0:
001776  3               	lda (scr_l),y		; scroll 1 line
001776  3               	rol a
001776  3               	sta (scr_l),y
001776  3               	dey
001776  3               	bpl scrly0
001776  3               
001776  3               	clc			; point to next line
001776  3               	lda scr_l
001776  3               	adc #32
001776  3               	sta scr_l
001776  3               	bcc scrly1		; repeat 8 times
001776  3               
001776  3               	lda txtpos 		; get text pointer.
001776  3               	sta scr_txt
001776  3               	lda txtpos+1
001776  3               	sta scr_txt+1
001776  3               
001776  3               	ldy #0
001776  3               	lda (scr_txt),y 		; find character we're displaying.
001776  3               	and #127 		; remove end marker bit if applicable.
001776  3               	cmp #13			; is it newline?
001776  3               	bne scrly5 		; no, it's okay.
001776  3               	lda #32			; convert to a space instead.
001776  3               scrly5:
001776  3               	sta fntaddr		; calculate char address
001776  3               	lda #0
001776  3               	sta fntaddr+1
001776  3               	asl fntaddr  		; multiply char by 8.
001776  3               	rol fntaddr+1
001776  3               	asl fntaddr
001776  3               	rol fntaddr+1
001776  3               	asl fntaddr
001776  3               	rol fntaddr+1
001776  3               	lda fntaddr
001776  3               	clc
001776  3               	adc FontPtr
001776  3               	sta scrly3+1		; that's the low byte.
001776  3               	lda fntaddr+1
001776  3               	adc FontPtr+1
001776  3               	sta scrly3+2		; add displacement.
001776  3               
001776  3               	ldx #0
001776  3               scrly3:
001776  3               	lda $3333,x		; get image of char line.
001776  3               	and txtbit
001776  3               	beq scrly2		; don't plot pixel
001776  3               	ldy scrline,x
001776  3               	lda (scr_r),y
001776  3               	clc
001776  3               	ora #1
001776  3               	sta (scr_r),y		; plot pixel
001776  3               scrly2:
001776  3               	inx			; next line of char.
001776  3               	cpx #8
001776  3               	bne scrly3
001776  3               
001776  3               	lsr txtbit		; bit of text to display.
001776  3               	bcs :+
001776  3               	rts
001776  3               :
001776  3               	ldy #0
001776  3               	lda (scr_txt),y 	; what was the character?
001776  3               	asl a	  		; end of message?
001776  3               	bcs scrly4
001776  3               	inc txtpos
001776  3               	bne :+
001776  3               	inc txtpos+1
001776  3               :
001776  3               	jmp scrly6 		; not yet - continue.
001776  3               scrly4:
001776  3               	lda txtini 		; start of scrolling message.
001776  3               	sta txtpos
001776  3               	lda txtini+1
001776  3               	sta txtpos+1
001776  3               scrly6:
001776  3               	lda #128
001776  3               	sta txtbit
001776  3               	ldx xtmp
001776  3               	rts
001776  3               
001776  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
001776  3               
001776  3               ;-------------------------------------------------------
001776  3               ; Entry TICKER command
001776  3               ;
001776  3               ; Entry:
001776  3               ;  z80_b = message nr
001776  3               ;  z80_c = width
001776  3               ;-------------------------------------------------------
001776  3               
001776  3               iscrly:
001776  3               	jsr prescr 		; set up display position.
001776  3               
001776  3               	lda #<msgdat 		; text messages.
001776  3               	sta z80_l
001776  3               	lda #>msgdat
001776  3               	sta z80_h
001776  3               
001776  3               	lda z80_c 		; width.
001776  3               	sec
001776  3               	sbc #1			; subtract one.
001776  3               	cmp #32 		; is it between 1 and 32?
001776  3               	bcc :+
001776  3               	lda #$60
001776  3               	jmp iscrl0		; no, disable messages.
001776  3               :
001776  3               	ldx z80_b		; message number.
001776  3               	jsr getwrd 		; find message start.
001776  3               
001776  3               	lda z80_l		; set initial text position.
001776  3               	sta txtini
001776  3               	lda z80_h
001776  3               	sta txtini+1
001776  3               
001776  3               	lda #$ad		; code for lda adrr
001776  3               iscrl0:
001776  3               	sta scrly		; enable/disable scrolling routine.
001776  3               
001776  3               	jsr prescr 		; set up display position.
001776  3               	jsr gprad 		; get print address.
001776  3               
001776  3               	lda scraddr 		; set text screen address.
001776  3               	sta txtscr
001776  3               	lda scraddr+1
001776  3               	sta txtscr+1
001776  3               
001776  3               	lda z80_c		; width.
001776  3               	sta txtwid		; set width in working storage.
001776  3               
001776  3               	lda #128 		; start with leftmost bit.
001776  3               	sta txtbit
001776  3               
001776  3               	jmp scrly4
001776  3               .endif
001776  3               
001776  3               ;------------------------------------------------------------------
001776  3               ; Sprite table 
001776  3               ;------------------------------------------------------------------
001776  3               
001776  3               
001776  3               ; ix+0  = type.
001776  3               ; ix+1  = sprite image number.
001776  3               ; ix+2  = frame.
001776  3               ; ix+3  = y coord.
001776  3               ; ix+4  = x coord.
001776  3               
001776  3               ; ix+5  = new type.
001776  3               ; ix+6  = new image number.
001776  3               ; ix+7  = new frame.
001776  3               ; ix+8  = new y coord.
001776  3               ; ix+9  = new x coord.
001776  3               
001776  3               ; ix+10 = direction.
001776  3               ; ix+11 = parameter 1.
001776  3               ; ix+12 = parameter 2.
001776  3               ; ix+13 = jump pointer low.
001776  3               ; ix+14 = jump pointer high.
001776  3               ; ix+15 = data pointer low.
001776  3               ; ix+16 = data pointer high.
001776  3               
001776  3               ; block NUMSPR * TABSIZ,255
001776  3               
001776  3  FF FF FF FF  sprtab:	.res NUMSPR*TABSIZ,255
00177A  3  FF FF FF FF  
00177E  3  FF FF FF FF  
001842  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
001846  3  FF FF FF 00  
00184A  3  C0 78 00 00  
001853  3  07           roomtb:	.byte 7                      ; start room map offset.
001854  3               
001854  3               ; User routine.  Put your own code in here to be called with USER instruction.
001854  3               ; if USER has an argument it will be passed in the accumulator.
001854  3               
001854  3               user:
001854  3  60           	rts
001855  3               
001855  3               ;----------------------------------------------------
001855  3               ; Missing vars 
001855  3               ;----------------------------------------------------
001855  3               
001855  3               MAP 		= $9800			; properties map buffer (3x256 bytes)
001855  3               SCADTB_lb 	= MAP+3*256		; screen address table lo-byte (256 bytes)
001855  3               SCADTB_hb 	= SCADTB_lb+256		; screen address table hi-byte (256 bytes)
001855  3               SHRAPN 		= SCADTB_hb+256		; shrapnel table (55x6 bytes)
001855  3               
001855  3  00 00        FontPtr:	.byte 0,0
001857  3  00 00        TmpAddr:	.byte 0,0
001859  3               
001859  3  00           loopa:		.byte 0
00185A  3  00           loopb:		.byte 0
00185B  3  00           loopc:		.byte 0
00185C  3               
00185C  3               ; Everything below here will be generated by the editors.
00185C  3               
00185C  3               WINDOWTOP = 1
00185C  3               WINDOWLFT = 1
00185C  3               WINDOWHGT = 22
00185C  3               WINDOWWID = 30 ;a
00185C  3               MAPWID = 3
00185C  3  FF FF FF             .byte 255,255,255
00185F  3               mapdat:
00185F  3  FF 00 FF             .byte 255,0,255
001862  3  FF FF FF             .byte 255,255,255
001865  3  01           stmap:  .byte 1
001866  3               
001866  3               evnt00:
001866  3  60                   rts
001867  3               evnt01:
001867  3  60                   rts
001868  3               evnt02:
001868  3  60                   rts
001869  3               evnt03:
001869  3  60                   rts
00186A  3               evnt04:
00186A  3  60                   rts
00186B  3               evnt05:
00186B  3  60                   rts
00186C  3               evnt06:
00186C  3  60                   rts
00186D  3               evnt07:
00186D  3  60                   rts
00186E  3               evnt08:
00186E  3  60                   rts
00186F  3               evnt09:
00186F  3  60                   rts
001870  3               evnt10:
001870  3  A9 00                lda #0
001872  3  8D 59 02             sta chary
001875  3  A9 01                lda #1
001877  3  8D 58 02             sta charx
00187A  3  A9 01                lda #1
00187C  3  8D 6B 0F             sta prtmod
00187F  3  A9 00                lda #0
001881  3  20 09 0F             jsr dmsg
001884  3  A9 00                lda #0
001886  3  8D 6B 0F             sta prtmod
001889  3  A9 03                lda #3
00188B  3  8D 59 02             sta chary
00188E  3  A9 01                lda #1
001890  3  8D 58 02             sta charx
001893  3  A9 01                lda #1
001895  3  20 09 0F             jsr dmsg
001898  3  A9 05                lda #5
00189A  3  8D 59 02             sta chary
00189D  3  A9 01                lda #1
00189F  3  8D 58 02             sta charx
0018A2  3  A9 02                lda #2
0018A4  3  20 09 0F             jsr dmsg
0018A7  3  A9 7B                lda #123
0018A9  3  8D 4B 02             sta varl
0018AC  3  AD 4B 02             lda varl
0018AF  3  AD 4B 02             lda varl
0018B2  3  20 F6 13             jsr disply
0018B5  3  A9 05                lda #5
0018B7  3  8D 59 02             sta chary
0018BA  3  A9 12                lda #18
0018BC  3  8D 58 02             sta charx
0018BF  3  A9 7B                lda #123
0018C1  3  CD 4B 02             cmp varl
0018C4  3  F0 03                beq *+5
0018C6  3  4C D1 18             jmp k00161
0018C9  3  A9 03                lda #3
0018CB  3  20 09 0F             jsr dmsg
0018CE  3  4C D6 18             jmp k00169
0018D1  3  A9 04        k00161: lda #4
0018D3  3  20 09 0F             jsr dmsg
0018D6  3  A9 06        k00169: lda #6
0018D8  3  8D 59 02             sta chary
0018DB  3  A9 01                lda #1
0018DD  3  8D 58 02             sta charx
0018E0  3  A9 05                lda #5
0018E2  3  20 09 0F             jsr dmsg
0018E5  3  A9 7B                lda #123
0018E7  3  8D 4B 02             sta varl
0018EA  3  AD 4B 02             lda varl
0018ED  3  4A                   lsr a
0018EE  3  8D 4B 02             sta varl
0018F1  3  AD 4B 02             lda varl
0018F4  3  20 F6 13             jsr disply
0018F7  3  A9 06                lda #6
0018F9  3  8D 59 02             sta chary
0018FC  3  A9 12                lda #18
0018FE  3  8D 58 02             sta charx
001901  3  A9 3D                lda #61
001903  3  CD 4B 02             cmp varl
001906  3  F0 03                beq *+5
001908  3  4C 13 19             jmp k00269
00190B  3  A9 06                lda #6
00190D  3  20 09 0F             jsr dmsg
001910  3  4C 18 19             jmp k00277
001913  3  A9 07        k00269: lda #7
001915  3  20 09 0F             jsr dmsg
001918  3  A9 07        k00277: lda #7
00191A  3  8D 59 02             sta chary
00191D  3  A9 01                lda #1
00191F  3  8D 58 02             sta charx
001922  3  A9 08                lda #8
001924  3  20 09 0F             jsr dmsg
001927  3  A9 7B                lda #123
001929  3  8D 4B 02             sta varl
00192C  3  AD 4B 02             lda varl
00192F  3  85 65                sta z80_d
001931  3  A9 03                lda #3
001933  3  85 64                sta z80_e
001935  3  20 AA 05             jsr idiv
001938  3  A5 65                lda z80_d
00193A  3  8D 4B 02             sta varl
00193D  3  AD 4B 02             lda varl
001940  3  20 F6 13             jsr disply
001943  3  A9 07                lda #7
001945  3  8D 59 02             sta chary
001948  3  A9 12                lda #18
00194A  3  8D 58 02             sta charx
00194D  3  A9 29                lda #41
00194F  3  CD 4B 02             cmp varl
001952  3  F0 03                beq *+5
001954  3  4C 5F 19             jmp k00396
001957  3  A9 09                lda #9
001959  3  20 09 0F             jsr dmsg
00195C  3  4C 64 19             jmp k00404
00195F  3  A9 0A        k00396: lda #10
001961  3  20 09 0F             jsr dmsg
001964  3  A9 08        k00404: lda #8
001966  3  8D 59 02             sta chary
001969  3  A9 01                lda #1
00196B  3  8D 58 02             sta charx
00196E  3  A9 0B                lda #11
001970  3  20 09 0F             jsr dmsg
001973  3  A9 7B                lda #123
001975  3  8D 4B 02             sta varl
001978  3  AD 4B 02             lda varl
00197B  3  4A                   lsr a
00197C  3  4A                   lsr a
00197D  3  8D 4B 02             sta varl
001980  3  AD 4B 02             lda varl
001983  3  20 F6 13             jsr disply
001986  3  A9 08                lda #8
001988  3  8D 59 02             sta chary
00198B  3  A9 12                lda #18
00198D  3  8D 58 02             sta charx
001990  3  A9 1E                lda #30
001992  3  CD 4B 02             cmp varl
001995  3  F0 03                beq *+5
001997  3  4C A2 19             jmp k00508
00199A  3  A9 0C                lda #12
00199C  3  20 09 0F             jsr dmsg
00199F  3  4C A7 19             jmp k00517
0019A2  3  A9 0D        k00508: lda #13
0019A4  3  20 09 0F             jsr dmsg
0019A7  3  A9 09        k00517: lda #9
0019A9  3  8D 59 02             sta chary
0019AC  3  A9 01                lda #1
0019AE  3  8D 58 02             sta charx
0019B1  3  A9 0E                lda #14
0019B3  3  20 09 0F             jsr dmsg
0019B6  3  A9 7B                lda #123
0019B8  3  8D 4B 02             sta varl
0019BB  3  AD 4B 02             lda varl
0019BE  3  85 65                sta z80_d
0019C0  3  A9 05                lda #5
0019C2  3  85 64                sta z80_e
0019C4  3  20 AA 05             jsr idiv
0019C7  3  A5 65                lda z80_d
0019C9  3  8D 4B 02             sta varl
0019CC  3  AD 4B 02             lda varl
0019CF  3  20 F6 13             jsr disply
0019D2  3  A9 09                lda #9
0019D4  3  8D 59 02             sta chary
0019D7  3  A9 12                lda #18
0019D9  3  8D 58 02             sta charx
0019DC  3  A9 18                lda #24
0019DE  3  CD 4B 02             cmp varl
0019E1  3  F0 03                beq *+5
0019E3  3  4C EE 19             jmp k00636
0019E6  3  A9 0F                lda #15
0019E8  3  20 09 0F             jsr dmsg
0019EB  3  4C F3 19             jmp k00644
0019EE  3  A9 10        k00636: lda #16
0019F0  3  20 09 0F             jsr dmsg
0019F3  3  A9 0A        k00644: lda #10
0019F5  3  8D 59 02             sta chary
0019F8  3  A9 01                lda #1
0019FA  3  8D 58 02             sta charx
0019FD  3  A9 11                lda #17
0019FF  3  20 09 0F             jsr dmsg
001A02  3  A9 7B                lda #123
001A04  3  8D 4B 02             sta varl
001A07  3  AD 4B 02             lda varl
001A0A  3  85 65                sta z80_d
001A0C  3  A9 06                lda #6
001A0E  3  85 64                sta z80_e
001A10  3  20 AA 05             jsr idiv
001A13  3  A5 65                lda z80_d
001A15  3  8D 4B 02             sta varl
001A18  3  AD 4B 02             lda varl
001A1B  3  20 F6 13             jsr disply
001A1E  3  A9 0A                lda #10
001A20  3  8D 59 02             sta chary
001A23  3  A9 12                lda #18
001A25  3  8D 58 02             sta charx
001A28  3  A9 14                lda #20
001A2A  3  CD 4B 02             cmp varl
001A2D  3  F0 03                beq *+5
001A2F  3  4C 3A 1A             jmp k00763
001A32  3  A9 12                lda #18
001A34  3  20 09 0F             jsr dmsg
001A37  3  4C 3F 1A             jmp k00772
001A3A  3  A9 13        k00763: lda #19
001A3C  3  20 09 0F             jsr dmsg
001A3F  3  A9 0B        k00772: lda #11
001A41  3  8D 59 02             sta chary
001A44  3  A9 01                lda #1
001A46  3  8D 58 02             sta charx
001A49  3  A9 14                lda #20
001A4B  3  20 09 0F             jsr dmsg
001A4E  3  A9 7B                lda #123
001A50  3  8D 4B 02             sta varl
001A53  3  AD 4B 02             lda varl
001A56  3  85 65                sta z80_d
001A58  3  A9 07                lda #7
001A5A  3  85 64                sta z80_e
001A5C  3  20 AA 05             jsr idiv
001A5F  3  A5 65                lda z80_d
001A61  3  8D 4B 02             sta varl
001A64  3  AD 4B 02             lda varl
001A67  3  20 F6 13             jsr disply
001A6A  3  A9 0B                lda #11
001A6C  3  8D 59 02             sta chary
001A6F  3  A9 12                lda #18
001A71  3  8D 58 02             sta charx
001A74  3  A9 11                lda #17
001A76  3  CD 4B 02             cmp varl
001A79  3  F0 03                beq *+5
001A7B  3  4C 86 1A             jmp k00891
001A7E  3  A9 15                lda #21
001A80  3  20 09 0F             jsr dmsg
001A83  3  4C 8B 1A             jmp k00899
001A86  3  A9 16        k00891: lda #22
001A88  3  20 09 0F             jsr dmsg
001A8B  3  A9 0C        k00899: lda #12
001A8D  3  8D 59 02             sta chary
001A90  3  A9 01                lda #1
001A92  3  8D 58 02             sta charx
001A95  3  A9 17                lda #23
001A97  3  20 09 0F             jsr dmsg
001A9A  3  A9 7B                lda #123
001A9C  3  8D 4B 02             sta varl
001A9F  3  AD 4B 02             lda varl
001AA2  3  4A                   lsr a
001AA3  3  4A                   lsr a
001AA4  3  4A                   lsr a
001AA5  3  8D 4B 02             sta varl
001AA8  3  AD 4B 02             lda varl
001AAB  3  20 F6 13             jsr disply
001AAE  3  A9 0C                lda #12
001AB0  3  8D 59 02             sta chary
001AB3  3  A9 12                lda #18
001AB5  3  8D 58 02             sta charx
001AB8  3  A9 0F                lda #15
001ABA  3  CD 4B 02             cmp varl
001ABD  3  F0 03                beq *+5
001ABF  3  4C CA 1A             jmp k01008
001AC2  3  A9 18                lda #24
001AC4  3  20 09 0F             jsr dmsg
001AC7  3  4C CF 1A             jmp k01016
001ACA  3  A9 19        k01008: lda #25
001ACC  3  20 09 0F             jsr dmsg
001ACF  3  A9 0D        k01016: lda #13
001AD1  3  8D 59 02             sta chary
001AD4  3  A9 01                lda #1
001AD6  3  8D 58 02             sta charx
001AD9  3  A9 1A                lda #26
001ADB  3  20 09 0F             jsr dmsg
001ADE  3  A9 7B                lda #123
001AE0  3  8D 4B 02             sta varl
001AE3  3  AD 4B 02             lda varl
001AE6  3  85 65                sta z80_d
001AE8  3  A9 09                lda #9
001AEA  3  85 64                sta z80_e
001AEC  3  20 AA 05             jsr idiv
001AEF  3  A5 65                lda z80_d
001AF1  3  8D 4B 02             sta varl
001AF4  3  AD 4B 02             lda varl
001AF7  3  20 F6 13             jsr disply
001AFA  3  A9 0D                lda #13
001AFC  3  8D 59 02             sta chary
001AFF  3  A9 12                lda #18
001B01  3  8D 58 02             sta charx
001B04  3  A9 0D                lda #13
001B06  3  CD 4B 02             cmp varl
001B09  3  F0 03                beq *+5
001B0B  3  4C 16 1B             jmp k01136
001B0E  3  A9 1B                lda #27
001B10  3  20 09 0F             jsr dmsg
001B13  3  4C 1B 1B             jmp k01144
001B16  3  A9 1C        k01136: lda #28
001B18  3  20 09 0F             jsr dmsg
001B1B  3  A9 0E        k01144: lda #14
001B1D  3  8D 59 02             sta chary
001B20  3  A9 01                lda #1
001B22  3  8D 58 02             sta charx
001B25  3  A9 1D                lda #29
001B27  3  20 09 0F             jsr dmsg
001B2A  3  A9 7B                lda #123
001B2C  3  8D 4B 02             sta varl
001B2F  3  AD 4B 02             lda varl
001B32  3  85 65                sta z80_d
001B34  3  A9 0A                lda #10
001B36  3  85 64                sta z80_e
001B38  3  20 AA 05             jsr idiv
001B3B  3  A5 65                lda z80_d
001B3D  3  8D 4B 02             sta varl
001B40  3  AD 4B 02             lda varl
001B43  3  20 F6 13             jsr disply
001B46  3  A9 0E                lda #14
001B48  3  8D 59 02             sta chary
001B4B  3  A9 12                lda #18
001B4D  3  8D 58 02             sta charx
001B50  3  A9 0C                lda #12
001B52  3  CD 4B 02             cmp varl
001B55  3  F0 03                beq *+5
001B57  3  4C 62 1B             jmp k01264
001B5A  3  A9 1E                lda #30
001B5C  3  20 09 0F             jsr dmsg
001B5F  3  4C 67 1B             jmp k01272
001B62  3  A9 1F        k01264: lda #31
001B64  3  20 09 0F             jsr dmsg
001B67  3  A9 0F        k01272: lda #15
001B69  3  8D 59 02             sta chary
001B6C  3  A9 01                lda #1
001B6E  3  8D 58 02             sta charx
001B71  3  A9 20                lda #32
001B73  3  20 09 0F             jsr dmsg
001B76  3  A9 7B                lda #123
001B78  3  8D 4B 02             sta varl
001B7B  3  AD 4B 02             lda varl
001B7E  3  85 65                sta z80_d
001B80  3  A9 0B                lda #11
001B82  3  85 64                sta z80_e
001B84  3  20 AA 05             jsr idiv
001B87  3  A5 65                lda z80_d
001B89  3  8D 4B 02             sta varl
001B8C  3  AD 4B 02             lda varl
001B8F  3  20 F6 13             jsr disply
001B92  3  A9 0F                lda #15
001B94  3  8D 59 02             sta chary
001B97  3  A9 12                lda #18
001B99  3  8D 58 02             sta charx
001B9C  3  A9 0B                lda #11
001B9E  3  CD 4B 02             cmp varl
001BA1  3  F0 03                beq *+5
001BA3  3  4C AE 1B             jmp k01392
001BA6  3  A9 21                lda #33
001BA8  3  20 09 0F             jsr dmsg
001BAB  3  4C B3 1B             jmp k01400
001BAE  3  A9 22        k01392: lda #34
001BB0  3  20 09 0F             jsr dmsg
001BB3  3  A9 10        k01400: lda #16
001BB5  3  8D 59 02             sta chary
001BB8  3  A9 01                lda #1
001BBA  3  8D 58 02             sta charx
001BBD  3  A9 23                lda #35
001BBF  3  20 09 0F             jsr dmsg
001BC2  3  A9 7B                lda #123
001BC4  3  8D 4B 02             sta varl
001BC7  3  AD 4B 02             lda varl
001BCA  3  85 65                sta z80_d
001BCC  3  A9 0C                lda #12
001BCE  3  85 64                sta z80_e
001BD0  3  20 AA 05             jsr idiv
001BD3  3  A5 65                lda z80_d
001BD5  3  8D 4B 02             sta varl
001BD8  3  AD 4B 02             lda varl
001BDB  3  20 F6 13             jsr disply
001BDE  3  A9 10                lda #16
001BE0  3  8D 59 02             sta chary
001BE3  3  A9 12                lda #18
001BE5  3  8D 58 02             sta charx
001BE8  3  A9 0A                lda #10
001BEA  3  CD 4B 02             cmp varl
001BED  3  F0 03                beq *+5
001BEF  3  4C FA 1B             jmp k01520
001BF2  3  A9 24                lda #36
001BF4  3  20 09 0F             jsr dmsg
001BF7  3  4C FF 1B             jmp k01528
001BFA  3  A9 25        k01520: lda #37
001BFC  3  20 09 0F             jsr dmsg
001BFF  3  A9 11        k01528: lda #17
001C01  3  8D 59 02             sta chary
001C04  3  A9 01                lda #1
001C06  3  8D 58 02             sta charx
001C09  3  A9 26                lda #38
001C0B  3  20 09 0F             jsr dmsg
001C0E  3  A9 7B                lda #123
001C10  3  8D 4B 02             sta varl
001C13  3  AD 4B 02             lda varl
001C16  3  85 65                sta z80_d
001C18  3  A9 0D                lda #13
001C1A  3  85 64                sta z80_e
001C1C  3  20 AA 05             jsr idiv
001C1F  3  A5 65                lda z80_d
001C21  3  8D 4B 02             sta varl
001C24  3  AD 4B 02             lda varl
001C27  3  20 F6 13             jsr disply
001C2A  3  A9 11                lda #17
001C2C  3  8D 59 02             sta chary
001C2F  3  A9 12                lda #18
001C31  3  8D 58 02             sta charx
001C34  3  A9 09                lda #9
001C36  3  CD 4B 02             cmp varl
001C39  3  F0 03                beq *+5
001C3B  3  4C 46 1C             jmp k01647
001C3E  3  A9 27                lda #39
001C40  3  20 09 0F             jsr dmsg
001C43  3  4C 4B 1C             jmp k01656
001C46  3  A9 28        k01647: lda #40
001C48  3  20 09 0F             jsr dmsg
001C4B  3  A9 12        k01656: lda #18
001C4D  3  8D 59 02             sta chary
001C50  3  A9 01                lda #1
001C52  3  8D 58 02             sta charx
001C55  3  A9 29                lda #41
001C57  3  20 09 0F             jsr dmsg
001C5A  3  A9 7B                lda #123
001C5C  3  8D 4B 02             sta varl
001C5F  3  AD 4B 02             lda varl
001C62  3  85 65                sta z80_d
001C64  3  A9 0E                lda #14
001C66  3  85 64                sta z80_e
001C68  3  20 AA 05             jsr idiv
001C6B  3  A5 65                lda z80_d
001C6D  3  8D 4B 02             sta varl
001C70  3  AD 4B 02             lda varl
001C73  3  20 F6 13             jsr disply
001C76  3  A9 12                lda #18
001C78  3  8D 59 02             sta chary
001C7B  3  A9 12                lda #18
001C7D  3  8D 58 02             sta charx
001C80  3  A9 08                lda #8
001C82  3  CD 4B 02             cmp varl
001C85  3  F0 03                beq *+5
001C87  3  4C 92 1C             jmp k01775
001C8A  3  A9 2A                lda #42
001C8C  3  20 09 0F             jsr dmsg
001C8F  3  4C 97 1C             jmp k01783
001C92  3  A9 2B        k01775: lda #43
001C94  3  20 09 0F             jsr dmsg
001C97  3  A9 13        k01783: lda #19
001C99  3  8D 59 02             sta chary
001C9C  3  A9 01                lda #1
001C9E  3  8D 58 02             sta charx
001CA1  3  A9 2C                lda #44
001CA3  3  20 09 0F             jsr dmsg
001CA6  3  A9 7B                lda #123
001CA8  3  8D 4B 02             sta varl
001CAB  3  AD 4B 02             lda varl
001CAE  3  4A                   lsr a
001CAF  3  4A                   lsr a
001CB0  3  4A                   lsr a
001CB1  3  4A                   lsr a
001CB2  3  8D 4B 02             sta varl
001CB5  3  AD 4B 02             lda varl
001CB8  3  20 F6 13             jsr disply
001CBB  3  A9 13                lda #19
001CBD  3  8D 59 02             sta chary
001CC0  3  A9 12                lda #18
001CC2  3  8D 58 02             sta charx
001CC5  3  A9 07                lda #7
001CC7  3  CD 4B 02             cmp varl
001CCA  3  F0 03                beq *+5
001CCC  3  4C D7 1C             jmp k01895
001CCF  3  A9 2D                lda #45
001CD1  3  20 09 0F             jsr dmsg
001CD4  3  4C DC 1C             jmp k01903
001CD7  3  A9 2E        k01895: lda #46
001CD9  3  20 09 0F             jsr dmsg
001CDC  3  A9 14        k01903: lda #20
001CDE  3  8D 59 02             sta chary
001CE1  3  A9 01                lda #1
001CE3  3  8D 58 02             sta charx
001CE6  3  A9 2F                lda #47
001CE8  3  20 09 0F             jsr dmsg
001CEB  3  A9 7B                lda #123
001CED  3  8D 4B 02             sta varl
001CF0  3  AD 4B 02             lda varl
001CF3  3  4A                   lsr a
001CF4  3  4A                   lsr a
001CF5  3  4A                   lsr a
001CF6  3  4A                   lsr a
001CF7  3  4A                   lsr a
001CF8  3  8D 4B 02             sta varl
001CFB  3  AD 4B 02             lda varl
001CFE  3  20 F6 13             jsr disply
001D01  3  A9 14                lda #20
001D03  3  8D 59 02             sta chary
001D06  3  A9 12                lda #18
001D08  3  8D 58 02             sta charx
001D0B  3  A9 03                lda #3
001D0D  3  CD 4B 02             cmp varl
001D10  3  F0 03                beq *+5
001D12  3  4C 1D 1D             jmp k02019
001D15  3  A9 30                lda #48
001D17  3  20 09 0F             jsr dmsg
001D1A  3  4C 22 1D             jmp k02027
001D1D  3  A9 31        k02019: lda #49
001D1F  3  20 09 0F             jsr dmsg
001D22  3  A9 15        k02027: lda #21
001D24  3  8D 59 02             sta chary
001D27  3  A9 01                lda #1
001D29  3  8D 58 02             sta charx
001D2C  3  A9 32                lda #50
001D2E  3  20 09 0F             jsr dmsg
001D31  3  A9 7B                lda #123
001D33  3  8D 4B 02             sta varl
001D36  3  AD 4B 02             lda varl
001D39  3  4A                   lsr a
001D3A  3  4A                   lsr a
001D3B  3  4A                   lsr a
001D3C  3  4A                   lsr a
001D3D  3  4A                   lsr a
001D3E  3  4A                   lsr a
001D3F  3  8D 4B 02             sta varl
001D42  3  AD 4B 02             lda varl
001D45  3  20 F6 13             jsr disply
001D48  3  A9 15                lda #21
001D4A  3  8D 59 02             sta chary
001D4D  3  A9 12                lda #18
001D4F  3  8D 58 02             sta charx
001D52  3  A9 01                lda #1
001D54  3  CD 4B 02             cmp varl
001D57  3  F0 03                beq *+5
001D59  3  4C 64 1D             jmp k02146
001D5C  3  A9 33                lda #51
001D5E  3  20 09 0F             jsr dmsg
001D61  3  4C 69 1D             jmp k02154
001D64  3  A9 34        k02146: lda #52
001D66  3  20 09 0F             jsr dmsg
001D69  3  A9 16        k02154: lda #22
001D6B  3  8D 59 02             sta chary
001D6E  3  A9 01                lda #1
001D70  3  8D 58 02             sta charx
001D73  3  A9 35                lda #53
001D75  3  20 09 0F             jsr dmsg
001D78  3  A9 7B                lda #123
001D7A  3  8D 4B 02             sta varl
001D7D  3  AD 4B 02             lda varl
001D80  3  4A                   lsr a
001D81  3  2A                   rol a
001D82  3  25 01                and 1
001D84  3  8D 4B 02             sta varl
001D87  3  AD 4B 02             lda varl
001D8A  3  20 F6 13             jsr disply
001D8D  3  A9 16                lda #22
001D8F  3  8D 59 02             sta chary
001D92  3  A9 12                lda #18
001D94  3  8D 58 02             sta charx
001D97  3  A9 00                lda #0
001D99  3  CD 4B 02             cmp varl
001D9C  3  F0 03                beq *+5
001D9E  3  4C A9 1D             jmp k02262
001DA1  3  A9 36                lda #54
001DA3  3  20 09 0F             jsr dmsg
001DA6  3  4C AE 1D             jmp k02270
001DA9  3  A9 37        k02262: lda #55
001DAB  3  20 09 0F             jsr dmsg
001DAE  3  20 67 02     k02270: jsr prskey
001DB1  3  60                   rts
001DB2  3               evnt11:
001DB2  3  60                   rts
001DB3  3               evnt12:
001DB3  3  20 4D 03             jsr cls
001DB6  3  60                   rts
001DB7  3               evnt13:
001DB7  3  60                   rts
001DB8  3               evnt14:
001DB8  3  60                   rts
001DB9  3               evnt15:
001DB9  3  60                   rts
001DBA  3               evnt16:
001DBA  3  60                   rts
001DBB  3               evnt17:
001DBB  3  60                   rts
001DBC  3               evnt18:
001DBC  3  60                   rts
001DBD  3               evnt19:
001DBD  3  60                   rts
001DBE  3               evnt20:
001DBE  3  60                   rts
001DBF  3  60           ptcusr: rts
001DC0  3               msgdat:
001DC0  3  43 41 4C 43          .byte "CALCULATIONS TEST",186
001DC4  3  55 4C 41 54  
001DC8  3  49 4F 4E 53  
001DD2  3  44 49 56 49          .byte "DIVISION",186
001DD6  3  53 49 4F 4E  
001DDA  3  BA           
001DDB  3  31 32 33 20          .byte "123 /  1 =",160
001DDF  3  2F 20 20 31  
001DE3  3  20 3D A0     
001DE6  3  4F CB                .byte "O",203
001DE8  3  4E 4F 54 20          .byte "NOT O",203
001DEC  3  4F CB        
001DEE  3  31 32 33 20          .byte "123 /  2 =",160
001DF2  3  2F 20 20 32  
001DF6  3  20 3D A0     
001DF9  3  4F CB                .byte "O",203
001DFB  3  4E 4F 54 20          .byte "NOT O",203
001DFF  3  4F CB        
001E01  3  31 32 33 20          .byte "123 /  3 =",160
001E05  3  2F 20 20 33  
001E09  3  20 3D A0     
001E0C  3  4F CB                .byte "O",203
001E0E  3  4E 4F 54 20          .byte "NOT O",203
001E12  3  4F CB        
001E14  3  31 32 33 20          .byte "123 /  4 =",160
001E18  3  2F 20 20 34  
001E1C  3  20 3D A0     
001E1F  3  4F CB                .byte "O",203
001E21  3  4E 4F 54 20          .byte "NOT O",203
001E25  3  4F CB        
001E27  3  31 32 33 20          .byte "123 /  5 =",160
001E2B  3  2F 20 20 35  
001E2F  3  20 3D A0     
001E32  3  4F CB                .byte "O",203
001E34  3  4E 4F 54 20          .byte "NOT O",203
001E38  3  4F CB        
001E3A  3  31 32 33 20          .byte "123 /  6 =",160
001E3E  3  2F 20 20 36  
001E42  3  20 3D A0     
001E45  3  4F CB                .byte "O",203
001E47  3  4E 4F 54 20          .byte "NOT O",203
001E4B  3  4F CB        
001E4D  3  31 32 33 20          .byte "123 /  7 =",160
001E51  3  2F 20 20 37  
001E55  3  20 3D A0     
001E58  3  4F CB                .byte "O",203
001E5A  3  4E 4F 54 20          .byte "NOT O",203
001E5E  3  4F CB        
001E60  3  31 32 33 20          .byte "123 /  8 =",160
001E64  3  2F 20 20 38  
001E68  3  20 3D A0     
001E6B  3  4F CB                .byte "O",203
001E6D  3  4E 4F 54 20          .byte "NOT O",203
001E71  3  4F CB        
001E73  3  31 32 33 20          .byte "123 /  9 =",160
001E77  3  2F 20 20 39  
001E7B  3  20 3D A0     
001E7E  3  4F CB                .byte "O",203
001E80  3  4E 4F 54 20          .byte "NOT O",203
001E84  3  4F CB        
001E86  3  31 32 33 20          .byte "123 / 10 =",160
001E8A  3  2F 20 31 30  
001E8E  3  20 3D A0     
001E91  3  4F CB                .byte "O",203
001E93  3  4E 4F 54 20          .byte "NOT O",203
001E97  3  4F CB        
001E99  3  31 32 33 20          .byte "123 / 11 =",160
001E9D  3  2F 20 31 31  
001EA1  3  20 3D A0     
001EA4  3  4F CB                .byte "O",203
001EA6  3  4E 4F 54 20          .byte "NOT O",203
001EAA  3  4F CB        
001EAC  3  31 32 33 20          .byte "123 / 12 =",160
001EB0  3  2F 20 31 32  
001EB4  3  20 3D A0     
001EB7  3  4F CB                .byte "O",203
001EB9  3  4E 4F 54 20          .byte "NOT O",203
001EBD  3  4F CB        
001EBF  3  31 32 33 20          .byte "123 / 13 =",160
001EC3  3  2F 20 31 33  
001EC7  3  20 3D A0     
001ECA  3  4F CB                .byte "O",203
001ECC  3  4E 4F 54 20          .byte "NOT O",203
001ED0  3  4F CB        
001ED2  3  31 32 33 20          .byte "123 / 14 =",160
001ED6  3  2F 20 31 34  
001EDA  3  20 3D A0     
001EDD  3  4F CB                .byte "O",203
001EDF  3  4E 4F 54 20          .byte "NOT O",203
001EE3  3  4F CB        
001EE5  3  31 32 33 20          .byte "123 / 16 =",160
001EE9  3  2F 20 31 36  
001EED  3  20 3D A0     
001EF0  3  4F CB                .byte "O",203
001EF2  3  4E 4F 54 20          .byte "NOT O",203
001EF6  3  4F CB        
001EF8  3  31 32 33 20          .byte "123 / 32 =",160
001EFC  3  2F 20 33 32  
001F00  3  20 3D A0     
001F03  3  4F CB                .byte "O",203
001F05  3  4E 4F 54 20          .byte "NOT O",203
001F09  3  4F CB        
001F0B  3  31 32 33 20          .byte "123 / 64 =",160
001F0F  3  2F 20 36 34  
001F13  3  20 3D A0     
001F16  3  4F CB                .byte "O",203
001F18  3  4E 4F 54 20          .byte "NOT O",203
001F1C  3  4F CB        
001F1E  3  31 32 33 20          .byte "123 /128 =",160
001F22  3  2F 31 32 38  
001F26  3  20 3D A0     
001F29  3  4F CB                .byte "O",203
001F2B  3  4E 4F 54 20          .byte "NOT O",203
001F2F  3  4F CB        
001F31  3               nummsg:
001F31  3  38                   .byte 56
001F32  3               chgfx:
001F32  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001F36  3  00 00 00 00  
001F3A  3               bprop:
001F3A  3  00                   .byte 0
001F3B  3               sprgfx:
001F3B  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001F3F  3  00 00 00 00  
001F43  3  00 00 00 00  
001F5B  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001F5F  3  00 00 00 00  
001F63  3  00 00 00 00  
001F7B  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001F7F  3  00 00 00 00  
001F83  3  00 00 00 00  
001F9B  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
001F9F  3  00 00 00 00  
001FA3  3  00 00 00 00  
001FBB  3               frmlst:
001FBB  3  00 01 01 00          .byte 0,1,1,0
001FBF  3               scdat:
001FBF  3  09 00                .word 9
001FC1  3  FF 00 00 FF          .byte 255,0,0,255,0,0,255,0,148
001FC5  3  00 00 FF 00  
001FC9  3  94           
001FCA  3               numsc:
001FCA  3  01                   .byte 1
001FCB  3               nmedat:
001FCB  3  00 00 58 80          .byte 0,0,88,128,255
001FCF  3  FF           
001FD0  3               NUMOBJ = 1
001FD0  3               objdta:
001FD0  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,32,0,160,32
001FD4  3  00 00 00 00  
001FD8  3  00 00 00 00  
001FF6  3               font:
001FF6  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
001FFA  3  00 00 00 00  
001FFE  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
002002  3  30 00 30 00  
002006  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
00200A  3  00 00 00 00  
00200E  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
002012  3  6C FE 6C 00  
002016  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
00201A  3  7E 1E 7E 18  
00201E  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
002022  3  30 6E CE 00  
002026  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
00202A  3  7E CC 7E 00  
00202E  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
002032  3  00 00 00 00  
002036  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
00203A  3  18 18 0C 00  
00203E  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
002042  3  30 30 60 00  
002046  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
00204A  3  7E 18 3C 00  
00204E  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
002052  3  7E 18 18 00  
002056  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
00205A  3  00 18 18 30  
00205E  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
002062  3  7E 00 00 00  
002066  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
00206A  3  00 38 38 00  
00206E  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
002072  3  18 30 60 00  
002076  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
00207A  3  F6 E6 7C 00  
00207E  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
002082  3  18 18 7E 00  
002086  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
00208A  3  7C C0 FE 00  
00208E  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
002092  3  06 C6 7C 00  
002096  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
00209A  3  D8 FE 18 00  
00209E  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
0020A2  3  06 C6 7C 00  
0020A6  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
0020AA  3  C6 C6 7C 00  
0020AE  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
0020B2  3  18 30 30 00  
0020B6  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
0020BA  3  C6 C6 7C 00  
0020BE  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
0020C2  3  7E 06 7C 00  
0020C6  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
0020CA  3  00 00 30 00  
0020CE  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
0020D2  3  00 30 30 60  
0020D6  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
0020DA  3  30 18 0C 00  
0020DE  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
0020E2  3  00 7E 00 00  
0020E6  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
0020EA  3  0C 18 30 00  
0020EE  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
0020F2  3  18 00 18 00  
0020F6  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
0020FA  3  FE C0 7C 00  
0020FE  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
002102  3  FE C6 C6 00  
002106  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
00210A  3  C6 C6 FC 00  
00210E  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
002112  3  C0 C6 7C 00  
002116  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
00211A  3  C6 CC F8 00  
00211E  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
002122  3  C0 C0 FE 00  
002126  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
00212A  3  C0 C0 C0 00  
00212E  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
002132  3  DE C6 7C 00  
002136  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
00213A  3  C6 C6 C6 00  
00213E  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
002142  3  18 18 7E 00  
002146  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
00214A  3  C6 C6 7C 00  
00214E  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
002152  3  D8 CC C6 00  
002156  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
00215A  3  C0 C0 FE 00  
00215E  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
002162  3  C6 C6 C6 00  
002166  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
00216A  3  DE CE C6 00  
00216E  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
002172  3  C6 C6 7C 00  
002176  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
00217A  3  FC C0 C0 00  
00217E  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
002182  3  F6 DE 7C 00  
002186  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
00218A  3  FC CC C6 00  
00218E  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
002192  3  06 C6 7C 00  
002196  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
00219A  3  30 30 30 00  
00219E  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
0021A2  3  C6 C6 7C 00  
0021A6  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
0021AA  3  C6 6C 38 00  
0021AE  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
0021B2  3  C6 FE 6C 00  
0021B6  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
0021BA  3  38 6C C6 00  
0021BE  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
0021C2  3  30 30 30 00  
0021C6  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
0021CA  3  30 60 FE 00  
0021CE  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
0021D2  3  18 18 1E 00  
0021D6  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
0021DA  3  30 18 0C 00  
0021DE  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
0021E2  3  30 30 F0 00  
0021E6  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
0021EA  3  30 30 30 00  
0021EE  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
0021F2  3  00 00 00 FF  
0021F6  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
0021FA  3  60 60 FE 00  
0021FE  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
002202  3  7C CC 7C 00  
002206  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
00220A  3  66 66 7C 00  
00220E  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
002212  3  60 60 3C 00  
002216  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
00221A  3  CC CC 7C 00  
00221E  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
002222  3  F8 C0 7C 00  
002226  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
00222A  3  30 30 30 00  
00222E  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
002232  3  CC 7C 0C 78  
002236  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
00223A  3  CC CC CC 00  
00223E  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
002242  3  30 30 78 00  
002246  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
00224A  3  0C 0C 6C 38  
00224E  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
002252  3  70 78 6C 00  
002256  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
00225A  3  30 30 1C 00  
00225E  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
002262  3  FC FC FC 00  
002266  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
00226A  3  CC CC CC 00  
00226E  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
002272  3  CC CC 78 00  
002276  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
00227A  3  CC F8 C0 C0  
00227E  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
002282  3  CC 7C 0C 0E  
002286  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
00228A  3  60 60 60 00  
00228E  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
002292  3  78 0C F8 00  
002296  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
00229A  3  30 30 1C 00  
00229E  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
0022A2  3  CC CC 78 00  
0022A6  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
0022AA  3  78 78 30 00  
0022AE  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
0022B2  3  FC FC 78 00  
0022B6  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
0022BA  3  30 78 CC 00  
0022BE  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
0022C2  3  CC 7C 0C 78  
0022C6  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
0022CA  3  30 60 FC 00  
0022CE  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
0022D2  3  18 18 1E 00  
0022D6  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
0022DA  3  18 18 18 00  
0022DE  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
0022E2  3  30 30 F0 00  
0022E6  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
0022EA  3  00 00 00 00  
0022EE  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
0022F2  3  E3 BB C6 7C  
0022F6  3  35 15 93 22  keys:   .byte 53,21,147,34,144,4,20,33,17,1,146
0022FA  3  90 04 14 21  
0022FE  3  11 01 92     
002301  3               
002301  1               eind_asm:
002301  2               ;------------------------------------------------------
002301  2               ; z80.asm
002301  2               ; spectrum stuff
002301  2               ; adresses
002301  2               
002301  2               ;ws	 = $60
002301  2               
002301  2               ;z80_f	 = ws+$00
002301  2               ;z80_a	 = ws+$01
002301  2               ;z80_af	 = z80_f
002301  2               
002301  2               ;z80_c	 = ws+$02
002301  2               ;z80_b	 = ws+$03
002301  2               ;z80_bc	 = z80_c
002301  2               
002301  2               ;z80_e	 = ws+$04
002301  2               ;z80_d	 = ws+$05
002301  2               ;z80_de	 = z80_e
002301  2               
002301  2               ;z80_l	 = ws+$06
002301  2               ;z80_h	 = ws+$07
002301  2               ;z80_hl	 = z80_l
002301  2               
002301  2               ;z80_x    = ws+$08
002301  2               ;z80_i    = ws+$09
002301  2               ;z80_ix	 = z80_x
002301  2               
002301  2               ;z80_iy	 = ws+$0a
002301  2               
002301  2               ;z80_fp	 = ws+$0c
002301  2               ;z80_ap	 = ws+$0d
002301  2               
002301  2               ;z80_cp	 = ws+$0e
002301  2               ;z80_bp	 = ws+$0f
002301  2               ;z80_bcp = z80_cp
002301  2               
002301  2               ;z80_ep	 = ws+$10
002301  2               ;z80_dp	 = ws+$11
002301  2               ;z80_dep = z80_ep
002301  2               
002301  2               ;z80_lp	 = ws+$12
002301  2               ;z80_hp	 = ws+$13
002301  2               ;z80_hlp = z80_lp
002301  2               
002301  2               ;z80_sp   = ws+$14
002301  2               
002301  2               ;z80_reg0 = ws+$16
002301  2               ;z80_reg1 = ws+$17
002301  2               ;z80_reg2 = ws+$18
002301  2               ;z80_reg3 = ws+$19
002301  2               
002301  2               ;z80_r	 = ws+$1a
002301  2               
002301  2               ; Contains seperatly 1 bit set
002301  2               
002301  2               _bitmem0	= $f8
002301  2               _bitmem1	= $f9
002301  2               _bitmem2	= $fa
002301  2               _bitmem3	= $fb
002301  2               _bitmem4	= $fc
002301  2               _bitmem5	= $fd
002301  2               _bitmem6	= $fe
002301  2               _bitmem7	= $ff
002301  2               	
002301  2               ; constants	
002301  2               _bitvalue0	= $01	
002301  2               _bitvalue1	= $02	
002301  2               _bitvalue2	= $04	
002301  2               _bitvalue3	= $08	
002301  2               _bitvalue4	= $10	
002301  2               _bitvalue5	= $20	
002301  2               _bitvalue6	= $40	
002301  2               _bitvalue7	= $80	
002301  2               
002301  2               _notbitvalue0	= $fe	
002301  2               _notbitvalue1	= $fd	
002301  2               _notbitvalue2	= $fb	
002301  2               _notbitvalue3	= $f7	
002301  2               _notbitvalue4	= $ef	
002301  2               _notbitvalue5	= $df	
002301  2               _notbitvalue6	= $bf	
002301  2               _notbitvalue7	= $7f	
002301  2               
002301  2               
002301  2               ;add_hl_bc:
002301  2               ;		lda z80_l
002301  2               ;		clc
002301  2               ;		adc z80_c
002301  2               ;		sta z80_l
002301  2               ;		lda z80_h
002301  2               ;		adc z80_b
002301  2               ;		sta z80_h
002301  2               ;		rts
002301  2               ;		
002301  2               ;add_ix_de:
002301  2               ;		lda z80_ix
002301  2               ;		clc
002301  2               ;		adc z80_e
002301  2               ;		sta z80_ix
002301  2               ;		lda z80_ix+1
002301  2               ;		adc z80_d
002301  2               ;		sta z80_ix+1
002301  2               ;		rts
002301  2               ;		
002301  2               ;add_iy_de:
002301  2               ;		lda z80_iy
002301  2               ;		clc
002301  2               ;		adc z80_e
002301  2               ;		sta z80_iy
002301  2               ;		lda z80_iy+1
002301  2               ;		adc z80_d
002301  2               ;		sta z80_iy+1
002301  2               ;		rts
002301  2               ;		
002301  2               ;add_hl_de:
002301  2               ;		lda z80_l
002301  2               ;		clc
002301  2               ;		adc z80_e
002301  2               ;		sta z80_l
002301  2               ;		lda z80_h
002301  2               ;		adc z80_d
002301  2               ;		sta z80_h
002301  2               ;		rts
002301  2               ;
002301  2               ;add_ix_bc:
002301  2               ;		lda z80_ix
002301  2               ;		clc
002301  2               ;		adc z80_c
002301  2               ;		sta z80_ix
002301  2               ;		lda z80_ix+1
002301  2               ;		adc z80_b
002301  2               ;		sta z80_ix+1
002301  2               ;		rts
002301  2               ;		
002301  2               ;add_iy_bc:
002301  2               ;		lda z80_iy
002301  2               ;		clc
002301  2               ;		adc z80_c
002301  2               ;		sta z80_iy
002301  2               ;		lda z80_iy+1
002301  2               ;		adc z80_b
002301  2               ;		sta z80_iy+1
002301  2               ;		rts
002301  2               ;		
002301  2               sbc_hl_de:
002301  2  A5 66        		lda z80_l
002303  2  E5 64        		sbc z80_e
002305  2  85 66        		sta z80_l
002307  2  A5 67        		lda z80_h
002309  2  E5 65        		sbc z80_d
00230B  2  85 67        		sta z80_h
00230D  2  60           		rts
00230E  2               
00230E  2               ;sbc_hl_bc:
00230E  2               ;		lda z80_l
00230E  2               ;		sbc z80_c
00230E  2               ;		sta z80_l
00230E  2               ;		lda z80_h
00230E  2               ;		sbc z80_b
00230E  2               ;		sta z80_h
00230E  2               ;		rts
00230E  2               ;
00230E  2               ;cmp_hl_bc:
00230E  2               ;		lda z80_l
00230E  2               ;		cmp z80_c
00230E  2               ;		bne cmp_hl_bc_end
00230E  2               ;		lda z80_h
00230E  2               ;		cmp z80_b
00230E  2               ;cmp_hl_bc_end:
00230E  2               ;		rts
00230E  2               ;		
00230E  2               ;cmp_iy_ix:
00230E  2               ;		lda z80_iy
00230E  2               ;		cmp z80_ix
00230E  2               ;		bne cmp_iy_ix_end
00230E  2               ;		lda z80_iy+1
00230E  2               ;		cmp z80_ix+1
00230E  2               ;cmp_iy_ix_end:
00230E  2               ;		rts
00230E  2               ;		
00230E  2               ;dec_hl:
00230E  2               ;		lda z80_l
00230E  2               ;		bne dec_hl_no_dec_h
00230E  2               ;		dec z80_h
00230E  2               ;dec_hl_no_dec_h:
00230E  2               ;		dec z80_l
00230E  2               ;		rts
00230E  2               ;	
00230E  2               ;dec_ix:
00230E  2               ;		lda z80_ix
00230E  2               ;		bne dec_ix_no_dec_h
00230E  2               ;		dec z80_ix+1
00230E  2               ;dec_ix_no_dec_h:
00230E  2               ;		dec z80_ix
00230E  2               ;		rts
00230E  2               ;		
00230E  2               ;dec_bc:	
00230E  2               ;		lda z80_c
00230E  2               ;		bne dec_bc_no_dec_b
00230E  2               ;		dec z80_b
00230E  2               ;dec_bc_no_dec_b:
00230E  2               ;		dec z80_c
00230E  2               ;		rts
00230E  2               ;	
00230E  2               ;dec_de:
00230E  2               ;		lda z80_e
00230E  2               ;		bne dec_de_no_dec_d
00230E  2               ;		dec z80_d
00230E  2               ;dec_de_no_dec_d:
00230E  2               ;		dec z80_e
00230E  2               ;		rts
00230E  2               ;		
00230E  2               ;ex_af_afs:
00230E  2               ;	rts
00230E  2               ;ex_de_hl:
00230E  2               ;		lda z80_e
00230E  2               ;		ldx z80_l
00230E  2               ;		stx z80_e
00230E  2               ;		sta z80_l
00230E  2               ;		lda z80_d
00230E  2               ;		ldx z80_h
00230E  2               ;		stx z80_d
00230E  2               ;		sta z80_h
00230E  2               ;		rts
00230E  2               ;
00230E  2               exx:
00230E  2  A5 62        		lda z80_c
002310  2  A4 6E        		ldy z80_cp
002312  2  84 62        		sty z80_c
002314  2  85 6E        		sta z80_cp
002316  2  A5 63        		lda z80_b
002318  2  A4 6F        		ldy z80_bp
00231A  2  84 63        		sty z80_b
00231C  2  85 6F        		sta z80_bp
00231E  2  A5 64        		lda z80_e
002320  2  A4 70        		ldy z80_ep
002322  2  84 64        		sty z80_e
002324  2  85 70        		sta z80_ep
002326  2  A5 65        		lda z80_d
002328  2  A4 71        		ldy z80_dp
00232A  2  84 65        		sty z80_d
00232C  2  85 71        		sta z80_dp		
00232E  2  A5 80        		lda scraddr
002330  2  A4 72        		ldy z80_lp
002332  2  84 80        		sty scraddr
002334  2  85 72        		sta z80_lp
002336  2  A5 81        		lda scraddr+1
002338  2  A4 73        		ldy z80_hp
00233A  2  84 81        		sty scraddr+1
00233C  2  85 73        		sta z80_hp
00233E  2  60           		rts
00233F  2               		
00233F  2               ;ex_sp_hl:
00233F  2               ;		tsx
00233F  2               ;		lda $0103,x
00233F  2               ;		ldy z80_h
00233F  2               ;		sta z80_h
00233F  2               ;		tya
00233F  2               ;		sta $0103,x
00233F  2               ;		lda $0104,x
00233F  2               ;		ldy z80_l
00233F  2               ;		sta z80_l
00233F  2               ;		tya
00233F  2               ;		sta $104,x
00233F  2               ;		rts
00233F  2               ;		
00233F  2               ;ldi:
00233F  2               ;	rts
00233F  2               ;ldir:
00233F  2               ;		ldy #$00
00233F  2               ;		ldx z80_b
00233F  2               ;		beq ldir_last_page
00233F  2               ;ldir_loop:		
00233F  2               ;		lda (z80_hl),y
00233F  2               ;		sta (z80_de),y
00233F  2               ;		iny
00233F  2               ;		bne ldir_loop
00233F  2               ;		inc z80_h
00233F  2               ;		inc z80_d
00233F  2               ;		dex
00233F  2               ;		bne ldir_loop
00233F  2               ;ldir_last_page:
00233F  2               ;		lda z80_c
00233F  2               ;		beq ldir_end
00233F  2               ;ldir_last_page_loop:		
00233F  2               ;		lda (z80_hl),y
00233F  2               ;		sta (z80_de),y
00233F  2               ;		iny
00233F  2               ;		cpy z80_c
00233F  2               ;		bne ldir_last_page_loop
00233F  2               ;ldir_end:		
00233F  2               ;		stx z80_c
00233F  2               ;		stx z80_b
00233F  2               ;		tya
00233F  2               ;		clc
00233F  2               ;		adc z80_l
00233F  2               ;		sta z80_l
00233F  2               ;		bcc *+4
00233F  2               ;		inc z80_h
00233F  2               ;		tya
00233F  2               ;		clc
00233F  2               ;		adc z80_e
00233F  2               ;		sta z80_e
00233F  2               ;		bcc *+4
00233F  2               ;		inc z80_d
00233F  2               ;		rts
00233F  2               ;		
00233F  2               ;lddr:		ldy #$00
00233F  2               ;lddr_loop:
00233F  2               ;		lda (z80_hl),y
00233F  2               ;		sta (z80_de),y
00233F  2               ;		jsr dec_hl
00233F  2               ;		jsr dec_de
00233F  2               ;		jsr dec_bc
00233F  2               ;		lda z80_b
00233F  2               ;		ora z80_c
00233F  2               ;		bne lddr_loop
00233F  2               ;		rts
00233F  2               ;ei:
00233F  2               ;		rts
00233F  2               ;di:
00233F  2               ;		rts
00233F  2               		
00233F  2               ;-------------------------------------------------------------
00233F  2               ; Set bits in bitmem
00233F  2               ;-------------------------------------------------------------
00233F  2               	
00233F  2               z80_init:
00233F  2  A2 00        	ldx #$00
002341  2  A9 01        	lda #$01
002343  2               z80_init_loop:		
002343  2  95 F8        	sta _bitmem0,x
002345  2  E8           	inx
002346  2  0A           	asl a
002347  2  D0 FA        	bne z80_init_loop
002349  2  60           	rts
00234A  2               
00234A  2               push_af:
00234A  2               push_bc:
00234A  2               push_de:
00234A  2               push_hl:
00234A  2               
00234A  2               pop_af:
00234A  2               pop_bc:
00234A  2               pop_de:
00234A  2               pop_ix:
00234A  2               pop_hl:
00234A  2               
00234A  2               add_hl_hl:
00234A  2               
00234A  2               inc_bc:
00234A  2               inc_de:
00234A  2               inc_hl:
00234A  2               inc_ix:
00234A  2               inc_sp:
00234A  2               
00234A  2               cpir:
00234A  2               
00234A  2               ex_af_af:
00234A  2               ;	rts
00234A  2               
00234A  1               
