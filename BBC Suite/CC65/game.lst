ca65 V2.17 - Git cc5c093
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; BBC AGD Engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ; BBC Micro version by Kieran Connell 2018
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .DEFINE asm_code $0e00		; assembly address _BEEB
000000r 1               .DEFINE load_address $1200	; load address _BEEB
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; BBC MICRO PLATFORM DEFINES
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; _BEEB MOS calls
000000r 1               
000000r 1               	OSBYTE	 = $fff4
000000r 1               	OSFILE	 = $ffdd
000000r 1               	OSWRCH	 = $ffee
000000r 1               	OSASCI	 = $ffe3
000000r 1               	OSWORD	 = $fff1
000000r 1               	OSFIND	 = $ffce
000000r 1               	OSGBPB	 = $ffd1
000000r 1               	OSARGS	 = $ffda
000000r 1               
000000r 1               	EVENTV	 = $0220
000000r 1               
000000r 1               	PAL_black = 0 ^ 7
000000r 1               	PAL_red = 1 ^ 7
000000r 1               	PAL_green = 2 ^ 7
000000r 1               	PAL_yellow = 3 ^ 7
000000r 1               	PAL_blue = 4 ^ 7
000000r 1               	PAL_magenta = 5 ^ 7
000000r 1               	PAL_cyan = 6 ^ 7
000000r 1               	PAL_white = 7 ^ 7
000000r 1               
000000r 1               ; System constants
000000r 1               
000000r 1               	ScreenSize  = $1800	; Startaddress video RAM _BEEB
000000r 1               	ScreenAddr 	= $8000 - ScreenSize	; Screen size bytes _BEEB
000000r 1               	ScreenRowBytes = 256				; 40 columns
000000r 1               
000000r 1               	SpriteMaxY	= 177	; used for clipping bottom of screen
000000r 1               
000000r 1               ; AGD Engine Workspace
000000r 1               
000000r 1               	MAP 		= $300				; properties map buffer (3x256 bytes)
000000r 1               	SCADTB_lb	= MAP + $300
000000r 1               	SCADTB_hb	= SCADTB_lb + $100
000000r 1               
000000r 1               .if pflag
000000r 1                   SHRAPN 		= $B00 - (NUMSHR * SHRSIZ)	; shrapnel table (55x6 bytes)
000000r 1               .endif
000000r 1               
000000r 1               	sprtab		= $B00				; NUMSPR*TABSIZ
000000r 1               
000000r 1               	.macro DEBUG_PAL pal
000000r 1               	;	SET_PAL pal
000000r 1               	.endmacro
000000r 1               
000000r 1               	.macro SET_PAL pal
000000r 1               		lda #$00+pal
000000r 1               		sta $fe21
000000r 1               		lda #$10+pal
000000r 1               		sta $fe21
000000r 1               		lda #$20+pal
000000r 1               		sta $fe21
000000r 1               		lda #$30+pal
000000r 1               		sta $fe21
000000r 1               		lda #$40+pal
000000r 1               		sta $fe21
000000r 1               		lda #$50+pal
000000r 1               		sta $fe21
000000r 1               		lda #$60+pal
000000r 1               		sta $fe21
000000r 1               		lda #$70+pal
000000r 1               		sta $fe21
000000r 1               	.endmacro
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; ZERO PAGE SEGMENT
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               
000000r 1               .include "z80-zp.inc"
000000r 2               ;ws	 = $60
000000r 2               
000000r 2  xx           z80_f: .res 1;	 = ws+$00
000001r 2  xx           z80_a: .res 1;	 = ws+$01
000002r 2               z80_af	 = z80_f
000002r 2               
000002r 2  xx           z80_c: .res 1;	 = ws+$02
000003r 2  xx           z80_b: .res 1;	 = ws+$03
000004r 2               z80_bc	 = z80_c
000004r 2               
000004r 2  xx           z80_e: .res 1;	 = ws+$04
000005r 2  xx           z80_d: .res 1;	 = ws+$05
000006r 2               z80_de	 = z80_e
000006r 2               
000006r 2  xx           z80_l: .res 1;	 = ws+$06
000007r 2  xx           z80_h: .res 1;	 = ws+$07
000008r 2               z80_hl	 = z80_l
000008r 2               
000008r 2  xx           z80_x: .res 1;    = ws+$08
000009r 2  xx           z80_i: .res 1;    = ws+$09
00000Ar 2               z80_ix	 = z80_x
00000Ar 2               
00000Ar 2  xx xx        z80_iy: .res 2;	 = ws+$0a
00000Cr 2               
00000Cr 2  xx           z80_fp: .res 1;	 = ws+$0c
00000Dr 2  xx           z80_ap: .res 1;	 = ws+$0d
00000Er 2               
00000Er 2  xx           z80_cp: .res 1;	 = ws+$0e
00000Fr 2  xx           z80_bp: .res 1;	 = ws+$0f
000010r 2               z80_bcp	 = z80_cp
000010r 2               
000010r 2  xx           z80_ep: .res 1;	 = ws+$10
000011r 2  xx           z80_dp: .res 1;	 = ws+$11
000012r 2               z80_dep	 = z80_ep
000012r 2               
000012r 2  xx           z80_lp: .res 1;	 = ws+$12
000013r 2  xx           z80_hp: .res 1;	 = ws+$13
000014r 2               z80_hlp	 = z80_lp
000014r 2               
000014r 2  xx xx        z80_sp: .res 2;   = ws+$14
000016r 2               
000016r 2  xx           z80_reg0: .res 1; = ws+$16
000017r 2  xx           z80_reg1: .res 1; = ws+$17
000018r 2  xx           z80_reg2: .res 1; = ws+$18
000019r 2  xx           z80_reg3: .res 1; = ws+$19
00001Ar 2               
00001Ar 2               ;z80_r: .res 1;	 = ws+$1a
00001Ar 2               
00001Ar 1               .include "engine-zp.inc"
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               ; AGD 6502 Engine Zero Page Variables
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               
00001Ar 2               ; Variables start here.
00001Ar 2               
00001Ar 2  xx           scno:	.res 1			; present screen number.
00001Br 2  xx           numlif:	.res 1			; number of lives.
00001Cr 2               
00001Cr 2  xx           vara:	.res 1			; general-purpose variable.
00001Dr 2  xx           varb:	.res 1			; general-purpose variable.
00001Er 2  xx           varc:	.res 1			; general-purpose variable.
00001Fr 2  xx           vard:	.res 1			; general-purpose variable.
000020r 2  xx           vare:	.res 1			; general-purpose variable.
000021r 2  xx           varf:	.res 1			; general-purpose variable.
000022r 2  xx           varg:	.res 1			; general-purpose variable.
000023r 2  xx           varh:	.res 1			; general-purpose variable.
000024r 2  xx           vari:	.res 1			; general-purpose variable.
000025r 2  xx           varj:	.res 1			; general-purpose variable.
000026r 2  xx           vark:	.res 1			; general-purpose variable.
000027r 2  xx           varl:	.res 1			; general-purpose variable.
000028r 2  xx           varm:	.res 1			; general-purpose variable.
000029r 2  xx           varn:	.res 1			; general-purpose variable.
00002Ar 2  xx           varo:	.res 1			; general-purpose variable.
00002Br 2  xx           varp:	.res 1			; general-purpose variable.
00002Cr 2  xx           varq:	.res 1			; general-purpose variable.
00002Dr 2  xx           varr:	.res 1			; general-purpose variable.
00002Er 2  xx           vars:	.res 1			; general-purpose variable.
00002Fr 2  xx           vart:	.res 1			; general-purpose variable.
000030r 2  xx           varu:	.res 1			; general-purpose variable.
000031r 2  xx           varv:	.res 1			; general-purpose variable.
000032r 2  xx           varw:	.res 1			; general-purpose variable.
000033r 2  xx           varz:	.res 1			; general-purpose variable.
000034r 2               
000034r 2  xx           charx:	.res 1			; cursor x position.
000035r 2  xx           chary:	.res 1			; cursor y position.
000036r 2               
000036r 2  xx           clock:	.res 1			; last clock reading.
000037r 2  xx           varrnd:	.res 1	        ; last random number.
000038r 2  xx           varobj:	.res 1  	    ; last object number.
000039r 2  xx           varopt:	.res 1     		; last option chosen from menu.
00003Ar 2  xx           varblk:	.res 1  		; block type.
00003Br 2  xx           nexlev:	.res 1			; next level flag.
00003Cr 2  xx           restfl:	.res 1			; restart screen flag.
00003Dr 2  xx           deadf:	.res 1			; dead flag.
00003Er 2  xx           gamwon:	.res 1			; game won flag.
00003Fr 2  xx           dispx:	.res 1			; cursor x position.
000040r 2  xx           dispy:	.res 1			; cursor y position.
000041r 2               
000041r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000042r 2  xx           joyval:	.res 1			; joystick reading.
000043r 2  xx           frmno:	.res 1			; selected frame.
000044r 2               
000044r 2               ;----------------------------------------------------
000044r 2               ; Missing vars
000044r 2               ;----------------------------------------------------
000044r 2               
000044r 2  xx           loopa:		.res 1
000045r 2  xx           loopb:		.res 1
000046r 2  xx           loopc:		.res 1
000047r 2  xx xx        FontPtr:    .res 2
000049r 2               
000049r 2               ; Local vars
000049r 2               
000049r 2  xx xx        scraddr:    .res 2
00004Br 2  xx xx        fntaddr:    .res 2
00004Dr 2  xx xx        tileaddr:   .res 2
00004Fr 2  xx xx        bufaddr:    .res 2
000051r 2               
000051r 2  xx xx        tmp:        .res 2
000053r 2  xx xx        scr_l:      .res 2
000055r 2  xx xx        scr_r:      .res 2
000057r 2  xx xx        scr_txt:    .res 2
000059r 2               
000059r 2  xx           xtmp:	    .res 1
00005Ar 2  xx           spcnt:	    .res 1
00005Br 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
00005Dr 2  xx           seed:	    .res 1		; seed for random numbers.
00005Er 2               
00005Er 2  xx           ccnt:       .res 1
00005Fr 2  xx           flag:	    .res 1
000060r 2  xx           rcol:	    .res 1
000061r 2  xx           rrow:	    .res 1
000062r 2               
000062r 2  xx           combyt:	    .res 1		; byte type compressed.
000063r 2  xx           comcnt:	    .res 1		; compression counter.
000064r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
000065r 2  xx           qscnt:	    .res 1
000066r 2               
000066r 2  xx           sprptr:	    .res 1      ; not a ptr
000067r 2  xx           sprcnt:	    .res 1
000068r 2               
000068r 2  xx xx        skptr:	    .res 2		; search pointer.
00006Ar 2  xx           sktptr:	    .res 1      ; not a ptr
00006Br 2  xx           tmproom:	.res 1
00006Cr 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
00006Er 2               
00006Er 2  xx xx xx     spr:	    .res 3      ; static sprite data
000071r 2  xx           vsync_count:.res 1
000072r 2  xx           colpatt:	.res 1
000073r 2               
000073r 2               
000073r 2               .if mflag
000073r 2               TmpAddr:	.res 2
000073r 2               bwid:	    .res 1     ; box/menu width.
000073r 2               blen:	    .res 1     ; box/menu height.
000073r 2               btop:	    .res 1     ; box coordinates.
000073r 2               blft:	    .res 1
000073r 2               .endif
000073r 2               
000073r 2               .if pflag
000073r 2               shrctr:	    .res 1
000073r 2               explcnt:	.res 1
000073r 2               seed3:	    .res 1
000073r 2               .endif
000073r 2               
000073r 1               
000073r 1               ;----------------------------------------------------------------------
000073r 1               ; ZCODE SEGMENT
000073r 1               ;----------------------------------------------------------------------
000073r 1               
000073r 1               .segment "CODE"
000000r 1               .org asm_code
000E00  1               
000E00  1               start_asm:
000E00  1               
000E00  1  4C C0 41     	jmp relocate + load_address - asm_code
000E03  1               
000E03  1               boot_game:
000E03  1               
000E03  1               ; Zero ZP vars
000E03  1               
000E03  1               clear_zp:
000E03  1  A2 00        	ldx #0
000E05  1  8A           	txa
000E06  1               	:
000E06  1  95 00        	sta $00, x
000E08  1  E8           	inx
000E09  1  E0 A0        	cpx #$a0
000E0B  1  D0 F9        	bne :-
000E0D  1               
000E0D  1               	; Init non-zero vars
000E0D  1  A9 03        	lda #3
000E0F  1  85 rr        	sta numlif
000E11  1               
000E11  1  A2 FF        	ldx #255
000E13  1  86 rr        	stx varrnd
000E15  1  86 rr        	stx varopt
000E17  1  86 rr        	stx varblk
000E19  1  CA           	dex
000E1A  1  86 rr        	stx varobj
000E1C  1               
000E1C  1  20 80 0E     	jsr bbcinit
000E1F  1               
000E1F  1               	; Call AGD Engine start game
000E1F  1  20 EF 10     	jsr start_game
000E22  1               
000E22  1  20 9F 0E     	jsr bbckill
000E25  1               
000E25  1                   ; Wait for keypress
000E25  1  A2 FF        	ldx #$ff
000E27  1  A0 7F        	ldy #$7f
000E29  1  A9 81        	lda #$81
000E2B  1  20 F4 FF     	jsr OSBYTE
000E2E  1               
000E2E  1               	; Restart or exit
000E2E  1  4C 03 0E     	jmp boot_game
000E31  1               
000E31  1               ;----------------------------------------------------------------------
000E31  1               ; PLATFORM SPECIFIC ENGINE CODE
000E31  1               ;----------------------------------------------------------------------
000E31  1               
000E31  1               	.include "z80.asm"
000E31  2               ;------------------------------------------------------
000E31  2               ; z80.asm
000E31  2               ; spectrum stuff
000E31  2               ; adresses
000E31  2               
000E31  2               ;ws	 = $60
000E31  2               
000E31  2               ;z80_f	 = ws+$00
000E31  2               ;z80_a	 = ws+$01
000E31  2               ;z80_af	 = z80_f
000E31  2               
000E31  2               ;z80_c	 = ws+$02
000E31  2               ;z80_b	 = ws+$03
000E31  2               ;z80_bc	 = z80_c
000E31  2               
000E31  2               ;z80_e	 = ws+$04
000E31  2               ;z80_d	 = ws+$05
000E31  2               ;z80_de	 = z80_e
000E31  2               
000E31  2               ;z80_l	 = ws+$06
000E31  2               ;z80_h	 = ws+$07
000E31  2               ;z80_hl	 = z80_l
000E31  2               
000E31  2               ;z80_x    = ws+$08
000E31  2               ;z80_i    = ws+$09
000E31  2               ;z80_ix	 = z80_x
000E31  2               
000E31  2               ;z80_iy	 = ws+$0a
000E31  2               
000E31  2               ;z80_fp	 = ws+$0c
000E31  2               ;z80_ap	 = ws+$0d
000E31  2               
000E31  2               ;z80_cp	 = ws+$0e
000E31  2               ;z80_bp	 = ws+$0f
000E31  2               ;z80_bcp = z80_cp
000E31  2               
000E31  2               ;z80_ep	 = ws+$10
000E31  2               ;z80_dp	 = ws+$11
000E31  2               ;z80_dep = z80_ep
000E31  2               
000E31  2               ;z80_lp	 = ws+$12
000E31  2               ;z80_hp	 = ws+$13
000E31  2               ;z80_hlp = z80_lp
000E31  2               
000E31  2               ;z80_sp   = ws+$14
000E31  2               
000E31  2               ;z80_reg0 = ws+$16
000E31  2               ;z80_reg1 = ws+$17
000E31  2               ;z80_reg2 = ws+$18
000E31  2               ;z80_reg3 = ws+$19
000E31  2               
000E31  2               ;z80_r	 = ws+$1a
000E31  2               
000E31  2               ; Contains seperatly 1 bit set
000E31  2               ; _BEEB this is not safe memory to use as required by MOS
000E31  2               
000E31  2               _bitmem0	= $f8
000E31  2               _bitmem1	= $f9
000E31  2               _bitmem2	= $fa
000E31  2               _bitmem3	= $fb
000E31  2               _bitmem4	= $fc
000E31  2               _bitmem5	= $fd
000E31  2               _bitmem6	= $fe
000E31  2               _bitmem7	= $ff
000E31  2               
000E31  2               ; constants
000E31  2               _bitvalue0	= $01
000E31  2               _bitvalue1	= $02
000E31  2               _bitvalue2	= $04
000E31  2               _bitvalue3	= $08
000E31  2               _bitvalue4	= $10
000E31  2               _bitvalue5	= $20
000E31  2               _bitvalue6	= $40
000E31  2               _bitvalue7	= $80
000E31  2               
000E31  2               _notbitvalue0	= $fe
000E31  2               _notbitvalue1	= $fd
000E31  2               _notbitvalue2	= $fb
000E31  2               _notbitvalue3	= $f7
000E31  2               _notbitvalue4	= $ef
000E31  2               _notbitvalue5	= $df
000E31  2               _notbitvalue6	= $bf
000E31  2               _notbitvalue7	= $7f
000E31  2               
000E31  2               
000E31  2               ;add_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_de:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_de:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_bc:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_bc:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		cmp z80_c
000E31  2               ;		bne cmp_hl_bc_end
000E31  2               ;		lda z80_h
000E31  2               ;		cmp z80_b
000E31  2               ;cmp_hl_bc_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_iy_ix:
000E31  2               ;		lda z80_iy
000E31  2               ;		cmp z80_ix
000E31  2               ;		bne cmp_iy_ix_end
000E31  2               ;		lda z80_iy+1
000E31  2               ;		cmp z80_ix+1
000E31  2               ;cmp_iy_ix_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_hl:
000E31  2               ;		lda z80_l
000E31  2               ;		bne dec_hl_no_dec_h
000E31  2               ;		dec z80_h
000E31  2               ;dec_hl_no_dec_h:
000E31  2               ;		dec z80_l
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_ix:
000E31  2               ;		lda z80_ix
000E31  2               ;		bne dec_ix_no_dec_h
000E31  2               ;		dec z80_ix+1
000E31  2               ;dec_ix_no_dec_h:
000E31  2               ;		dec z80_ix
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_bc:
000E31  2               ;		lda z80_c
000E31  2               ;		bne dec_bc_no_dec_b
000E31  2               ;		dec z80_b
000E31  2               ;dec_bc_no_dec_b:
000E31  2               ;		dec z80_c
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_de:
000E31  2               ;		lda z80_e
000E31  2               ;		bne dec_de_no_dec_d
000E31  2               ;		dec z80_d
000E31  2               ;dec_de_no_dec_d:
000E31  2               ;		dec z80_e
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;ex_af_afs:
000E31  2               ;	rts
000E31  2               ;ex_de_hl:
000E31  2               ;		lda z80_e
000E31  2               ;		ldx z80_l
000E31  2               ;		stx z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_d
000E31  2               ;		ldx z80_h
000E31  2               ;		stx z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               exx:
000E31  2  A5 rr        		lda z80_c
000E33  2  A4 rr        		ldy z80_cp
000E35  2  84 rr        		sty z80_c
000E37  2  85 rr        		sta z80_cp
000E39  2  A5 rr        		lda z80_b
000E3B  2  A4 rr        		ldy z80_bp
000E3D  2  84 rr        		sty z80_b
000E3F  2  85 rr        		sta z80_bp
000E41  2  A5 rr        		lda z80_e
000E43  2  A4 rr        		ldy z80_ep
000E45  2  84 rr        		sty z80_e
000E47  2  85 rr        		sta z80_ep
000E49  2  A5 rr        		lda z80_d
000E4B  2  A4 rr        		ldy z80_dp
000E4D  2  84 rr        		sty z80_d
000E4F  2  85 rr        		sta z80_dp
000E51  2  A5 rr        		lda scraddr
000E53  2  A4 rr        		ldy z80_lp
000E55  2  84 rr        		sty scraddr
000E57  2  85 rr        		sta z80_lp
000E59  2  A5 rr        		lda scraddr+1
000E5B  2  A4 rr        		ldy z80_hp
000E5D  2  84 rr        		sty scraddr+1
000E5F  2  85 rr        		sta z80_hp
000E61  2  60           		rts
000E62  2               
000E62  2               ;ex_sp_hl:
000E62  2               ;		tsx
000E62  2               ;		lda $0103,x
000E62  2               ;		ldy z80_h
000E62  2               ;		sta z80_h
000E62  2               ;		tya
000E62  2               ;		sta $0103,x
000E62  2               ;		lda $0104,x
000E62  2               ;		ldy z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		tya
000E62  2               ;		sta $104,x
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;ldi:
000E62  2               ;	rts
000E62  2               ;ldir:
000E62  2               ;		ldy #$00
000E62  2               ;		ldx z80_b
000E62  2               ;		beq ldir_last_page
000E62  2               ;ldir_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		bne ldir_loop
000E62  2               ;		inc z80_h
000E62  2               ;		inc z80_d
000E62  2               ;		dex
000E62  2               ;		bne ldir_loop
000E62  2               ;ldir_last_page:
000E62  2               ;		lda z80_c
000E62  2               ;		beq ldir_end
000E62  2               ;ldir_last_page_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		cpy z80_c
000E62  2               ;		bne ldir_last_page_loop
000E62  2               ;ldir_end:
000E62  2               ;		stx z80_c
000E62  2               ;		stx z80_b
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_h
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_e
000E62  2               ;		sta z80_e
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_d
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;lddr:		ldy #$00
000E62  2               ;lddr_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		jsr dec_hl
000E62  2               ;		jsr dec_de
000E62  2               ;		jsr dec_bc
000E62  2               ;		lda z80_b
000E62  2               ;		ora z80_c
000E62  2               ;		bne lddr_loop
000E62  2               ;		rts
000E62  2               ;ei:
000E62  2               ;		rts
000E62  2               ;di:
000E62  2               ;		rts
000E62  2               
000E62  2               ;-------------------------------------------------------------
000E62  2               ; Set bits in bitmem
000E62  2               ;-------------------------------------------------------------
000E62  2               
000E62  2               .if 0
000E62  2               z80_init:
000E62  2               	ldx #$00
000E62  2               	lda #$01
000E62  2               z80_init_loop:
000E62  2               	sta _bitmem0,x
000E62  2               	inx
000E62  2               	asl a
000E62  2               	bne z80_init_loop
000E62  2               	rts
000E62  2               .endif
000E62  2               
000E62  2               push_af:
000E62  2               push_bc:
000E62  2               push_de:
000E62  2               push_hl:
000E62  2               
000E62  2               pop_af:
000E62  2               pop_bc:
000E62  2               pop_de:
000E62  2               pop_ix:
000E62  2               pop_hl:
000E62  2               
000E62  2               add_hl_hl:
000E62  2               
000E62  2               inc_bc:
000E62  2               inc_de:
000E62  2               inc_hl:
000E62  2               inc_ix:
000E62  2               inc_sp:
000E62  2               
000E62  2               cpir:
000E62  2               
000E62  2               ex_af_af:
000E62  2               ;	rts
000E62  2               
000E62  1               	.include "bbc.inc"
000E62  2               ;----------------------------------------------------------------------
000E62  2               ; BBC Platform Specific functions
000E62  2               ;----------------------------------------------------------------------
000E62  2               
000E62  2               ;--------------------------------------------------------
000E62  2               ; Keys
000E62  2               ;
000E62  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000E62  2               ;             ||||||||
000E62  2               ;             |||||||+> Right    KEY 0  - X
000E62  2               ;             ||||||+-> Left     KEY 1  - Z
000E62  2               ;             |||||+--> Down     KEY 2  - .
000E62  2               ;             ||||+---> Up       KEY 3  - ;
000E62  2               ;             |||+----> Fire1    KEY 4  - SPC
000E62  2               ;             ||+-----> Fire2    KEY 5  - Q
000E62  2               ;             |+------> Fire3    KEY 6  - P
000E62  2               ;             +-------> Not used
000E62  2               ;
000E62  2               ;                       Option1  KEY 7  - 1
000E62  2               ;                       Option2  KEY 8  - 2
000E62  2               ;                       Option3  KEY 9  - 3
000E62  2               ;                       Option4  KEY 10 - 4
000E62  2               ;--------------------------------------------------------
000E62  2               
000E62  2               ;              X   Z   .   ;  SPC  Q   P
000E62  2               ;keys:   .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E62  2               ;        .byte $30,$31,$11,$12                   ; menu options.
000E62  2               
000E62  2  42 61 68 48  jkeys:  .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E66  2  62 10 37     
000E69  2  30 31 11 12          .byte $30,$31,$11,$12                   ; menu options.
000E6D  2               
000E6D  2               ;----------------------------------------------------
000E6D  2               ; Wait for keypress.
000E6D  2               ;----------------------------------------------------
000E6D  2               
000E6D  2               prskey:
000E6D  2  8A           	txa
000E6E  2  48           	pha
000E6F  2               prsloop:
000E6F  2  20 0E 0F     	jsr vsync
000E72  2               
000E72  2  A9 79        	lda #$79
000E74  2  A2 01        	ldx #$01
000E76  2  20 F4 FF     	jsr OSBYTE
000E79  2               
000E79  2  E0 FF        	cpx #$ff
000E7B  2  F0 F2        	beq prsloop		; wait until key pressed
000E7D  2  68           	pla
000E7E  2  AA           	tax
000E7F  2  60           	rts
000E80  2               
000E80  2               bbcinit:
000E80  2  78           	sei
000E81  2  AD 20 02     	lda EVENTV
000E84  2  8D B4 0E     	sta old_eventv
000E87  2  AD 21 02     	lda EVENTV+1
000E8A  2  8D B5 0E     	sta old_eventv+1
000E8D  2               
000E8D  2  A9 B6        	lda #<event_handler
000E8F  2  8D 20 02     	sta EVENTV
000E92  2  A9 0E        	lda #>event_handler
000E94  2  8D 21 02     	sta EVENTV+1
000E97  2  58           	cli
000E98  2               
000E98  2               	; Enable VSYNC event.
000E98  2  A9 0E        	lda #14
000E9A  2  A2 04        	ldx #4
000E9C  2  4C F4 FF     	jmp OSBYTE
000E9F  2               
000E9F  2               bbckill:
000E9F  2  78           	sei
000EA0  2  AD B4 0E     	lda old_eventv
000EA3  2  8D 20 02     	sta EVENTV
000EA6  2  AD B5 0E     	lda old_eventv+1
000EA9  2  8D 21 02     	sta EVENTV+1
000EAC  2  58           	cli
000EAD  2               
000EAD  2               	; Disable VSYNC event.
000EAD  2  A9 0D        	lda #13
000EAF  2  A2 04        	ldx #4
000EB1  2  4C F4 FF     	jmp OSBYTE
000EB4  2               
000EB4  2               
000EB4  2               old_eventv:
000EB4  2  xx xx        	.res 2
000EB6  2               
000EB6  2               event_handler:
000EB6  2  08           	php
000EB7  2  C9 04        	cmp #4
000EB9  2  D0 02        	bne not_vsync
000EBB  2               
000EBB  2  E6 rr        	inc vsync_count
000EBD  2               
000EBD  2               not_vsync:
000EBD  2  28           	plp
000EBE  2  6C B4 0E     	jmp (old_eventv)
000EC1  2               
000EC1  2               bbcsync:
000EC1  2  A5 rr        	lda vsync_count
000EC3  2  C9 02        	cmp #2
000EC5  2  90 FA        	bcc bbcsync
000EC7  2  A9 00        	lda #0
000EC9  2  85 rr        	sta vsync_count
000ECB  2  60           	rts
000ECC  2               
000ECC  2               ;--------------------------------------------------------
000ECC  2               ; Keyboard test routine.
000ECC  2               ;
000ECC  2               ; Input:
000ECC  2               ;  A = key to read, high nibble=row and low nibble=col
000ECC  2               ;
000ECC  2               ; Output:
000ECC  2               ;  carry clr = key pressed
000ECC  2               ;  carry set = key not pressed
000ECC  2               ;--------------------------------------------------------
000ECC  2               
000ECC  2               ktest:
000ECC  2  85 rr        	sta z80_a		; save key
000ECE  2  98           	tya
000ECF  2  48           	pha
000ED0  2               
000ED0  2               ; _BEEB keyboard read
000ED0  2  A5 rr        	lda z80_a
000ED2  2  49 80        	eor #$80		; _BEEB just look for this key
000ED4  2  AA           	tax
000ED5  2               
000ED5  2  A9 79        	lda #$79
000ED7  2  20 F4 FF     	jsr OSBYTE
000EDA  2               
000EDA  2  8A           	txa
000EDB  2  30 04        	bmi pressed 	; _BEEB X is negative if key is pressed
000EDD  2               
000EDD  2  38           	sec			; key not pressed
000EDE  2  68           	pla
000EDF  2  A8           	tay
000EE0  2  60           	rts
000EE1  2               
000EE1  2               pressed:
000EE1  2  18           	clc			; key pressed
000EE2  2  68           	pla
000EE3  2  A8           	tay
000EE4  2  60           	rts
000EE5  2               
000EE5  2               ;---------------------------------------------------------------
000EE5  2               ; Getkey in column,row format
000EE5  2               ;
000EE5  2               ; Output:
000EE5  2               ;  A = high nibble=row and low nibble=column key in matrix
000EE5  2               ;---------------------------------------------------------------
000EE5  2               
000EE5  2               kget:
000EE5  2  86 rr        	stx xtmp
000EE7  2               
000EE7  2               kget1:
000EE7  2  A9 79        	lda #$79			; _BEEB read keyboard with OSBYTE &79
000EE9  2  A2 01        	ldx #$01
000EEB  2  20 F4 FF     	jsr OSBYTE
000EEE  2               
000EEE  2  E0 FF        	cpx #$ff
000EF0  2  F0 F5        	beq kget1
000EF2  2               
000EF2  2  8A           	txa
000EF3  2               
000EF3  2  A6 rr        	ldx xtmp
000EF5  2  60           	rts
000EF6  2               
000EF6  2               ;----------------------------------------------------
000EF6  2               ; AtoMMC joystick controls.
000EF6  2               ; _BEEB TODO
000EF6  2               ;----------------------------------------------------
000EF6  2               
000EF6  2               joyinit:
000EF6  2               joysin:
000EF6  2  60           	rts
000EF7  2               
000EF7  2               
000EF7  2               ;----------------------------------------------------
000EF7  2               ; Delay routine 1/50 sec
000EF7  2               ;
000EF7  2               ; Wait 1/60 sec = 16666 usec
000EF7  2               ; Wait 208 x 16 =  3328 usec
000EF7  2               ;                 19994 usec
000EF7  2               ; rts           =     6 usec
000EF7  2               ; Total         = 20000 usec
000EF7  2               ;----------------------------------------------------
000EF7  2               
000EF7  2               delay:
000EF7  2  85 rr        	sta xtmp
000EF9  2               del_loop:
000EF9  2  A9 13        	lda #19
000EFB  2  20 F4 FF     	jsr OSBYTE		; wait for vsync _BEEB
000EFE  2               
000EFE  2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
000F00  2               delay1:
000F00  2  61 80        	adc ($80,x)		;	 6 usec
000F02  2  61 80        	adc ($80,x)		;	 6 usec
000F04  2  88           	dey			;	 2 usec
000F05  2  D0 F9        	bne delay1		;	 2 usec
000F07  2  EA           	nop			; 2 usec
000F08  2  EA           	nop			; 2 usec
000F09  2               				; tot: 20000 usec
000F09  2  C6 rr        	dec xtmp
000F0B  2  D0 EC        	bne del_loop
000F0D  2  60           	rts
000F0E  2               
000F0E  2               ;-------------------------------------------------------------
000F0E  2               ; Screen synchronisation.
000F0E  2               ;
000F0E  2               ;  - read joystick/keyboard
000F0E  2               ;  - handle sound
000F0E  2               ;  - sync framerate with clock
000F0E  2               ;  - handle shrapnel every even frame
000F0E  2               ;-------------------------------------------------------------
000F0E  2               
000F0E  2               vsync:
000F0E  2  48           	pha
000F0F  2  98           	tya
000F10  2  48           	pha
000F11  2  8A           	txa
000F12  2  48           	pha
000F13  2  20 25 1B     	jsr joykey		; read joystick/keyboard.
000F16  2               vsync1:
000F16  2               ; Don't sync to vsync here - we can sync to every other vsync in main loop
000F16  2               ;	lda #19
000F16  2               ;	jsr OSBYTE		; _BEEB vsync
000F16  2               
000F16  2  A5 rr        	lda clock
000F18  2  29 01        	and #1
000F1A  2  D0 03        	bne:+
000F1C  2  20 E4 11     	jsr proshr		; handle shrapnel every even frame
000F1F  2               :
000F1F  2  AD 2A 0F     	lda sndtyp
000F22  2  F0 00        	beq sndskip
000F24  2               
000F24  2               ; _BEEB TODO SOUND
000F24  2               ;sndloop:
000F24  2               ;	lda SpeakerBit		; handle sound
000F24  2               ;	ldy sndtyp
000F24  2               ;sndwait:
000F24  2               ;	dey
000F24  2               ;	bne sndwait
000F24  2               ;	eor #4
000F24  2               ;	sta SpeakerBit
000F24  2               ;	dec sndtyp
000F24  2               ;	bne sndloop
000F24  2               
000F24  2               sndskip:
000F24  2  68           	pla
000F25  2  AA           	tax
000F26  2  68           	pla
000F27  2  A8           	tay
000F28  2  68           	pla
000F29  2  60           	rts
000F2A  2               
000F2A  2  00           sndtyp:	.byte 0
000F2B  2               
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               ; BBC video hardware fns
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               
000F2B  2               screeninit:
000F2B  2  A2 0D        	ldx #13
000F2D  2               crtcloop:
000F2D  2  8E 00 FE     	stx $FE00
000F30  2  BD 4D 0F     	lda crtc_regs_high,x
000F33  2  8D 01 FE     	sta $FE01
000F36  2  CA           	dex
000F37  2  10 F4        	bpl crtcloop
000F39  2               
000F39  2                   ; Set ULA
000F39  2  A9 88            lda #$88            ; MODE 4
000F3B  2  8D 48 02         sta $248            ; Tell the OS or it will mess with ULA settings at vsync
000F3E  2  8D 20 FE         sta $FE20
000F41  2               
000F41  2               ; fall through to palette
000F41  2               
000F41  2               setpal:
000F41  2  A2 0F        	ldx #15
000F43  2               palloop:
000F43  2  BD 5B 0F     	lda ula_pal,x
000F46  2  8D 21 FE     	sta $fe21
000F49  2  CA           	dex
000F4A  2  10 F7        	bpl palloop
000F4C  2  60           	rts
000F4D  2               
000F4D  2               crtc_regs_high:
000F4D  2  3F           	.byte 63				; R0  horizontal total
000F4E  2  20           	.byte 32				; R1  horizontal displayed
000F4F  2  31           	.byte 49				; R2  horizontal position
000F50  2  24           	.byte $24				; R3  sync width 40 = &28
000F51  2  26           	.byte 38				; R4  vertical total
000F52  2  00           	.byte 0					; R5  vertical total adjust
000F53  2  18           	.byte 24				; R6  vertical displayed
000F54  2  23           	.byte 35				; R7  vertical position; 35=top of screen
000F55  2  00           	.byte $00				; R8  interlace
000F56  2  07           	.byte 7					; R9  scanlines per row
000F57  2  20           	.byte 32				; R10 cursor start
000F58  2  08           	.byte 8					; R11 cursor end
000F59  2  0D           	.byte >(ScreenAddr/8)	; R12 screen start address, high
000F5A  2  00           	.byte <(ScreenAddr/8)	; R13 screen start address, low
000F5B  2               
000F5B  2               ula_pal:
000F5B  2  07           	.byte $00 + PAL_black
000F5C  2  17           	.byte $10 + PAL_black
000F5D  2  27           	.byte $20 + PAL_black
000F5E  2  37           	.byte $30 + PAL_black
000F5F  2  47           	.byte $40 + PAL_black
000F60  2  57           	.byte $50 + PAL_black
000F61  2  67           	.byte $60 + PAL_black
000F62  2  77           	.byte $70 + PAL_black
000F63  2  80           	.byte $80 + PAL_white
000F64  2  90           	.byte $90 + PAL_white
000F65  2  A0           	.byte $a0 + PAL_white
000F66  2  B0           	.byte $b0 + PAL_white
000F67  2  C0           	.byte $c0 + PAL_white
000F68  2  D0           	.byte $d0 + PAL_white
000F69  2  E0           	.byte $e0 + PAL_white
000F6A  2  F0           	.byte $f0 + PAL_white
000F6B  2               
000F6B  2               ;----------------------------------------------------
000F6B  2               ; Draw sprite
000F6B  2               ;----------------------------------------------------
000F6B  2               
000F6B  2               sprite:
000F6B  2  86 rr        	stx xtmp		; Save X-reg
000F6D  2  20 BD 0F     	jsr scadd 		; get screen address in scraddr.
000F70  2               
000F70  2  A5 rr        	lda dispx 		; x position.
000F72  2  29 07        	and #7 			; position straddling cells.
000F74  2  85 rr        	sta z80_b		; store in b register.
000F76  2               
000F76  2  A5 rr        	lda z80_l		; store sprite graphic address.
000F78  2  8D 89 0F     	sta sprit1+1
000F7B  2  8D 8F 0F     	sta sprit2+1
000F7E  2  A5 rr        	lda z80_h
000F80  2  8D 8A 0F     	sta sprit1+2
000F83  2  8D 90 0F     	sta sprit2+2
000F86  2               
000F86  2  A2 00        	ldx #0			; pixel height.
000F88  2               sprit1:
000F88  2  BD 8F 3A     	lda objdta,x		; fetch first byte.
000F8B  2  85 rr        	sta spr
000F8D  2  E8           	inx
000F8E  2               sprit2:
000F8E  2  BD 8F 3A     	lda objdta,x
000F91  2  85 rr        	sta spr+1
000F93  2               
000F93  2  A9 00        	lda #0
000F95  2  85 rr        	sta spr+2
000F97  2  20 A0 17     	jsr sprit7		; shift sprite
000F9A  2               
000F9A  2  A5 rr        	lda spr			; fetch graphic.
000F9C  2  A0 00        	ldy #0			; _BEEB
000F9E  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA0  2  91 rr        	sta (scraddr),y		; write to screen.
000FA2  2               
000FA2  2  A5 rr        	lda spr+1		; fetch graphic.
000FA4  2  A0 08        	ldy #8			; _BEEB
000FA6  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA8  2  91 rr        	sta (scraddr),y		; write to screen.
000FAA  2               
000FAA  2  A5 rr        	lda spr+2		; fetch graphic.
000FAC  2  A0 10        	ldy #16			; _BEEB
000FAE  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FB0  2  91 rr        	sta (scraddr),y		; write to screen.
000FB2  2               
000FB2  2  20 1F 10     	jsr nline
000FB5  2               
000FB5  2  E8           	inx			; next source byte.
000FB6  2  E0 20        	cpx #32
000FB8  2  D0 CE        	bne sprit1		; repeat
000FBA  2               
000FBA  2  A6 rr        	ldx xtmp		; retreive X-reg
000FBC  2  60           	rts
000FBD  2               
000FBD  2               ;------------------------------------------------------------------
000FBD  2               ; This routine returns a screen address for (dispx, dispy) in scraddr.
000FBD  2               ;------------------------------------------------------------------
000FBD  2               
000FBD  2               scadd:
000FBD  2  A6 rr        	ldx dispy
000FBF  2  A5 rr        	lda dispx
000FC1  2  29 F8        	and #$f8
000FC3  2  18           	clc
000FC4  2  7D 00 06     	adc SCADTB_lb,x
000FC7  2  85 rr        	sta scraddr
000FC9  2  BD 00 07     	lda SCADTB_hb,x
000FCC  2  69 00        	adc #0
000FCE  2  85 rr        	sta scraddr+1
000FD0  2  60           	rts
000FD1  2               
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               ; These are the sprite routines.
000FD1  2               ; sspria = single sprite, old (ix).
000FD1  2               ; ssprib = single sprite, new (ix+5).
000FD1  2               ; sspric = both sprites, old (ix) and new (ix+5).
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               
000FD1  2               sspria:
000FD1  2  20 73 1E     	jsr gsprad		; get old sprite address.
000FD4  2               sspri2:
000FD4  2  A2 10        	ldx #16			; vertical lines.
000FD6  2               sspri0:
000FD6  2  20 F5 0F     	jsr dline		; draw a line.
000FD9  2  CA           	dex
000FDA  2  D0 FA        	bne sspri0		; repeat 16 times
000FDC  2  60           	rts
000FDD  2               
000FDD  2               ;-----------------------------------------------------------------
000FDD  2               
000FDD  2               ssprib:
000FDD  2  20 54 1E     	jsr gspran 		; get new sprite address.
000FE0  2  4C D4 0F     	jmp sspri2
000FE3  2               
000FE3  2               ;-----------------------------------------------------------------
000FE3  2               
000FE3  2               sspric:
000FE3  2  20 73 1E     	jsr gsprad 		; get old sprite address.
000FE6  2  20 31 0E     	jsr exx  		; store addresses.
000FE9  2  20 54 1E     	jsr gspran 		; get new sprite addresses.
000FEC  2               
000FEC  2  A2 10        	ldx #16
000FEE  2               lloop:
000FEE  2  20 38 10     	jsr ddline 		; draw a line.
000FF1  2  CA           	dex
000FF2  2  D0 FA        	bne lloop
000FF4  2  60           	rts
000FF5  2               
000FF5  2               ;-------------------------------------------------------------
000FF5  2               ; Drop through.
000FF5  2               ; Line drawn, now work out next target address.
000FF5  2               ;
000FF5  2               ; Input:
000FF5  2               ;  B  = right mask
000FF5  2               ;  C  = left mask
000FF5  2               ;  DE = spriteaddress
000FF5  2               ;  scraddr = screen address
000FF5  2               ;-------------------------------------------------------------
000FF5  2               
000FF5  2               dline:
000FF5  2  A0 00        	ldy #0
000FF7  2  B1 rr        	lda (z80_de),y 		; graphic data.
000FF9  2  25 rr        	and z80_c 			; mask away what's not needed.
000FFB  2               
000FFB  2               ; _BEEB screen arrangement
000FFB  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
000FFD  2  91 rr        	sta (scraddr),y 	; bung it in.
000FFF  2               
000FFF  2  B1 rr        	lda (z80_de),y 		; fetch data.
001001  2  25 rr        	and z80_b 			; mask away unwanted
001003  2               
001003  2               ; _BEEB screen arrangement
001003  2  A0 10        	ldy #16
001005  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001007  2  91 rr        	sta (scraddr),y 	; bung it in.
001009  2               
001009  2  E6 rr        	inc z80_e			; next graphic.
00100B  2  D0 02        	bne :+
00100D  2  E6 rr        	inc z80_d
00100F  2               :
00100F  2  A0 00        	ldy #0
001011  2  B1 rr        	lda (z80_de),y 		; second bit of data.
001013  2               
001013  2               ; _BEEB screen arrangement
001013  2  A0 08        	ldy #8
001015  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001017  2  91 rr        	sta (scraddr),y 	; bung it in.
001019  2               
001019  2  E6 rr        	inc z80_e			; next graphic.
00101B  2  D0 02        	bne :+
00101D  2  E6 rr        	inc z80_d
00101F  2               :
00101F  2               
00101F  2               ;----------------------------------------------------------------------
00101F  2               ; Line drawn, now work out next target address.
00101F  2               ;----------------------------------------------------------------------
00101F  2               
00101F  2               ; _BEEB screen arrangement
00101F  2               
00101F  2               nline:
00101F  2  A5 rr        	lda scraddr 		; get low byte of address.
001021  2  29 07        	and #7
001023  2  C9 07        	cmp #7				; is this last line of row?
001025  2  F0 03        	beq beeb_next_row
001027  2               
001027  2               	; within same row
001027  2  E6 rr        	inc scraddr			; new low byte of address.
001029  2               ;	bne :+
001029  2               ;	inc scraddr+1		; new high byte of address.
001029  2               :
001029  2  60           	rts
00102A  2               
00102A  2               beeb_next_row:
00102A  2  18           	clc
00102B  2  A5 rr        	lda scraddr
00102D  2  69 F9        	adc #<(ScreenRowBytes-7)
00102F  2  85 rr        	sta scraddr			; new low byte of address.
001031  2  A5 rr        	lda scraddr+1
001033  2  69 00        	adc #>(ScreenRowBytes-7)
001035  2  85 rr        	sta scraddr+1		; new high byte of address.
001037  2  60           	rts
001038  2               
001038  2               ;-------------------------------------------------------------
001038  2               ; Drop through.
001038  2               ; Line drawn, now work out next target address.
001038  2               ;
001038  2               ; Input:
001038  2               ;  B  = right mask
001038  2               ;  C  = left mask
001038  2               ;  DE = spriteaddress
001038  2               ;  scraddr = screen address
001038  2               ;-------------------------------------------------------------
001038  2               
001038  2               ddline:
001038  2               
001038  2               ; NEW SPRITE
001038  2               
001038  2  A0 00        	ldy #0
00103A  2  B1 rr        	lda (z80_de),y 		; graphic data.
00103C  2  25 rr        	and z80_c 			; mask away what's not needed.
00103E  2               
00103E  2               ; _BEEB screen arrangement
00103E  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001040  2  91 rr        	sta (scraddr),y 	; bung it in.
001042  2               
001042  2  B1 rr        	lda (z80_de),y 		; fetch data.
001044  2  25 rr        	and z80_b 			; mask away unwanted
001046  2               
001046  2               ; _BEEB screen arrangement
001046  2  A0 10        	ldy #16
001048  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00104A  2  91 rr        	sta (scraddr),y 	; bung it in.
00104C  2               
00104C  2  E6 rr        	inc z80_e			; next graphic.
00104E  2  D0 02        	bne :+
001050  2  E6 rr        	inc z80_d
001052  2               :
001052  2  A0 00        	ldy #0
001054  2  B1 rr        	lda (z80_de),y 		; second bit of data.
001056  2               
001056  2               ; _BEEB screen arrangement
001056  2  A0 08        	ldy #8
001058  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00105A  2  91 rr        	sta (scraddr),y 	; bung it in.
00105C  2               
00105C  2  E6 rr        	inc z80_e			; next graphic.
00105E  2  D0 02        	bne :+
001060  2  E6 rr        	inc z80_d
001062  2               :
001062  2               
001062  2               ; _BEEB next row
001062  2               
001062  2  A5 rr        	lda scraddr 		; get low byte of address.
001064  2  29 07        	and #7
001066  2  C9 07        	cmp #7				; is this last line of row?
001068  2  F0 05        	beq :+
00106A  2               
00106A  2               	; within same row can't increment page
00106A  2  E6 rr        	inc scraddr			; new low byte of address.
00106C  2  4C 7C 10     	jmp ddline2
00106F  2               
00106F  2               :
00106F  2  18           	clc
001070  2  A5 rr        	lda scraddr
001072  2  69 F9        	adc #<(ScreenRowBytes-7)
001074  2  85 rr        	sta scraddr			; new low byte of address.
001076  2  A5 rr        	lda scraddr+1
001078  2  69 00        	adc #>(ScreenRowBytes-7)
00107A  2  85 rr        	sta scraddr+1		; new high byte of address.
00107C  2               
00107C  2               ; OLD SPRITE
00107C  2               
00107C  2               ddline2:
00107C  2               
00107C  2  A0 00        	ldy #0
00107E  2  B1 rr        	lda (z80_dep),y 		; graphic data.
001080  2  25 rr        	and z80_cp 			; mask away what's not needed.
001082  2               
001082  2               ; _BEEB screen arrangement
001082  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
001084  2  91 rr        	sta (z80_hlp),y 	; bung it in.
001086  2               
001086  2  B1 rr        	lda (z80_dep),y 		; fetch data.
001088  2  25 rr        	and z80_bp 			; mask awayh unwanted
00108A  2               
00108A  2               ; _BEEB screen arrangement
00108A  2  A0 10        	ldy #16
00108C  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
00108E  2  91 rr        	sta (z80_hlp),y 	; bung it in.
001090  2               
001090  2  E6 rr        	inc z80_ep			; next graphic.
001092  2  D0 02        	bne :+
001094  2  E6 rr        	inc z80_dp
001096  2               :
001096  2  A0 00        	ldy #0
001098  2  B1 rr        	lda (z80_dep),y 		; second bit of data.
00109A  2               
00109A  2               ; _BEEB screen arrangement
00109A  2  A0 08        	ldy #8
00109C  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
00109E  2  91 rr        	sta (z80_hlp),y 	; bung it in.
0010A0  2               
0010A0  2  E6 rr        	inc z80_ep			; next graphic.
0010A2  2  D0 02        	bne :+
0010A4  2  E6 rr        	inc z80_dp
0010A6  2               :
0010A6  2               
0010A6  2               ; _BEEB screen arrangement
0010A6  2               
0010A6  2  A5 rr        	lda z80_lp 		; get low byte of address.
0010A8  2  29 07        	and #7
0010AA  2  C9 07        	cmp #7				; is this last line of row?
0010AC  2  F0 03        	beq :+
0010AE  2               
0010AE  2               	; within same row can't increment page
0010AE  2  E6 rr        	inc z80_lp			; new low byte of address.
0010B0  2  60           	rts
0010B1  2               
0010B1  2               :
0010B1  2  18           	clc
0010B2  2  A5 rr        	lda z80_lp
0010B4  2  69 F9        	adc #<(ScreenRowBytes-7)
0010B6  2  85 rr        	sta z80_lp			; new low byte of address.
0010B8  2  A5 rr        	lda z80_lp+1
0010BA  2  69 00        	adc #>(ScreenRowBytes-7)
0010BC  2  85 rr        	sta z80_lp+1		; new high byte of address.
0010BE  2  60           	rts
0010BF  2               
0010BF  2               ;----------------------------------------------------
0010BF  2               ; Display character in A at dispx,dispy.
0010BF  2               ;
0010BF  2               ; Input:
0010BF  2               ;  A 	   = character to print
0010BF  2               ;----------------------------------------------------
0010BF  2               
0010BF  2               pchar:
0010BF  2  85 rr        	sta fntaddr
0010C1  2  A9 00        	lda #0
0010C3  2  85 rr        	sta fntaddr+1
0010C5  2  06 rr        	asl fntaddr  		; multiply char by 8.
0010C7  2  26 rr        	rol fntaddr+1
0010C9  2  06 rr        	asl fntaddr
0010CB  2  26 rr        	rol fntaddr+1
0010CD  2  06 rr        	asl fntaddr
0010CF  2  26 rr        	rol fntaddr+1
0010D1  2               
0010D1  2  A5 rr        	lda fntaddr
0010D3  2  18           	clc
0010D4  2  65 rr        	adc FontPtr
0010D6  2  85 rr        	sta fntaddr		; that's the low byte.
0010D8  2  A5 rr        	lda fntaddr+1
0010DA  2  65 rr        	adc FontPtr+1
0010DC  2  85 rr        	sta fntaddr+1		; add displacement.
0010DE  2               pchark:
0010DE  2  20 F3 16     	jsr gprad		; get screen address.
0010E1  2  A0 00        	ldy #0
0010E3  2               
0010E3  2               pchar0:
0010E3  2  B1 rr        	lda (fntaddr),y 	; get image byte.
0010E5  2  49 FF        	eor #TxtInvert		; Invert
0010E7  2  91 rr        	sta (scraddr),y 	; copy to screen.
0010E9  2  C8           	iny					; next screen row down.
0010EA  2  C0 08        	cpy #8				; number lines
0010EC  2  90 F5        	bcc pchar0			; repeat.
0010EE  2  60           	rts
0010EF  2               
0010EF  2               
0010EF  1               
0010EF  1               ;----------------------------------------------------------------------
0010EF  1               ; AGD 6502 ENGINE CODE + COMPILED GAME SCRIPT
0010EF  1               ;----------------------------------------------------------------------
0010EF  1               
0010EF  1               start_game:
0010EF  1               
0010EF  1               	.include "game.inc"
0010EF  2               .include "doodlebug.inc"
0010EF  3               ; Game engine code --------------------------------------------------------------
0010EF  3               
0010EF  3               ; Arcade Game Designer.
0010EF  3               ; (C) 2008 Jonathan Cauldwell.
0010EF  3               ; ZX Spectrum Next Engine v0.1.
0010EF  3               
0010EF  3               ; Global definitions ------------------------------------------------------------
0010EF  3               
0010EF  3               	FONT = font			; Font address
0010EF  3               
0010EF  3               ; Block characteristics.
0010EF  3               
0010EF  3               	PLATFM = 1			; platform.
0010EF  3               	WALL = PLATFM + 1	; solid wall.
0010EF  3               	LADDER = WALL + 1	; ladder.
0010EF  3               	FODDER = LADDER + 1	; fodder block.
0010EF  3               	DEADLY = FODDER + 1	; deadly block.
0010EF  3               	CUSTOM = DEADLY + 1	; custom block.
0010EF  3               	WATER  = CUSTOM + 1	; water block.
0010EF  3                   COLECT = WATER + 1      ; collectable block.
0010EF  3                   NUMTYP = COLECT + 1     ; number of types.
0010EF  3               
0010EF  3               ; Sprites.
0010EF  3               
0010EF  3               	NUMSPR = 12			; number of sprites.
0010EF  3               	TABSIZ = 17			; size of each entry.
0010EF  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
0010EF  3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
0010EF  3               
0010EF  3               ; Sprite table variable offsets.
0010EF  3               
0010EF  3               	var_Type = 0		; sprite type
0010EF  3               	var_Image = 1		; sprite time number
0010EF  3               	var_Frame = 2		; sprite frame
0010EF  3               	var_Y = 3			; sprite y coordinate
0010EF  3               	var_X = 4			; sprite X coordinate
0010EF  3               
0010EF  3               	var_newType = 5		; sprite new type
0010EF  3               	var_newImage = 6	; sprite new image number
0010EF  3               	var_newFrame = 7	; sprite new frame
0010EF  3               	var_newY = 8		; sprite new y coordinate
0010EF  3               	var_newX = 9		; sprite new x coordinate
0010EF  3               
0010EF  3               	var_Direction = 10	; sprite direction
0010EF  3               	var_Param1 = 11		; sprite parameter 1
0010EF  3               	var_Param2 = 12		; sprite parameter 2
0010EF  3               
0010EF  3               	var_jumpLo = 13		; sprite jump ptr low
0010EF  3               	var_jumpHi = 14		; sprite jump ptr high
0010EF  3               	var_dataLo = 15		; sprite data ptr low
0010EF  3               	var_dataHi = 16		; sprite data ptr high
0010EF  3               
0010EF  3               ; Particle engine.
0010EF  3               
0010EF  3               	NUMSHR = 55			; pieces of shrapnel.
0010EF  3               	SHRSIZ = 6			; bytes per particle.
0010EF  3               
0010EF  3               ; Conditional compilation flags
0010EF  3               ; Flags are set in commandline assembly
0010EF  3               
0010EF  3               ;	mflag = 0 		; MENU + INV
0010EF  3               ;	pflag = 0		; Particle engine
0010EF  3               ;	sflag = 0		; scrollytext
0010EF  3               ;	fflag = 1		; Fontflag
0010EF  3               
0010EF  3               .if iflag
0010EF  3               	TxtInvert   = $ff	; Invert byte for character printing
0010EF  3               	ScrFillByte = $ff	; Screen fill byte for CLS
0010EF  3               .else
0010EF  3               	TxtInvert   = $00	; Invert byte for character printing
0010EF  3               	ScrFillByte = $00	; Screen fill byte for CLS
0010EF  3               .endif
0010EF  3               
0010EF  3               	ASCII_NEWLINE = 13
0010EF  3               
0010EF  3               ;===============================================================
0010EF  3               ; Game starts here
0010EF  3               ;===============================================================
0010EF  3               
0010EF  3               ;--------------------------------------------------------------
0010EF  3               ; If a font is required...
0010EF  3               ;--------------------------------------------------------------
0010EF  3               
0010EF  3  A9 B5        	lda #<(FONT-256)	; address of font.
0010F1  3  85 rr        	sta FontPtr
0010F3  3  A9 39        	lda #>(FONT-256)
0010F5  3  85 rr        	sta FontPtr+1
0010F7  3               
0010F7  3  20 E5 11     	jsr game	 		; start the game.
0010FA  3  60           	rts
0010FB  3               
0010FB  3               ; Don't change the order of these four.
0010FB  3               ; Menu routine relies on winlft following wintop.
0010FB  3               
0010FB  3  00           wintop:	.byte WINDOWTOP		; top of window.
0010FC  3  00           winlft:	.byte WINDOWLFT		; left edge.
0010FD  3  17           winhgt:	.byte WINDOWHGT		; window height.
0010FE  3  20           winwid:	.byte WINDOWWID		; window width.
0010FF  3  01           numob:	.byte NUMOBJ		; number of objects in game.
001100  3               
001100  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
001100  3               
001100  3  00           wntopx:	.byte (8 * WINDOWTOP)
001101  3  00           wnlftx:	.byte (8 * WINDOWLFT)
001102  3  A8           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
001103  3  EE           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
001104  3               
001104  3               ; Make sure pointers are arranged in the same order as the data itself.
001104  3               
001104  3  B2 31        frmptr:	.word frmlst         ; sprite frames.
001106  3               
001106  3               ; Assorted game routines which can go in contended memory.
001106  3               
001106  3               ;--------------------------------------------------------------
001106  3               ; Modify for inventory.
001106  3               ; called by the INV command
001106  3               ;
001106  3               ; Input:
001106  3               ;  X   = message nr with objects seperated with ,
001106  3               ;
001106  3               ; Output:
001106  3               ;  OPT = selected line nr of INV menu
001106  3               ;--------------------------------------------------------------
001106  3               
001106  3               .if mflag
001106  3               minve:
001106  3               	lda #<(invdis)		; routine address.
001106  3               	sta mod0+1		; set up menu routine.
001106  3               	sta mod2+1		; set up count routine.
001106  3               	lda #>(invdis)
001106  3               	sta mod0+2
001106  3               	sta mod2+2
001106  3               	lda #<(fopt)		; find option from available objects.
001106  3               	sta mod1+1		; set up routine.
001106  3               	lda #>(fopt)
001106  3               	sta mod1+1+1
001106  3               	jmp dbox		; do menu routine.
001106  3               
001106  3               ;--------------------------------------------------------------
001106  3               ; Modify for menu.
001106  3               ; called by the MENU command
001106  3               ;
001106  3               ; Input:
001106  3               ;  X   = message nr with menu items seperated with ,
001106  3               ;
001106  3               ; Output:
001106  3               ;  OPT = selected line nr of MENU menu
001106  3               ;--------------------------------------------------------------
001106  3               
001106  3               mmenu:
001106  3               	lda #<(always)		; routine address.
001106  3               	sta mod0+1		; set up routine.
001106  3               	sta mod2+1		; set up count routine.
001106  3               	lda #>(always)
001106  3               	sta mod0+2
001106  3               	sta mod2+2
001106  3               
001106  3               	lda #<(fstd)		; standard option selection.
001106  3               	sta mod1+1		; set up routine.
001106  3               	lda #>(fstd)
001106  3               	sta mod1+2
001106  3               
001106  3               ; Drop through into box routine.
001106  3               
001106  3               ;--------------------------------------------------------------
001106  3               ; Work out size of box for message or menu.
001106  3               ;--------------------------------------------------------------
001106  3               
001106  3               dbox:
001106  3               	lda #<(msgdat)		; pointer to messages.
001106  3               	sta z80_l
001106  3               	lda #>(msgdat)
001106  3               	sta z80_h
001106  3               
001106  3               	jsr getwrd		; get message number.
001106  3               
001106  3               	lda z80_h		; store pointer to message.
001106  3               	sta TmpAddr
001106  3               	lda z80_l
001106  3               	sta TmpAddr+1
001106  3               
001106  3               	lda #1			; height.
001106  3               	sta z80_d
001106  3               	lda #0			; start at object zero.
001106  3               	sta combyt		; store number of object in combyt.
001106  3               	sta z80_e		; maximum width.
001106  3               dbox5:
001106  3               	lda #0			; this line"s width.
001106  3               	sta z80_b
001106  3               mod2:
001106  3               	jsr always		; item in player"s possession?
001106  3               	cmp #255
001106  3               	bne dbox6		; not in inventory, skip this line.
001106  3               	inc z80_d		; add to tally.
001106  3               dbox6:
001106  3               	ldy #0			; get character.
001106  3               	lda (z80_hl),y
001106  3               	sta z80_a
001106  3               	inc z80_l		; next character.
001106  3               	bne :+
001106  3               	inc z80_h
001106  3               :
001106  3               	lda z80_a		; reached end of line?
001106  3               	cmp #','
001106  3               	beq dbox3		; yes.
001106  3               	cmp #ASCII_NEWLINE
001106  3               	beq dbox3		; yes.
001106  3               	inc z80_b		; add to this line"s width.
001106  3               	lda z80_a
001106  3               	bmi dbox4		; end of message? yes, end count.
001106  3               	jmp dbox6		; repeat until we find the end.
001106  3               dbox3:
001106  3               	lda z80_e		; maximum line width.
001106  3               	cmp z80_b		; have we exceeded longest so far?
001106  3               	bpl dbox5		; no, carry on looking.
001106  3               	lda z80_b		; make this the widest so far.
001106  3               	sta z80_e
001106  3               	jmp dbox5		; keep looking.
001106  3               dbox4:
001106  3               	lda z80_e		; maximum line width.
001106  3               	cmp z80_b		; have we exceeded longest so far?
001106  3               	bpl dbox8		; no, carry on looking.
001106  3               	lda z80_b		; final line is the longest so far.
001106  3               	sta z80_e
001106  3               dbox8:
001106  3               	dec z80_d		; decrement items found.
001106  3               	bne :+			; total was zero.
001106  3               	jmp dbox15
001106  3               :
001106  3               	lda z80_e		; longest line.
001106  3               	bne :+			; was it zero?
001106  3               	jmp dbox15		; total was zero.
001106  3               :
001106  3               	sta bwid		; set up size.
001106  3               	lda z80_d
001106  3               	sta blen
001106  3               
001106  3               ;--------------------------------------------------------------
001106  3               ; That's set up our box size.
001106  3               ;--------------------------------------------------------------
001106  3               
001106  3               	lda winhgt		; window height in characters.
001106  3               	sec
001106  3               	sbc z80_d		; subtract height of box.
001106  3               	lsr a			; divide by 2.
001106  3               	clc
001106  3               	adc wintop		; add top edge of window.
001106  3               	sta btop		; set up box top.
001106  3               
001106  3               	lda winwid		; window width in characters.
001106  3               	sec
001106  3               	sbc z80_e		; subtract box width.
001106  3               	lsr a			; divide by 2.
001106  3               	clc
001106  3               	adc winlft		; add left edge of window.
001106  3               	sta blft		; box left.
001106  3               
001106  3               	lda FontPtr		; font.
001106  3               	sta grbase		; set up for text display.
001106  3               	lda FontPtr+1
001106  3               	sta grbase+1
001106  3               
001106  3               	lda TmpAddr+1		; restore message pointer.
001106  3               	sta z80_l
001106  3               	lda TmpAddr
001106  3               	sta z80_h
001106  3               
001106  3               	lda btop		; box top.
001106  3               	sta dispy		; set display coordinate.
001106  3               	lda #0			; start at object zero.
001106  3               	sta combyt		; store number of object in combyt.
001106  3               dbox2:
001106  3               	lda combyt		; get object number.
001106  3               	sta z80_a
001106  3               mod0:
001106  3               	jsr always		; check inventory for display.
001106  3               	cmp #255
001106  3               	beq :+
001106  3               	jmp dbox13		; not in inventory, skip this line.
001106  3               :
001106  3               	lda blft		; box left.
001106  3               	sta dispx		; set left display position.
001106  3               	lda bwid		; box width.
001106  3               	sta z80_b		; store width.
001106  3               dbox0:
001106  3               	ldy #0			; get character.
001106  3               	lda (z80_hl),y
001106  3               	cmp #','		; end of line?
001106  3               	beq dbox1		; yes, next one.
001106  3               	cmp #ASCII_NEWLINE			; end of line?
001106  3               	beq dbox1		; yes, next one.
001106  3               
001106  3               	dec z80_b		; one less to display.
001106  3               	and #127		; remove terminator.
001106  3               
001106  3               	jsr pchr		; display on screen.
001106  3               
001106  3               	ldy #0
001106  3               	lda (z80_hl),y		; get character.
001106  3               	sta z80_a
001106  3               	inc z80_l		; next character.
001106  3               	bne :+
001106  3               	inc z80_h
001106  3               :
001106  3               	lda z80_a
001106  3               	cmp #128		; end of message?
001106  3               	bmi :+
001106  3               	jmp dbox7		; yes, job done.
001106  3               :
001106  3               	lda z80_b		; chars remaining.
001106  3               	beq :+			; are any left?
001106  3               	jmp dbox0		; yes, continue.
001106  3               :
001106  3               ;---------------------------------------------------
001106  3               ; Reached limit of characters per line.
001106  3               ;---------------------------------------------------
001106  3               
001106  3               dbox9:
001106  3               	ldy #0
001106  3               	lda (z80_hl),y		; get character.
001106  3               	inc z80_l		; next one.
001106  3               	bne :+
001106  3               	inc z80_h
001106  3               :
001106  3               	cmp #','		; another line?
001106  3               	beq dbox10		; yes, do next line.
001106  3               	cmp #ASCII_NEWLINE			; another line?
001106  3               	beq dbox10		; yes, do next line.
001106  3               	cmp #128		; end of message?
001106  3               	bcs :+
001106  3               	jmp dbox11		; yes, finish message.
001106  3               :
001106  3               	jmp dbox9
001106  3               
001106  3               ;---------------------------------------------------
001106  3               ; Fill box to end of line.
001106  3               ;---------------------------------------------------
001106  3               
001106  3               dboxf:
001106  3               	lda #32			; space character.
001106  3               	jsr pchr		; display character.
001106  3               	dec z80_b
001106  3               	beq :+
001106  3               	jmp dboxf		; repeat for remaining chars on line.
001106  3               :
001106  3               	rts
001106  3               dbox1:
001106  3               	inc z80_l		; skip character.
001106  3               	bne :+
001106  3               	inc z80_h
001106  3               :
001106  3               	jsr dboxf		; fill box out to right side.
001106  3               dbox10:
001106  3               	inc dispy		; y coordinate down a line next position.
001106  3               	jmp dbox2		; next line.
001106  3               dbox7:
001106  3               	lda z80_b		; chars remaining.
001106  3               	bne :+			; are any left?
001106  3               	jmp dbox11		; no, nothing to draw.
001106  3               :
001106  3               	jsr dboxf		; fill message to line.
001106  3               
001106  3               ;------------------------------------------------------
001106  3               ; Drawn the box menu, now select option.
001106  3               ;------------------------------------------------------
001106  3               
001106  3               dbox11:
001106  3               	lda btop		; box top.
001106  3               	sta dispy		; set bar position.
001106  3               dbox14:
001106  3               	jsr joykey		; get controls.
001106  3               	cmp #$7f		; anything pressed?
001106  3               	bne dbox14		; yes, debounce it.
001106  3               	jsr dbar		; draw bar.
001106  3               dbox12:
001106  3               	jsr joykey		; get controls.
001106  3               	cmp #$7f		; anything pressed?
001106  3               	beq dbox12		; no, nothing.
001106  3               	and #16			; fire button pressed?
001106  3               	bne :+
001106  3               mod1:
001106  3               	jmp fstd		; yes, job done.
001106  3               :
001106  3               	jsr dbar		; delete bar.
001106  3               
001106  3               	lda joyval		; joystick reading.
001106  3               	and #8			; going up?
001106  3               	beq dboxu		; yes, go up.
001106  3               
001106  3               	ldx dispy		; vertical position of bar.
001106  3               	inx			; look down.
001106  3               	txa
001106  3               	sec
001106  3               	sbc btop		; find distance from top.
001106  3               	cmp blen		; top of box.
001106  3               	bne :+
001106  3               	jmp dbox14		; yes, go no further.
001106  3               :
001106  3               	inc dispy		; move bar.
001106  3               	jmp dbox14		; continue.
001106  3               dboxu:
001106  3               	lda dispy		; vertical position of bar.
001106  3               	cmp btop		; are we at the top?
001106  3               	bne :+
001106  3               	jmp dbox14		; yes, go no further.
001106  3               :
001106  3               	dec dispy		; move bar.
001106  3               	jmp dbox14		; continue.
001106  3               fstd:
001106  3               	lda dispy		; bar position.
001106  3               	sec
001106  3               	sbc btop		; find selected option.
001106  3               	sta varopt		; store the option.
001106  3               	jmp redraw		; redraw the screen.
001106  3               
001106  3               ;------------------------------------------------------
001106  3               ; Option not available.  Skip this line.
001106  3               ;------------------------------------------------------
001106  3               
001106  3               dbox13:
001106  3               	ldy #0
001106  3               	lda (z80_hl),y		; get character.
001106  3               	inc z80_l		; next one.
001106  3               	bne :+
001106  3               	inc z80_h
001106  3               :
001106  3               	cmp #','		; another line?
001106  3               	bne :+
001106  3               	jmp dbox2		; yes, do next line.
001106  3               :
001106  3               	cmp #ASCII_NEWLINE			; another line?
001106  3               	bne :+
001106  3               	jmp dbox2		; yes, do next line.
001106  3               :
001106  3               
001106  3               	bpl :+			; end of message?
001106  3               	jmp dbox11		; yes, finish message.
001106  3               :
001106  3               	jmp dbox13
001106  3               dbox15:
001106  3               	lda TmpAddr		; pop message pointer from the stack.
001106  3               	sta z80_h
001106  3               	lda TmpAddr+1
001106  3               	sta z80_l
001106  3               	rts
001106  3               
001106  3               ;------------------------------------------------------
001106  3               ; Invert bar
001106  3               ;------------------------------------------------------
001106  3               
001106  3               dbar:
001106  3               	lda blft		; box left.
001106  3               	sta dispx		; set display coordinate.
001106  3               	jsr gprad		; get printing address.
001106  3               
001106  3               	lda bwid		; box width.
001106  3               	sta z80_c		; loop counter in c.
001106  3               	lda z80_h
001106  3               	sta z80_d		; store screen address high byte.
001106  3               dbar1:
001106  3               	ldy #7			; pixel height in b.
001106  3               dbar0:
001106  3               	lda (scraddr),y		; get screen byte.
001106  3               	eor #255		; reverse all bits.
001106  3               	sta (scraddr),y		; write back to screen.
001106  3               	dey			; next line down.
001106  3               	bpl dbar0		; draw rest of character.
001106  3               
001106  3               	clc
001106  3               	lda scraddr		; one char right.
001106  3               	adc #8
001106  3               	sta scraddr
001106  3               	bcc :+
001106  3               	inc scraddr+1
001106  3               :
001106  3               
001106  3               	dec z80_c		; decrement character counter.
001106  3               	beq :+
001106  3               	jmp dbar1		; repeat for whole line.
001106  3               :
001106  3               	rts
001106  3               
001106  3               ;------------------------------------------------------
001106  3               ; Point to object
001106  3               ;
001106  3               ; Input:
001106  3               ;  -
001106  3               ;
001106  3               ; Output:
001106  3               ;  A = object number, A=255 if already in possession
001106  3               ;------------------------------------------------------
001106  3               
001106  3               invdis:
001106  3               	lda z80_l		; store message text pointer.
001106  3               	pha
001106  3               	lda z80_h
001106  3               	pha
001106  3               	lda combyt		; object number.
001106  3               	inc combyt		; ready for next one.
001106  3               	jsr gotob		; check if we have object.
001106  3               	tay
001106  3               	pla
001106  3               	sta z80_h
001106  3               	pla
001106  3               	sta z80_l
001106  3               	tya
001106  3               	rts
001106  3               
001106  3               ;------------------------------------------------------
001106  3               ; Find option selected.
001106  3               ;
001106  3               ; Input:
001106  3               ;  -
001106  3               ;
001106  3               ; Output:
001106  3               ;  OPT = selected object
001106  3               ;------------------------------------------------------
001106  3               
001106  3               fopt:
001106  3               	lda dispy
001106  3               	sec
001106  3               	sbc btop		; find selected option.
001106  3               	sta tmp+2		; option selected in b register.
001106  3               	inc tmp+2
001106  3               
001106  3               	lda #0			; set to first item.
001106  3               	sta combyt		; object number.
001106  3               fopt0:
001106  3               	jsr fobj		; find next object in inventory.
001106  3               	dec tmp+2
001106  3               	bne fopt0		; repeat for relevant steps down the list.
001106  3               
001106  3               	lda combyt		; get option.
001106  3               	sta varopt		; store the option.
001106  3               	dec varopt		; one less, due to where we increment combyt.
001106  3               	jmp redraw		; redraw the screen.
001106  3               fobj:
001106  3               	ldy combyt		; object number.
001106  3               	inc combyt		; ready for next item.
001106  3               	tya
001106  3               	jsr gotob		; do we have this item?
001106  3               	cmp #255
001106  3               	bne :+
001106  3               	rts
001106  3               :
001106  3               	jmp fobj		; yes, it's on the list.
001106  3               .endif
001106  3               
001106  3               ;----------------------------------------------------
001106  3               ; Clear sprite table.
001106  3               ;
001106  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
001106  3               ;----------------------------------------------------
001106  3               
001106  3               xspr:
001106  3  A9 FF        	lda #255		; clear byte.
001108  3  A2 00        	ldx #0			; length of table.
00110A  3               xspr0:
00110A  3  9D 00 0B     	sta sprtab,x		; sprite table.
00110D  3  E8           	inx			; move to next byte.
00110E  3  E0 CC        	cpx #SPRBUF
001110  3  D0 F8        	bne xspr0		; repeat for rest of table.
001112  3  60           	rts
001113  3               
001113  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001113  3               ; Sound, NOT IMPLEMENTED!!!
001113  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001113  3               ;
001113  3               ;silenc:
001113  3               ;	jsr silen1 		; silence channel 1.
001113  3               ;	jsr silen2 		; silence channel 2.
001113  3               ;	jsr silen3 		; silence channel 3.
001113  3               ;	jmp plsnd 		; play all channels to switch them off.
001113  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001113  3               
001113  3               ;-------------------------------------------------------------
001113  3               ; Initialise all objects.
001113  3               ;
001113  3               ; Reset current room,y,x to start room,y,x for all objects
001113  3               ;-------------------------------------------------------------
001113  3               
001113  3               iniob:
001113  3  A9 8F        	lda #<objdta 		; objects table.
001115  3  85 rr        	sta z80_x
001117  3  A9 3A        	lda #>objdta
001119  3  85 rr        	sta z80_i
00111B  3               
00111B  3  AE FF 10     	ldx numob 		; number of objects in the game.
00111E  3               iniob0:
00111E  3  A0 23        	ldy #35
001120  3  B1 rr        	lda (z80_ix),y 		; start screen.
001122  3  A0 20        	ldy #32
001124  3  91 rr        	sta (z80_ix),y 		; set start screen.
001126  3               
001126  3  A0 24        	ldy #36
001128  3  B1 rr        	lda (z80_ix),y 		; find start y.
00112A  3  A0 21        	ldy #33
00112C  3  91 rr        	sta (z80_ix),y 		; set start y.
00112E  3               
00112E  3  A0 25        	ldy #37
001130  3  B1 rr        	lda (z80_ix),y 		; get initial x.
001132  3  A0 22        	ldy #34
001134  3  91 rr        	sta (z80_ix),y 		; set x coord.
001136  3               
001136  3  18           	clc 			; point to next object.
001137  3  A5 rr        	lda z80_x
001139  3  69 26        	adc #38			; distance between objects.
00113B  3  85 rr        	sta z80_x
00113D  3  90 02        	bcc :+
00113F  3  E6 rr        	inc z80_i
001141  3               :
001141  3  CA           	dex 			; repeat.
001142  3  D0 DA        	bne iniob0
001144  3               
001144  3  60           	rts
001145  3               
001145  3               ;-----------------------------------------------
001145  3               ; Redraw the screen.
001145  3               ;
001145  3               ; Remove old copy of all sprites for redraw.
001145  3               ;-----------------------------------------------
001145  3               
001145  3               redraw:
001145  3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
001147  3  48           	pha
001148  3  A5 rr        	lda z80_x
00114A  3  48           	pha
00114B  3               
00114B  3  20 E4 17     	jsr droom		; show screen layout.
00114E  3  20 D7 13     	jsr shwob		; draw objects.
001151  3               numsp0:
001151  3  A9 0C        	lda #NUMSPR		; sprites to draw.
001153  3  85 rr        	sta tmp
001155  3               
001155  3  A9 00        	lda #<sprtab		; sprite table.
001157  3  85 rr        	sta z80_x
001159  3  A9 0B        	lda #>sprtab
00115B  3  85 rr        	sta z80_i
00115D  3               redrw0:
00115D  3  A0 00        	ldy #0
00115F  3  B1 rr        	lda (z80_ix),y		; old sprite type.
001161  3  C9 FF        	cmp #255		; is it enabled?
001163  3  F0 0B        	beq redrw1 		; no, find next one.
001165  3               
001165  3  A0 03        	ldy #var_Y
001167  3  B1 rr        	lda (z80_ix),y 		; sprite y.
001169  3  C9 B1        	cmp #177		; beyond maximum?
00116B  3  B0 03        	bcs redrw1		; yes, nothing to draw.
00116D  3               
00116D  3  20 D1 0F     	jsr sspria		; show single sprite.
001170  3               
001170  3               redrw1:
001170  3  18           	clc			; next sprite.
001171  3  A5 rr        	lda z80_x
001173  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
001175  3  85 rr        	sta z80_x
001177  3  90 02        	bcc :+
001179  3  E6 rr        	inc z80_i
00117B  3               :
00117B  3  C6 rr        	dec tmp			; repeat for remaining sprites.
00117D  3  D0 DE        	bne redrw0
00117F  3               
00117F  3               rpblc1:
00117F  3               ;	jsr dshrp		; redraw shrapnel.
00117F  3               
00117F  3  68           	pla			; retrieve sprite pointer.
001180  3  85 rr        	sta z80_x
001182  3  68           	pla
001183  3  85 rr        	sta z80_i
001185  3               
001185  3  60           	rts
001186  3               
001186  3               ;----------------------------------------------------------------------
001186  3               ; Clear screen routine.
001186  3               ;
001186  3               ; Fill screenmem $8000-$97ff with ScrFillByte
001186  3               ;----------------------------------------------------------------------
001186  3               
001186  3               cls:
001186  3  A9 68        	lda #>ScreenAddr		; screen address.
001188  3  8D 91 11     	sta clsloop+2
00118B  3  A9 FF        	lda #ScrFillByte
00118D  3  A0 00        	ldy #0
00118F  3               clsloop:
00118F  3  99 00 68     	sta ScreenAddr,y
001192  3  C8           	iny
001193  3  D0 FA        	bne clsloop
001195  3  EE 91 11     	inc clsloop+2
001198  3  AE 91 11     	ldx clsloop+2
00119B  3  E0 80        	cpx #>(ScreenAddr+ScreenSize)		; _BEEB
00119D  3  D0 F0        	bne clsloop
00119F  3  60           	rts
0011A0  3               
0011A0  3               ;----------------------------------------------------------------------
0011A0  3               ; FODDER check
0011A0  3               ;----------------------------------------------------------------------
0011A0  3               
0011A0  3               fdchk:
0011A0  3  A0 00        	ldy #0
0011A2  3  B1 rr        	lda (z80_hl),y	 	; fetch cell.
0011A4  3  C9 04        	cmp #FODDER 		; is it fodder?
0011A6  3  F0 01        	beq :+
0011A8  3  60           	rts 			; no.
0011A9  3               :
0011A9  3  A9 00        	lda #0
0011AB  3  A0 00        	ldy #0
0011AD  3  91 rr        	sta (z80_hl),y 		; rewrite block type.
0011AF  3               
0011AF  3  A5 rr        	lda z80_h		; store pointer to block.
0011B1  3  48           	pha
0011B2  3  A5 rr        	lda z80_l
0011B4  3  48           	pha
0011B5  3               
0011B5  3  38           	sec			; set carry flag for subtraction.
0011B6  3  A5 rr        	lda z80_l 		; find simple displacement for block.
0011B8  3  E9 00        	sbc #<MAP
0011BA  3  85 rr        	sta z80_l
0011BC  3  A5 rr        	lda z80_h
0011BE  3  E9 03        	sbc #>MAP
0011C0  3  85 rr        	sta z80_h
0011C2  3               
0011C2  3  A5 rr        	lda z80_l		; low byte is y coordinate.
0011C4  3  29 1F        	and #31 		; column position 0 - 31.
0011C6  3  85 rr        	sta dispx		; set up x position.
0011C8  3               
0011C8  3  06 rr        	asl z80_l		; multiply displacement by 8.
0011CA  3  26 rr        	rol z80_h
0011CC  3  06 rr        	asl z80_l
0011CE  3  26 rr        	rol z80_h
0011D0  3  06 rr        	asl z80_l
0011D2  3  26 rr        	rol z80_h
0011D4  3               
0011D4  3  A5 rr        	lda z80_h		; x coordinate now in h.
0011D6  3  85 rr        	sta dispy		; set the display coordinate.
0011D8  3               
0011D8  3  A9 00        	lda #0 			; block to write.
0011DA  3  20 4D 17     	jsr pattr 		; write block.
0011DD  3               
0011DD  3  68           	pla 			; restore block pointer.
0011DE  3  85 rr        	sta z80_l
0011E0  3  68           	pla
0011E1  3  85 rr        	sta z80_h
0011E3  3               
0011E3  3  60           	rts
0011E4  3               
0011E4  3               ;----------------------------------------------------
0011E4  3               ; Scrolly text and puzzle variables.
0011E4  3               ;----------------------------------------------------
0011E4  3               
0011E4  3               .if sflag
0011E4  3               txtbit:	.byte 128		; bit to write.
0011E4  3               txtwid:	.byte 16		; width of ticker message.
0011E4  3               txtpos:	.word msgdat
0011E4  3               txtini:	.word msgdat
0011E4  3               txtscr:	.word ScreenAddr
0011E4  3               .endif
0011E4  3               
0011E4  3               ;----------------------------------------------------
0011E4  3               ; Specialist routines.
0011E4  3               ; Process shrapnel.
0011E4  3               ;----------------------------------------------------
0011E4  3               proshr:
0011E4  3               .if pflag
0011E4  3               	lda #<SHRAPN		; table.
0011E4  3               	sta z80_x
0011E4  3               	lda #>SHRAPN
0011E4  3               	sta z80_i
0011E4  3               
0011E4  3               	lda #NUMSHR		; shrapnel pieces to process.
0011E4  3               	sta shrctr
0011E4  3               prosh0:
0011E4  3               	ldy #0
0011E4  3               	lda (z80_ix),y		; on/off marker.
0011E4  3               	asl a
0011E4  3               proshx:
0011E4  3               	bcs :+
0011E4  3               	jsr prosh1 		; on, so process it.
0011E4  3               :
0011E4  3               	clc
0011E4  3               	lda z80_x
0011E4  3               	adc #SHRSIZ
0011E4  3               	sta z80_x
0011E4  3               	bcc :+
0011E4  3               	inc z80_i
0011E4  3               :
0011E4  3               	dec shrctr		; round again.
0011E4  3               	bne prosh0
0011E4  3               .endif
0011E4  3               .if sflag
0011E4  3               	jsr scrly
0011E4  3               .endif
0011E4  3  60           	rts
0011E5  3               
0011E5  3               .if pflag
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Proces shrapnel piece
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               prosh1:
0011E5  3               	jsr plot 		; delete the pixel.
0011E5  3               
0011E5  3               	lda #<shrptr		; shrapnel routine pointers.
0011E5  3               	sta z80_l
0011E5  3               	lda #>shrptr
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	ldy #0
0011E5  3               	lda (z80_ix),y		; restore shrapnel type.
0011E5  3               	jsr prosh2 		; run the routine.
0011E5  3               	jsr chkxy		; check x and y are good before we redisplay.
0011E5  3               
0011E5  3               	lda #<SHRSIZ 		; distance to next.
0011E5  3               	sta z80_e
0011E5  3               	lda #>SHRSIZ
0011E5  3               	sta z80_d
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Run the routine
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               prosh2:
0011E5  3               	asl a 			; 2 bytes per address.
0011E5  3               	tay
0011E5  3               	lda shrptr,y
0011E5  3               	sta z80_l
0011E5  3               	lda shrptr+1,y 		; fetch high byte from table.
0011E5  3               	sta z80_h
0011E5  3               	jmp (z80_hl) 		; jump to routine.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Paricle routine table
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               shrptr:	.word laser		; laser.
0011E5  3               	.word trail		; vapour trail.
0011E5  3               	.word shrap		; shrapnel from explosion.
0011E5  3               	.word dotl		; horizontal starfield left.
0011E5  3               	.word dotr		; horizontal starfield right.
0011E5  3               	.word dotu		; vertical starfield up.
0011E5  3               	.word dotd		; vertical starfield down.
0011E5  3               	.word ptcusr		; user particle.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Explosion shrapnel.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               shrap:
0011E5  3               	ldy #1
0011E5  3               	lda (z80_ix),y 		; get the angle.
0011E5  3               	clc
0011E5  3               	adc #<shrsin		; shrapnel sine table.
0011E5  3               	sta z80_l
0011E5  3               	lda #>shrsin
0011E5  3               	adc #0
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	ldy #0
0011E5  3               	lda (z80_hl),y 		; fetch value from table.
0011E5  3               	sta z80_e
0011E5  3               	inc z80_l 		; next byte of table.
0011E5  3               	bne :+
0011E5  3               	inc z80_h
0011E5  3               :
0011E5  3               	ldy #0
0011E5  3               	lda (z80_hl),y		; fetch value from table.
0011E5  3               	sta z80_d
0011E5  3               	inc z80_l		; next byte of table.
0011E5  3               	bne :+
0011E5  3               	inc z80_h
0011E5  3               :
0011E5  3               	ldy #0
0011E5  3               	lda (z80_hl),y 		; fetch value from table.
0011E5  3               	sta z80_c
0011E5  3               	inc z80_l 		; next byte of table.
0011E5  3               	bne :+
0011E5  3               	inc z80_h
0011E5  3               :
0011E5  3               	ldy #0
0011E5  3               	lda (z80_hl),y 		; fetch value from table.
0011E5  3               	sta z80_b
0011E5  3               
0011E5  3               	ldy #2
0011E5  3               	lda (z80_ix),y 		; x coordinate in hl.
0011E5  3               	clc
0011E5  3               	adc z80_e		; add sine lb
0011E5  3               	sta (z80_ix),y		; store new coordinate lb.
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y
0011E5  3               	adc z80_d		; add sine hb
0011E5  3               	sta (z80_ix),y		; store new coordinate hb.
0011E5  3               
0011E5  3               	ldy #4
0011E5  3               	lda (z80_ix),y	 	; y coordinate in hl.
0011E5  3               	clc
0011E5  3               	adc z80_c		; add cosine lb
0011E5  3               	sta (z80_ix),y		; store new coordinate lb.
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y
0011E5  3               	adc z80_b		; add cosine lb
0011E5  3               	sta (z80_ix),y		; store new coordinate hb.
0011E5  3               
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Move dots
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               dotl:
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y
0011E5  3               	sec
0011E5  3               	sbc #1		 	; move left.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               dotr:
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y
0011E5  3               	clc
0011E5  3               	adc #1		 	; move left.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               dotu:
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y
0011E5  3               	sec
0011E5  3               	sbc #1		 	; move up.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               dotd:
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y
0011E5  3               	clc
0011E5  3               	adc #1			; move down.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Check if coordinates are ok before redrawing at new position.
0011E5  3               ;
0011E5  3               ; left:   X>L		X=L	Ok
0011E5  3               ; right:  R+15>X	X=R	Ok
0011E5  3               ; top:    Y>T		Y=T	Ok
0011E5  3               ; bottom: B+15>Y	Y=B	Ok
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               chkxy:
0011E5  3               
0011E5  3               ; top:    Y>T		Y=T	Ok
0011E5  3               
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0011E5  3               	cmp wntopx		; window top.
0011E5  3               	bcs :+			; compare with top window limit.
0011E5  3               	jmp kilshr		; out of window, kill shrapnel.
0011E5  3               :
0011E5  3               ; left:   X>L		X=L	Ok
0011E5  3               
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0011E5  3               	cmp wnlftx		; left edge.
0011E5  3               	bcs :+			; compare with left window limit.
0011E5  3               	jmp kilshr		; out of window, kill shrapnel.
0011E5  3               :
0011E5  3               ; bottom: B+15>Y	Y=B	Ok
0011E5  3               
0011E5  3               	lda wnbotx		; point to bottom.
0011E5  3               	clc
0011E5  3               	adc #15
0011E5  3               	ldy #3
0011E5  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0011E5  3               	bcs :+			; compare with shrapnel x coordinate.
0011E5  3               	jmp kilshr		; off screen, kill shrapnel..
0011E5  3               :
0011E5  3               ; right:  R+15>X	X=R	Ok
0011E5  3               
0011E5  3               	lda wnrgtx		; point to right edge.
0011E5  3               	clc
0011E5  3               	adc #15
0011E5  3               	ldy #5
0011E5  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0011E5  3               	bcs :+			; compare with window limit.
0011E5  3               	jmp kilshr		; off screen, kill shrapnel.
0011E5  3               :
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Drop through.
0011E5  3               ; Display shrapnel.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               plot:
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y		; y integer.
0011E5  3               	sta dispy	 	; workspace coordinates.
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y	 	; x integer.
0011E5  3               	sta dispx 		; workspace coordinates.
0011E5  3               
0011E5  3               	ldy #0
0011E5  3               	lda (z80_ix),y 		; type.
0011E5  3               	bne :+			; is it a laser?
0011E5  3               	jmp plot1 		; yes, draw laser instead.
0011E5  3               :
0011E5  3               plot0:
0011E5  3               	lda dispx		; which pixel within byte do we
0011E5  3               	and #7			; want to set first?
0011E5  3               	tay
0011E5  3               	lda dots,y 		; table of small pixel positions.
0011E5  3               	sta z80_e 		; get value.
0011E5  3               
0011E5  3               	jsr scadd 		; screen address.
0011E5  3               	ldy #0
0011E5  3               	lda (scraddr),y		; see what's already there.
0011E5  3               	eor z80_e
0011E5  3               	sta (scraddr),y 	; put back on screen.
0011E5  3               	rts
0011E5  3               
0011E5  3               plot1:
0011E5  3               	jsr scadd 		; screen address.
0011E5  3               	ldy #0
0011E5  3               	lda (scraddr),y 	; fetch byte there.
0011E5  3               	eor #255 		; toggle all bits.
0011E5  3               	sta (scraddr),y 	; new byte.
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Switch off shrapnel
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               kilshr:
0011E5  3               	lda #128
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y	; switch off shrapnel.
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Sine/cosine table
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               shrsin:	.word 0,1024,391,946,724,724,946,391
0011E5  3               	.word 1024,0,946,65144,724,64811,391,64589
0011E5  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0011E5  3               	.word 64512,0,64589,391,64811,724,65144,946
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create trail
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               trail:
0011E5  3               	ldy #1
0011E5  3               	lda (z80_ix),y 	; time remaining.
0011E5  3               	sec
0011E5  3               	sbc #1
0011E5  3               	sta (z80_ix),y
0011E5  3               	bne :+
0011E5  3               	jmp trailk		; time to switch it off.
0011E5  3               :
0011E5  3               	jsr qrand		; get a random number.
0011E5  3               	lsr a 			; x or y axis?
0011E5  3               	bcc :+
0011E5  3               	jmp trailv		; use y.
0011E5  3               :
0011E5  3               ; Trail horizontal
0011E5  3               
0011E5  3               	lsr a 			; which direction?
0011E5  3               	bcc :+
0011E5  3               	jmp traill		; go left.
0011E5  3               :
0011E5  3               ; Trail right
0011E5  3               
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y
0011E5  3               	clc
0011E5  3               	adc #1	 		; go right.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ; Trail left
0011E5  3               
0011E5  3               traill:
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y
0011E5  3               	sec
0011E5  3               	sbc #1 			; go left.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ; Trail vertical
0011E5  3               
0011E5  3               trailv:
0011E5  3               	lsr a		 	; which direction?
0011E5  3               	bcc :+
0011E5  3               	jmp trailu		; go up.
0011E5  3               :
0011E5  3               ; Trail down
0011E5  3               
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y
0011E5  3               	clc
0011E5  3               	adc #1 			; go down.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ; Trail up
0011E5  3               
0011E5  3               trailu:
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y
0011E5  3               	sec
0011E5  3               	sbc #1 			; go up.
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ; Kill trail
0011E5  3               
0011E5  3               trailk:
0011E5  3               	lda #200		; set off-screen to kill vapour trail.
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create laser beam
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               laser:
0011E5  3               	ldy #1
0011E5  3               	lda (z80_ix),y 		; direction.
0011E5  3               	ror a 			; left or right?
0011E5  3               	bcs :+
0011E5  3               	jmp laserl		; move left.
0011E5  3               :
0011E5  3               ; Laser right
0011E5  3               
0011E5  3               	lda #8			; distance to travel.
0011E5  3               	sta z80_b
0011E5  3               	jmp laserm		; move laser.
0011E5  3               
0011E5  3               ; Laser left
0011E5  3               
0011E5  3               laserl:
0011E5  3               	lda #248		; distance to travel.
0011E5  3               	sta z80_b
0011E5  3               laserm:
0011E5  3               	ldy #5
0011E5  3               	lda (z80_ix),y		; x position.
0011E5  3               	clc
0011E5  3               	adc z80_b		; add distance.
0011E5  3               	sta (z80_ix),y		; set new x coordinate.
0011E5  3               
0011E5  3               ; Test new block.
0011E5  3               
0011E5  3               	sta dispx 		; set x for block collision detection purposes.
0011E5  3               	ldy #3
0011E5  3               	lda (z80_ix),y 		; get y.
0011E5  3               	sta dispy		; set coordinate for collision test.
0011E5  3               	jsr tstbl 		; get block type there.
0011E5  3               	cmp #WALL		; is it solid?
0011E5  3               	bne :+
0011E5  3               	jmp trailk		; yes, it cannot pass.
0011E5  3               :
0011E5  3                       cmp #FODDER             ; is it fodder?
0011E5  3                       bne :+
0011E5  3                       jsr fdchk               ; remove fodder block.
0011E5  3                       jmp trailk              ; destroy laser.
0011E5  3               :
0011E5  3                       rts                     ; no, ignore it.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Dots mask
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               dots:	.byte 128,64,32,16,8,4,2,1
0011E5  3               
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Plot, preserving de.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               plotde:
0011E5  3               	lda z80_d 		; put de on stack.
0011E5  3               	pha
0011E5  3               	lda z80_e
0011E5  3               	pha
0011E5  3               
0011E5  3               	jsr plot 		; plot pixel.
0011E5  3               
0011E5  3               	pla			; restore de from stack.
0011E5  3               	sta z80_e
0011E5  3               	pla
0011E5  3               	sta z80_d
0011E5  3               
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Shoot a laser.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               shoot:
0011E5  3               	sta z80_c		; store direction in c register.
0011E5  3               	ldy #8
0011E5  3               	lda (z80_ix),y 		; y coordinate.
0011E5  3               shoot1:
0011E5  3               	clc
0011E5  3               	adc #7 			; down 7 pixels.
0011E5  3               	sta z80_l 		; puty y coordinate in l.
0011E5  3               
0011E5  3               	ldy #9
0011E5  3               	lda (z80_ix),y 		; x coordinate in h.
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	lda z80_i		; store pointer to sprite.
0011E5  3               	pha
0011E5  3               	lda z80_x
0011E5  3               	pha
0011E5  3               
0011E5  3               	jsr fpslot 		; find particle slot.
0011E5  3               	bcs :+
0011E5  3               	jmp vapou2		; failed, restore ix.
0011E5  3               :
0011E5  3               	lda #0
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y 		; set up a laser.
0011E5  3               
0011E5  3               	lda z80_c
0011E5  3               	ldy #1
0011E5  3               	sta (z80_ix),y 		; set the direction.
0011E5  3               
0011E5  3               	lda z80_l
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y		; set y coordinate.
0011E5  3               
0011E5  3               	ror z80_c		; check direction we want.
0011E5  3               	bcc :+
0011E5  3               	jmp shootr		; shoot right.
0011E5  3               :
0011E5  3               	lda z80_h		; X position.
0011E5  3               shoot0:
0011E5  3               	and #248		; align on character boundary.
0011E5  3               	ldy #5
0011E5  3               	sta (z80_ix),y		; set x coordinate.
0011E5  3               	jmp vapou0 		; draw first image.
0011E5  3               shootr:
0011E5  3               	lda z80_h		; x position.
0011E5  3               	clc
0011E5  3               	adc #15			; look right.
0011E5  3               	jmp shoot0		; align and continue.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create a bit of vapour trail.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               vapour:
0011E5  3               	lda z80_i		; store pointer to sprite.
0011E5  3               	pha
0011E5  3               	lda z80_x
0011E5  3               	pha
0011E5  3               
0011E5  3               	ldy #8
0011E5  3               	lda (z80_ix),y 		; y coordinate.
0011E5  3               	clc
0011E5  3               	adc #7			; mid-point of sprite.
0011E5  3               	sta z80_l
0011E5  3               
0011E5  3               	ldy #9
0011E5  3               	lda (z80_ix),y 		; x coordinate.
0011E5  3               	adc #7
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	jsr fpslot 		; find particle slot.
0011E5  3               	bcc :+
0011E5  3               	jmp vapou1		; no, we can use it.
0011E5  3               :
0011E5  3               vapou2:
0011E5  3               	pla
0011E5  3               	sta z80_x
0011E5  3               	pla
0011E5  3               	sta z80_i
0011E5  3               	rts
0011E5  3               vapou1:
0011E5  3               	lda z80_l
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y		; set up y.
0011E5  3               
0011E5  3               	lda z80_h
0011E5  3               	ldy #5
0011E5  3               	sta (z80_ix),y 		; set up x coordinate.
0011E5  3               
0011E5  3               	jsr qrand		; get quick random number.
0011E5  3               	and #15			; random time.
0011E5  3               	clc
0011E5  3               	adc #15			; minimum time on screen.
0011E5  3               	ldy #1
0011E5  3               	sta (z80_ix),y		; set time on screen.
0011E5  3               
0011E5  3               	lda #1
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y		; define particle as vapour trail.
0011E5  3               vapou0:
0011E5  3               	jsr chkxy		; plot first position.
0011E5  3               	jmp vapou2
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create a user particle.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               ptusr:
0011E5  3               	sta z80_f		; store timer.
0011E5  3               
0011E5  3               	ldy #8
0011E5  3               	lda (z80_ix),y 		; y coordinate.
0011E5  3               	clc
0011E5  3               	adc #7			; mid-point of sprite.
0011E5  3               	sta z80_l
0011E5  3               
0011E5  3               	ldy #9
0011E5  3               	lda (z80_ix),y 		; x coordinate.
0011E5  3               	clc
0011E5  3               	adc #7			; mid-point of sprite.
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	jsr fpslot 		; find particle slot.
0011E5  3               	bcs ptusr1
0011E5  3               	rts 			; out of slots, can't generate anything.
0011E5  3               ptusr1:
0011E5  3               	lda z80_l
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y 		; set up y.
0011E5  3               
0011E5  3               	lda z80_h
0011E5  3               	ldy #5
0011E5  3               	sta (z80_ix),y		; set up x coordinate.
0011E5  3               
0011E5  3               	lda z80_f 		; restore timer.
0011E5  3               	ldy #1
0011E5  3               	sta (z80_ix),y		; set time on screen.
0011E5  3               
0011E5  3               	lda #7
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y		; define particle as user particle.
0011E5  3               
0011E5  3               	jmp chkxy		; plot first position.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create a vertical or horizontal star.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               star:
0011E5  3               	lda z80_i		; store pointer to sprite.
0011E5  3               	pha
0011E5  3               	lda z80_x
0011E5  3               	pha
0011E5  3               
0011E5  3               	jsr fpslot 		; find particle slot.
0011E5  3               	bcs star7		; found one we can use.
0011E5  3               star0:
0011E5  3               	pla 			; restore sprite pointer.
0011E5  3               	sta z80_x
0011E5  3               	pla
0011E5  3               	sta z80_i
0011E5  3               	rts 			; out of slots, can't generate anything.
0011E5  3               star7:
0011E5  3               	lda z80_c		; direction.
0011E5  3               	and #3 			; is it left?
0011E5  3               	bne :+
0011E5  3               	jmp star1 		; yes, it's left.
0011E5  3               :
0011E5  3               	cmp #1 			; is it right?
0011E5  3               	bne :+
0011E5  3               	jmp star2 		; yes, it's right.
0011E5  3               :
0011E5  3               	cmp #2 			; is it up?
0011E5  3               	bne :+
0011E5  3               	jmp star3 		; yes, it's up.
0011E5  3               :
0011E5  3               	ldy wntopx 		; get edge of screen.
0011E5  3               	iny			; down one pixel.
0011E5  3               	tya
0011E5  3               star8:
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y 		; set y coord.
0011E5  3               	jsr qrand 		; get quick random number.
0011E5  3               star9:
0011E5  3               	ldy #5
0011E5  3               	sta (z80_ix),y		; set x position.
0011E5  3               
0011E5  3               	lda z80_c		; direction.
0011E5  3               	and #3			; zero to three.
0011E5  3               	clc
0011E5  3               	adc #3			; 3 to 6 for starfield.
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y		; define particle as star.
0011E5  3               	jsr chkxy		; plot first position.
0011E5  3               	jmp star0
0011E5  3               star1:
0011E5  3               	jsr qrand		; get quick random number.
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y 		; set y coord.
0011E5  3               
0011E5  3               	lda wnrgtx 		; get edge of screen.
0011E5  3               	clc
0011E5  3               	adc #15			; add width of sprite minus 1.
0011E5  3               	jmp star9
0011E5  3               star2:
0011E5  3               	jsr qrand 		; get quick random number.
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y		; set y coord.
0011E5  3               
0011E5  3               	lda wnlftx		; get edge of screen.
0011E5  3               	jmp star9
0011E5  3               star3:
0011E5  3               	lda wnbotx 		; get edge of screen.
0011E5  3               	clc
0011E5  3               	adc #15 		; height of sprite minus one pixel.
0011E5  3               	jmp star8
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Find particle slot for lasers or vapour trail.
0011E5  3               ; can't use alternate accumulator.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               fpslot:
0011E5  3               	lda #<SHRAPN 		; shrapnel table.
0011E5  3               	sta z80_x
0011E5  3               	lda #>SHRAPN
0011E5  3               	sta z80_i
0011E5  3               
0011E5  3               	lda #NUMSHR		; number of pieces in table.
0011E5  3               	sta z80_b
0011E5  3               fpslt0:
0011E5  3               	ldy #0
0011E5  3               	lda (z80_ix),y		; get type.
0011E5  3               	asl a  			; is this slot in use?
0011E5  3               	bcc :+
0011E5  3               	rts			; no, we can use it.
0011E5  3               :
0011E5  3               	clc			; point to more shrapnel.
0011E5  3               	lda z80_x
0011E5  3               	adc #SHRSIZ
0011E5  3               	sta z80_x
0011E5  3               	bcc :+
0011E5  3               	inc z80_i
0011E5  3               :
0011E5  3               	dec z80_b		; repeat for all shrapnel.
0011E5  3               	bne fpslt0
0011E5  3               
0011E5  3               	clc
0011E5  3               	rts 			; out of slots, can't generate anything.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Create an explosion at sprite position.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               explod:
0011E5  3               	sta z80_c 		; particles to create.
0011E5  3               
0011E5  3               	lda z80_i 		; store pointer to sprite.
0011E5  3               	pha
0011E5  3               	lda z80_x
0011E5  3               	pha
0011E5  3               
0011E5  3               	ldy #8
0011E5  3               	lda (z80_ix),y 		; y coordinate.
0011E5  3               	sta z80_l
0011E5  3               	ldy #9
0011E5  3               	lda (z80_ix),y		; x coordinate.
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	lda #<SHRAPN		; shrapnel table.
0011E5  3               	sta z80_x
0011E5  3               	lda #>SHRAPN
0011E5  3               	sta z80_i
0011E5  3               
0011E5  3               	lda #NUMSHR		; number of pieces in table.
0011E5  3               	sta explcnt
0011E5  3               expld0:
0011E5  3               	ldy #0
0011E5  3               	lda (z80_ix),y		; get type.
0011E5  3               	asl a 			; is this slot in use?
0011E5  3               	bcs expld1		; no, we can use it.
0011E5  3               expld2:
0011E5  3               	clc
0011E5  3               	lda z80_x
0011E5  3               	adc #SHRSIZ
0011E5  3               	sta z80_x
0011E5  3               	bcc :+
0011E5  3               	inc z80_i
0011E5  3               :
0011E5  3               	dec explcnt		; repeat for all shrapnel.
0011E5  3               	bne expld0
0011E5  3               expld3:
0011E5  3               	pla			; restore sprite pointer.
0011E5  3               	sta z80_x
0011E5  3               	pla
0011E5  3               	sta z80_i
0011E5  3               	rts 			; out of slots, can't generate any more.
0011E5  3               
0011E5  3               expld1:
0011E5  3               	lda z80_c		; shrapnel counter.
0011E5  3               	and #15			; 0 to 15.
0011E5  3               	clc			; add to x.
0011E5  3               	adc z80_l
0011E5  3               	ldy #3
0011E5  3               	sta (z80_ix),y		; y coord.
0011E5  3               
0011E5  3               	lda seed3 		; crap random number.
0011E5  3               	and #15			; 0 to 15.
0011E5  3               	clc 			; add to y.
0011E5  3               	adc z80_h
0011E5  3               	ldy #5
0011E5  3               	sta (z80_ix),y		; x coord.
0011E5  3               
0011E5  3               	lda #2
0011E5  3               	ldy #0
0011E5  3               	sta (z80_ix),y		; switch it on.
0011E5  3               
0011E5  3               	jsr chkxy		; plot first position.
0011E5  3               	jsr qrand		; quick random angle.
0011E5  3               	and #60 		; keep within range.
0011E5  3               	ldy #1
0011E5  3               	sta (z80_ix),y		; angle.
0011E5  3               
0011E5  3               	dec z80_c		; one less piece of shrapnel to generate.
0011E5  3               	bne expld2 		; back to main explosion loop.
0011E5  3               	jmp expld3 		; restore sprite pointer and exit.
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Quick random
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               qrand:
0011E5  3               	jsr random		; r register.
0011E5  3               	eor seed3		; combine with seed.
0011E5  3               	sta seed3 		; new seed.
0011E5  3               	rts
0011E5  3               
0011E5  3               ;----------------------------------------------------
0011E5  3               ; Display all shrapnel.
0011E5  3               ;----------------------------------------------------
0011E5  3               
0011E5  3               dshrp:
0011E5  3               	lda #<plotde		; display routine.
0011E5  3               	sta proshx+1
0011E5  3               	lda #>plotde
0011E5  3               	sta proshx+2
0011E5  3               	jsr proshr		; process shrapnel.
0011E5  3               
0011E5  3               	lda #<prosh1		; processing routine.
0011E5  3               	sta proshx+1
0011E5  3               	lda #>prosh1
0011E5  3               	sta proshx+2
0011E5  3               	rts
0011E5  3               
0011E5  3               ;------------------------------------------------------
0011E5  3               ; Particle engine.
0011E5  3               ;
0011E5  3               ; Init particle data for 55 particles in SHRAPN table.
0011E5  3               ; Every particle has 6 bytes.
0011E5  3               ;
0011E5  3               ; global:	-
0011E5  3               ; local:	x,y,hl
0011E5  3               ; calls:	-
0011E5  3               ;------------------------------------------------------
0011E5  3               
0011E5  3               inishr:
0011E5  3               	lda #<SHRAPN 		; table.
0011E5  3               	sta z80_l
0011E5  3               	lda #>SHRAPN
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	ldy #0
0011E5  3               	ldx #NUMSHR		; shrapnel pieces to process.
0011E5  3               inish0:
0011E5  3               	lda #255 		; kill the shrapnel.
0011E5  3               	sta (z80_hl),y
0011E5  3               
0011E5  3               	clc 			; point there.
0011E5  3               	lda z80_l
0011E5  3               	adc #SHRSIZ		; distance to next.
0011E5  3               	sta z80_l
0011E5  3               	bcc :+
0011E5  3               	inc z80_h
0011E5  3               :
0011E5  3               	dex
0011E5  3               	bne inish0 		; round again.
0011E5  3               	rts
0011E5  3               
0011E5  3               ;------------------------------------------------------
0011E5  3               ; Check for collision between laser and sprite.
0011E5  3               ;------------------------------------------------------
0011E5  3               
0011E5  3               lcol:
0011E5  3               	lda #<SHRAPN		; shrapnel table.
0011E5  3               	sta z80_l
0011E5  3               	lda #>SHRAPN
0011E5  3               	sta z80_h
0011E5  3               
0011E5  3               	lda #NUMSHR		; number of pieces in table.
0011E5  3               	sta z80_b
0011E5  3               lcol0:
0011E5  3               	ldy #0
0011E5  3               	lda (z80_hl),y 		; get type.
0011E5  3               	beq lcol1		; yes, check collision.
0011E5  3               lcol3:
0011E5  3               	clc			; point to more shrapnel.
0011E5  3               	lda z80_l
0011E5  3               	adc #SHRSIZ
0011E5  3               	sta z80_l
0011E5  3               	bcc :+
0011E5  3               	inc z80_h
0011E5  3               :
0011E5  3               	dec z80_b		; repeat for all shrapnel.
0011E5  3               	bne lcol0
0011E5  3               	rts 			; no collision, carry not set.
0011E5  3               lcol1:
0011E5  3               	ldy #3
0011E5  3               	lda (z80_hl),y		; get y.
0011E5  3               	sec
0011E5  3               	ldy #8
0011E5  3               	sbc (z80_ix),y		; subtract sprite y.
0011E5  3               lcolh:
0011E5  3               	cmp #16 		; within range?
0011E5  3               	bcc :+
0011E5  3               	jmp lcol2		; no, missed.
0011E5  3               :
0011E5  3               	ldy #5
0011E5  3               	lda (z80_hl),y 		; get x.
0011E5  3               	sec
0011E5  3               	ldy #9
0011E5  3               	sbc (z80_ix),y 		; subtract sprite y.
0011E5  3               	cmp #16			; within range?
0011E5  3               	bcs :+
0011E5  3               	jmp lcol4 		; yes, collision occurred.
0011E5  3               :
0011E5  3               lcol2:
0011E5  3               	jmp lcol3
0011E5  3               lcol4:
0011E5  3               	sec
0011E5  3               	rts 			; return with carry set for collision.
0011E5  3               .endif
0011E5  3               
0011E5  3               ;------------------------------------------------------
0011E5  3               ; Main game engine code starts here.
0011E5  3               ; After initialisation, mloop is the main loop
0011E5  3               ;------------------------------------------------------
0011E5  3               
0011E5  3               game:
0011E5  3               
0011E5  3               ; Set up screen address table.
0011E5  3               
0011E5  3               setsat:
0011E5  3  A9 00        	lda #<ScreenAddr		; start of screen.
0011E7  3  85 rr        	sta scraddr
0011E9  3  A9 68        	lda #>ScreenAddr
0011EB  3  85 rr        	sta scraddr+1
0011ED  3               
0011ED  3  A0 00        	ldy #0			; vertical lines on screen.
0011EF  3               setsa0:
0011EF  3  A5 rr        	lda scraddr
0011F1  3  99 00 06     	sta SCADTB_lb,y		; write low byte.
0011F4  3  A5 rr        	lda scraddr+1
0011F6  3  99 00 07     	sta SCADTB_hb,y		; write high byte.
0011F9  3  20 1F 10     	jsr nline		; next line down.
0011FC  3  C8           	iny			; next position in table.
0011FD  3  D0 F0        	bne setsa0
0011FF  3               
0011FF  3               ; Init graphics mode
0011FF  3               
0011FF  3  20 2B 0F     	jsr screeninit
001202  3               
001202  3               ; Init AtoMMC joystick
001202  3  20 F6 0E     	jsr joyinit		; AtoMMC joystick on PORT B
001205  3               
001205  3               rpblc2:
001205  3               .if pflag
001205  3               	jsr inishr 		; initialise particle engine.
001205  3               .endif
001205  3               evintr:
001205  3  20 23 28     	jsr evnt12 		; call intro/menu event.
001208  3               
001208  3  A9 02        	lda #WALL 		; write default property.
00120A  3  A2 00        	ldx #0
00120C  3               clrmap:
00120C  3  9D 00 03     	sta MAP,x 		; block properties.
00120F  3  9D 00 04     	sta MAP+256,x
001212  3  9D 00 05     	sta MAP+512,x
001215  3  E8           	inx			; next byte.
001216  3  D0 F4        	bne clrmap
001218  3               
001218  3  20 13 11     	jsr iniob 		; initialise objects.
00121B  3               
00121B  3  A9 00        	lda #0			; put zero in accumulator.
00121D  3  85 rr        	sta gamwon		; reset game won flag.
00121F  3               
00121F  3  20 87 13     	jsr inisc 		; init the score.
001222  3               mapst:
001222  3  AD 1C 23     	lda stmap 		; start position on map.
001225  3  8D 11 23     	sta roomtb		; set up position in table, if there is one.
001228  3               
001228  3               inipbl:
001228  3  20 D2 1F     	jsr initsc 		; set up first screen.
00122B  3               
00122B  3  A9 00        	lda #<ssprit 		; default to spare sprite in table.
00122D  3  85 rr        	sta z80_x
00122F  3  A9 23        	lda #>ssprit
001231  3  85 rr        	sta z80_i
001233  3               evini:
001233  3  20 24 28     	jsr evnt13 		; initialisation.
001236  3               
001236  3               ; Two restarts.
001236  3               ; First restart - clear all sprites and initialise everything.
001236  3               
001236  3               rstrt:
001236  3  20 27 13     	jsr rsevt 		; restart events.
001239  3  20 06 11     	jsr xspr 		; clear sprite table.
00123C  3  20 34 21     	jsr sprlst 		; fetch pointer to screen sprites.
00123F  3  20 BD 21     	jsr ispr 		; initialise sprite table.
001242  3               
001242  3  4C 51 12     	jmp rstrt0
001245  3               
001245  3               ; Second restart - clear all but player, and don't initialise him.
001245  3               
001245  3               rstrtn:
001245  3  20 27 13     	jsr rsevt		; restart events.
001248  3  20 61 21     	jsr nspr 		; clear all non-player sprites.
00124B  3  20 34 21     	jsr sprlst 		; fetch pointer to screen sprites.
00124E  3  20 FA 21     	jsr kspr 		; initialise sprite table, no more players.
001251  3               
001251  3               ; Set up the player and/or enemy sprites.
001251  3               
001251  3               rstrt0:
001251  3  A9 00        	lda #0 			; zero in accumulator.
001253  3  85 rr        	sta nexlev 		; reset next level flag.
001255  3  85 rr        	sta restfl 		; reset restart flag.
001257  3  85 rr        	sta deadf 		; reset dead flag.
001259  3  20 E4 17     	jsr droom 		; show screen layout.
00125C  3               rpblc0:
00125C  3               .if pflag
00125C  3               	jsr inishr 		; initialise particle engine.
00125C  3               .endif
00125C  3  20 D7 13     	jsr shwob		; draw objects.
00125F  3               
00125F  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
001261  3  85 rr        	sta z80_x
001263  3  A9 0B        	lda #>sprtab
001265  3  85 rr        	sta z80_i
001267  3               
001267  3  20 A3 1D     	jsr dspr 		; display sprites.
00126A  3               
00126A  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00126C  3  85 rr        	sta z80_x
00126E  3  A9 0B        	lda #>(sprtab+TABSIZ)
001270  3  85 rr        	sta z80_i
001272  3  20 A3 1D     	jsr dspr 		; display sprites.
001275  3               
001275  3               mloop:
001275  3  20 C1 0E     	jsr bbcsync
001278  3               
001278  3  20 0E 0F     	jsr vsync 		; synchronise with display.
00127B  3               
00127B  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
00127D  3  85 rr        	sta z80_x
00127F  3  A9 0B        	lda #>sprtab
001281  3  85 rr        	sta z80_i
001283  3               
001283  3               DEBUG_PAL PAL_red
001283  3  20 A3 1D     	jsr dspr 		; display even sprites.
001286  3               DEBUG_PAL PAL_black
001286  3               
001286  3  20 D6 13     	jsr plsnd 		; play sounds.
001289  3  20 0E 0F     	jsr vsync 		; synchronise with display.
00128C  3               
00128C  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
00128E  3  85 rr        	sta z80_x
001290  3  A9 0B        	lda #>(sprtab+TABSIZ)
001292  3  85 rr        	sta z80_i
001294  3               
001294  3               DEBUG_PAL PAL_red
001294  3  20 A3 1D     	jsr dspr 		; display odd sprites.
001297  3               DEBUG_PAL PAL_black
001297  3               
001297  3  A9 00        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
001299  3  85 rr        	sta z80_x
00129B  3  A9 23        	lda #>(ssprit)
00129D  3  85 rr        	sta z80_i
00129F  3               evlp1:
00129F  3               DEBUG_PAL PAL_green
00129F  3  20 A9 27     	jsr evnt10 		; called once per main loop.
0012A2  3  20 21 1D     	jsr pspr 		; process sprites.
0012A5  3               DEBUG_PAL PAL_black
0012A5  3               
0012A5  3               ; Main loop events.
0012A5  3               
0012A5  3  A9 00        	lda #<ssprit 		; point to spare sprite for spawning purposes.
0012A7  3  85 rr        	sta z80_x
0012A9  3  A9 23        	lda #>ssprit
0012AB  3  85 rr        	sta z80_i
0012AD  3               DEBUG_PAL PAL_green
0012AD  3               evlp2:
0012AD  3  20 BE 27     	jsr evnt11 		; called once per main loop.
0012B0  3               bsortx:
0012B0  3  20 97 1C     	jsr bsort 		; sort sprites.
0012B3  3               DEBUG_PAL PAL_black
0012B3  3               
0012B3  3  A5 rr        	lda nexlev		; finished level flag.
0012B5  3  D0 1F        	bne newlev		; is set, go to next level.
0012B7  3  A5 rr        	lda gamwon		; finished game flag.
0012B9  3  D0 2A        	bne evwon		; is set, finish the game.
0012BB  3  A5 rr        	lda restfl 		; finished level flag.
0012BD  3  C9 01        	cmp #1			; has it been set?
0012BF  3  D0 03        	bne :+
0012C1  3  4C 36 12     	jmp rstrt		; yes, go to next level.
0012C4  3               :
0012C4  3  C9 02        	cmp #2			; has it been set?
0012C6  3  D0 03        	bne :+
0012C8  3  4C 45 12     	jmp rstrtn		; yes, go to next level.
0012CB  3               :
0012CB  3  A5 rr        	lda deadf 		; dead flag.
0012CD  3  D0 1C        	bne pdead		; yes, player dead.
0012CF  3               
0012CF  3               ; back to start of main loop.
0012CF  3               
0012CF  3  E6 rr        	inc frmno
0012D1  3  E6 rr        	inc clock
0012D3  3  4C 75 12     	jmp mloop		; switched to a jmp mloop during test mode.
0012D6  3               
0012D6  3               ;----------------------------------------------------------
0012D6  3               ; New level
0012D6  3               ;----------------------------------------------------------
0012D6  3               
0012D6  3               newlev:
0012D6  3  A5 rr        	lda scno 			; current screen.
0012D8  3  18           	clc
0012D9  3  69 01        	adc #1				; next screen.
0012DB  3  CD EA 39     	cmp numsc			; total number of screens.
0012DE  3  B0 05        	bcs evwon			; yes, game finished.
0012E0  3  85 rr        	sta scno			; set new level number.
0012E2  3  4C 36 12     	jmp rstrt			; restart, clearing all aliens.
0012E5  3               
0012E5  3               evwon:
0012E5  3  20 47 28     	jsr evnt18		 	; game completed.
0012E8  3  4C FC 12     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0012EB  3               
0012EB  3               ;----------------------------------------------------------
0012EB  3               ; Player dead.
0012EB  3               ;----------------------------------------------------------
0012EB  3               
0012EB  3               pdead:
0012EB  3  A9 00        	lda #0				; zeroise accumulator.
0012ED  3  85 rr        	sta deadf			; reset dead flag.
0012EF  3               evdie:
0012EF  3  20 3A 28     	jsr evnt16 			; death subroutine.
0012F2  3  A5 rr        	lda numlif			; number of lives.
0012F4  3  F0 03        	beq :+
0012F6  3  4C 36 12     	jmp rstrt 			; restart game.
0012F9  3               :
0012F9  3               evfail:
0012F9  3  20 41 28     	jsr evnt17 			; failure event.
0012FC  3               
0012FC  3               ;----------------------------------------------------------
0012FC  3               ; Tidy things up
0012FC  3               ;----------------------------------------------------------
0012FC  3               
0012FC  3               tidyup:
0012FC  3  A0 00        	ldy #0				; digits to check.
0012FE  3               tidyu2:
0012FE  3  B9 A1 15     	lda score,y 			; get score digit.
001301  3  CD A7 15     	cmp hiscor 			; are we larger than high score digit?
001304  3  90 07        	bcc tidyu0			; high score is bigger.
001306  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
001308  3  C8           	iny				; next digit of high score.
001309  3  C0 06        	cpy #6
00130B  3  D0 F1        	bne tidyu2			; repeat for all digits
00130D  3               tidyu0:
00130D  3  A9 A1        	lda #<score			; return pointing to score.
00130F  3  85 rr        	sta z80_c
001311  3  A9 15        	lda #>score
001313  3  85 rr        	sta z80_b
001315  3  60           	rts
001316  3               tidyu1:
001316  3  A0 05        	ldy #5
001318  3               tidyu3:
001318  3  B9 A1 15     	lda score,y			; score.
00131B  3  99 A7 15     	sta hiscor,y			; high score.
00131E  3  88           	dey
00131F  3  10 F7        	bpl tidyu3 			; copy score to high score.
001321  3               evnewh:
001321  3  20 4D 28     	jsr evnt19			; new high score event.
001324  3  4C 0D 13     	jmp tidyu0			; tidy up.
001327  3               
001327  3               ;--------------------------------------------------
001327  3               ; Restart event.
001327  3               ;--------------------------------------------------
001327  3               
001327  3               rsevt:
001327  3  A9 00        	lda #<ssprit 			; default to spare element in table.
001329  3  85 rr        	sta z80_x
00132B  3  A9 23        	lda #>ssprit
00132D  3  85 rr        	sta z80_i
00132F  3               evrs:
00132F  3  4C 30 28     	jmp evnt14	 		; call restart event.
001332  3               
001332  3               ;------------------------------------------------------------------
001332  3               ; Copy number passed in a to string position bc, right-justified.
001332  3               ;
001332  3               ; Input:
001332  3               ;  A  = number
001332  3               ;  BC = string address
001332  3               ;
001332  3               ; Output:
001332  3               ;  BC = string with number
001332  3               ;-----------------------------------------------------------------
001332  3               
001332  3               num2ch:
001332  3  85 rr        	sta z80_d		; Save number
001334  3               
001334  3  A9 00        	lda #0
001336  3  85 rr        	sta flag
001338  3               numdg3:
001338  3  A2 64        	ldx #100		; hundreds column.
00133A  3  86 rr        	stx z80_e
00133C  3  20 4C 13     	jsr numdg		; show digit.
00133F  3               numdg2:
00133F  3  A2 0A        	ldx #10			; tens column.
001341  3  86 rr        	stx z80_e
001343  3  20 4C 13     	jsr numdg		; show digit.
001346  3               
001346  3  E6 rr        	inc flag
001348  3  A2 01        	ldx #1			; units column.
00134A  3  86 rr        	stx z80_e
00134C  3               numdg:
00134C  3  A9 30        	lda #48			; clear digit.
00134E  3  85 rr        	sta z80_a
001350  3               numdg1:
001350  3  A5 rr        	lda z80_d
001352  3  C5 rr        	cmp z80_e
001354  3  90 0E        	bcc numdg0		; nothing to show.
001356  3  38           	sec
001357  3  A5 rr        	lda z80_d
001359  3  E5 rr        	sbc z80_e		; subtract from column.
00135B  3  85 rr        	sta z80_d
00135D  3  E6 rr        	inc z80_a		; increment digit.
00135F  3  E6 rr        	inc flag
001361  3  4C 50 13     	jmp numdg1		; repeat until column is zero.
001364  3               numdg0:
001364  3  A0 00        	ldy #0
001366  3  A5 rr        	lda z80_a
001368  3  91 rr        	sta (z80_bc),y		; write digit to buffer.
00136A  3  A5 rr        	lda flag
00136C  3  F0 06        	beq :+
00136E  3  E6 rr        	inc z80_c		; next buffer position.
001370  3  D0 02        	bne :+
001372  3  E6 rr        	inc z80_b
001374  3               :
001374  3  60           	rts
001375  3               num2dd:
001375  3  85 rr        	sta z80_d		; Save number
001377  3               
001377  3  A9 01        	lda #1
001379  3  85 rr        	sta flag
00137B  3               
00137B  3  4C 3F 13     	jmp numdg2
00137E  3               num2td:
00137E  3  85 rr        	sta z80_d		; Save number
001380  3               
001380  3  A9 01        	lda #1
001382  3  85 rr        	sta flag
001384  3  4C 38 13     	jmp numdg3
001387  3               
001387  3               ;---------------------------------------------------------
001387  3               ; Reset score to "000000"
001387  3               ;---------------------------------------------------------
001387  3               
001387  3               inisc:
001387  3  A9 30        	lda #'0'
001389  3  A2 05        	ldx #5			; digits to initialise.
00138B  3               inisc0:
00138B  3  9D A1 15     	sta score,x 		; write zero digit.
00138E  3  CA           	dex			; next column.
00138F  3  10 FA        	bpl inisc0		; repeat for all digits.
001391  3               
001391  3  60           	rts
001392  3               
001392  3               ;-----------------------------------------------------
001392  3               ; Multiply h by d and return in hl.
001392  3               ;
001392  3               ; Input:
001392  3               ;  H = first number
001392  3               ;  D = second number
001392  3               ;
001392  3               ; Output:
001392  3               ;  HL = result H x D
001392  3               ;-----------------------------------------------------
001392  3               
001392  3               imul:
001392  3  A5 rr        	lda z80_d		; HL = H * D
001394  3  85 rr        	sta z80_e
001396  3  A5 rr        	lda z80_h
001398  3  85 rr        	sta z80_c		; make c first multiplier.
00139A  3               imul0:
00139A  3  A9 00        	lda #0			; zeroise total.
00139C  3  85 rr        	sta z80_l
00139E  3  85 rr        	sta z80_h
0013A0  3               
0013A0  3  A5 rr        	lda z80_h
0013A2  3  85 rr        	sta z80_d		; zeroise high byte.
0013A4  3               
0013A4  3  A9 08        	lda #8			; repeat 8 times.
0013A6  3  85 rr        	sta z80_b
0013A8  3               imul1:
0013A8  3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
0013AA  3  90 0E        	bcc imul2		; wasn't set.
0013AC  3  18           	clc			; bit was set, so add de.
0013AD  3  A5 rr        	lda z80_l
0013AF  3  65 rr        	adc z80_e
0013B1  3  85 rr        	sta z80_l
0013B3  3  A5 rr        	lda z80_h
0013B5  3  65 rr        	adc z80_d
0013B7  3  85 rr        	sta z80_h
0013B9  3  18           	clc 			; reset carry.
0013BA  3               imul2:
0013BA  3  06 rr        	asl z80_e 		; shift de 1 bit left.
0013BC  3  26 rr        	rol z80_d
0013BE  3  C6 rr        	dec z80_b
0013C0  3  D0 E6        	bne imul1		; repeat 8 times.
0013C2  3               
0013C2  3  60           	rts
0013C3  3               
0013C3  3               ;-----------------------------------------------
0013C3  3               ; Divide d by e and return in d, remainder in a.
0013C3  3               ;
0013C3  3               ; Input:
0013C3  3               ;  D = first number
0013C3  3               ;  E = second number
0013C3  3               ;
0013C3  3               ; Output:
0013C3  3               ;  D = result D/E
0013C3  3               ;  A = remainder
0013C3  3               ;-----------------------------------------------
0013C3  3               
0013C3  3               idiv:
0013C3  3  A9 00        	lda #0
0013C5  3  A0 08        	ldy #8		 	; bits to shift.
0013C7  3  06 rr        	asl z80_d
0013C9  3               idiv0:
0013C9  3  2A           	rol a 			; multiply d by 2.
0013CA  3  C5 rr        	cmp z80_e 		; test if e is smaller.
0013CC  3  90 02        	bcc idiv1		; e is greater, no division this time.
0013CE  3  E5 rr        	sbc z80_e		; subtract it.
0013D0  3               idiv1:
0013D0  3  26 rr        	rol z80_d		; rotate into d.
0013D2  3  88           	dey
0013D3  3  D0 F4        	bne idiv0		; repeat
0013D5  3  60           	rts
0013D6  3               
0013D6  3               ;---------------------------------------------------
0013D6  3               ; Play AY sound effect
0013D6  3               ;---------------------------------------------------
0013D6  3               
0013D6  3               plsnd:
0013D6  3  60           	rts
0013D7  3               
0013D7  3               ;---------------------------------------------------
0013D7  3               ; Objects handling.
0013D7  3               ; 32 bytes for image
0013D7  3               ; 3 for room, y and x
0013D7  3               ; 3 for starting room, y and x.
0013D7  3               ; 254 = disabled.
0013D7  3               ; 255 = object in player"s pockets.
0013D7  3               ;---------------------------------------------------
0013D7  3               
0013D7  3               ;---------------------------------------------------
0013D7  3               ; Show items present.
0013D7  3               ;---------------------------------------------------
0013D7  3               
0013D7  3               shwob:
0013D7  3  A9 8F        	lda #<objdta 			; objects table.
0013D9  3  85 rr        	sta z80_l
0013DB  3  A9 3A        	lda #>objdta
0013DD  3  85 rr        	sta z80_h
0013DF  3               
0013DF  3  AD FF 10     	lda numob 			; number of objects in the game.
0013E2  3  85 rr        	sta sprcnt
0013E4  3               shwob0:
0013E4  3  A0 20        	ldy #32 			; distance to room number.
0013E6  3  B1 rr        	lda (z80_hl),y 			; same as an item?
0013E8  3  C5 rr        	cmp scno 			; current location.
0013EA  3  D0 03        	bne :+
0013EC  3  20 01 14     	jsr dobj 			; yes, display object.
0013EF  3               :
0013EF  3  18           	clc
0013F0  3  A5 rr        	lda z80_l
0013F2  3  69 26        	adc #38 			; distance to next item.
0013F4  3  85 rr        	sta z80_l
0013F6  3  A5 rr        	lda z80_h
0013F8  3  69 00        	adc #0
0013FA  3  85 rr        	sta z80_h	 		; point to it.
0013FC  3  C6 rr        	dec sprcnt
0013FE  3  D0 E4        	bne shwob0 			; repeat for others.
001400  3  60           	rts
001401  3               
001401  3               ;---------------------------------------------------
001401  3               ; Display object.
001401  3               ; hl must point to object's start address.
001401  3               ;
001401  3               ; Input:
001401  3               ;  HL = object address
001401  3               ;---------------------------------------------------
001401  3               
001401  3               dobj:
001401  3  A0 21        	ldy #33
001403  3  B1 rr        	lda (z80_hl),y 			; point to y.
001405  3  85 rr        	sta dispy
001407  3  C8           	iny
001408  3  B1 rr        	lda (z80_hl),y 			; point to x.
00140A  3  85 rr        	sta dispx
00140C  3               dobj1:
00140C  3  4C 6B 0F     	jmp sprite 			; draw this sprite.
00140F  3               
00140F  3               ;--------------------------------------
00140F  3               ; Remove an object.
00140F  3               ;
00140F  3               ; Input:
00140F  3               ;  A = object number
00140F  3               ;--------------------------------------
00140F  3               
00140F  3               remob:
00140F  3  CD FF 10     	cmp numob			; number of objects in game.
001412  3  90 01        	bcc :+				; are we checking past the end?
001414  3  60           	rts				; yes, can't get non-existent item.
001415  3               :
001415  3  48           	pha				; remember object.
001416  3  20 24 14     	jsr getob			; pick it up if we haven't already got it.
001419  3  68           	pla				; retrieve object number.
00141A  3  20 53 14     	jsr gotob			; get its address.
00141D  3  A9 FE        	lda #254
00141F  3  A0 20        	ldy #32
001421  3  91 rr        	sta (z80_hl),y			; remove it.
001423  3  60           	rts
001424  3               
001424  3               ;---------------------------------------------------
001424  3               ; Pick up object number held in the accumulator.
001424  3               ;
001424  3               ; Input:
001424  3               ;  A = object number
001424  3               ;---------------------------------------------------
001424  3               
001424  3               getob:
001424  3  CD FF 10     	cmp numob 		; number of objects in game.
001427  3  90 01        	bcc :+			; are we checking past the end?
001429  3  60           	rts			; yes, can't get non-existent item.
00142A  3               :
00142A  3  20 53 14     	jsr gotob 		; check if we already have it.
00142D  3  C9 FF        	cmp #255
00142F  3  D0 01        	bne :+
001431  3  60           	rts			; we already do.
001432  3               :
001432  3  A0 20        	ldy #32
001434  3  B1 rr        	lda (z80_hl),y		; is it on this screen?
001436  3  C5 rr        	cmp scno 		; current screen.
001438  3  D0 14        	bne getob0		; not on screen, so nothing to delete.
00143A  3               
00143A  3  A9 FF        	lda #255
00143C  3  91 rr        	sta (z80_hl),y		; pick it up.
00143E  3  C8           	iny 			; point to y coord.
00143F  3               getob1:
00143F  3  A0 21        	ldy #33
001441  3  B1 rr        	lda (z80_hl),y		; y coord.
001443  3  85 rr        	sta dispy
001445  3  A0 22        	ldy #34
001447  3  B1 rr        	lda (z80_hl),y 		; x coord.
001449  3  85 rr        	sta dispx
00144B  3  4C 0C 14     	jmp dobj1 		; delete object sprite.
00144E  3               getob0:
00144E  3  A9 FF        	lda #255
001450  3  91 rr        	sta (z80_hl),y 		; pick it up.
001452  3  60           	rts
001453  3               
001453  3               ;-----------------------------------------------------------------
001453  3               ; Got object check.
001453  3               ; Call with object in accumulator, returns zero set if in pockets.
001453  3               ;
001453  3               ; Input:
001453  3               ;  A = object number
001453  3               ;-----------------------------------------------------------------
001453  3               
001453  3               gotob:
001453  3  CD FF 10     	cmp numob 		; number of objects in game.
001456  3  90 03        	bcc :+ 			; are we checking past the end?
001458  3  4C 5F 14     	jmp gotob0 		; yes, we can't have a non-existent object.
00145B  3               :
00145B  3  20 64 14     	jsr findob		; find the object.
00145E  3               gotob1:
00145E  3  60           	rts
00145F  3               
00145F  3               gotob0:
00145F  3  A9 FE        	lda #254 		; missing.
001461  3  4C 5E 14     	jmp gotob1
001464  3               
001464  3               findob:
001464  3  48           	pha			; save object number
001465  3  A9 8F        	lda #<objdta 		; objects.
001467  3  85 rr        	sta z80_l
001469  3  A9 3A        	lda #>objdta
00146B  3  85 rr        	sta z80_h
00146D  3  68           	pla			; retreive object number
00146E  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
001470  3  AA           	tax 			; loop counter
001471  3               fndob2:
001471  3  18           	clc
001472  3  A5 rr        	lda z80_l
001474  3  69 26        	adc #38 		; size of each object.
001476  3  85 rr        	sta z80_l
001478  3  90 02        	bcc :+
00147A  3  E6 rr        	inc z80_h
00147C  3               :
00147C  3  CA           	dex 			; repeat until we find address.
00147D  3  D0 F2        	bne fndob2
00147F  3               fndob1:
00147F  3  A0 20        	ldy #32			; distance to room it's in.
001481  3  B1 rr        	lda (z80_hl),y		; fetch status.
001483  3  60           	rts
001484  3               
001484  3               ;---------------------------------------------
001484  3               ; Drop object number at (dispx, dispy).
001484  3               ;
001484  3               ; Input:
001484  3               ;  A = object number
001484  3               ;---------------------------------------------
001484  3               
001484  3               drpob:
001484  3  CD FF 10     	cmp numob 		; are we checking past the end?
001487  3  90 01        	bcc :+
001489  3  60           	rts			; yes, can't drop non-existent item.
00148A  3               :
00148A  3  20 53 14     	jsr gotob		; make sure object is in inventory.
00148D  3  C5 rr        	cmp scno		; already on this screen?
00148F  3  D0 01        	bne :+
001491  3  60           	rts			; yes, nothing to do.
001492  3               :
001492  3  A0 20        	ldy #32
001494  3  A5 rr        	lda scno
001496  3  91 rr        	sta (z80_hl),y		; bring onto screen.
001498  3  A5 rr        	lda dispy		; sprite y coordinate.
00149A  3  C8           	iny
00149B  3  91 rr        	sta (z80_hl),y		; point to object y.
00149D  3  A5 rr        	lda dispx 		; sprite x coordinate.
00149F  3  C8           	iny
0014A0  3  91 rr        	sta (z80_hl),y 		; point to object x
0014A2  3  4C 01 14     	jmp dobj		; draw the object sprite.
0014A5  3               
0014A5  3               ;-----------------------------------------------
0014A5  3               ; Seek objects at sprite position.
0014A5  3               ;
0014A5  3               ; Output:
0014A5  3               ;  A = object number, if not found A=255
0014A5  3               ;-----------------------------------------------
0014A5  3               
0014A5  3               skobj:
0014A5  3  A9 8F        	lda #<objdta 		; pointer to objects.
0014A7  3  85 rr        	sta z80_l
0014A9  3  A9 3A        	lda #>objdta
0014AB  3  85 rr        	sta z80_h
0014AD  3               
0014AD  3  AD FF 10     	lda numob 		; number of objects in game.
0014B0  3  85 rr        	sta z80_b 		; set up the loop counter.
0014B2  3               skobj0:
0014B2  3  A5 rr        	lda scno		; current room number.
0014B4  3  A0 20        	ldy #32
0014B6  3  D1 rr        	cmp (z80_hl),y		; is object in here?
0014B8  3  D0 03        	bne :+
0014BA  3  20 CF 14     	jsr skobj1		; yes, check coordinates.
0014BD  3               :
0014BD  3  18           	clc			; point to next object in table.
0014BE  3  A5 rr        	lda z80_l
0014C0  3  69 26        	adc #38			; size of each object.
0014C2  3  85 rr        	sta z80_l
0014C4  3  90 02        	bcc :+
0014C6  3  E6 rr        	inc z80_h
0014C8  3               :
0014C8  3  C6 rr        	dec z80_b
0014CA  3  D0 E6        	bne skobj0		; repeat for all objects.
0014CC  3               
0014CC  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
0014CE  3  60           	rts
0014CF  3               
0014CF  3               skobj1:
0014CF  3  A0 21        	ldy #33			; point to y coordinate.
0014D1  3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
0014D3  3  38           	sec
0014D4  3  A0 08        	ldy #var_newY
0014D6  3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
0014D8  3  18           	clc
0014D9  3  69 0F        	adc #15			; add sprite height minus one.
0014DB  3  C9 1F        	cmp #31			; within range?
0014DD  3  90 03        	bcc :+
0014DF  3  4C FD 14     	jmp skobj2		; no, ignore object.
0014E2  3               :
0014E2  3  A0 22        	ldy #34			; point to x coordinate now.
0014E4  3  B1 rr        	lda (z80_hl),y 		; get coordinate.
0014E6  3  38           	sec
0014E7  3  A0 09        	ldy #var_newX
0014E9  3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
0014EB  3  18           	clc			; add sprite width minus one.
0014EC  3  69 0F        	adc #15
0014EE  3  C9 1F        	cmp #31			; within range?
0014F0  3  90 03        	bcc :+
0014F2  3  4C FD 14     	jmp skobj2		; no, ignore object.
0014F5  3               :
0014F5  3  68           	pla			; remove return address from stack.
0014F6  3  68           	pla
0014F7  3               
0014F7  3  AD FF 10     	lda numob 		; objects in game.
0014FA  3  38           	sec
0014FB  3  E5 rr        	sbc z80_b		; subtract loop counter.
0014FD  3               skobj2:
0014FD  3  60           	rts			; accumulator now points to object.
0014FE  3               
0014FE  3               
0014FE  3               ;---------------------------------------------------------------------
0014FE  3               ; Spawn a new sprite.
0014FE  3               ;---------------------------------------------------------------------
0014FE  3               
0014FE  3               spawn:
0014FE  3  A9 00        	lda #<sprtab		; sprite table.
001500  3  85 rr        	sta z80_l
001502  3  A9 0B        	lda #>sprtab
001504  3  85 rr        	sta z80_h
001506  3               numsp1:
001506  3  A9 0C        	lda #NUMSPR		; number of sprites.
001508  3  85 rr        	sta spcnt
00150A  3               spaw0:
00150A  3  A0 00        	ldy #var_Type
00150C  3  B1 rr        	lda (z80_hl),y		; get sprite type.
00150E  3  C9 FF        	cmp #255		; is it an unused slot?
001510  3  F0 0F        	beq spaw1 		; yes, we can use this one.
001512  3               
001512  3  18           	clc 			; point to next sprite in table.
001513  3  A5 rr        	lda z80_l
001515  3  69 11        	adc #TABSIZ		; size of each entry.
001517  3  85 rr        	sta z80_l
001519  3  90 02        	bcc :+
00151B  3  E6 rr        	inc z80_h
00151D  3               :
00151D  3  C6 rr        	dec spcnt		; one less iteration.
00151F  3  D0 E9        	bne spaw0		; keep going until we find a slot.
001521  3               
001521  3               ; Didn't find one but drop through and set up a dummy sprite instead.
001521  3               
001521  3               spaw1:
001521  3  A5 rr        	lda z80_i		; address of original sprite.
001523  3  48           	pha
001524  3  A5 rr        	lda z80_x
001526  3  48           	pha
001527  3               
001527  3  A5 rr        	lda z80_l		; store spawned sprite address.
001529  3  85 rr        	sta spptr
00152B  3  A5 rr        	lda z80_h
00152D  3  85 rr        	sta spptr+1
00152F  3               
00152F  3  A5 rr        	lda z80_c
001531  3  A0 00        	ldy #var_Type
001533  3  91 rr        	sta (z80_hl),y 		; set the type.
001535  3  A0 05        	ldy #var_newType
001537  3  91 rr        	sta (z80_hl),y		; copy
001539  3               
001539  3  A5 rr        	lda z80_b
00153B  3  A0 01        	ldy #var_Image
00153D  3  91 rr        	sta (z80_hl),y		; set the image.
00153F  3  A0 06        	ldy #var_newImage
001541  3  91 rr        	sta (z80_hl),y		; copy
001543  3               
001543  3  A9 00        	lda #0 				; frame zero.
001545  3  A0 02        	ldy #var_Frame
001547  3  91 rr        	sta (z80_hl),y		; set frame.
001549  3  A0 07        	ldy #var_newFrame
00154B  3  91 rr        	sta (z80_hl),y		; copy
00154D  3               
00154D  3  A0 09        	ldy #9
00154F  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001551  3  A0 04        	ldy #var_X
001553  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001555  3  A0 09        	ldy #var_newX
001557  3  91 rr        	sta (z80_hl),y		; copy
001559  3               
001559  3  A0 08        	ldy #8
00155B  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00155D  3  A0 03        	ldy #var_Y
00155F  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001561  3  A0 08        	ldy #var_newY
001563  3  91 rr        	sta (z80_hl),y		; copy
001565  3               
001565  3  A0 0A        	ldy #10				; direction of original.
001567  3  B1 rr        	lda (z80_ix),y
001569  3  A0 0A        	ldy #var_Direction
00156B  3  91 rr        	sta (z80_hl),y		; direction
00156D  3               
00156D  3  A9 00        	lda #0
00156F  3  A0 0D        	ldy #var_jumpLo
001571  3  91 rr        	sta (z80_hl),y		; reset parameter.
001573  3  C8           	iny
001574  3  91 rr        	sta (z80_hl),y		; reset parameter.
001576  3  C8           	iny
001577  3  91 rr        	sta (z80_hl),y		; reset parameter.
001579  3  C8           	iny
00157A  3  91 rr        	sta (z80_hl),y		; reset parameter.
00157C  3               rtssp:
00157C  3  A5 rr        	lda spptr			; address of new sprite.
00157E  3  85 rr        	sta z80_x
001580  3  A5 rr        	lda spptr+1
001582  3  85 rr        	sta z80_i
001584  3               evis1:
001584  3  20 96 27     	jsr evnt09 			; call sprite initialisation event.
001587  3               
001587  3  A5 rr        	lda spptr 			; address of new sprite.
001589  3  85 rr        	sta z80_x
00158B  3  A5 rr        	lda spptr+1
00158D  3  85 rr        	sta z80_i
00158F  3               
00158F  3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
00158F  3  A0 03        	ldy #var_Y
001591  3  B1 rr        	lda (z80_hl), y		; old x coord
001593  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001595  3  B0 03        	bcs :+				; yes, don't draw it.
001597  3               
001597  3  20 D1 0F     	jsr sspria 			; display the new sprite.
00159A  3               :
00159A  3  68           	pla					; address of original sprite.
00159B  3  85 rr        	sta z80_x
00159D  3  68           	pla
00159E  3  85 rr        	sta z80_i
0015A0  3               
0015A0  3  60           	rts
0015A1  3               
0015A1  3  30 30 30 30  score:	.byte "000000"		; player"s score.
0015A5  3  30 30        
0015A7  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
0015AB  3  30 30        
0015AD  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
0015B1  3  30 30        
0015B3  3  00 68        grbase:	.word ScreenAddr	; graphics base address.
0015B5  3               
0015B5  3               ;----------------------------------------------------
0015B5  3               ; Check y-pos
0015B5  3               ;----------------------------------------------------
0015B5  3               
0015B5  3               checkx:
0015B5  3  A5 rr        	lda dispy		; y position.
0015B7  3  C9 18        	cmp #24			; off screen?
0015B9  3  B0 01        	bcs :+
0015BB  3  60           	rts			; no, it's okay.
0015BC  3               :
0015BC  3  68           	pla			; remove return address from stack.
0015BD  3  85 rr        	sta z80_l
0015BF  3  68           	pla
0015C0  3  85 rr        	sta z80_h
0015C2  3  60           	rts
0015C3  3               
0015C3  3               ;-----------------------------------------------
0015C3  3               ; Displays the current high score.
0015C3  3               ;-----------------------------------------------
0015C3  3               
0015C3  3               dhisc:
0015C3  3  A9 A7        	lda #<hiscor 		; high score text.
0015C5  3  85 rr        	sta z80_l
0015C7  3  A9 15        	lda #>hiscor
0015C9  3  85 rr        	sta z80_h
0015CB  3  4C D6 15     	jmp dscor1		; check in printable range then show 6 digits.
0015CE  3               
0015CE  3               ;------------------------------------------------------
0015CE  3               ; Displays the current score.
0015CE  3               ;------------------------------------------------------
0015CE  3               
0015CE  3               dscor:
0015CE  3  A9 A1        	lda #<score		; score text.
0015D0  3  85 rr        	sta z80_l
0015D2  3  A9 15        	lda #>score
0015D4  3  85 rr        	sta z80_h
0015D6  3               dscor1:
0015D6  3  20 6B 1C     	jsr preprt		; set up font and print position.
0015D9  3  20 B5 15     	jsr checkx		; make sure we're in a printable range.
0015DC  3               
0015DC  3  A9 06        	lda #6			; digits to display.
0015DE  3  85 rr        	sta z80_b
0015E0  3  A5 rr        	lda prtmod		; get print mode.
0015E2  3  F0 03        	beq :+			; standard size text?
0015E4  3  4C 03 16     	jmp bscor0		; no, show double-height.
0015E7  3               :
0015E7  3               dscor0:
0015E7  3  A0 00        	ldy #0
0015E9  3  B1 rr        	lda (z80_hl),y 		; fetch character.
0015EB  3  20 BF 10     	jsr pchar 		; display character.
0015EE  3  E6 rr        	inc dispx		; move along x coordinate
0015F0  3               
0015F0  3  E6 rr        	inc z80_l		; next score column.
0015F2  3  D0 02        	bne :+
0015F4  3  E6 rr        	inc z80_h
0015F6  3               :
0015F6  3  C6 rr        	dec z80_b
0015F8  3  D0 ED        	bne dscor0 		; repeat for all digits.
0015FA  3               dscor2:
0015FA  3  A5 rr        	lda dispx 		; set up display coordinates.
0015FC  3  85 rr        	sta charx
0015FE  3  A5 rr        	lda dispy
001600  3  85 rr        	sta chary
001602  3  60           	rts
001603  3               
001603  3               ;------------------------------------------------------
001603  3               ; Displays the current score in double-height characters.
001603  3               ;
001603  3               ; Input:
001603  3               ;  B  = digit number
001603  3               ;  HL = score string
001603  3               ;------------------------------------------------------
001603  3               
001603  3               bscor0:
001603  3  A0 00        	ldy #0
001605  3               
001605  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001607  3  20 EE 1B     	jsr bchar 		; display big char.
00160A  3               
00160A  3  E6 rr        	inc z80_l 		; next score column.
00160C  3  D0 02        	bne :+
00160E  3  E6 rr        	inc z80_h
001610  3               :
001610  3  C6 rr        	dec z80_b
001612  3  F0 03        	beq :+
001614  3  4C 03 16     	jmp bscor0 		; repeat for all digits.
001617  3               :
001617  3  4C FA 15     	jmp dscor2 		; tidy up line and column variables.
00161A  3               
00161A  3               ;-----------------------------------------------------
00161A  3               ; Adds number in the hl pair to the score.
00161A  3               ;-----------------------------------------------------
00161A  3               
00161A  3               addsc:
00161A  3  A9 A2        	lda #<(score+1) 	; ten thousands column.
00161C  3  85 rr        	sta z80_e
00161E  3  A9 15        	lda #>(score+1)
001620  3  85 rr        	sta z80_d
001622  3  A9 10        	lda #<10000		; amount to add each time.
001624  3  85 rr        	sta z80_c
001626  3  A9 27        	lda #>10000
001628  3  85 rr        	sta z80_b
00162A  3  20 6E 16     	jsr incsc		; add to score.
00162D  3               
00162D  3  E6 rr        	inc z80_e		; thousands column.
00162F  3  D0 02        	bne :+
001631  3  E6 rr        	inc z80_d
001633  3               :
001633  3  A9 E8        	lda #<1000		; amount to add each time.
001635  3  85 rr        	sta z80_c
001637  3  A9 03        	lda #>1000
001639  3  85 rr        	sta z80_b
00163B  3  20 6E 16     	jsr incsc 		; add to score.
00163E  3               
00163E  3  E6 rr        	inc z80_e		; hundreds column.
001640  3  D0 02        	bne :+
001642  3  E6 rr        	inc z80_d
001644  3               :
001644  3  A9 64        	lda #<100		; amount to add each time.
001646  3  85 rr        	sta z80_c
001648  3  A9 00        	lda #>100
00164A  3  85 rr        	sta z80_b
00164C  3  20 6E 16     	jsr incsc		; add to score.
00164F  3               
00164F  3  E6 rr        	inc z80_e 		; tens column.
001651  3  D0 02        	bne :+
001653  3  E6 rr        	inc z80_d
001655  3               :
001655  3  A9 0A        	lda #<10		; amount to add each time.
001657  3  85 rr        	sta z80_c
001659  3  A9 00        	lda #>10
00165B  3  85 rr        	sta z80_b
00165D  3  20 6E 16     	jsr incsc 		; add to score.
001660  3               
001660  3  E6 rr        	inc z80_e		; units column.
001662  3  D0 02        	bne :+
001664  3  E6 rr        	inc z80_d
001666  3               :
001666  3  A9 01        	lda #<1			; units.
001668  3  85 rr        	sta z80_c
00166A  3  A9 00        	lda #>1
00166C  3  85 rr        	sta z80_b
00166E  3               incsc:
00166E  3  A5 rr        	lda z80_h		; store amount to add.
001670  3  48           	pha
001671  3  A5 rr        	lda z80_l
001673  3  48           	pha
001674  3               
001674  3  38           	sec			; subtract from amount to add.
001675  3  A5 rr        	lda z80_l
001677  3  E5 rr        	sbc z80_c
001679  3  85 rr        	sta z80_l
00167B  3  A5 rr        	lda z80_h
00167D  3  E5 rr        	sbc z80_b
00167F  3  85 rr        	sta z80_h
001681  3  90 14        	bcc incsc0		; too much, restore value.
001683  3               
001683  3  68           	pla			; delete the previous amount from the stack.
001684  3  68           	pla
001685  3               
001685  3  A5 rr        	lda z80_d 		; store column position.
001687  3  48           	pha
001688  3  A5 rr        	lda z80_e
00168A  3  48           	pha
00168B  3  20 9E 16     	jsr incsc2		; do the increment.
00168E  3               
00168E  3  68           	pla			; restore column.
00168F  3  85 rr        	sta z80_e
001691  3  68           	pla
001692  3  85 rr        	sta z80_d
001694  3  4C 6E 16     	jmp incsc		; repeat until all added.
001697  3               
001697  3               incsc0:
001697  3  68           	pla			; restore previous value.
001698  3  85 rr        	sta z80_l
00169A  3  68           	pla
00169B  3  85 rr        	sta z80_h
00169D  3  60           	rts
00169E  3               incsc2:
00169E  3  A0 00        	ldy #0
0016A0  3  B1 rr        	lda (z80_de),y 		; get amount.
0016A2  3  18           	clc
0016A3  3  69 01        	adc #1			; add one to column.
0016A5  3  91 rr        	sta (z80_de),y		; write new column total.
0016A7  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
0016A9  3  B0 01        	bcs :+
0016AB  3  60           	rts			; no, carry on.
0016AC  3               :
0016AC  3  A9 30        	lda #'0'		; make it zero.
0016AE  3  91 rr        	sta (z80_de),y		; write new column total.
0016B0  3  C6 rr        	dec z80_e		; back one column.
0016B2  3  D0 02        	bne :+
0016B4  3  C6 rr        	dec z80_d
0016B6  3               :
0016B6  3  4C 9E 16     	jmp incsc2
0016B9  3               
0016B9  3               ;------------------------------------
0016B9  3               ; Add bonus to score and reset bonus
0016B9  3               ;------------------------------------
0016B9  3               
0016B9  3               addbo:
0016B9  3  A2 05        	ldx #5			; last digit.
0016BB  3  18           	clc			; clear carry.
0016BC  3               addbo0:
0016BC  3  BD A1 15     	lda score,x		; get score.
0016BF  3  7D AD 15     	adc bonus,x		; add bonus.
0016C2  3  38           	sec			; 0 to 18.
0016C3  3  E9 30        	sbc #48
0016C5  3  48           	pha
0016C6  3  A9 30        	lda #'0'
0016C8  3  9D AD 15     	sta bonus,x		; zeroise bonus.
0016CB  3  68           	pla
0016CC  3  C9 3A        	cmp #58			; carried?
0016CE  3  B0 07        	bcs addbo2		; no, do next one.
0016D0  3  38           	sec
0016D1  3  E9 0A        	sbc #10			; subtract 10.
0016D3  3  38           	sec
0016D4  3  4C D8 16     	jmp addbo1
0016D7  3               addbo2:
0016D7  3  18           	clc
0016D8  3               addbo1:
0016D8  3  9D A1 15     	sta score,x		; write new score.
0016DB  3  CA           	dex			; next digit.
0016DC  3  10 DE        	bpl addbo0		; repeat for all 6 digits.
0016DE  3  60           	rts
0016DF  3               
0016DF  3               ;------------------------------------
0016DF  3               ; Swap score and bonus.
0016DF  3               ;------------------------------------
0016DF  3               
0016DF  3               swpsb:
0016DF  3  A2 05        	ldx #5			; digits to add.
0016E1  3               swpsb0:
0016E1  3  BD A1 15     	lda score,x 		; get score digits.
0016E4  3  48           	pha			; save digit
0016E5  3  BD AD 15     	lda bonus,x 		; get bonus digits.
0016E8  3  9D A1 15     	sta score,x		; switch score-bonus
0016EB  3  68           	pla
0016EC  3  9D AD 15     	sta bonus,x
0016EF  3  CA           	dex 			; repeat for all 6 digits.
0016F0  3  10 EF        	bpl swpsb0
0016F2  3  60           	rts
0016F3  3               
0016F3  3               ;----------------------------------------------------
0016F3  3               ; Get print address.
0016F3  3               ;----------------------------------------------------
0016F3  3               
0016F3  3               gprad:
0016F3  3  98           	tya
0016F4  3  48           	pha
0016F5  3               
0016F5  3  A5 rr        	lda dispx 		; x coordinate.
0016F7  3  85 rr        	sta scraddr
0016F9  3  A9 00        	lda #0
0016FB  3  85 rr        	sta scraddr+1
0016FD  3  06 rr        	asl scraddr  	; multiply char by 8
0016FF  3  26 rr        	rol scraddr+1
001701  3  06 rr        	asl scraddr
001703  3  26 rr        	rol scraddr+1
001705  3  06 rr        	asl scraddr
001707  3  26 rr        	rol scraddr+1
001709  3               
001709  3  A5 rr        	lda dispy		; y coordinate.
00170B  3  0A           	asl a
00170C  3  0A           	asl a
00170D  3  0A           	asl a			; multiply char by 8
00170E  3  A8           	tay
00170F  3               
00170F  3  18           	clc
001710  3  A5 rr        	lda scraddr
001712  3  79 00 06     	adc SCADTB_lb,y
001715  3  85 rr        	sta scraddr
001717  3  A5 rr        	lda scraddr+1
001719  3  79 00 07     	adc SCADTB_hb,y
00171C  3  85 rr        	sta scraddr+1
00171E  3               
00171E  3  68           	pla
00171F  3  A8           	tay
001720  3  60           	rts
001721  3               
001721  3               ;--------------------------------------------------------------
001721  3               ; Get property buffer address of char at (dispx, dispy) in hl.
001721  3               ;
001721  3               ; Output:
001721  3               ;  bufaddr = MAP + dispy*32 + dispx
001721  3               ;--------------------------------------------------------------
001721  3               
001721  3               pradd:
001721  3  A5 rr        	lda dispy 		; y coordinate.
001723  3  85 rr        	sta bufaddr
001725  3  A9 00        	lda #0
001727  3  85 rr        	sta bufaddr+1
001729  3  06 rr        	asl bufaddr  		; multiply char by 32
00172B  3  26 rr        	rol bufaddr+1
00172D  3  06 rr        	asl bufaddr
00172F  3  26 rr        	rol bufaddr+1
001731  3  06 rr        	asl bufaddr
001733  3  26 rr        	rol bufaddr+1
001735  3  06 rr        	asl bufaddr
001737  3  26 rr        	rol bufaddr+1
001739  3  06 rr        	asl bufaddr
00173B  3  26 rr        	rol bufaddr+1
00173D  3  18           	clc			; add address of MAP graphics.
00173E  3  A5 rr        	lda bufaddr
001740  3  65 rr        	adc dispx
001742  3  69 00        	adc #<MAP
001744  3  85 rr        	sta bufaddr
001746  3  A5 rr        	lda bufaddr+1
001748  3  69 03        	adc #>MAP
00174A  3  85 rr        	sta bufaddr+1
00174C  3  60           	rts
00174D  3               
00174D  3               ;----------------------------------------------
00174D  3               ; Print attributes, properties and pixels.
00174D  3               ;
00174D  3               ; Input:
00174D  3               ;  A	= tile number
00174D  3               ;----------------------------------------------
00174D  3               
00174D  3               pattr:
00174D  3  85 rr        	sta z80_b		; store cell in b register for now.
00174F  3  AA           	tax
001750  3  BD 22 29     	lda bprop,x 		; block properties.
001753  3  85 rr        	sta z80_c
001755  3  C9 08        	cmp #COLECT
001757  3  D0 04        	bne :+
001759  3  A5 rr        	lda z80_b
00175B  3  85 rr        	sta colpatt
00175D  3               :
00175D  3  20 21 17     	jsr pradd 		; get property buffer address.
001760  3  A5 rr        	lda z80_c
001762  3  A0 00        	ldy #0
001764  3  91 rr        	sta (bufaddr),y 	; write property.
001766  3  A5 rr        	lda z80_b 		; restore cell.
001768  3               
001768  3               ; Print attributes, no properties.
001768  3               
001768  3               panp:
001768  3  85 rr        	sta z80_e		; displacement in e.
00176A  3  A9 00        	lda #0
00176C  3  85 rr        	sta z80_d		; no high byte.
00176E  3  06 rr        	asl z80_e  		; multiply char by 8.
001770  3  26 rr        	rol z80_d
001772  3  06 rr        	asl z80_e
001774  3  26 rr        	rol z80_d
001776  3  06 rr        	asl z80_e
001778  3  26 rr        	rol z80_d
00177A  3  18           	clc
00177B  3  A5 rr        	lda z80_e
00177D  3  69 A2        	adc #<chgfx 		; address of graphics.
00177F  3  85 rr        	sta tileaddr
001781  3  A5 rr        	lda z80_d
001783  3  69 28        	adc #>chgfx
001785  3  85 rr        	sta tileaddr+1
001787  3  20 F3 16     	jsr gprad 		; get screen address.
00178A  3  A0 07        	ldy #7			; number of pixel rows to write.
00178C  3               panp0:
00178C  3  B1 rr        	lda (tileaddr),y 	; get image byte.
00178E  3  49 FF        	eor #TxtInvert		; Invert
001790  3  91 rr        	sta (scraddr),y 	; copy to screen.
001792  3  88           	dey	 		; repeat for 8 pixel rows.
001793  3  10 F7        	bpl panp0
001795  3  E6 rr        	inc dispx 		; move along one.
001797  3  E6 rr        	inc charx
001799  3  60           	rts
00179A  3               
00179A  3               ;----------------------------------------------
00179A  3               ; Print character pixels, no more.
00179A  3               ;
00179A  3               ; Input:
00179A  3               ;  A	= character to print
00179A  3               ;----------------------------------------------
00179A  3               
00179A  3               pchr:
00179A  3  20 BF 10     	jsr pchar 		; show character in accumulator.
00179D  3  E6 rr        	inc dispx		; move along one.
00179F  3  60           	rts
0017A0  3               
0017A0  3               ;----------------------------------------------------
0017A0  3               ; Shifter sprite routine for objects.
0017A0  3               ;----------------------------------------------------
0017A0  3               
0017A0  3               sprit7:
0017A0  3  A5 rr        	lda z80_b
0017A2  3  F0 0A        	beq sprit0
0017A4  3  A8           	tay
0017A5  3               sprit3:
0017A5  3  46 rr        	lsr spr			; shift into position.
0017A7  3  66 rr        	ror spr+1
0017A9  3  66 rr        	ror spr+2
0017AB  3  88           	dey				; one less iteration.
0017AC  3  D0 F7        	bne sprit3
0017AE  3               sprit0:
0017AE  3  60           	rts 			; now apply to screen.
0017AF  3               
0017AF  3               ;-----------------------------------------------------------
0017AF  3               ; Get room address.
0017AF  3               ;-----------------------------------------------------------
0017AF  3               
0017AF  3               groom:
0017AF  3  A6 rr        	ldx scno 		; screen number.
0017B1  3  A0 00        	ldy #0
0017B3  3               groomx:
0017B3  3  A9 C0        	lda #<scdat 		; pointer to screens.
0017B5  3  85 rr        	sta z80_l
0017B7  3  A9 31        	lda #>scdat
0017B9  3  85 rr        	sta z80_h
0017BB  3               groom1:
0017BB  3  E0 00        	cpx #0			; is it the first one?
0017BD  3  F0 15        	beq groom0 		; no more screens to skip.
0017BF  3               
0017BF  3  18           	clc
0017C0  3  A5 rr        	lda z80_l
0017C2  3  79 C0 31     	adc scdat,y 		; low byte of screen size.
0017C5  3  85 rr        	sta z80_l
0017C7  3  C8           	iny			; point to high byte.
0017C8  3  A5 rr        	lda z80_h
0017CA  3  79 C0 31     	adc scdat,y 		; high byte of screen size.
0017CD  3  85 rr        	sta z80_h
0017CF  3  C8           	iny			; next address.
0017D0  3               
0017D0  3  CA           	dex 			; one less iteration.
0017D1  3  4C BB 17     	jmp groom1 		; loop until we reach the end.
0017D4  3               groom0:
0017D4  3  AD EA 39     	lda numsc 		; add displacement.
0017D7  3  0A           	asl a
0017D8  3  18           	clc			; add double displacement to address.
0017D9  3  65 rr        	adc z80_l
0017DB  3  85 rr        	sta z80_l
0017DD  3  A5 rr        	lda z80_h
0017DF  3  69 00        	adc #0
0017E1  3  85 rr        	sta z80_h
0017E3  3  60           	rts
0017E4  3               
0017E4  3               ;-----------------------------------------------------------
0017E4  3               ; Draw present room.
0017E4  3               ;-----------------------------------------------------------
0017E4  3               
0017E4  3               droom:
0017E4  3  AD FB 10     	lda wintop 		; window top.
0017E7  3  85 rr        	sta dispy		; set cursor y position.
0017E9  3               droom2:
0017E9  3  20 AF 17     	jsr groom 		; get address of current room.
0017EC  3  A9 00        	lda #0	 		; zero in accumulator.
0017EE  3  85 rr        	sta comcnt 		; reset compression counter.
0017F0  3  AD FD 10     	lda winhgt 		; height of window.
0017F3  3  85 rr        	sta rrow		; set row counter
0017F5  3               droom0:
0017F5  3  AD FC 10     	lda winlft 		; window left edge.
0017F8  3  85 rr        	sta dispx 		; set cursor x position.
0017FA  3  AD FE 10     	lda winwid 		; width of window.
0017FD  3  85 rr        	sta rcol		; set column counter
0017FF  3               droom1:
0017FF  3  20 10 18     	jsr flbyt 		; decompress next byte on the fly.
001802  3  20 4D 17     	jsr pattr 		; show attributes and block.
001805  3  C6 rr        	dec rcol		; one less column.
001807  3  D0 F6        	bne droom1 		; repeat for entire line.
001809  3  E6 rr        	inc dispy		; move down one line.
00180B  3  C6 rr        	dec rrow 		; one less row.
00180D  3  D0 E6        	bne droom0 		; repeat for all rows.
00180F  3  60           	rts
001810  3               
001810  3               ;----------------------------------------------
001810  3               ; Decompress bytes on-the-fly.
001810  3               ;----------------------------------------------
001810  3               
001810  3               flbyt:
001810  3  A5 rr        	lda comcnt 		; compression counter.
001812  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
001814  3               
001814  3  A0 00        	ldy #0
001816  3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
001818  3  E6 rr        	inc z80_l 		; point to next cell.
00181A  3  D0 02        	bne :+
00181C  3  E6 rr        	inc z80_h
00181E  3               :
00181E  3  C9 FF        	cmp #255 		; is this byte a control code?
001820  3  F0 01        	beq :+
001822  3  60           	rts 			; no, this byte is uncompressed.
001823  3               :
001823  3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
001825  3  85 rr        	sta combyt 		; set up the type.
001827  3  E6 rr        	inc z80_l 		; point to quantity.
001829  3  D0 02        	bne :+
00182B  3  E6 rr        	inc z80_h
00182D  3               :
00182D  3  B1 rr        	lda (z80_hl),y 		; get quantity.
00182F  3  E6 rr        	inc z80_l 		; point to next byte.
001831  3  D0 02        	bne :+
001833  3  E6 rr        	inc z80_h
001835  3               :
001835  3               flbyt1:
001835  3  85 rr        	sta comcnt 		; store new quantity.
001837  3  C6 rr        	dec comcnt		; one less.
001839  3  A5 rr        	lda combyt 		; byte to expand.
00183B  3  60           	rts
00183C  3               
00183C  3               ;------------------------------------------
00183C  3               ; Ladder down check.
00183C  3               ;
00183C  3               ; Input:
00183C  3               ;  IX = sprite pointer
00183C  3               ;------------------------------------------
00183C  3               
00183C  3               laddd:
00183C  3  A0 09        	ldy #9
00183E  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001840  3  85 rr        	sta dispx
001842  3               
001842  3  A0 08        	ldy #8
001844  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001846  3  29 FE        	and #254		; make it even.
001848  3  91 rr        	sta (z80_ix),y 		; reset it.
00184A  3               numsp5:
00184A  3  18           	clc 			; look down 16 pixels.
00184B  3  69 10        	adc #16
00184D  3  85 rr        	sta dispy		; coords in dispx,dispy.
00184F  3  4C 65 18     	jmp laddv
001852  3               
001852  3               ;------------------------------------------
001852  3               ; Ladder up check.
001852  3               ;
001852  3               ; Input:
001852  3               ;  IX = sprite pointer
001852  3               ;
001852  3               ; Output:
001852  3               ;  A  = 0 is ok, A <>0 is not ok
001852  3               ;------------------------------------------
001852  3               
001852  3               laddu:
001852  3  A0 09        	ldy #9
001854  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001856  3  85 rr        	sta dispx
001858  3               
001858  3  A0 08        	ldy #8
00185A  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00185C  3  29 FE        	and #254 		; make it even.
00185E  3  91 rr        	sta (z80_ix),y		; reset it.
001860  3               numsp6:
001860  3  18           	clc 			; look 2 pixels above feet.
001861  3  69 0E        	adc #14
001863  3  85 rr        	sta dispy		; coords in dispx,dispy.
001865  3               laddv:
001865  3  20 A7 1A     	jsr tstbl 		; get map address.
001868  3  20 72 19     	jsr ldchk 		; standard ladder check.
00186B  3  F0 01        	beq :+
00186D  3  60           	rts 			; no way through.
00186E  3               :
00186E  3  E6 rr        	inc bufaddr 		; look right one cell.
001870  3  D0 02        	bne :+
001872  3  E6 rr        	inc bufaddr+1
001874  3               :
001874  3  20 72 19     	jsr ldchk 		; do the check.
001877  3  F0 01        	beq :+
001879  3  60           	rts 			; impassable.
00187A  3               :
00187A  3  A5 rr        	lda dispx 		; y coordinate.
00187C  3  29 07        	and #7 			; position straddling block cells.
00187E  3  D0 01        	bne :+
001880  3  60           	rts 			; no more checks needed.
001881  3               :
001881  3  E6 rr        	inc bufaddr 		; look to third cell.
001883  3  D0 02        	bne :+
001885  3  E6 rr        	inc bufaddr+1
001887  3               :
001887  3  20 72 19     	jsr ldchk 		; do the check.
00188A  3  60           	rts  			; return with zero flag set accordingly.
00188B  3               
00188B  3               ;---------------------------------------------------------
00188B  3               ; Can go up check.
00188B  3               ;
00188B  3               ; Input:
00188B  3               ;  IX = sprite pointer
00188B  3               ;
00188B  3               ; Output:
00188B  3               ;  A  = 0 is ok, A <>0 is not ok
00188B  3               ;---------------------------------------------------------
00188B  3               
00188B  3               cangu:
00188B  3  A0 09        	ldy #9
00188D  3  B1 rr        	lda (z80_ix),y		; x coordinate.
00188F  3  85 rr        	sta dispx
001891  3  A0 08        	ldy #8
001893  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001895  3  38           	sec
001896  3  E9 02        	sbc #2
001898  3  85 rr        	sta dispy		; coords in dispx,dispy.
00189A  3  20 A7 1A     	jsr tstbl 		; get map address.
00189D  3  20 3D 19     	jsr lrchk 		; standard left/right check.
0018A0  3  F0 01        	beq :+
0018A2  3  60           	rts			; no way through.
0018A3  3               :
0018A3  3  E6 rr        	inc bufaddr		; look right one cell.
0018A5  3  D0 02        	bne :+
0018A7  3  E6 rr        	inc bufaddr+1
0018A9  3               :
0018A9  3  20 3D 19     	jsr lrchk 		; do the check.
0018AC  3  F0 01        	beq :+
0018AE  3  60           	rts			; impassable.
0018AF  3               :
0018AF  3  A5 rr        	lda dispx		; x coordinate.
0018B1  3  29 07        	and #7			; position straddling block cells.
0018B3  3  D0 01        	bne :+
0018B5  3  60           	rts			; no more checks needed.
0018B6  3               :
0018B6  3  E6 rr        	inc bufaddr		; look to third cell.
0018B8  3  D0 02        	bne :+
0018BA  3  E6 rr        	inc bufaddr+1
0018BC  3               :
0018BC  3  20 3D 19     	jsr lrchk		; do the check.
0018BF  3  60           	rts 			; return with zero flag set accordingly.
0018C0  3               
0018C0  3               ;---------------------------------------------------------
0018C0  3               ; Can go down check.
0018C0  3               ;
0018C0  3               ; Input:
0018C0  3               ;  IX = sprite pointer
0018C0  3               ;
0018C0  3               ; Output:
0018C0  3               ;  A  = 0 is ok, A <>0 is not ok
0018C0  3               ;---------------------------------------------------------
0018C0  3               
0018C0  3               cangd:
0018C0  3  A0 09        	ldy #9
0018C2  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0018C4  3  85 rr        	sta dispx
0018C6  3  A0 08        	ldy #8
0018C8  3  B1 rr        	lda (z80_ix),y		; y coordinate.
0018CA  3               numsp3:
0018CA  3  18           	clc
0018CB  3  69 10        	adc #16 		; look down 16 pixels.
0018CD  3  85 rr        	sta dispy		; coords in dispx,dispy.
0018CF  3  20 A7 1A     	jsr tstbl 		; get map address.
0018D2  3  20 52 19     	jsr plchk 		; block, platform check.
0018D5  3  F0 01        	beq :+
0018D7  3  60           	rts			; no way through.
0018D8  3               :
0018D8  3  E6 rr        	inc bufaddr		; look right one cell.
0018DA  3  D0 02        	bne :+
0018DC  3  E6 rr        	inc bufaddr+1
0018DE  3               :
0018DE  3  20 52 19     	jsr plchk		; block, platform check.
0018E1  3  F0 01        	beq :+
0018E3  3  60           	rts			; impassable.
0018E4  3               :
0018E4  3  A5 rr        	lda dispx		; x coordinate.
0018E6  3  29 07        	and #7			; position straddling block cells.
0018E8  3  D0 01        	bne :+
0018EA  3  60           	rts			; no more checks needed.
0018EB  3               :
0018EB  3  E6 rr        	inc bufaddr		; look to third cell.
0018ED  3  D0 02        	bne :+
0018EF  3  E6 rr        	inc bufaddr+1
0018F1  3               :
0018F1  3  20 52 19     	jsr plchk		; block, platform check.
0018F4  3  60           	rts			; return with zero flag set accordingly.
0018F5  3               
0018F5  3               ;---------------------------------------------------------
0018F5  3               ; Can go left check.
0018F5  3               ;
0018F5  3               ; Input:
0018F5  3               ;  IX = sprite pointer
0018F5  3               ;
0018F5  3               ; Output:
0018F5  3               ;  A  = 0 is ok, A <>0 is not ok
0018F5  3               ;---------------------------------------------------------
0018F5  3               
0018F5  3               cangl:
0018F5  3  A0 08        	ldy #8
0018F7  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0018F9  3  85 rr        	sta dispy
0018FB  3  A0 09        	ldy #9
0018FD  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0018FF  3  38           	sec
001900  3  E9 02        	sbc #2			; look left 2 pixels.
001902  3  85 rr        	sta dispx		; coords in dispx,dispy.
001904  3  4C 16 19     	jmp cangh		; test if we can go there.
001907  3               
001907  3               ;---------------------------------------------------------
001907  3               ; Can go right check.
001907  3               ;
001907  3               ; Input:
001907  3               ;  IX = sprite pointer
001907  3               ;
001907  3               ; Output:
001907  3               ;  A  = 0 is ok, A <>0 is not ok
001907  3               ;---------------------------------------------------------
001907  3               
001907  3               cangr:
001907  3  A0 08        	ldy #8
001909  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00190B  3  85 rr        	sta dispy
00190D  3  A0 09        	ldy #9
00190F  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001911  3  18           	clc
001912  3  69 10        	adc #16			; look right 16 pixels.
001914  3  85 rr        	sta dispx		; coords in dispx,dispy.
001916  3               cangh:
001916  3               cangh2:
001916  3  A9 03        	lda #3			; default rows to write.
001918  3  85 rr        	sta z80_b
00191A  3  A5 rr        	lda dispy		; y position.
00191C  3  29 07        	and #7			; does x straddle cells?
00191E  3  D0 02        	bne cangh0		; yes, loop counter is good.
001920  3  C6 rr        	dec z80_b		; one less row to write.
001922  3               cangh0:
001922  3  20 A7 1A     	jsr tstbl		; get map address.
001925  3               cangh1:
001925  3  20 3D 19     	jsr lrchk		; standard left/right check.
001928  3  F0 01        	beq :+
00192A  3  60           	rts			; no way through.
00192B  3               :
00192B  3  48           	pha
00192C  3  18           	clc
00192D  3  A5 rr        	lda bufaddr
00192F  3  69 20        	adc #32			; look down.
001931  3  85 rr        	sta bufaddr
001933  3  90 02        	bcc :+
001935  3  E6 rr        	inc bufaddr+1
001937  3               :
001937  3  68           	pla
001938  3               
001938  3  C6 rr        	dec z80_b
00193A  3  D0 E9        	bne cangh1
00193C  3  60           	rts
00193D  3               
00193D  3               ;-------------------------------------
00193D  3               ; Check left/right movement is okay.
00193D  3               ;
00193D  3               ; Input:
00193D  3               ;  bufaddr = MAP + x/8 + y/8*32
00193D  3               ;
00193D  3               ; Output:
00193D  3               ;  A  = 0 is ok, A <>0 is not ok
00193D  3               ;-------------------------------------
00193D  3               
00193D  3               lrchk:
00193D  3  A0 00        	ldy #0
00193F  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
001941  3  C9 02        	cmp #WALL 		; is it passable?
001943  3  F0 0A        	beq lrchkx		; no.
001945  3               
001945  3  C9 04        	cmp #FODDER		; fodder has to be dug.
001947  3  F0 06        	beq lrchkx		; not passable.
001949  3  A9 00        	lda #0
00194B  3  60           	rts
00194C  3               
00194C  3               ;--------------------------------------------------------------
00194C  3               ; Called by mmenu
00194C  3               ;--------------------------------------------------------------
00194C  3               
00194C  3               always:
00194C  3  A9 FF        	lda #255		; report it as okay.
00194E  3  60           	rts
00194F  3               
00194F  3               lrchkx:
00194F  3  A9 01        	lda #1 			; reset all bits.
001951  3  60           	rts
001952  3               
001952  3               
001952  3               ;--------------------------------------------------------------
001952  3               ; Check platform or solid item is not in way.
001952  3               ;
001952  3               ; Input:
001952  3               ;  bufaddr = MAP + x/8 + y/8*32
001952  3               ;
001952  3               ; Output:
001952  3               ;  A  = 0 is ok, A <>0 is not ok
001952  3               ;--------------------------------------------------------------
001952  3               
001952  3               plchk:
001952  3  A0 00        	ldy #0
001954  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
001956  3  C9 02        	cmp #WALL 		; is it passable?
001958  3  F0 F5        	beq lrchkx		; no.
00195A  3               
00195A  3  C9 04        	cmp #FODDER		; fodder has to be dug.
00195C  3  F0 F1        	beq lrchkx		; not passable.
00195E  3               
00195E  3  C9 01        	cmp #PLATFM		; platform is solid.
001960  3  F0 07        	beq plchkx		; not passable.
001962  3               
001962  3  C9 03        	cmp #LADDER		; is it a ladder?
001964  3  F0 E9        	beq lrchkx		; on ladder, deny movement.
001966  3               plchk0:
001966  3  A9 00        	lda #0			; report as ok
001968  3  60           	rts
001969  3               plchkx:
001969  3  A5 rr        	lda dispy		; x coordinate.
00196B  3  29 07        	and #7			; position straddling blocks.
00196D  3  F0 E0        	beq lrchkx		; on platform, deny movement.
00196F  3  4C 66 19     	jmp plchk0
001972  3               
001972  3               ;--------------------------------------------------------------
001972  3               ; Check ladder is available.
001972  3               ;
001972  3               ; Input:
001972  3               ;  bufaddr = MAP + x/8 + y/8*32
001972  3               ;
001972  3               ; Output:
001972  3               ;  A  = 0 is ok, A <>0 is not ok
001972  3               ;--------------------------------------------------------------
001972  3               
001972  3               ldchk:
001972  3  A0 00        	ldy #0
001974  3  B1 rr        	lda (bufaddr),y 	; fetch cell.
001976  3  C9 03        	cmp #LADDER 		; is it a ladder?
001978  3  F0 03        	beq :+
00197A  3  A9 01        	lda #1
00197C  3  60           	rts  			; return with zero flag set accordingly.
00197D  3               :
00197D  3  A9 00        	lda #0
00197F  3  60           	rts
001980  3               
001980  3               ;--------------------------------------------------------------
001980  3               ; Get collectables.
001980  3               ;--------------------------------------------------------------
001980  3               
001980  3               getcol:
001980  3  A9 08            lda #COLECT             ; collectable blocks.
001982  3  85 rr            sta z80_b
001984  3  20 EC 19         jsr tded                ; test for collectable blocks.
001987  3  C5 rr            cmp z80_b               ; did we find one?
001989  3  F0 01            beq :+
00198B  3  60               rts                     ; none were found, job done.
00198C  3               :
00198C  3  20 95 19         jsr gtblk               ; get block.
00198F  3               
00198F  3  20 4E 28         jsr evnt20              ; collected block event.
001992  3  4C 80 19         jmp getcol              ; repeat until none left.
001995  3               
001995  3               ; Get collectable block.
001995  3               
001995  3               gtblk:
001995  3  A0 00        	ldy #0
001997  3  B1 rr        	lda (bufaddr),y
001999  3  85 rr        	sta z80_a
00199B  3  A9 00                lda #0
00199D  3  91 rr                sta (bufaddr),y		; make it empty now.
00199F  3               
00199F  3  A5 rr        	lda bufaddr		; set dispx
0019A1  3  29 1F        	and #31
0019A3  3  85 rr        	sta dispx
0019A5  3               
0019A5  3  A5 rr        	lda bufaddr+1		; Set dispy
0019A7  3  38           	sec
0019A8  3  E9 03        	sbc #>MAP
0019AA  3  85 rr        	sta bufaddr+1
0019AC  3  06 rr        	asl bufaddr
0019AE  3  26 rr        	rol bufaddr+1
0019B0  3  06 rr        	asl bufaddr
0019B2  3  26 rr        	rol bufaddr+1
0019B4  3  06 rr        	asl bufaddr
0019B6  3  26 rr        	rol bufaddr+1
0019B8  3  A5 rr        	lda bufaddr+1
0019BA  3  85 rr        	sta dispy
0019BC  3               
0019BC  3  A5 rr        	lda colpatt		; get blocknr
0019BE  3  85 rr        	sta z80_e		; displacement in e.
0019C0  3  A9 00        	lda #0
0019C2  3  85 rr        	sta z80_d		; no high byte.
0019C4  3  06 rr        	asl z80_e  		; multiply char by 8.
0019C6  3  26 rr        	rol z80_d
0019C8  3  06 rr        	asl z80_e
0019CA  3  26 rr        	rol z80_d
0019CC  3  06 rr        	asl z80_e
0019CE  3  26 rr        	rol z80_d
0019D0  3  18           	clc
0019D1  3  A5 rr        	lda z80_e
0019D3  3  69 A2        	adc #<chgfx 		; address of graphics.
0019D5  3  85 rr        	sta tileaddr
0019D7  3  A5 rr        	lda z80_d
0019D9  3  69 28        	adc #>chgfx
0019DB  3  85 rr        	sta tileaddr+1
0019DD  3  20 F3 16     	jsr gprad 		; get screen address.
0019E0  3  A0 07        	ldy #7			; number of pixel rows to write.
0019E2  3               gtblk0:
0019E2  3  B1 rr        	lda (tileaddr),y 	; get image byte.
0019E4  3  51 rr        	eor (scraddr),y 	; XOR tile on screen
0019E6  3  91 rr        	sta (scraddr),y 	; copy to screen.
0019E8  3  88           	dey	 		; repeat for 8 pixel rows.
0019E9  3  10 F7        	bpl gtblk0
0019EB  3  60           	rts
0019EC  3               
0019EC  3               ;--------------------------------------------------------------
0019EC  3               ; Touched deadly block check.
0019EC  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
0019EC  3               ;
0019EC  3               ; Input:
0019EC  3               ;  IX = sprite address
0019EC  3               ;
0019EC  3               ; Output:
0019EC  3               ;  A  = 0 is ok, A=5 is not ok
0019EC  3               ;--------------------------------------------------------------
0019EC  3               
0019EC  3               tded:
0019EC  3  A0 08        	ldy #8
0019EE  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0019F0  3  85 rr        	sta dispy
0019F2  3  C8           	iny
0019F3  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0019F5  3  85 rr        	sta dispx		; coords in dispx,dispy.
0019F7  3  20 A7 1A     	jsr tstbl		; get map address.
0019FA  3  48           	pha
0019FB  3  A9 1F        	lda #31			; default distance to next line down.
0019FD  3  85 rr        	sta z80_e
0019FF  3  68           	pla
001A00  3  C5 rr        	cmp z80_b		; is this the required block?
001A02  3  D0 01        	bne :+
001A04  3  60           	rts			; yes.
001A05  3               :
001A05  3  E6 rr        	inc bufaddr 		; next cell.
001A07  3  D0 02        	bne :+
001A09  3  E6 rr        	inc bufaddr+1
001A0B  3               :
001A0B  3  A0 00        	ldy #0
001A0D  3  B1 rr        	lda (bufaddr),y		; fetch type.
001A0F  3  C5 rr        	cmp z80_b 		; is this deadly/custom?
001A11  3  D0 01        	bne :+
001A13  3  60           	rts			; yes.
001A14  3               :
001A14  3  A5 rr        	lda dispx		; horizontal position.
001A16  3  85 rr        	sta z80_c 		; store column in c register.
001A18  3  29 07        	and #7			; is it straddling cells?
001A1A  3  D0 03        	bne :+
001A1C  3  4C 30 1A     	jmp tded0		; no.
001A1F  3               :
001A1F  3  E6 rr        	inc bufaddr 		; last cell.
001A21  3  D0 02        	bne :+
001A23  3  E6 rr        	inc bufaddr+1
001A25  3               :
001A25  3  A0 00        	ldy #0
001A27  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001A29  3  C5 rr        	cmp z80_b		; is this the block?
001A2B  3  D0 01        	bne :+
001A2D  3  60           	rts			; yes.
001A2E  3               :
001A2E  3  C6 rr        	dec z80_e		; one less cell to next row down.
001A30  3               tded0:
001A30  3  18           	clc 			; point to next row.
001A31  3  A5 rr        	lda bufaddr
001A33  3  65 rr        	adc z80_e
001A35  3  85 rr        	sta bufaddr
001A37  3  90 02        	bcc :+
001A39  3  E6 rr        	inc bufaddr+1
001A3B  3               :
001A3B  3  A0 00        	ldy #0
001A3D  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
001A3F  3  C5 rr        	cmp z80_b		; is this fatal?
001A41  3  D0 01        	bne :+
001A43  3  60           	rts			; yes.
001A44  3               :
001A44  3  E6 rr        	inc bufaddr 		; next cell.
001A46  3  D0 02        	bne :+
001A48  3  E6 rr        	inc bufaddr+1
001A4A  3               :
001A4A  3  A0 00        	ldy #0
001A4C  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001A4E  3  C5 rr        	cmp z80_b		; is this fatal?
001A50  3  D0 01        	bne :+
001A52  3  60           	rts			; yes.
001A53  3               :
001A53  3  A5 rr        	lda z80_c		; horizontal position.
001A55  3  29 07        	and #7			; is it straddling cells?
001A57  3  D0 03        	bne :+
001A59  3  4C 6B 1A     	jmp tded1 		; no.
001A5C  3               :
001A5C  3  E6 rr        	inc bufaddr		; last cell.
001A5E  3  D0 02        	bne :+
001A60  3  E6 rr        	inc bufaddr+1
001A62  3               :
001A62  3  A0 00        	ldy #0
001A64  3  B1 rr        	lda (bufaddr),y		; fetch type.
001A66  3  C5 rr        	cmp z80_b		; is this fatal?
001A68  3  D0 01        	bne :+
001A6A  3  60           	rts			; yes.
001A6B  3               :
001A6B  3               tded1:
001A6B  3  A5 rr        	lda dispy		; vertical position.
001A6D  3  29 07        	and #7 			; is it straddling cells?
001A6F  3  D0 01        	bne :+
001A71  3  60           	rts			; no, job done.
001A72  3               :
001A72  3  18           	clc			; point to next row.
001A73  3  A5 rr        	lda bufaddr
001A75  3  65 rr        	adc z80_e
001A77  3  85 rr        	sta bufaddr
001A79  3  90 02        	bcc :+
001A7B  3  E6 rr        	inc bufaddr+1
001A7D  3               :
001A7D  3  A0 00        	ldy #0
001A7F  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
001A81  3  C5 rr        	cmp z80_b		; is this fatal?
001A83  3  D0 01        	bne :+
001A85  3  60           	rts			; yes.
001A86  3               :
001A86  3  E6 rr        	inc bufaddr		; next cell.
001A88  3  D0 02        	bne :+
001A8A  3  E6 rr        	inc bufaddr+1
001A8C  3               :
001A8C  3  A0 00        	ldy #0
001A8E  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001A90  3  C5 rr        	cmp z80_b		; is this fatal?
001A92  3  D0 01        	bne :+
001A94  3  60           	rts			; yes.
001A95  3               :
001A95  3  A5 rr        	lda z80_c		; horizontal position.
001A97  3  29 07        	and #7			; is it straddling cells?
001A99  3  D0 01        	bne :+
001A9B  3  60           	rts			; no.
001A9C  3               :
001A9C  3  E6 rr        	inc bufaddr		; last cell.
001A9E  3  D0 02        	bne :+
001AA0  3  E6 rr        	inc bufaddr+1
001AA2  3               :
001AA2  3  A0 00        	ldy #0
001AA4  3  B1 rr        	lda (bufaddr),y		; fetch final type.
001AA6  3  60           	rts 			; return with final type in accumulator.
001AA7  3               
001AA7  3               ;---------------------------------------------------
001AA7  3               ; Fetch block type at (dispx, dispy).
001AA7  3               ;
001AA7  3               ; Output:
001AA7  3               ;  A = block type
001AA7  3               ;---------------------------------------------------
001AA7  3               
001AA7  3               tstbl:
001AA7  3  A5 rr        	lda dispy 		; fetch y coord.
001AA9  3  4A           	lsr a			; bufaddr = y/8
001AAA  3  4A           	lsr a
001AAB  3  4A           	lsr a
001AAC  3  85 rr        	sta bufaddr
001AAE  3  A9 00        	lda #0
001AB0  3  85 rr        	sta bufaddr+1
001AB2  3               
001AB2  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
001AB4  3  26 rr        	rol bufaddr+1
001AB6  3  06 rr        	asl bufaddr
001AB8  3  26 rr        	rol bufaddr+1
001ABA  3  06 rr        	asl bufaddr
001ABC  3  26 rr        	rol bufaddr+1
001ABE  3  06 rr        	asl bufaddr
001AC0  3  26 rr        	rol bufaddr+1
001AC2  3  06 rr        	asl bufaddr
001AC4  3  26 rr        	rol bufaddr+1
001AC6  3               
001AC6  3  A5 rr        	lda dispx		; x/8
001AC8  3  4A           	lsr a
001AC9  3  4A           	lsr a
001ACA  3  4A           	lsr a
001ACB  3               
001ACB  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
001ACC  3  65 rr        	adc bufaddr
001ACE  3  69 00        	adc #<MAP
001AD0  3  85 rr        	sta bufaddr
001AD2  3  A5 rr        	lda bufaddr+1
001AD4  3  69 03        	adc #>MAP
001AD6  3  85 rr        	sta bufaddr+1
001AD8  3               
001AD8  3  A0 00        	ldy #0
001ADA  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
001ADC  3  60           	rts
001ADD  3               
001ADD  3               ;-------------------------------------------------------------------
001ADD  3               ; Jump - if we can.
001ADD  3               ; Requires initial speed to be set up in accumulator prior to call.
001ADD  3               ;
001ADD  3               ; Input:
001ADD  3               ;  IX = sprite address
001ADD  3               ;-------------------------------------------------------------------
001ADD  3               
001ADD  3               jump:
001ADD  3  A0 0D        	ldy #var_jumpLo
001ADF  3  B1 rr        	lda (z80_ix),y		; jump table low.
001AE1  3  A0 0E        	ldy #var_jumpHi
001AE3  3  11 rr        	ora (z80_ix),y		; jump table high.
001AE5  3  F0 01        	beq :+
001AE7  3  60           	rts			; already in the air.
001AE8  3               :
001AE8  3  A9 1B        	lda #>jtab
001AEA  3  A0 0E        	ldy #var_jumpHi
001AEC  3  91 rr        	sta (z80_ix),y		; set jump high.
001AEE  3  A9 00        	lda #<jtab		; jump table start.
001AF0  3  A0 0D        	ldy #var_jumpLo
001AF2  3  91 rr        	sta (z80_ix),y		; set jump low.
001AF4  3  60           	rts
001AF5  3               
001AF5  3               ; Jump table.
001AF5  3  xx xx xx xx  .align 32
001AF9  3  xx xx xx xx  
001AFD  3  xx xx xx     
001B00  3               jtab:
001B00  3  F8 FA FC     	.byte 248,250,252
001B03  3  FE FE FF     	.byte 254,254,255
001B06  3  FF FF 00 00  	.byte 255,255,0,0
001B0A  3  00 01 01 01  	.byte 0,1,1,1,2,2
001B0E  3  02 02        
001B10  3  04 06 08 08  	.byte 4,6,8,8,8,99
001B14  3  08 63        
001B16  3               .align 1
001B16  3               
001B16  3               ;------------------------------------------------
001B16  3               ; Random numbers code.
001B16  3               ; Pseudo-random number generator, 8-bit.
001B16  3               ;
001B16  3               ; Output:
001B16  3               ;  RND = random number
001B16  3               ;------------------------------------------------
001B16  3               
001B16  3               random:
001B16  3  A5 rr        	lda seed		; get last random number.
001B18  3  0A           	asl a
001B19  3  0A           	asl a
001B1A  3  18           	clc
001B1B  3  65 rr        	adc seed
001B1D  3  18           	clc
001B1E  3  69 45        	adc #$45
001B20  3  85 rr        	sta seed		; store new seed.
001B22  3  85 rr        	sta varrnd		; return number in variable.
001B24  3  60           	rts
001B25  3               
001B25  3               ;-------------------------------------------------------
001B25  3               ; Joystick and keyboard reading routines.
001B25  3               ;
001B25  3               ; contrl = 0, Keyboard
001B25  3               ;          1, JoyKeyb
001B25  3               ;          2, JoyMMC
001B25  3               ;-------------------------------------------------------
001B25  3               
001B25  3               joykey:
001B25  3  A5 rr        	lda contrl 		; control flag.
001B27  3  C9 01        	cmp #1
001B29  3  D0 03        	bne :+
001B2B  3  4C 49 1B     	jmp joyjoy 		; read keyboard joystick
001B2E  3               :
001B2E  3  C9 02        	cmp #2
001B30  3  D0 03        	bne :+
001B32  3  4C F6 0E     	jmp joysin 		; read MMC joystick.
001B35  3               :
001B35  3               ; Keyboard controls.
001B35  3               
001B35  3  A9 00        	lda #0		 	; zero reading.
001B37  3  85 rr        	sta z80_e
001B39  3               
001B39  3  A0 06        	ldy #6	 		; address of last key.
001B3B  3               joyke0:
001B3B  3  B9 B5 3D     	lda keys,y 		; get key from table.
001B3E  3  20 CC 0E     	jsr ktest		; being pressed?
001B41  3  26 rr        	rol z80_e 		; rotate into reading.
001B43  3               
001B43  3  88           	dey		 	; next key.
001B44  3  10 F5        	bpl joyke0 		; repeat for all keys.
001B46  3  4C 5A 1B     	jmp joyjo1 		; store the value.
001B49  3               
001B49  3               ; Keyboard joystick controls.
001B49  3               
001B49  3               joyjoy:
001B49  3  A9 00        	lda #0		 	; zero reading.
001B4B  3  85 rr        	sta z80_e
001B4D  3               
001B4D  3  A0 06        	ldy #6	 		; address of last key.
001B4F  3               joyjo3:
001B4F  3  B9 62 0E     	lda jkeys,y 		; get key from table.
001B52  3  20 CC 0E     	jsr ktest		; being pressed?
001B55  3  26 rr        	rol z80_e 		; rotate into reading.
001B57  3               
001B57  3  88           	dey		 	; next key.
001B58  3  10 F5        	bpl joyjo3 		; repeat for all keys.
001B5A  3               joyjo1:
001B5A  3  A5 rr        	lda z80_e 		; copy e register to accumulator.
001B5C  3               joyjo2:
001B5C  3  85 rr        	sta joyval		; remember value.
001B5E  3  60           	rts
001B5F  3               
001B5F  3               ;---------------------------------------------------------------
001B5F  3               ; Display message.
001B5F  3               ;
001B5F  3               ; Input:
001B5F  3               ;  A = message number
001B5F  3               ;---------------------------------------------------------------
001B5F  3               
001B5F  3               dmsg:
001B5F  3  AA           	tax
001B60  3  A9 50        	lda #<msgdat		; pointer to messages.
001B62  3  85 rr        	sta z80_l
001B64  3  A9 28        	lda #>msgdat
001B66  3  85 rr        	sta z80_h
001B68  3  20 7E 1C     	jsr getwrd		; get message number.
001B6B  3               dmsg3:
001B6B  3  20 6B 1C     	jsr preprt		; pre-printing stuff.
001B6E  3  20 B5 15     	jsr checkx		; make sure we"re in a printable range.
001B71  3  A5 rr        	lda prtmod		; print mode.
001B73  3  D0 47        	bne bmsg1		; no, double-height text.
001B75  3               dmsg0:
001B75  3  A5 rr        	lda z80_h		; store string pointer.
001B77  3  48           	pha
001B78  3  A5 rr        	lda z80_l
001B7A  3  48           	pha
001B7B  3               
001B7B  3  A0 00        	ldy #0
001B7D  3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
001B7F  3  29 7F        	and #127		; remove any end marker.
001B81  3  C9 0D        	cmp #ASCII_NEWLINE
001B83  3  F0 24        	beq dmsg1
001B85  3  20 BF 10     	jsr pchar		; display character.
001B88  3  20 56 1C     	jsr nexpos 		; display position.
001B8B  3  D0 03        	bne dmsg2		; not on a new line.
001B8D  3  20 5D 1C     	jsr nexlin		; next line down.
001B90  3               dmsg2:
001B90  3  68           	pla			; retrieve string pointer
001B91  3  85 rr        	sta z80_l
001B93  3  68           	pla
001B94  3  85 rr        	sta z80_h
001B96  3               
001B96  3  A0 00        	ldy #0
001B98  3  B1 rr        	lda (z80_hl),y		; fetch last character.
001B9A  3  0A           	asl a  			; was it the end?
001B9B  3  90 03        	bcc :+
001B9D  3  4C FA 15     	jmp dscor2		; yes, job done.
001BA0  3               :
001BA0  3  E6 rr        	inc z80_l		; next character to display.
001BA2  3  D0 02        	bne :+
001BA4  3  E6 rr        	inc z80_h
001BA6  3               :
001BA6  3  4C 75 1B     	jmp dmsg0
001BA9  3               dmsg1:
001BA9  3  E6 rr        	inc dispy
001BAB  3  A5 rr        	lda dispy
001BAD  3  C9 18        	cmp #24
001BAF  3  90 04        	bcc dmsg4
001BB1  3  A9 00        	lda #0
001BB3  3  85 rr        	sta dispy
001BB5  3               dmsg4:
001BB5  3  A9 00        	lda #0
001BB7  3  85 rr        	sta dispx
001BB9  3  4C 90 1B     	jmp dmsg2
001BBC  3               
001BBC  3               ;----------------------------------------------------------
001BBC  3               ; Display message in big text.
001BBC  3               ;
001BBC  3               ; Input:
001BBC  3               ;  HL = string pointer
001BBC  3               ;----------------------------------------------------------
001BBC  3               
001BBC  3               bmsg1:
001BBC  3  A0 00        	ldy #0
001BBE  3  B1 rr        	lda (z80_hl),y 		; get character to display.
001BC0  3  29 7F        	and #127		; only want 7 bits.
001BC2  3  C9 0D        	cmp #ASCII_NEWLINE
001BC4  3  F0 13        	beq bmsg2
001BC6  3  20 EE 1B     	jsr bchar 		; display big char.
001BC9  3               bmsg3:
001BC9  3  A0 00        	ldy #0
001BCB  3  B1 rr        	lda (z80_hl),y 		; look at last character.
001BCD  3  48           	pha
001BCE  3  E6 rr        	inc z80_l 		; next character in list.
001BD0  3  D0 02        	bne :+
001BD2  3  E6 rr        	inc z80_h
001BD4  3               :
001BD4  3  68           	pla
001BD5  3  0A           	asl a  			; was terminator flag set?
001BD6  3  90 E4        	bcc bmsg1		; no, keep going.
001BD8  3               :
001BD8  3  60           	rts
001BD9  3               bmsg2:
001BD9  3  A9 00        	lda #0
001BDB  3  85 rr        	sta dispx
001BDD  3  E6 rr        	inc dispy
001BDF  3  E6 rr        	inc dispy
001BE1  3  A5 rr        	lda dispy
001BE3  3  C9 17        	cmp #23
001BE5  3  90 E2        	bcc bmsg3
001BE7  3  A9 00        	lda #0
001BE9  3  85 rr        	sta dispy
001BEB  3  4C C9 1B     	jmp bmsg3
001BEE  3               
001BEE  3               ;----------------------------------------------------------
001BEE  3               ; Big character display.
001BEE  3               ;
001BEE  3               ; Input:
001BEE  3               ;  A = character
001BEE  3               ;----------------------------------------------------------
001BEE  3               
001BEE  3               bchar:
001BEE  3  85 rr        	sta z80_e		; save char in lb
001BF0  3  A9 00        	lda #0
001BF2  3  85 rr        	sta z80_d		; reset hb
001BF4  3               
001BF4  3  06 rr        	asl z80_e 		; multiply char by 8.
001BF6  3  26 rr        	rol z80_d
001BF8  3  06 rr        	asl z80_e
001BFA  3  26 rr        	rol z80_d
001BFC  3  06 rr        	asl z80_e
001BFE  3  26 rr        	rol z80_d		; de = a*8
001C00  3               
001C00  3  18           	clc			; de = FontPtr + a*8
001C01  3  A5 rr        	lda z80_e
001C03  3  65 rr        	adc FontPtr 		; address of font.
001C05  3  85 rr        	sta z80_e
001C07  3  A5 rr        	lda z80_d
001C09  3  65 rr        	adc FontPtr+1
001C0B  3  85 rr        	sta z80_d
001C0D  3               
001C0D  3  20 F3 16     	jsr gprad 		; get screen address.
001C10  3               
001C10  3  A2 00        	ldx #0			; height of character in font.
001C12  3               bchar0:
001C12  3  A0 00        	ldy #0
001C14  3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
001C16  3               
001C16  3  49 FF        	eor #TxtInvert		; Invert
001C18  3               
001C18  3  91 rr        	sta (scraddr),y
001C1A  3  48           	pha
001C1B  3  20 1F 10     	jsr nline 		; next line down.
001C1E  3  68           	pla
001C1F  3  91 rr        	sta (scraddr),y
001C21  3  20 1F 10     	jsr nline 		; next line down.
001C24  3               
001C24  3  18           	clc
001C25  3  E6 rr        	inc z80_e 		; next line of font.
001C27  3  D0 02        	bne :+
001C29  3  E6 rr        	inc z80_d
001C2B  3               :
001C2B  3  E8           	inx
001C2C  3  E0 08        	cpx #8
001C2E  3  D0 E2        	bne bchar0
001C30  3               
001C30  3  20 56 1C     	jsr nexpos		; display position.
001C33  3  D0 05        	bne bchar2 		; not on a new line.
001C35  3               bchar3:
001C35  3  E6 rr        	inc dispy
001C37  3  20 5D 1C     	jsr nexlin 		; next line check.
001C3A  3               bchar2:
001C3A  3  4C FA 15     	jmp dscor2		; tidy up line and column variables.
001C3D  3               
001C3D  3               
001C3D  3               ;-------------------------------------------------
001C3D  3               ; Display a character.
001C3D  3               ;
001C3D  3               ; Input:
001C3D  3               ;  A = character
001C3D  3               ;-------------------------------------------------
001C3D  3               
001C3D  3               achar:
001C3D  3  85 rr        	sta z80_b 		; copy to b.
001C3F  3  20 6B 1C     	jsr preprt 		; get ready to print.
001C42  3  A5 rr        	lda z80_b		; character in accumulator.
001C44  3  A6 rr        	ldx prtmod 		; print mode.
001C46  3  F0 03        	beq :+
001C48  3  4C EE 1B     	jmp bchar 		; no, double-height text.
001C4B  3               :
001C4B  3  20 BF 10     	jsr pchar 		; display character.
001C4E  3  20 56 1C     	jsr nexpos 		; display position.
001C51  3  F0 E2        	beq bchar3		; next line down.
001C53  3  4C 3A 1C     	jmp bchar2 		; tidy up.
001C56  3               
001C56  3               
001C56  3               ;-------------------------------------------------
001C56  3               ; Get next print column position.
001C56  3               ;-------------------------------------------------
001C56  3               
001C56  3               nexpos:
001C56  3  E6 rr        	inc dispx		; move along one position.
001C58  3  A5 rr        	lda dispx 		; get coordinate.
001C5A  3  29 1F        	and #31
001C5C  3  60           	rts 			; return with status in zero flag.
001C5D  3               
001C5D  3               ;-------------------------------------------------
001C5D  3               ; Get next print line position.
001C5D  3               ;-------------------------------------------------
001C5D  3               
001C5D  3               nexlin:
001C5D  3  E6 rr        	inc dispy 		; newline.
001C5F  3  A5 rr        	lda dispy		; vertical position.
001C61  3  C9 18        	cmp #24			; past screen edge?
001C63  3  B0 01        	bcs :+
001C65  3  60           	rts			; no, still okay.
001C66  3               :
001C66  3  A9 00        	lda #0			; restart at top.
001C68  3  85 rr        	sta dispy
001C6A  3  60           	rts
001C6B  3               
001C6B  3               ;--------------------------------------------------------
001C6B  3               ; Pre-print preliminaries.
001C6B  3               ;--------------------------------------------------------
001C6B  3               
001C6B  3               preprt:
001C6B  3  A5 rr        	lda FontPtr		; font pointer.
001C6D  3  8D B3 15     	sta grbase		; set up graphics base.
001C70  3  A5 rr        	lda FontPtr+1
001C72  3  8D B4 15     	sta grbase+1
001C75  3               prescr:
001C75  3  A5 rr        	lda charx 		; display coordinates.
001C77  3  85 rr        	sta dispx		; set up general coordinates.
001C79  3  A5 rr        	lda chary
001C7B  3  85 rr        	sta dispy
001C7D  3  60           	rts
001C7E  3               
001C7E  3               ;--------------------------------------------------------------
001C7E  3               ; Get messagenr x in hl
001C7E  3               ;
001C7E  3               ; Input:
001C7E  3               ;  HL = pointer to message list
001C7E  3               ;  X  = message number.
001C7E  3               ;--------------------------------------------------------------
001C7E  3               
001C7E  3               getwrd:
001C7E  3  E0 00        	cpx #0
001C80  3  D0 01        	bne:+ 			; first word in list?
001C82  3  60           	rts 			; yep, don't search.
001C83  3               :
001C83  3  A0 00        	ldy #0
001C85  3               getwd0:
001C85  3  B1 rr        	lda (z80_hl),y
001C87  3  48           	pha
001C88  3  E6 rr        	inc z80_l
001C8A  3  D0 02        	bne :+
001C8C  3  E6 rr        	inc z80_h
001C8E  3               :
001C8E  3  68           	pla
001C8F  3  C9 80        	cmp #128		; found end?
001C91  3  30 F2        	bmi getwd0		; no, carry on.
001C93  3  CA           	dex			; until we have right number.
001C94  3  D0 EF        	bne getwd0
001C96  3  60           	rts
001C97  3               
001C97  3               ;-----------------------------------------------------------
001C97  3               ; Bubble sort.
001C97  3               ;-----------------------------------------------------------
001C97  3               
001C97  3               bsort:
001C97  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
001C99  3  85 rr        	sta qscnt
001C9B  3               
001C9B  3  A9 00        	lda #<sprtab 		; sprite table.
001C9D  3  85 rr        	sta z80_x
001C9F  3  A9 0B        	lda #>sprtab
001CA1  3  85 rr        	sta z80_i
001CA3  3               bsort0:
001CA3  3  A0 00        	ldy #0
001CA5  3  B1 rr        	lda (z80_ix),y 		; first sprite type.
001CA7  3  C9 FF        	cmp #255 		; is it switched off?
001CA9  3  F0 30        	beq swemp		; yes, may need to switch another in here.
001CAB  3               
001CAB  3  A0 11        	ldy #TABSIZ
001CAD  3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
001CAF  3  C9 FF        	cmp #255 		; is it enabled?
001CB1  3  F0 0A        	beq bsort2 		; no, nothing to swap.
001CB3  3               
001CB3  3  A0 14        	ldy #TABSIZ+3
001CB5  3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
001CB7  3  A0 03        	ldy #3
001CB9  3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
001CBB  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
001CBD  3               bsort2:
001CBD  3  18           	clc
001CBE  3  A5 rr        	lda z80_x
001CC0  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001CC2  3  85 rr        	sta z80_x
001CC4  3  90 02        	bcc :+
001CC6  3  E6 rr        	inc z80_i
001CC8  3               :
001CC8  3  C6 rr        	dec qscnt
001CCA  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
001CCC  3  60           	rts
001CCD  3               
001CCD  3               bsort1:
001CCD  3  A0 11        	ldy #TABSIZ
001CCF  3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
001CD1  3  C9 FF        	cmp #255		; is it enabled?
001CD3  3  F0 E8        	beq bsort2		; no, nothing to swap.
001CD5  3  20 E9 1C     	jsr swspr		; swap positions.
001CD8  3  4C BD 1C     	jmp bsort2
001CDB  3               swemp:
001CDB  3  A0 11        	ldy #TABSIZ
001CDD  3  B1 rr        	lda (z80_ix),y		; next table entry.
001CDF  3  C9 FF        	cmp #255		; is that one on?
001CE1  3  F0 DA        	beq bsort2		; no, nothing to swap.
001CE3  3  20 E9 1C     	jsr swspr		; swap positions.
001CE6  3  4C BD 1C     	jmp bsort2
001CE9  3               
001CE9  3               ; Swap sprites.
001CE9  3               
001CE9  3               swspr:
001CE9  3  A5 rr        	lda z80_x		; table address
001CEB  3  85 rr        	sta z80_e		; copy to de pair.
001CED  3  85 rr        	sta z80_l		; copy to hl pair.
001CEF  3  A5 rr        	lda z80_i
001CF1  3  85 rr        	sta z80_h
001CF3  3  85 rr        	sta z80_d
001CF5  3               
001CF5  3  18           	clc
001CF6  3  A5 rr        	lda z80_l
001CF8  3  69 11        	adc #TABSIZ		; distance to second entry.
001CFA  3  85 rr        	sta z80_l
001CFC  3  90 02        	bcc :+
001CFE  3  E6 rr        	inc z80_h
001D00  3               :
001D00  3  A9 11        	lda #TABSIZ		; bytes to swap.
001D02  3  85 rr        	sta z80_b
001D04  3  A0 00        	ldy #0
001D06  3               swspr0:
001D06  3  B1 rr        	lda (z80_hl),y		; fetch second byte.
001D08  3  48           	pha
001D09  3  B1 rr        	lda (z80_de),y 		; fetch first byte.
001D0B  3  91 rr        	sta (z80_hl),y 		; copy to second.
001D0D  3  68           	pla
001D0E  3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
001D10  3               
001D10  3  E6 rr        	inc z80_e 		; next byte.
001D12  3  D0 02        	bne :+
001D14  3  E6 rr        	inc z80_d
001D16  3               :
001D16  3  E6 rr        	inc z80_l 		; next byte.
001D18  3  D0 02        	bne :+
001D1A  3  E6 rr        	inc z80_h
001D1C  3               :
001D1C  3  C6 rr        	dec z80_b
001D1E  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
001D20  3  60           	rts
001D21  3               
001D21  3               ;----------------------------------------------------
001D21  3               ; Process sprites.
001D21  3               ;----------------------------------------------------
001D21  3               
001D21  3               pspr:
001D21  3  A9 0C        	lda #NUMSPR		; sprites to process.
001D23  3  85 rr        	sta sprptr
001D25  3               
001D25  3  A9 00        	lda #<sprtab 		; sprite table.
001D27  3  85 rr        	sta z80_x
001D29  3  A9 0B        	lda #>sprtab
001D2B  3  85 rr        	sta z80_i
001D2D  3               pspr1:
001D2D  3  A0 00        	ldy #0
001D2F  3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
001D31  3  C9 09        	cmp #9 			; within range of sprite types?
001D33  3  B0 03        	bcs :+
001D35  3  20 48 1D     	jsr pspr2 		; yes, process this one.
001D38  3               :
001D38  3  18           	clc
001D39  3  A5 rr        	lda z80_x
001D3B  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001D3D  3  85 rr        	sta z80_x
001D3F  3  90 02        	bcc :+
001D41  3  E6 rr        	inc z80_i		; next sprite.
001D43  3               :
001D43  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
001D45  3  D0 E6        	bne pspr1
001D47  3  60           	rts
001D48  3               
001D48  3               pspr2:
001D48  3  A5 rr        	lda z80_x 		; store original sprite pointer.
001D4A  3  85 rr        	sta ogptr
001D4C  3  A5 rr        	lda z80_i
001D4E  3  85 rr        	sta ogptr+1
001D50  3  20 5C 1D     	jsr pspr3		; do the routine.
001D53  3               rtorg:
001D53  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
001D55  3  85 rr        	sta z80_x
001D57  3  A5 rr        	lda ogptr+1
001D59  3  85 rr        	sta z80_i
001D5B  3               rtorg0:
001D5B  3  60           	rts
001D5C  3               
001D5C  3               pspr3:
001D5C  3  A9 91        	lda #<evtyp0		; sprite type events list.
001D5E  3  85 rr        	sta z80_l
001D60  3  A9 1D        	lda #>evtyp0
001D62  3  85 rr        	sta z80_h
001D64  3               pspr4:
001D64  3  B1 rr        	lda (z80_ix),y
001D66  3  0A           	asl a			; double accumulator.
001D67  3  18           	clc
001D68  3  65 rr        	adc z80_l
001D6A  3  85 rr        	sta z80_l
001D6C  3  90 02        	bcc :+
001D6E  3  E6 rr        	inc z80_h
001D70  3               :
001D70  3  B1 rr        	lda (z80_hl),y
001D72  3  85 rr        	sta z80_e 		; copy to de.
001D74  3  48           	pha
001D75  3               
001D75  3  E6 rr        	inc z80_l 		; next byte of address.
001D77  3  D0 02        	bne :+
001D79  3  E6 rr        	inc z80_h
001D7B  3               :
001D7B  3  B1 rr        	lda (z80_hl),y 		; address high.
001D7D  3  85 rr        	sta z80_d
001D7F  3               
001D7F  3  48           	pha	 		; swap address into hl.
001D80  3  A5 rr        	lda z80_h
001D82  3  85 rr        	sta z80_d
001D84  3  68           	pla
001D85  3  85 rr        	sta z80_h
001D87  3  68           	pla
001D88  3  85 rr        	sta z80_l
001D8A  3  A5 rr        	lda z80_l
001D8C  3  85 rr        	sta z80_e
001D8E  3               
001D8E  3  6C rr rr     	jmp (z80_hl) 		; go there.
001D91  3               
001D91  3               ; Address of each sprite type's routine.
001D91  3               
001D91  3  1D 23        evtyp0:	.word evnt00
001D93  3  CF 23        evtyp1:	.word evnt01
001D95  3  59 24        evtyp2:	.word evnt02
001D97  3  2F 25        evtyp3:	.word evnt03
001D99  3  06 26        evtyp4:	.word evnt04
001D9B  3  90 26        evtyp5:	.word evnt05
001D9D  3  24 27        evtyp6:	.word evnt06
001D9F  3  6F 27        evtyp7:	.word evnt07
001DA1  3  70 27        evtyp8:	.word evnt08
001DA3  3               
001DA3  3               ;--------------------------------------------------------------
001DA3  3               ; Display sprites.
001DA3  3               ;
001DA3  3               ; Input:
001DA3  3               ;  IX = sprite table
001DA3  3               ;--------------------------------------------------------------
001DA3  3               
001DA3  3               dspr:
001DA3  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
001DA5  3  85 rr        	sta sprcnt
001DA7  3               
001DA7  3               dspr0:
001DA7  3  A0 00        	ldy #var_Type
001DA9  3  B1 rr        	lda (z80_ix),y 		; get sprite type.
001DAB  3  C9 FF        	cmp #255 			; is it enabled?
001DAD  3  D0 45        	bne dspr1 			; yes, it needs deleting.
001DAF  3               
001DAF  3               dspr5:
001DAF  3  A0 05        	ldy #var_newType
001DB1  3  B1 rr        	lda (z80_ix),y 		; new type.
001DB3  3  C9 FF        	cmp #255			; is it enabled?
001DB5  3  F0 03        	beq dspr2			; no, skip
001DB7  3  4C 43 1E     	jmp dspr3 			; yes, it needs drawing.
001DBA  3               
001DBA  3               dspr2:
001DBA  3  A0 05        	ldy #var_newType
001DBC  3  B1 rr        	lda (z80_ix),y 		; copy new type.
001DBE  3  A0 00        	ldy #var_Type
001DC0  3  91 rr        	sta (z80_ix),y
001DC2  3  A0 06        	ldy #var_newImage
001DC4  3  B1 rr        	lda (z80_ix),y 		; copy new image number.
001DC6  3  A0 01        	ldy #var_Image
001DC8  3  91 rr        	sta (z80_ix),y
001DCA  3  A0 07        	ldy #var_newFrame
001DCC  3  B1 rr        	lda (z80_ix),y 		; copy new frame.
001DCE  3  A0 02        	ldy #var_Frame
001DD0  3  91 rr        	sta (z80_ix),y
001DD2  3  A0 08        	ldy #var_newY
001DD4  3  B1 rr        	lda (z80_ix),y 		; copy new y.
001DD6  3  A0 03        	ldy #var_Y
001DD8  3  91 rr        	sta (z80_ix),y
001DDA  3  A0 09        	ldy #var_newX
001DDC  3  B1 rr        	lda (z80_ix),y 		; copy new x.
001DDE  3  A0 04        	ldy #var_X
001DE0  3  91 rr        	sta (z80_ix),y
001DE2  3               
001DE2  3  18           	clc
001DE3  3  A5 rr        	lda z80_x
001DE5  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
001DE7  3  85 rr        	sta z80_x
001DE9  3  A5 rr        	lda z80_i
001DEB  3  69 00        	adc #0
001DED  3  85 rr        	sta z80_i 			; next sprite.
001DEF  3  C6 rr        	dec sprcnt
001DF1  3  D0 B4        	bne dspr0			; repeat for remaining sprites.
001DF3  3  60           	rts
001DF4  3               
001DF4  3               dspr1:
001DF4  3               	; _BEEB clipping code copied from CPC Engine
001DF4  3  A0 03        	ldy #var_Y
001DF6  3  B1 rr        	lda (z80_ix), y		; old x coord
001DF8  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001DFA  3  B0 B3        	bcs dspr5			; yes, don't delete it.
001DFC  3               
001DFC  3  A0 05        	ldy #var_newType
001DFE  3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
001E00  3  C9 FF        	cmp #255			; is this enabled?
001E02  3  D0 06        	bne dspr4 			; yes, display both.
001E04  3               
001E04  3               dspr6:
001E04  3  20 D1 0F     	jsr sspria 			; show single sprite.
001E07  3  4C BA 1D     	jmp dspr2
001E0A  3               
001E0A  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
001E0A  3               
001E0A  3               dspr4:
001E0A  3               	; _BEEB clipping code copied from CPC Engine
001E0A  3  A0 08        	ldy #var_newY
001E0C  3  B1 rr        	lda (z80_ix), y		; old x coord
001E0E  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001E10  3  B0 F2        	bcs dspr6			; yes, don't display it.
001E12  3               
001E12  3  A0 04        	ldy #var_X
001E14  3  B1 rr        	lda (z80_ix),y		; old x.
001E16  3  A0 09        	ldy #var_newX
001E18  3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
001E1A  3  D0 21        	bne dspr7 			; they differ, need to redraw.
001E1C  3               
001E1C  3  A0 03        	ldy #var_Y
001E1E  3  B1 rr        	lda (z80_ix),y		; old y.
001E20  3  A0 08        	ldy #var_newY
001E22  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001E24  3  D0 17        	bne dspr7			; they differ, need to redraw.
001E26  3               
001E26  3  A0 02        	ldy #var_Frame
001E28  3  B1 rr        	lda (z80_ix),y 		; old frame.
001E2A  3  A0 07        	ldy #var_newFrame
001E2C  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001E2E  3  D0 0D        	bne dspr7 			; they differ, need to redraw.
001E30  3               
001E30  3  A0 01        	ldy #var_Image
001E32  3  B1 rr        	lda (z80_ix),y 		; old image.
001E34  3  A0 06        	ldy #var_newImage
001E36  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001E38  3  D0 03        	bne dspr7 			; they differ, need to redraw.
001E3A  3  4C BA 1D     	jmp dspr2			; everything is the same, don't redraw.
001E3D  3               
001E3D  3               dspr7:
001E3D  3  20 E3 0F     	jsr sspric 			; delete old sprite, draw new one simultaneously.
001E40  3  4C BA 1D     	jmp dspr2
001E43  3               
001E43  3               dspr3:
001E43  3               	; _BEEB clipping code copied from CPC Engine
001E43  3  A0 08        	ldy #var_newY
001E45  3  B1 rr        	lda (z80_ix), y		; old x coord
001E47  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001E49  3  90 03        	bcc :+				; no, continue
001E4B  3  4C BA 1D     	jmp dspr2			; yes, don't display it.
001E4E  3               :
001E4E  3  20 DD 0F     	jsr ssprib 			; show single sprite.
001E51  3  4C BA 1D     	jmp dspr2
001E54  3               
001E54  3               ;-----------------------------------------
001E54  3               ; Get sprite address calculations.
001E54  3               ; gspran = new sprite, gsprad = old sprite.
001E54  3               ;
001E54  3               ; Input:
001E54  3               ;  IX = sprite address
001E54  3               ;-----------------------------------------
001E54  3               
001E54  3               gspran:
001E54  3  A0 08        	ldy #var_newY
001E56  3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
001E58  3  85 rr        	sta dispy
001E5A  3  A0 09        	ldy #var_newX
001E5C  3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
001E5E  3  85 rr        	sta dispx
001E60  3  A0 06        	ldy #var_newImage
001E62  3  B1 rr        	lda (z80_ix),y 		; new sprite image.
001E64  3  20 25 21     	jsr gfrm		; fetch start frame for this sprite.
001E67  3               
001E67  3  A0 00        	ldy #0
001E69  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
001E6B  3  A0 07        	ldy #var_newFrame
001E6D  3  18           	clc
001E6E  3  71 rr        	adc (z80_ix),y 		; new add frame number.
001E70  3  4C 8F 1E     	jmp gspra0
001E73  3               
001E73  3               ;-----------------------------------------
001E73  3               ; Calculate old sprite address
001E73  3               ;
001E73  3               ; Input:
001E73  3               ;  IX = sprite address
001E73  3               ;
001E73  3               ; Output:
001E73  3               ;  B  = right byte mask
001E73  3               ;  C  = left byte mask
001E73  3               ;  DE = spriteframe address
001E73  3               ;  scraddr = screenaddress(dispx,dispy)
001E73  3               ;-----------------------------------------
001E73  3               
001E73  3               gsprad:
001E73  3  A0 03        	ldy #var_Y
001E75  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001E77  3  85 rr        	sta dispy
001E79  3  A0 04        	ldy #var_X
001E7B  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001E7D  3  85 rr        	sta dispx
001E7F  3  A0 01        	ldy #var_Image
001E81  3  B1 rr        	lda (z80_ix),y 		; sprite image.
001E83  3  20 25 21     	jsr gfrm 		; fetch start frame for this sprite.
001E86  3               
001E86  3  A0 00        	ldy #0
001E88  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
001E8A  3  A0 02        	ldy #var_Frame
001E8C  3  18           	clc
001E8D  3  71 rr        	adc (z80_ix),y 		; add frame number.
001E8F  3               
001E8F  3               gspra0:
001E8F  3  4A           	lsr a	  		; multiply by 128.
001E90  3  85 rr        	sta z80_d 		; store in d.
001E92  3  A9 00        	lda #0
001E94  3  6A           	ror a
001E95  3  85 rr        	sta z80_e 		; got low byte.
001E97  3               
001E97  3  18           	clc 			; address of play sprites.
001E98  3  A5 rr        	lda z80_e
001E9A  3  69 32        	adc #<sprgfx
001E9C  3  85 rr        	sta z80_e
001E9E  3  A5 rr        	lda z80_d
001EA0  3  69 29        	adc #>sprgfx
001EA2  3  85 rr        	sta z80_d
001EA4  3               
001EA4  3  A5 rr        	lda dispx 		; y coordinate.
001EA6  3  29 06        	and #6 			; position within byte boundary.
001EA8  3  AA           	tax	 		; low byte of table displacement.
001EA9  3               
001EA9  3  0A           	asl a	  		; multiply by 32.
001EAA  3  0A           	asl a  			; already a multiple
001EAB  3  0A           	asl a  			; of 2, so just 4
001EAC  3  0A           	asl a  			; shifts needed.
001EAD  3               
001EAD  3  18           	clc 			; add to sprite address.
001EAE  3  65 rr        	adc z80_e
001EB0  3  85 rr        	sta z80_e
001EB2  3  90 02        	bcc :+
001EB4  3  E6 rr        	inc z80_d
001EB6  3               :
001EB6  3  BD C3 1E     	lda spmask,x		 ; pointer to mask table.
001EB9  3  85 rr        	sta z80_c 		; left mask.
001EBB  3  BD C4 1E     	lda spmask+1,x
001EBE  3  85 rr        	sta z80_b 		; right mask.
001EC0  3               ; Drop into screen address routine.
001EC0  3  4C BD 0F     	jmp scadd
001EC3  3               
001EC3  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
001EC7  3  0F F0 03 FC  
001ECB  3               
001ECB  3               
001ECB  3               ;-----------------------------------------------------------
001ECB  3               ; Animates a sprite.
001ECB  3               ;
001ECB  3               ; Input:
001ECB  3               ;  IX = sprite address
001ECB  3               ;  HL = last sprite address
001ECB  3               ;-----------------------------------------------------------
001ECB  3               
001ECB  3               animsp:
001ECB  3  25 rr        	and frmno
001ECD  3  F0 01        	beq :+
001ECF  3  60           	rts
001ED0  3               :
001ED0  3  A0 06        	ldy #var_newImage
001ED2  3  B1 rr        	lda (z80_ix),y		; sprite image
001ED4  3  20 25 21     	jsr gfrm		; get frame data.
001ED7  3               
001ED7  3  E6 rr        	inc z80_l		; point to frames.
001ED9  3  D0 02        	bne :+
001EDB  3  E6 rr        	inc z80_h
001EDD  3               :
001EDD  3  A0 07        	ldy #var_newFrame
001EDF  3  B1 rr        	lda (z80_ix),y		; sprite frame.
001EE1  3  18           	clc
001EE2  3  69 01        	adc #1			; next one along.
001EE4  3  A0 00        	ldy #0
001EE6  3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
001EE8  3  90 02        	bcc anims0		; no, not yet.
001EEA  3  A9 00        	lda #0			; start at first frame.
001EEC  3               anims0:
001EEC  3  A0 07        	ldy #var_newFrame
001EEE  3  91 rr        	sta (z80_ix),y		; new frame.
001EF0  3  60           	rts
001EF1  3               
001EF1  3               ;--------------------------------------------------------------
001EF1  3               ; Animate back
001EF1  3               ;
001EF1  3               ; Input:
001EF1  3               ;  IX = sprite address
001EF1  3               ;  HL = last sprite address
001EF1  3               ;--------------------------------------------------------------
001EF1  3               
001EF1  3               animbk:
001EF1  3  25 rr        	and frmno
001EF3  3  F0 01        	beq :+
001EF5  3  60           	rts
001EF6  3               :
001EF6  3  A0 06        	ldy #var_newImage
001EF8  3  B1 rr        	lda (z80_ix),y		; sprite image.
001EFA  3  20 25 21     	jsr gfrm		; get frame data.
001EFD  3               
001EFD  3  E6 rr        	inc z80_l 		; point to frames.
001EFF  3  D0 02        	bne :+
001F01  3  E6 rr        	inc z80_h
001F03  3               :
001F03  3  A0 07        	ldy #var_newFrame
001F05  3  B1 rr        	lda (z80_ix),y 		; sprite frame.
001F07  3  F0 03        	beq :+
001F09  3  4C 10 1F     	jmp rtanb0 		; yes, start at end.
001F0C  3               :
001F0C  3  A0 00        	ldy #0
001F0E  3  B1 rr        	lda (z80_hl),y 		; last sprite.
001F10  3               rtanb0:
001F10  3  38           	sec
001F11  3  E9 01        	sbc #1			; next one along.
001F13  3  4C EC 1E     	jmp anims0		; set new frame.
001F16  3               
001F16  3               ;--------------------------------------------------------------
001F16  3               ; Check for collision with other sprite, strict enforcement.
001F16  3               ;
001F16  3               ; Input:
001F16  3               ;  b		= sprite to test for
001F16  3               ;  ix		= current sprite pointer
001F16  3               ;
001F16  3               ; global:	b
001F16  3               ; local:	x,y,hl,de,skptr
001F16  3               ; calls:	-
001F16  3               ;--------------------------------------------------------------
001F16  3               
001F16  3               sktyp:
001F16  3  A9 00        	lda #<sprtab				; sprite table.
001F18  3  85 rr        	sta z80_l
001F1A  3  A9 0B        	lda #>sprtab
001F1C  3  85 rr        	sta z80_h
001F1E  3               numsp2:
001F1E  3  A9 0C        	lda #NUMSPR				; number of sprites.
001F20  3  85 rr        	sta sktptr
001F22  3               sktyp0:
001F22  3  A5 rr        	lda z80_l 				; store pointer to sprite.
001F24  3  85 rr        	sta skptr
001F26  3  A5 rr        	lda z80_h
001F28  3  85 rr        	sta skptr+1
001F2A  3               
001F2A  3  A0 00        	ldy #0
001F2C  3  B1 rr        	lda (z80_hl),y 				; get sprite type.
001F2E  3  C5 rr        	cmp z80_b				; is it the type we seek?
001F30  3  F0 1D        	beq coltyp				; yes, we can use this one.
001F32  3               :
001F32  3               sktyp1:
001F32  3  18           	clc
001F33  3  A5 rr        	lda skptr				; retrieve sprite pointer.
001F35  3  69 11        	adc #TABSIZ				; size of each entry.
001F37  3  85 rr        	sta z80_l
001F39  3  A5 rr        	lda skptr+1
001F3B  3  69 00        	adc #0
001F3D  3  85 rr        	sta z80_h
001F3F  3  C6 rr        	dec sktptr					; one less iteration.
001F41  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
001F43  3               :
001F43  3  A9 00        	lda #0					; default to ROM address - no sprite.
001F45  3  85 rr        	sta z80_l
001F47  3  85 rr        	sta z80_h
001F49  3  85 rr        	sta skptr				; store pointer to sprite.
001F4B  3  85 rr        	sta skptr+1
001F4D  3               
001F4D  3  18           	clc					; don't return with zero flag set.
001F4E  3  60           	rts 					; didn't find one.
001F4F  3               
001F4F  3               coltyp:
001F4F  3  A0 00        	ldy #0
001F51  3  B1 rr        	lda (z80_ix),y				; current sprite type.
001F53  3  C5 rr        	cmp z80_b				; seeking sprite of same type?
001F55  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
001F57  3               colty0:
001F57  3  A0 09        	ldy #9					; distance to x position in table.
001F59  3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
001F5B  3  85 rr        	sta z80_e
001F5D  3  88           	dey
001F5E  3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
001F60  3  85 rr        	sta z80_d
001F62  3               
001F62  3               ; Drop into collision detection.
001F62  3               
001F62  3               colc16:
001F62  3  A0 09        	ldy #9
001F64  3  B1 rr        	lda (z80_ix),y			 	; x coord.
001F66  3  38           	sec					; subtract x.
001F67  3  E5 rr        	sbc z80_e
001F69  3  B0 05        	bcs  colc1a 				; result is positive.
001F6B  3  49 FF        	eor #$ff				; make negative positive.
001F6D  3  18           	clc
001F6E  3  69 01        	adc #1
001F70  3               colc1a:
001F70  3  C9 10        	cmp #16 				; within x range?
001F72  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
001F74  3  85 rr        	sta z80_c				; store difference.
001F76  3               
001F76  3  A0 08        	ldy #8
001F78  3  B1 rr        	lda (z80_ix),y				; y coord.
001F7A  3  38           	sec
001F7B  3  E5 rr        	sbc z80_d				; subtract y.
001F7D  3  B0 05        	bcs colc1b				; result is positive.
001F7F  3  49 FF        	eor #$ff				; make negative positive.
001F81  3  18           	clc
001F82  3  69 01        	adc #1
001F84  3               colc1b:
001F84  3  C9 10        	cmp #16					; within y range?
001F86  3  B0 AA        	bcs sktyp1 				; no - they've missed.
001F88  3  18           	clc					; add x difference.
001F89  3  65 rr        	adc z80_c
001F8B  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
001F8D  3  B0 02        	bcs :+
001F8F  3  38           	sec
001F90  3  60           	rts 					; carry set if there's a collision.
001F91  3               :
001F91  3  4C 32 1F     	jmp sktyp1				; try next sprite in table.
001F94  3               colty1:
001F94  3  A5 rr        	lda z80_x  				; compare the two.
001F96  3  C5 rr        	cmp z80_l
001F98  3  D0 09        	bne end_col
001F9A  3  A5 rr        	lda z80_i
001F9C  3  C5 rr        	cmp z80_h
001F9E  3  D0 03        	bne end_col
001FA0  3  4C 32 1F     	jmp sktyp1 				; addresses are identical.
001FA3  3               end_col:
001FA3  3  4C 57 1F     	jmp colty0
001FA6  3               
001FA6  3               ;-----------------------------------------------------------
001FA6  3               ; Display number, left aligned
001FA6  3               ;
001FA6  3               ; Input:
001FA6  3               ;  a		= number
001FA6  3               ;
001FA6  3               ; global:	-
001FA6  3               ; local:	a,y,bc,hl,displ0
001FA6  3               ; calls:	num2ch,dmsg3
001FA6  3               ;-----------------------------------------------------------
001FA6  3               
001FA6  3               disply:
001FA6  3  85 rr        	sta z80_a
001FA8  3  A9 CE        	lda #<displ0				; display workspace.
001FAA  3  85 rr        	sta z80_c
001FAC  3  A9 1F        	lda #>displ0
001FAE  3  85 rr        	sta z80_b
001FB0  3  A5 rr        	lda z80_a
001FB2  3  20 32 13     	jsr num2ch				; convert accumulator to string.
001FB5  3               displ1:
001FB5  3  C6 rr        	dec z80_c				; back one character.
001FB7  3  D0 02        	bne :+
001FB9  3  C6 rr        	dec z80_b
001FBB  3               :
001FBB  3  A0 00        	ldy #0
001FBD  3  B1 rr        	lda (z80_bc),y				; fetch digit.
001FBF  3  09 80        	ora #128				; insert end marker.
001FC1  3  91 rr        	sta (z80_bc),y				; new value.
001FC3  3               
001FC3  3  A9 CE        	lda #<displ0				; display space.
001FC5  3  85 rr        	sta z80_l
001FC7  3  A9 1F        	lda #>displ0
001FC9  3  85 rr        	sta z80_h
001FCB  3  4C 6B 1B     	jmp dmsg3				; display the string.
001FCE  3               
001FCE  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
001FD2  3               
001FD2  3               ;----------------------------------------------------------------
001FD2  3               ; Initialise screen.
001FD2  3               ;
001FD2  3               ; global:	roomtb,scno
001FD2  3               ; local:	-
001FD2  3               ; calls:	tstcs
001FD2  3               ;----------------------------------------------------------------
001FD2  3               
001FD2  3               initsc:
001FD2  3  AD 11 23     	lda roomtb 			; whereabouts in the map are we?
001FD5  3  20 DF 1F     	jsr tstsc 			; find displacement.
001FD8  3  C9 FF        	cmp #255 			; is it valid?
001FDA  3  F0 02        	beq init_end 			; no, it's rubbish.
001FDC  3  85 rr        	sta scno			; store new room number.
001FDE  3               init_end:
001FDE  3  60           	rts
001FDF  3               
001FDF  3               ;----------------------------------------------------------------
001FDF  3               ; Test screen.
001FDF  3               ;
001FDF  3               ; global:	-
001FDF  3               ; local:	x
001FDF  3               ; calls:	-
001FDF  3               ;----------------------------------------------------------------
001FDF  3               
001FDF  3               tstsc:
001FDF  3  85 rr        	sta tmproom
001FE1  3  18           	clc
001FE2  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
001FE4  3  AA           	tax 				; add displacement to map data.
001FE5  3  BD 13 23     	lda mapdat-MAPWID,x 		; find room number there.
001FE8  3  60           	rts
001FE9  3               
001FE9  3               ;--------------------------
001FE9  3               ; Screen left.
001FE9  3               ;--------------------------
001FE9  3               
001FE9  3               scrl:
001FE9  3  AD 11 23     	lda roomtb 			; present room table pointer.
001FEC  3  38           	sec
001FED  3  E9 01        	sbc #1				; room left.
001FEF  3               scrl0:
001FEF  3  20 DF 1F     	jsr tstsc			; test screen.
001FF2  3  C9 FF        	cmp #255			; is there a screen this way?
001FF4  3  D0 01        	bne :+
001FF6  3  60           	rts				; no, return to loop.
001FF7  3               :
001FF7  3  A5 rr        	lda tmproom			; restore room displacement.
001FF9  3  8D 11 23     	sta roomtb			; new room table position.
001FFC  3               scrl1:
001FFC  3  20 D2 1F     	jsr initsc 			; set new screen.
001FFF  3  A9 02        	lda #2
002001  3  85 rr        	sta restfl 			; set it.
002003  3  60           	rts
002004  3               scrr:
002004  3  AD 11 23     	lda roomtb 			; room table pointer.
002007  3  18           	clc
002008  3  69 01        	adc #1				; room right.
00200A  3  4C EF 1F     	jmp scrl0
00200D  3               scru:
00200D  3  AD 11 23     	lda roomtb 			; room table pointer.
002010  3  38           	sec
002011  3  E9 03        	sbc #MAPWID 			; room up.
002013  3  4C EF 1F     	jmp scrl0
002016  3               scrd:
002016  3  AD 11 23     	lda roomtb 			; room table pointer.
002019  3  18           	clc
00201A  3  69 03        	adc #MAPWID 			; room down.
00201C  3  4C EF 1F     	jmp scrl0
00201F  3               
00201F  3               ;-----------------------------------------
00201F  3               ; Jump to new screen.
00201F  3               ;-----------------------------------------
00201F  3               
00201F  3               nwscr:
00201F  3  A2 00        	ldx #0				; start of map data.
002021  3               nwscr0:
002021  3  DD 16 23     	cmp mapdat,x
002024  3  F0 06        	beq nwscr1			; have we found a match for screen?
002026  3  E8           	inx 				; next room.
002027  3  E0 50        	cpx #80				; zero room count, 80 to search.
002029  3  D0 F6        	bne nwscr0			; keep looking.
00202B  3  60           	rts
00202C  3               nwscr1:
00202C  3  8E 11 23     	stx roomtb			; set the map position.
00202F  3  4C FC 1F     	jmp scrl1			; draw new room.
002032  3               
002032  3               
002032  3               ;----------------------------------------------------------
002032  3               ; Gravity processing.
002032  3               ;----------------------------------------------------------
002032  3               
002032  3               grav:
002032  3  A0 0D        	ldy #var_jumpLo
002034  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002036  3  85 rr        	sta z80_l
002038  3  A0 0E        	ldy #var_jumpHi
00203A  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
00203C  3  85 rr        	sta z80_h
00203E  3  05 rr        	ora z80_l			; merge in low byte.
002040  3  D0 01        	bne :+
002042  3  60           	rts				; if neither is set, we're not in the air.
002043  3               :
002043  3  A0 00        	ldy #0
002045  3  B1 rr        	lda (z80_hl),y			; pixels to move.
002047  3  85 rr        	sta z80_a
002049  3  C9 63        	cmp #99				; reached the end?
00204B  3  D0 06        	bne grav0			; no, continue.
00204D  3               grav2:
00204D  3  C6 rr        	dec z80_l			; go back to previous value.
00204F  3               	; 6502 WARNING - not updating 16-bit pointer properly!
00204F  3  B1 rr        	lda (z80_hl),y			; fetch that from table.
002051  3  85 rr        	sta z80_a
002053  3               grav0:
002053  3  E6 rr        	inc z80_l			; point to next table entry.
002055  3               	; 6502 WARNING - not updating 16-bit pointer properly!
002055  3  A5 rr        	lda z80_l
002057  3  A0 0D        	ldy #var_jumpLo
002059  3  91 rr        	sta (z80_ix),y			; store new pointer low.
00205B  3  A5 rr        	lda z80_h
00205D  3  A0 0E        	ldy #var_jumpHi
00205F  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002061  3               grav1:
002061  3  A5 rr        	lda z80_a
002063  3  D0 01        	bne :+				; any movement required?
002065  3  60           	rts				; no, not this time.
002066  3               :
002066  3  A5 rr        	lda z80_a
002068  3  C9 80        	cmp #128			; is it up or down?
00206A  3  B0 15        	bcs gravu			; it's up.
00206C  3               gravd:
00206C  3  85 rr        	sta z80_b			; set pixels to move.
00206E  3               gravd0:
00206E  3  20 C0 18     	jsr cangd			; can we go down?
002071  3  D0 28        	bne gravst			; can't move down, so stop.
002073  3  A0 08        	ldy #8
002075  3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
002077  3  18           	clc
002078  3  69 01        	adc #1
00207A  3  91 rr        	sta (z80_ix),y
00207C  3  C6 rr        	dec z80_b
00207E  3  D0 EE        	bne gravd0
002080  3  60           	rts
002081  3               gravu:
002081  3  49 FF        	eor #$ff			; flip the sign so it's positive.
002083  3  18           	clc
002084  3  69 01        	adc #1
002086  3  85 rr        	sta z80_b			; set pixels to move.
002088  3               gravu0:
002088  3  20 8B 18     	jsr cangu			; can we go up?
00208B  3  D0 6E        	bne ifalls			; can't move up, go down next.
00208D  3  A0 08        	ldy #8
00208F  3  B1 rr        	lda (z80_ix),y
002091  3  38           	sec
002092  3  E9 01        	sbc #1
002094  3  91 rr        	sta (z80_ix),y			; adjust new x coord.
002096  3  C6 rr        	dec z80_b
002098  3  D0 EE        	bne gravu0
00209A  3  60           	rts
00209B  3               gravst:
00209B  3  A0 0D        	ldy #var_jumpLo
00209D  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
00209F  3  85 rr        	sta z80_l
0020A1  3  A0 0E        	ldy #var_jumpHi
0020A3  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
0020A5  3  85 rr        	sta z80_h
0020A7  3               
0020A7  3  A9 00        	lda #0				; null value in pointer.
0020A9  3  A0 0D        	ldy #var_jumpLo
0020AB  3  91 rr        	sta (z80_ix),y			; store new pointer low.
0020AD  3  C8           	iny
0020AE  3  91 rr        	sta (z80_ix),y			; store new pointer high.
0020B0  3               
0020B0  3  A0 00        	ldy #0
0020B2  3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
0020B4  3  C9 63        	cmp #99				; is it the end marker?
0020B6  3               evftf:
0020B6  3  F0 01        	beq :+				; yes, fallen too far.
0020B8  3  60           	rts
0020B9  3               :
0020B9  3  4C 39 28     	jmp evnt15			; EVENT FELLTOOFAR
0020BC  3               
0020BC  3               ;------------------------------------------------
0020BC  3               ; Initiate fall check.
0020BC  3               ;------------------------------------------------
0020BC  3               
0020BC  3               ifall:
0020BC  3  A0 0D        	ldy #var_jumpLo
0020BE  3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
0020C0  3  85 rr        	sta z80_l
0020C2  3  A0 0E        	ldy #var_jumpHi
0020C4  3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
0020C6  3  85 rr        	sta z80_h			; high byte in accumulator.
0020C8  3  05 rr        	ora z80_l			; merge in low byte.
0020CA  3  F0 01        	beq :+
0020CC  3  60           	rts				; if either is set, we're already in the air.
0020CD  3               :
0020CD  3  A0 09        	ldy #9
0020CF  3  B1 rr        	lda (z80_ix),y			; y coordinate.
0020D1  3  85 rr        	sta dispx
0020D3  3               numsp7:
0020D3  3  A0 08        	ldy #8
0020D5  3  B1 rr        	lda (z80_ix),y			; look x coordinate.
0020D7  3  18           	clc
0020D8  3  69 10        	adc #16				; add 16 pixels.
0020DA  3  85 rr        	sta dispy			; set up test coordinates.
0020DC  3  20 A7 1A     	jsr tstbl			; get map address.
0020DF  3  20 52 19     	jsr plchk			; block, platform check.
0020E2  3  F0 01        	beq :+
0020E4  3  60           	rts				; it's solid, don't fall.
0020E5  3               :
0020E5  3  E6 rr        	inc bufaddr			; look right one cell.
0020E7  3  20 52 19     	jsr plchk			; block, platform check.
0020EA  3  F0 01        	beq :+
0020EC  3  60           	rts				; it's solid, don't fall.
0020ED  3               :
0020ED  3  A5 rr        	lda dispx			; y coordinate.
0020EF  3  29 07        	and #7				; position straddling block cells.
0020F1  3  F0 08        	beq ifalls			; no more checks needed.
0020F3  3  E6 rr        	inc bufaddr			; look to third cell.
0020F5  3  20 52 19     	jsr plchk			; block, platform check.
0020F8  3  F0 01        	beq :+
0020FA  3  60           	rts				; it's solid, don't fall.
0020FB  3               :
0020FB  3               ifalls:
0020FB  3  A9 00        	lda #<jtab			; jump table start.
0020FD  3  85 rr        	sta z80_l
0020FF  3  A9 1B        	lda #>jtab
002101  3  85 rr        	sta z80_h
002103  3               ifal0:
002103  3  E6 rr        	inc z80_l			; point to next value.
002105  3  D0 02        	bne :+
002107  3  E6 rr        	inc z80_h
002109  3               :
002109  3  A0 00        	ldy #0
00210B  3  B1 rr        	lda (z80_hl),y			; fetch value.
00210D  3  F0 F4        	beq ifal0			; no, get next value.
00210F  3  C9 63        	cmp #99				; reached end of table?
002111  3  D0 01        	bne :+
002113  3  60           	rts				; yes, don't fall.
002114  3               :
002114  3  C9 80        	cmp #128			; is it going up?
002116  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
002118  3               
002118  3  A0 0D        	ldy #var_jumpLo
00211A  3  A5 rr        	lda z80_l
00211C  3  91 rr        	sta (z80_ix),y 			; set jump low.
00211E  3  A0 0E        	ldy #var_jumpHi
002120  3  A5 rr        	lda z80_h
002122  3  91 rr        	sta (z80_ix),y 			; set jump high.
002124  3  60           	rts
002125  3               
002125  3               
002125  3               ;----------------------------------------------------
002125  3               ; Get frame data for a particular sprite.
002125  3               ; Input:
002125  3               ;  a		= framenumer
002125  3               ; Output:
002125  3               ;  hl		= frame address
002125  3               ;
002125  3               ; global:	hl,frmptr
002125  3               ; local:	-
002125  3               ; calls:	-
002125  3               ;----------------------------------------------------
002125  3               
002125  3               gfrm:
002125  3  0A           	asl a	 		 	; multiple of 2.
002126  3  18           	clc
002127  3  6D 04 11     	adc frmptr 			; frames used by game.
00212A  3  85 rr        	sta z80_l
00212C  3  AD 05 11     	lda frmptr+1
00212F  3  69 00        	adc #0
002131  3  85 rr        	sta z80_h 			; point to frame start.
002133  3  60           	rts
002134  3               
002134  3               ;----------------------------------------------------
002134  3               ; Find sprite list for current room.
002134  3               ;
002134  3               ; global:	hl
002134  3               ; local:	x,y
002134  3               ; calls:	-
002134  3               ;----------------------------------------------------
002134  3               
002134  3               sprlst:
002134  3  A9 EB        	lda #<nmedat 			; list of enemy sprites.
002136  3  85 rr        	sta z80_l
002138  3  A9 39        	lda #>nmedat
00213A  3  85 rr        	sta z80_h
00213C  3  A6 rr        	ldx scno 			; screen number.
00213E  3  D0 01        	bne sprls2 			; is it the first screen?
002140  3  60           	rts 				; yes, don't need to search data.
002141  3               sprls2:
002141  3  A0 00        	ldy #0
002143  3               sprls1:
002143  3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
002145  3  C9 FF        	cmp #255			; is it an end marker?
002147  3  F0 0E        	beq sprls0 			; yes, end of this room.
002149  3               
002149  3  18           	clc 				; point to next sprite in list.
00214A  3  A5 rr        	lda z80_l
00214C  3  69 04        	adc #NMESIZ
00214E  3  85 rr        	sta z80_l
002150  3  90 02        	bcc :+
002152  3  E6 rr        	inc z80_h
002154  3               :
002154  3  4C 43 21     	jmp sprls1 			; continue until end of room.
002157  3               sprls0:
002157  3  E6 rr        	inc z80_l 			; point to start of next screen.s
002159  3  D0 02        	bne :+
00215B  3  E6 rr        	inc z80_h
00215D  3               :
00215D  3  CA           	dex
00215E  3  D0 E3        	bne sprls1 			; continue until room found.
002160  3  60           	rts
002161  3               
002161  3               
002161  3               ;----------------------------------------------------
002161  3               ; Clear all but a single player sprite.
002161  3               ;
002161  3               ; global:	-
002161  3               ; local:	x,y,ix
002161  3               ; calls:	-
002161  3               ;----------------------------------------------------
002161  3               
002161  3               nspr:
002161  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002163  3  85 rr        	sta sprcnt
002165  3  A9 00        	lda #<sprtab 			; sprite table.
002167  3  85 rr        	sta z80_x
002169  3  A9 0B        	lda #>sprtab
00216B  3  85 rr        	sta z80_i
00216D  3               nspr0:
00216D  3  A0 00        	ldy #0 				; fetch sprite type.
00216F  3  B1 rr        	lda (z80_ix),y 			; is it a player?
002171  3  F0 1A        	beq nspr1 			; yes, keep this one.
002173  3               
002173  3  A9 FF        	lda #255
002175  3  A0 00        	ldy #0 				; fetch sprite type.
002177  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002179  3  A0 05        	ldy #5
00217B  3  91 rr        	sta (z80_ix),y 			; remove next type.
00217D  3               
00217D  3  18           	clc	 			; next sprite.
00217E  3  A5 rr        	lda z80_x
002180  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002182  3  85 rr        	sta z80_x
002184  3  90 02        	bcc :+
002186  3  E6 rr        	inc z80_i
002188  3               :
002188  3  C6 rr        	dec sprcnt	 			; one less space in the table.
00218A  3  D0 E1        	bne nspr0
00218C  3  60           	rts
00218D  3               nspr1:
00218D  3  A9 FF        	lda #255
00218F  3  A0 00        	ldy #0
002191  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002193  3               
002193  3  18           	clc	 			; point to next sprite.
002194  3  A5 rr        	lda z80_x
002196  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002198  3  85 rr        	sta z80_x
00219A  3  90 02        	bcc :+
00219C  3  E6 rr        	inc z80_i
00219E  3               :
00219E  3  C6 rr        	dec sprcnt	 			; one less to do.
0021A0  3  D0 01        	bne nspr2
0021A2  3  60           	rts
0021A3  3               nspr2:
0021A3  3  A9 FF        	lda #255
0021A5  3  A0 00        	ldy #0
0021A7  3  91 rr        	sta (z80_ix),y 			; delete sprite.
0021A9  3  A0 05        	ldy #5
0021AB  3  91 rr        	sta (z80_ix),y 			; remove next type.
0021AD  3               
0021AD  3  18           	clc	 			; next sprite.
0021AE  3  A5 rr        	lda z80_x
0021B0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0021B2  3  85 rr        	sta z80_x
0021B4  3  90 02        	bcc :+
0021B6  3  E6 rr        	inc z80_i
0021B8  3               :
0021B8  3  C6 rr        	dec sprcnt	 			; one less space in table.
0021BA  3  D0 E7        	bne nspr2
0021BC  3  60           	rts
0021BD  3               
0021BD  3               ;----------------------------------------------------------
0021BD  3               ; Two initialisation routines.
0021BD  3               ; Initialise sprites - copy everything from list to table.
0021BD  3               ;
0021BD  3               ; global:	-
0021BD  3               ; local:	x,y,ix
0021BD  3               ; calls:	cpsp
0021BD  3               ;----------------------------------------------------------
0021BD  3               
0021BD  3               ispr:
0021BD  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0021BF  3  85 rr        	sta sprcnt
0021C1  3  A9 00        	lda #<sprtab			; sprite table.
0021C3  3  85 rr        	sta z80_x
0021C5  3  A9 0B        	lda #>sprtab
0021C7  3  85 rr        	sta z80_i
0021C9  3               ispr2:
0021C9  3  A0 00        	ldy #0
0021CB  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0021CD  3  C9 FF        	cmp #255 			; is it an end marker?
0021CF  3  D0 01        	bne :+
0021D1  3  60           	rts 				; yes, no more to do.
0021D2  3               :
0021D2  3               ispr1:
0021D2  3  A0 00        	ldy #0
0021D4  3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
0021D6  3  C9 FF        	cmp #255 			; is it enabled yet?
0021D8  3  D0 08        	bne ispr4			; yes, try another slot.
0021DA  3               
0021DA  3  A0 05        	ldy #5
0021DC  3  B1 rr        	lda (z80_ix),y		 	; next type.
0021DE  3  C9 FF        	cmp #255 			; is it enabled yet?
0021E0  3  F0 10        	beq ispr3 			; no, process this one.
0021E2  3               ispr4:
0021E2  3  18           	clc 				; next sprite.
0021E3  3  A5 rr        	lda z80_x
0021E5  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0021E7  3  85 rr        	sta z80_x
0021E9  3  90 02        	bcc :+
0021EB  3  E6 rr        	inc z80_i
0021ED  3               :
0021ED  3  C6 rr        	dec sprcnt
0021EF  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
0021F1  3  60           	rts  				; no more room in table.
0021F2  3               ispr3:
0021F2  3  20 45 22     	jsr cpsp			; initialise a sprite.
0021F5  3  C6 rr        	dec sprcnt			; one less space in the table.
0021F7  3  D0 D0        	bne ispr2
0021F9  3  60           	rts
0021FA  3               
0021FA  3               
0021FA  3               ;-----------------------------------------------------------------------
0021FA  3               ; Initialise sprites - but not player, we're keeping the old one.
0021FA  3               ;
0021FA  3               ; global:	-
0021FA  3               ; local:	x,y,ix
0021FA  3               ; calls:	cpsp
0021FA  3               ;-----------------------------------------------------------------------
0021FA  3               
0021FA  3               kspr:
0021FA  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
0021FC  3  A9 00        	lda #<sprtab 			; sprite table.
0021FE  3  85 rr        	sta z80_x
002200  3  A9 0B        	lda #>sprtab
002202  3  85 rr        	sta z80_i
002204  3               kspr2:
002204  3  A0 00        	ldy #0
002206  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
002208  3  C9 FF        	cmp #255 			; is it an end marker?
00220A  3  D0 01        	bne :+
00220C  3  60           	rts 				; yes, no more to do.
00220D  3               :
00220D  3  C9 00        	cmp #0
00220F  3  D0 0E        	bne kspr1 			; no, add to table as normal.
002211  3               
002211  3  18           	clc 				; next sprite.
002212  3  A5 rr        	lda z80_l
002214  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
002216  3  85 rr        	sta z80_l
002218  3  90 02        	bcc :+
00221A  3  E6 rr        	inc z80_h
00221C  3               :
00221C  3  4C 04 22     	jmp kspr2
00221F  3               kspr1:
00221F  3  A0 00        	ldy #0 				; fetch sprite type.
002221  3  B1 rr        	lda (z80_ix),y
002223  3  C9 FF        	cmp #255 			; is it enabled yet?
002225  3  D0 08        	bne kspr4 			; yes, try another slot.
002227  3               
002227  3  A0 05        	ldy #5 				; next type.
002229  3  B1 rr        	lda (z80_ix),y
00222B  3  C9 FF        	cmp #255 			; is it enabled yet?
00222D  3  F0 0F        	beq kspr3 			; no, process this one.
00222F  3               kspr4:
00222F  3  18           	clc 				; next sprite.
002230  3  A5 rr        	lda z80_x
002232  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
002234  3  85 rr        	sta z80_x
002236  3  90 02        	bcc :+
002238  3  E6 rr        	inc z80_i
00223A  3               :
00223A  3  CA           	dex	 			; repeat for remaining sprites.
00223B  3  D0 E2        	bne kspr1
00223D  3  60           	rts  				; no more room in table.
00223E  3               kspr3:
00223E  3  20 45 22     	jsr cpsp 			; copy sprite to table.
002241  3  CA           	dex	 			; one less space in the table.
002242  3  D0 C0        	bne kspr2
002244  3  60           	rts
002245  3               
002245  3               ;----------------------------------------------
002245  3               ; Copy sprite from list to table.
002245  3               ;
002245  3               ; global:	hl,ix
002245  3               ; local:	y
002245  3               ; calls:	evnt09
002245  3               ;----------------------------------------------
002245  3               
002245  3               cpsp:
002245  3  A0 00        	ldy #0					; fetch byte from table.
002247  3  B1 rr        	lda (z80_hl),y
002249  3               	; y=var_Type
002249  3  91 rr        	sta (z80_ix),y			; set up type.
00224B  3  A0 05        	ldy #var_newType
00224D  3  91 rr        	sta (z80_ix),y 			; set up type.
00224F  3               
00224F  3  E6 rr        	inc z80_l 				; move to next byte.
002251  3  D0 02        	bne :+
002253  3  E6 rr        	inc z80_h
002255  3               :
002255  3  A0 00        	ldy #0 					; fetch byte from table.
002257  3  B1 rr        	lda (z80_hl),y
002259  3  A0 06        	ldy #var_newImage
00225B  3  91 rr        	sta (z80_ix),y			; set up image.
00225D  3               
00225D  3  E6 rr        	inc z80_l 				; move to next byte.
00225F  3  D0 02        	bne :+
002261  3  E6 rr        	inc z80_h
002263  3               :
002263  3  A0 00        	ldy #0
002265  3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
002267  3  A0 08        	ldy #var_newY
002269  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
00226B  3               
00226B  3  A9 C8        	lda #200 				; set initial coordinate off screen.
00226D  3  A0 03        	ldy #var_Y
00226F  3  91 rr        	sta (z80_ix),y
002271  3               
002271  3  E6 rr        	inc z80_l 				; move to next byte.
002273  3  D0 02        	bne :+
002275  3  E6 rr        	inc z80_h
002277  3               :
002277  3  A0 00        	ldy #0 					; fetch byte from table.
002279  3  B1 rr        	lda (z80_hl),y
00227B  3  A0 09        	ldy #var_newX
00227D  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
00227F  3               
00227F  3  E6 rr        	inc z80_l 				; move to next byte.
002281  3  D0 02        	bne :+
002283  3  E6 rr        	inc z80_h
002285  3               :
002285  3  A9 00        	lda #0					; zeroes in accumulator.
002287  3  A0 07        	ldy #var_newFrame 		; reset frame number.
002289  3  91 rr        	sta (z80_ix),y
00228B  3  A0 0A        	ldy #var_Direction 		; reset direction.
00228D  3  91 rr        	sta (z80_ix),y
00228F  3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
002291  3  91 rr        	sta (z80_ix),y
002293  3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
002295  3  91 rr        	sta (z80_ix),y
002297  3               
002297  3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
002299  3  A0 10        	ldy #var_dataHi
00229B  3  91 rr        	sta (z80_ix),y
00229D  3               evis0:
00229D  3  A5 rr        	lda z80_i
00229F  3  48           	pha
0022A0  3  A5 rr        	lda z80_x
0022A2  3  48           	pha
0022A3  3  A5 rr        	lda z80_h
0022A5  3  48           	pha
0022A6  3  A5 rr        	lda z80_l
0022A8  3  48           	pha
0022A9  3               
0022A9  3  20 96 27     	jsr evnt09 				; perform event.
0022AC  3               
0022AC  3  68           	pla
0022AD  3  85 rr        	sta z80_l
0022AF  3  68           	pla
0022B0  3  85 rr        	sta z80_h
0022B2  3  68           	pla
0022B3  3  85 rr        	sta z80_x
0022B5  3  68           	pla
0022B6  3  85 rr        	sta z80_i
0022B8  3               
0022B8  3  18           	clc
0022B9  3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
0022BB  3  69 11        	adc #TABSIZ		 	; next sprite.
0022BD  3  85 rr        	sta z80_x
0022BF  3  90 02        	bcc :+
0022C1  3  E6 rr        	inc z80_i
0022C3  3               :
0022C3  3  60           	rts
0022C4  3               
0022C4  3               
0022C4  3               ;-------------------------------------
0022C4  3               ; Clear the play area window.
0022C4  3               ;-------------------------------------
0022C4  3               
0022C4  3               clw:
0022C4  3  AD FB 10     	lda wintop			; get coordinates of window.
0022C7  3  85 rr        	sta dispy			; put into dispx for calculation.
0022C9  3  AD FC 10     	lda winlft
0022CC  3  85 rr        	sta dispx
0022CE  3               
0022CE  3  AD FD 10     	lda winhgt			; height of window.
0022D1  3  85 rr        	sta rrow			; copy to b register.
0022D3  3               clw3:
0022D3  3  AD FE 10     	lda winwid 			; width of window.
0022D6  3  85 rr        	sta rcol
0022D8  3               clw2:
0022D8  3  20 F3 16     	jsr gprad 			; get print address.
0022DB  3  A9 00        	lda #0				; zero byte to write.
0022DD  3  A0 07        	ldy #7				; pixel height of each cell.
0022DF  3               clw1:
0022DF  3  91 rr        	sta (scraddr),y 	; copy to screen.
0022E1  3  88           	dey					; next screen row down.
0022E2  3  10 FB        	bpl clw1
0022E4  3               
0022E4  3  E6 rr        	inc dispx			; next column.
0022E6  3  C6 rr        	dec rcol			; one less to do.
0022E8  3  D0 EE        	bne clw2			; repeat for remaining columns.
0022EA  3               
0022EA  3  AD FC 10     	lda winlft			; get left edge.
0022ED  3  85 rr        	sta dispx 			; reset x.
0022EF  3  E6 rr        	inc dispy 			; next line down.
0022F1  3               
0022F1  3  C6 rr        	dec rrow
0022F3  3  D0 DE        	bne clw3			; repeat down the screen.
0022F5  3               
0022F5  3  AD FB 10     	lda wintop			; get coordinates of window.
0022F8  3  85 rr        	sta chary			; put into display position.
0022FA  3  AD FC 10     	lda winlft
0022FD  3  85 rr        	sta charx
0022FF  3  60           	rts
002300  3               
002300  3               
002300  3               ;----------------------------------------------------------
002300  3               ; Effects code.
002300  3               ; Ticker routine is called 25 times per second.
002300  3               ;
002300  3               ; HL = txtscr = left text screen address
002300  3               ; DE = txtscr+txtwid-1 = right text screen address
002300  3               ; BC = txtpos = text scroller position
002300  3               ;
002300  3               ;----------------------------------------------------------
002300  3               
002300  3               .if sflag
002300  3               scrly:
002300  3               	rts
002300  3               	.word txtscr         	; get left screen address.
002300  3               	sta scr_l
002300  3               	lda txtscr+1
002300  3               	sta scr_l+1
002300  3               	sta scr_r+1
002300  3               
002300  3               	stx xtmp
002300  3               
002300  3               	clc         		; get right screen address.
002300  3               	lda scr_l
002300  3               	adc txtwid
002300  3               	sta scr_r
002300  3               	dec scr_r
002300  3               scrly1:
002300  3               	ldy txtwid		; set txtwide
002300  3               	dey
002300  3               	clc
002300  3               scrly0:
002300  3               	lda (scr_l),y		; scroll 1 line
002300  3               	rol a
002300  3               	sta (scr_l),y
002300  3               	dey
002300  3               	bpl scrly0
002300  3               
002300  3               	clc			; point to next line
002300  3               	lda scr_l
002300  3               	adc #32
002300  3               	sta scr_l
002300  3               	bcc scrly1		; repeat 8 times
002300  3               
002300  3               	lda txtpos 		; get text pointer.
002300  3               	sta scr_txt
002300  3               	lda txtpos+1
002300  3               	sta scr_txt+1
002300  3               
002300  3               	ldy #0
002300  3               	lda (scr_txt),y 		; find character we're displaying.
002300  3               	and #127 		; remove end marker bit if applicable.
002300  3               	cmp #ASCII_NEWLINE			; is it newline?
002300  3               	bne scrly5 		; no, it's okay.
002300  3               	lda #32			; convert to a space instead.
002300  3               scrly5:
002300  3               	sta fntaddr		; calculate char address
002300  3               	lda #0
002300  3               	sta fntaddr+1
002300  3               	asl fntaddr  		; multiply char by 8.
002300  3               	rol fntaddr+1
002300  3               	asl fntaddr
002300  3               	rol fntaddr+1
002300  3               	asl fntaddr
002300  3               	rol fntaddr+1
002300  3               	lda fntaddr
002300  3               	clc
002300  3               	adc FontPtr
002300  3               	sta scrly3+1		; that's the low byte.
002300  3               	lda fntaddr+1
002300  3               	adc FontPtr+1
002300  3               	sta scrly3+2		; add displacement.
002300  3               
002300  3               	ldx #0
002300  3               scrly3:
002300  3               	lda $3333,x		; get image of char line.
002300  3               	and txtbit
002300  3               	beq scrly2		; don't plot pixel
002300  3               	ldy scrline,x
002300  3               	lda (scr_r),y
002300  3               	clc
002300  3               	ora #1
002300  3               	sta (scr_r),y		; plot pixel
002300  3               scrly2:
002300  3               	inx			; next line of char.
002300  3               	cpx #8
002300  3               	bne scrly3
002300  3               
002300  3               	lsr txtbit		; bit of text to display.
002300  3               	bcs :+
002300  3               	rts
002300  3               :
002300  3               	ldy #0
002300  3               	lda (scr_txt),y 	; what was the character?
002300  3               	asl a	  		; end of message?
002300  3               	bcs scrly4
002300  3               	inc txtpos
002300  3               	bne :+
002300  3               	inc txtpos+1
002300  3               :
002300  3               	jmp scrly6 		; not yet - continue.
002300  3               scrly4:
002300  3               	lda txtini 		; start of scrolling message.
002300  3               	sta txtpos
002300  3               	lda txtini+1
002300  3               	sta txtpos+1
002300  3               scrly6:
002300  3               	lda #128
002300  3               	sta txtbit
002300  3               	ldx xtmp
002300  3               	rts
002300  3               
002300  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
002300  3               
002300  3               ;-------------------------------------------------------
002300  3               ; Entry TICKER command
002300  3               ;
002300  3               ; Entry:
002300  3               ;  z80_b = message nr
002300  3               ;  z80_c = width
002300  3               ;-------------------------------------------------------
002300  3               
002300  3               iscrly:
002300  3               	jsr prescr 		; set up display position.
002300  3               
002300  3               	lda #<msgdat 		; text messages.
002300  3               	sta z80_l
002300  3               	lda #>msgdat
002300  3               	sta z80_h
002300  3               
002300  3               	lda z80_c 		; width.
002300  3               	sec
002300  3               	sbc #1			; subtract one.
002300  3               	cmp #32 		; is it between 1 and 32?
002300  3               	bcc :+
002300  3               	lda #$60
002300  3               	jmp iscrl0		; no, disable messages.
002300  3               :
002300  3               	ldx z80_b		; message number.
002300  3               	jsr getwrd 		; find message start.
002300  3               
002300  3               	lda z80_l		; set initial text position.
002300  3               	sta txtini
002300  3               	lda z80_h
002300  3               	sta txtini+1
002300  3               
002300  3               	lda #$ad		; code for lda adrr
002300  3               iscrl0:
002300  3               	sta scrly		; enable/disable scrolling routine.
002300  3               
002300  3               	jsr prescr 		; set up display position.
002300  3               	jsr gprad 		; get print address.
002300  3               
002300  3               	lda scraddr 		; set text screen address.
002300  3               	sta txtscr
002300  3               	lda scraddr+1
002300  3               	sta txtscr+1
002300  3               
002300  3               	lda z80_c		; width.
002300  3               	sta txtwid		; set width in working storage.
002300  3               
002300  3               	lda #128 		; start with leftmost bit.
002300  3               	sta txtbit
002300  3               
002300  3               	jmp scrly4
002300  3               .endif
002300  3               
002300  3               ;------------------------------------------------------------------
002300  3               ; Sprite table
002300  3               ;------------------------------------------------------------------
002300  3               
002300  3               
002300  3               ; ix+0  = type.
002300  3               ; ix+1  = sprite image number.
002300  3               ; ix+2  = frame.
002300  3               ; ix+3  = y coord.
002300  3               ; ix+4  = x coord.
002300  3               
002300  3               ; ix+5  = new type.
002300  3               ; ix+6  = new image number.
002300  3               ; ix+7  = new frame.
002300  3               ; ix+8  = new y coord.
002300  3               ; ix+9  = new x coord.
002300  3               
002300  3               ; ix+10 = direction.
002300  3               ; ix+11 = parameter 1.
002300  3               ; ix+12 = parameter 2.
002300  3               ; ix+13 = jump pointer low.
002300  3               ; ix+14 = jump pointer high.
002300  3               ; ix+15 = data pointer low.
002300  3               ; ix+16 = data pointer high.
002300  3               
002300  3               ; block NUMSPR * TABSIZ,255
002300  3               ; sprtab NUMSPR*TABSIZ,255
002300  3               
002300  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
002304  3  FF FF FF 00  
002308  3  C0 78 00 00  
002311  3  07           roomtb:	.byte 7                      ; start room map offset.
002312  3               
002312  3               ; User routine.  Put your own code in here to be called with USER instruction.
002312  3               ; if USER has an argument it will be passed in the accumulator.
002312  3               
002312  3               user:
002312  3  60           	rts
002313  3               
002313  3               ; Everything below here will be generated by the editors.
002313  3               
002313  3               script_start:
002313  3               
002313  3               WINDOWTOP = 0
002313  3               WINDOWLFT = 0
002313  3               WINDOWHGT = 23
002313  3               WINDOWWID = 32 ;
002313  3               MAPWID = 3
002313  3  FF FF FF             .byte 255,255,255
002316  3               mapdat:
002316  3  FF 00 FF             .byte 255,0,255
002319  3  FF FF FF             .byte 255,255,255
00231C  3  02           stmap:  .byte 2
00231D  3               
00231D  3               evnt00:
00231D  3  20 BC 20             jsr ifall
002320  3  A5 rr                lda joyval
002322  3  29 04                and #4
002324  3  F0 03                beq :+
002326  3  4C 2C 23             jmp a00028
002329  3               :
002329  3  20 6D 0E             jsr prskey
00232C  3  A5 rr        a00028: lda joyval
00232E  3  29 01                and #1
002330  3  F0 03                beq :+
002332  3  4C 46 23             jmp a00081
002335  3               :
002335  3  20 07 19             jsr cangr
002338  3  F0 03                beq :+
00233A  3  4C 46 23             jmp a00081
00233D  3               :
00233D  3  A0 09                ldy #9
00233F  3  B1 rr                lda (z80_ix),y
002341  3  18                   clc
002342  3  69 02                adc #2
002344  3  91 rr                sta (z80_ix),y
002346  3  A5 rr        a00081: lda joyval
002348  3  29 02                and #2
00234A  3  F0 03                beq :+
00234C  3  4C 60 23             jmp a00134
00234F  3               :
00234F  3  20 F5 18             jsr cangl
002352  3  F0 03                beq :+
002354  3  4C 60 23             jmp a00134
002357  3               :
002357  3  A0 09                ldy #9
002359  3  B1 rr                lda (z80_ix),y
00235B  3  38                   sec
00235C  3  E9 02                sbc #2
00235E  3  91 rr                sta (z80_ix),y
002360  3  20 C0 18     a00134: jsr cangd
002363  3  F0 03                beq :+
002365  3  4C 6B 23             jmp a00153
002368  3               :
002368  3  4C 71 23             jmp a00166
00236B  3  A9 03        a00153: lda #3
00236D  3  A0 0B                ldy #11
00236F  3  91 rr                sta (z80_ix),y
002371  3  A0 0B        a00166: ldy #11
002373  3  B1 rr                lda (z80_ix),y
002375  3  A0 07                ldy #7
002377  3  91 rr                sta (z80_ix),y
002379  3  A9 00                lda #0
00237B  3  A0 0B                ldy #11
00237D  3  D1 rr                cmp (z80_ix),y
00237F  3  90 03                bcc *+5
002381  3  4C 92 23             jmp a00252
002384  3                       ; lda #0
002384  3  C5 rr                cmp vart
002386  3  F0 03                beq *+5
002388  3  4C 92 23             jmp a00252
00238B  3                       ; ldy #11
00238B  3  B1 rr                lda (z80_ix),y
00238D  3  38                   sec
00238E  3  E9 01                sbc #1
002390  3                       ; ldy #11
002390  3  91 rr                sta (z80_ix),y
002392  3  20 DD 1A     a00252: jsr jump
002395  3  A9 05                lda #DEADLY
002397  3  85 rr                sta z80_b
002399  3  20 EC 19             jsr tded
00239C  3  C5 rr                cmp z80_b
00239E  3  F0 03                beq :+
0023A0  3  4C A7 23             jmp a00292
0023A3  3               :
0023A3  3  A9 01                lda #1
0023A5  3  85 rr                sta deadf
0023A7  3  A9 06        a00292: lda #CUSTOM
0023A9  3  85 rr                sta z80_b
0023AB  3  20 EC 19             jsr tded
0023AE  3  C5 rr                cmp z80_b
0023B0  3  F0 03                beq :+
0023B2  3  4C CC 23             jmp a00364
0023B5  3               :
0023B5  3  A9 01                lda #1
0023B7  3  85 rr                sta vare
0023B9  3  A9 00                lda #0
0023BB  3  C5 rr                cmp vars
0023BD  3  F0 03                beq *+5
0023BF  3  4C C8 23             jmp a00356
0023C2  3  A9 64                lda #100
0023C4  3  0A                   asl a
0023C5  3  8D 2A 0F             sta sndtyp
0023C8  3  A9 01        a00356: lda #1
0023CA  3  85 rr                sta vars
0023CC  3  4C 32 20     a00364: jmp grav
0023CF  3               .out .sprintf("EVENT 0 SIZE = %d", (* - evnt00))
0023CF  3               
0023CF  3               evnt01:
0023CF  3  A9 00                lda #0
0023D1  3  A0 0B                ldy #11
0023D3  3  D1 rr                cmp (z80_ix),y
0023D5  3  F0 03                beq *+5
0023D7  3  4C F7 23             jmp b00082
0023DA  3  20 8B 18             jsr cangu
0023DD  3  F0 03                beq :+
0023DF  3  4C EE 23             jmp b00064
0023E2  3               :
0023E2  3  A0 08                ldy #8
0023E4  3  B1 rr                lda (z80_ix),y
0023E6  3  38                   sec
0023E7  3  E9 02                sbc #2
0023E9  3  91 rr                sta (z80_ix),y
0023EB  3  4C F4 23             jmp b00078
0023EE  3  A9 01        b00064: lda #1
0023F0  3  A0 0B                ldy #11
0023F2  3  91 rr                sta (z80_ix),y
0023F4  3  4C 11 24     b00078: jmp b00136
0023F7  3  20 C0 18     b00082: jsr cangd
0023FA  3  F0 03                beq :+
0023FC  3  4C 0B 24             jmp b00123
0023FF  3               :
0023FF  3  A0 08                ldy #8
002401  3  B1 rr                lda (z80_ix),y
002403  3  18                   clc
002404  3  69 02                adc #2
002406  3  91 rr                sta (z80_ix),y
002408  3  4C 11 24             jmp b00136
00240B  3  A9 00        b00123: lda #0
00240D  3  A0 0B                ldy #11
00240F  3  91 rr                sta (z80_ix),y
002411  3  A9 01        b00136: lda #1
002413  3  C5 rr                cmp vart
002415  3  F0 03                beq *+5
002417  3  4C 48 24             jmp b00260
00241A  3  A0 0C                ldy #12
00241C  3  B1 rr                lda (z80_ix),y
00241E  3  18                   clc
00241F  3  69 01                adc #1
002421  3                       ; ldy #12
002421  3  91 rr                sta (z80_ix),y
002423  3  A9 05                lda #5
002425  3                       ; ldy #12
002425  3  D1 rr                cmp (z80_ix),y
002427  3  90 03                bcc *+5
002429  3  4C 30 24             jmp b00216
00242C  3  A9 00                lda #0
00242E  3                       ; ldy #12
00242E  3  91 rr                sta (z80_ix),y
002430  3  A0 0C        b00216: ldy #12
002432  3  B1 rr                lda (z80_ix),y
002434  3  C9 03                cmp #3
002436  3  90 03                bcc *+5
002438  3  4C 43 24             jmp b00252
00243B  3  A9 00                lda #0
00243D  3  20 CB 1E             jsr animsp
002440  3  4C 48 24             jmp b00260
002443  3  A9 00        b00252: lda #0
002445  3  20 F1 1E             jsr animbk
002448  3  A9 00        b00260: lda #0
00244A  3  85 rr                sta z80_b
00244C  3  20 16 1F             jsr sktyp
00244F  3  B0 03                bcs :+
002451  3  4C 58 24             jmp b00290
002454  3               :
002454  3  A9 01                lda #1
002456  3  85 rr                sta deadf
002458  3  60           b00290: rts
002459  3               .out .sprintf("EVENT 1 SIZE = %d", (* - evnt01))
002459  3               
002459  3               evnt02:
002459  3  A9 00                lda #0
00245B  3  A0 0B                ldy #11
00245D  3  D1 rr                cmp (z80_ix),y
00245F  3  F0 03                beq *+5
002461  3  4C A7 24             jmp c00181
002464  3  20 F5 18             jsr cangl
002467  3  F0 03                beq :+
002469  3  4C 9E 24             jmp c00163
00246C  3               :
00246C  3  A0 09                ldy #9
00246E  3  B1 rr                lda (z80_ix),y
002470  3  38                   sec
002471  3  E9 02                sbc #2
002473  3  91 rr                sta (z80_ix),y
002475  3  A9 10                lda #16
002477  3  85 rr                sta z80_c
002479  3                       ; ldy #9
002479  3  B1 rr                lda (z80_ix),y
00247B  3  38                   sec
00247C  3  E5 rr                sbc z80_c
00247E  3                       ; ldy #9
00247E  3  91 rr                sta (z80_ix),y
002480  3  20 C0 18             jsr cangd
002483  3  F0 03                beq :+
002485  3  4C 8E 24             jmp c00122
002488  3               :
002488  3  A9 01                lda #1
00248A  3  A0 0B                ldy #11
00248C  3  91 rr                sta (z80_ix),y
00248E  3  A9 10        c00122: lda #16
002490  3  85 rr                sta z80_c
002492  3  A0 09                ldy #9
002494  3  B1 rr                lda (z80_ix),y
002496  3  18                   clc
002497  3  65 rr                adc z80_c
002499  3                       ; ldy #9
002499  3  91 rr                sta (z80_ix),y
00249B  3  4C A4 24             jmp c00176
00249E  3  A9 01        c00163: lda #1
0024A0  3  A0 0B                ldy #11
0024A2  3  91 rr                sta (z80_ix),y
0024A4  3  4C E7 24     c00176: jmp c00333
0024A7  3  20 07 19     c00181: jsr cangr
0024AA  3  F0 03                beq :+
0024AC  3  4C E1 24             jmp c00320
0024AF  3               :
0024AF  3  A0 09                ldy #9
0024B1  3  B1 rr                lda (z80_ix),y
0024B3  3  18                   clc
0024B4  3  69 02                adc #2
0024B6  3  91 rr                sta (z80_ix),y
0024B8  3  A9 10                lda #16
0024BA  3  85 rr                sta z80_c
0024BC  3                       ; ldy #9
0024BC  3  B1 rr                lda (z80_ix),y
0024BE  3  18                   clc
0024BF  3  65 rr                adc z80_c
0024C1  3                       ; ldy #9
0024C1  3  91 rr                sta (z80_ix),y
0024C3  3  20 C0 18             jsr cangd
0024C6  3  F0 03                beq :+
0024C8  3  4C D1 24             jmp c00279
0024CB  3               :
0024CB  3  A9 00                lda #0
0024CD  3  A0 0B                ldy #11
0024CF  3  91 rr                sta (z80_ix),y
0024D1  3  A9 10        c00279: lda #16
0024D3  3  85 rr                sta z80_c
0024D5  3  A0 09                ldy #9
0024D7  3  B1 rr                lda (z80_ix),y
0024D9  3  38                   sec
0024DA  3  E5 rr                sbc z80_c
0024DC  3                       ; ldy #9
0024DC  3  91 rr                sta (z80_ix),y
0024DE  3  4C E7 24             jmp c00333
0024E1  3  A9 00        c00320: lda #0
0024E3  3  A0 0B                ldy #11
0024E5  3  91 rr                sta (z80_ix),y
0024E7  3  A9 00        c00333: lda #0
0024E9  3  C5 rr                cmp vart
0024EB  3  F0 03                beq *+5
0024ED  3  4C 1E 25             jmp c00457
0024F0  3  A0 0C                ldy #12
0024F2  3  B1 rr                lda (z80_ix),y
0024F4  3  18                   clc
0024F5  3  69 01                adc #1
0024F7  3                       ; ldy #12
0024F7  3  91 rr                sta (z80_ix),y
0024F9  3  A9 05                lda #5
0024FB  3                       ; ldy #12
0024FB  3  D1 rr                cmp (z80_ix),y
0024FD  3  90 03                bcc *+5
0024FF  3  4C 06 25             jmp c00413
002502  3  A9 00                lda #0
002504  3                       ; ldy #12
002504  3  91 rr                sta (z80_ix),y
002506  3  A0 0C        c00413: ldy #12
002508  3  B1 rr                lda (z80_ix),y
00250A  3  C9 03                cmp #3
00250C  3  90 03                bcc *+5
00250E  3  4C 19 25             jmp c00449
002511  3  A9 00                lda #0
002513  3  20 CB 1E             jsr animsp
002516  3  4C 1E 25             jmp c00457
002519  3  A9 00        c00449: lda #0
00251B  3  20 F1 1E             jsr animbk
00251E  3  A9 00        c00457: lda #0
002520  3  85 rr                sta z80_b
002522  3  20 16 1F             jsr sktyp
002525  3  B0 03                bcs :+
002527  3  4C 2E 25             jmp c00487
00252A  3               :
00252A  3  A9 01                lda #1
00252C  3  85 rr                sta deadf
00252E  3  60           c00487: rts
00252F  3               .out .sprintf("EVENT 2 SIZE = %d", (* - evnt02))
00252F  3               
00252F  3               evnt03:
00252F  3  A9 00                lda #0
002531  3  85 rr                sta z80_b
002533  3  20 16 1F             jsr sktyp
002536  3  B0 03                bcs :+
002538  3  4C 3F 25             jmp d00032
00253B  3               :
00253B  3  A9 01                lda #1
00253D  3  85 rr                sta deadf
00253F  3  A9 01        d00032: lda #1
002541  3  C5 rr                cmp vart
002543  3  F0 03                beq *+5
002545  3  4C 49 25             jmp d00051
002548  3  60                   rts
002549  3  A9 00        d00051: lda #0
00254B  3  A0 0B                ldy #11
00254D  3  D1 rr                cmp (z80_ix),y
00254F  3  F0 03                beq *+5
002551  3  4C 97 25             jmp d00231
002554  3  20 F5 18             jsr cangl
002557  3  F0 03                beq :+
002559  3  4C 8E 25             jmp d00212
00255C  3               :
00255C  3  A0 09                ldy #9
00255E  3  B1 rr                lda (z80_ix),y
002560  3  38                   sec
002561  3  E9 02                sbc #2
002563  3  91 rr                sta (z80_ix),y
002565  3  A9 10                lda #16
002567  3  85 rr                sta z80_c
002569  3                       ; ldy #9
002569  3  B1 rr                lda (z80_ix),y
00256B  3  38                   sec
00256C  3  E5 rr                sbc z80_c
00256E  3                       ; ldy #9
00256E  3  91 rr                sta (z80_ix),y
002570  3  20 C0 18             jsr cangd
002573  3  F0 03                beq :+
002575  3  4C 7E 25             jmp d00172
002578  3               :
002578  3  A9 01                lda #1
00257A  3  A0 0B                ldy #11
00257C  3  91 rr                sta (z80_ix),y
00257E  3  A9 10        d00172: lda #16
002580  3  85 rr                sta z80_c
002582  3  A0 09                ldy #9
002584  3  B1 rr                lda (z80_ix),y
002586  3  18                   clc
002587  3  65 rr                adc z80_c
002589  3                       ; ldy #9
002589  3  91 rr                sta (z80_ix),y
00258B  3  4C 94 25             jmp d00226
00258E  3  A9 01        d00212: lda #1
002590  3  A0 0B                ldy #11
002592  3  91 rr                sta (z80_ix),y
002594  3  4C D7 25     d00226: jmp d00383
002597  3  20 07 19     d00231: jsr cangr
00259A  3  F0 03                beq :+
00259C  3  4C D1 25             jmp d00369
00259F  3               :
00259F  3  A0 09                ldy #9
0025A1  3  B1 rr                lda (z80_ix),y
0025A3  3  18                   clc
0025A4  3  69 02                adc #2
0025A6  3  91 rr                sta (z80_ix),y
0025A8  3  A9 10                lda #16
0025AA  3  85 rr                sta z80_c
0025AC  3                       ; ldy #9
0025AC  3  B1 rr                lda (z80_ix),y
0025AE  3  18                   clc
0025AF  3  65 rr                adc z80_c
0025B1  3                       ; ldy #9
0025B1  3  91 rr                sta (z80_ix),y
0025B3  3  20 C0 18             jsr cangd
0025B6  3  F0 03                beq :+
0025B8  3  4C C1 25             jmp d00329
0025BB  3               :
0025BB  3  A9 00                lda #0
0025BD  3  A0 0B                ldy #11
0025BF  3  91 rr                sta (z80_ix),y
0025C1  3  A9 10        d00329: lda #16
0025C3  3  85 rr                sta z80_c
0025C5  3  A0 09                ldy #9
0025C7  3  B1 rr                lda (z80_ix),y
0025C9  3  38                   sec
0025CA  3  E5 rr                sbc z80_c
0025CC  3                       ; ldy #9
0025CC  3  91 rr                sta (z80_ix),y
0025CE  3  4C D7 25             jmp d00383
0025D1  3  A9 00        d00369: lda #0
0025D3  3  A0 0B                ldy #11
0025D5  3  91 rr                sta (z80_ix),y
0025D7  3  A0 0C        d00383: ldy #12
0025D9  3  B1 rr                lda (z80_ix),y
0025DB  3  18                   clc
0025DC  3  69 01                adc #1
0025DE  3                       ; ldy #12
0025DE  3  91 rr                sta (z80_ix),y
0025E0  3  A9 05                lda #5
0025E2  3                       ; ldy #12
0025E2  3  D1 rr                cmp (z80_ix),y
0025E4  3  90 03                bcc *+5
0025E6  3  4C ED 25             jmp d00446
0025E9  3  A9 00                lda #0
0025EB  3                       ; ldy #12
0025EB  3  91 rr                sta (z80_ix),y
0025ED  3  A0 0C        d00446: ldy #12
0025EF  3  B1 rr                lda (z80_ix),y
0025F1  3  C9 03                cmp #3
0025F3  3  90 03                bcc *+5
0025F5  3  4C 00 26             jmp d00482
0025F8  3  A9 00                lda #0
0025FA  3  20 CB 1E             jsr animsp
0025FD  3  4C 05 26             jmp d00490
002600  3  A9 00        d00482: lda #0
002602  3  20 F1 1E             jsr animbk
002605  3  60           d00490: rts
002606  3               .out .sprintf("EVENT 3 SIZE = %d", (* - evnt03))
002606  3               
002606  3               evnt04:
002606  3  A9 00                lda #0
002608  3  85 rr                sta z80_b
00260A  3  20 16 1F             jsr sktyp
00260D  3  B0 03                bcs :+
00260F  3  4C 16 26             jmp e00032
002612  3               :
002612  3  A9 01                lda #1
002614  3  85 rr                sta deadf
002616  3  A9 00        e00032: lda #0
002618  3  A0 0B                ldy #11
00261A  3  D1 rr                cmp (z80_ix),y
00261C  3  F0 03                beq *+5
00261E  3  4C 3E 26             jmp e00112
002621  3  20 F5 18             jsr cangl
002624  3  F0 03                beq :+
002626  3  4C 35 26             jmp e00094
002629  3               :
002629  3  A0 09                ldy #9
00262B  3  B1 rr                lda (z80_ix),y
00262D  3  38                   sec
00262E  3  E9 02                sbc #2
002630  3  91 rr                sta (z80_ix),y
002632  3  4C 3B 26             jmp e00108
002635  3  A9 01        e00094: lda #1
002637  3  A0 0B                ldy #11
002639  3  91 rr                sta (z80_ix),y
00263B  3  4C 58 26     e00108: jmp e00166
00263E  3  20 07 19     e00112: jsr cangr
002641  3  F0 03                beq :+
002643  3  4C 52 26             jmp e00153
002646  3               :
002646  3  A0 09                ldy #9
002648  3  B1 rr                lda (z80_ix),y
00264A  3  18                   clc
00264B  3  69 02                adc #2
00264D  3  91 rr                sta (z80_ix),y
00264F  3  4C 58 26             jmp e00166
002652  3  A9 00        e00153: lda #0
002654  3  A0 0B                ldy #11
002656  3  91 rr                sta (z80_ix),y
002658  3  A9 00        e00166: lda #0
00265A  3  C5 rr                cmp vart
00265C  3  F0 03                beq *+5
00265E  3  4C 8F 26             jmp e00290
002661  3  A0 0C                ldy #12
002663  3  B1 rr                lda (z80_ix),y
002665  3  18                   clc
002666  3  69 01                adc #1
002668  3                       ; ldy #12
002668  3  91 rr                sta (z80_ix),y
00266A  3  A9 05                lda #5
00266C  3                       ; ldy #12
00266C  3  D1 rr                cmp (z80_ix),y
00266E  3  90 03                bcc *+5
002670  3  4C 77 26             jmp e00246
002673  3  A9 00                lda #0
002675  3                       ; ldy #12
002675  3  91 rr                sta (z80_ix),y
002677  3  A0 0C        e00246: ldy #12
002679  3  B1 rr                lda (z80_ix),y
00267B  3  C9 03                cmp #3
00267D  3  90 03                bcc *+5
00267F  3  4C 8A 26             jmp e00282
002682  3  A9 00                lda #0
002684  3  20 CB 1E             jsr animsp
002687  3  4C 8F 26             jmp e00290
00268A  3  A9 00        e00282: lda #0
00268C  3  20 F1 1E             jsr animbk
00268F  3  60           e00290: rts
002690  3               .out .sprintf("EVENT 4 SIZE = %d", (* - evnt04))
002690  3               
002690  3               evnt05:
002690  3  A9 00                lda #0
002692  3  85 rr                sta z80_b
002694  3  20 16 1F             jsr sktyp
002697  3  B0 03                bcs :+
002699  3  4C A0 26             jmp f00032
00269C  3               :
00269C  3  A9 01                lda #1
00269E  3  85 rr                sta deadf
0026A0  3  A9 00        f00032: lda #0
0026A2  3  C5 rr                cmp vart
0026A4  3  F0 03                beq *+5
0026A6  3  4C AA 26             jmp f00051
0026A9  3  60                   rts
0026AA  3  A9 00        f00051: lda #0
0026AC  3  A0 0B                ldy #11
0026AE  3  D1 rr                cmp (z80_ix),y
0026B0  3  F0 03                beq *+5
0026B2  3  4C D2 26             jmp f00132
0026B5  3  20 C0 18             jsr cangd
0026B8  3  F0 03                beq :+
0026BA  3  4C C9 26             jmp f00114
0026BD  3               :
0026BD  3  A0 08                ldy #8
0026BF  3  B1 rr                lda (z80_ix),y
0026C1  3  18                   clc
0026C2  3  69 02                adc #2
0026C4  3  91 rr                sta (z80_ix),y
0026C6  3  4C CF 26             jmp f00127
0026C9  3  A9 01        f00114: lda #1
0026CB  3  A0 0B                ldy #11
0026CD  3  91 rr                sta (z80_ix),y
0026CF  3  4C EC 26     f00127: jmp f00186
0026D2  3  20 8B 18     f00132: jsr cangu
0026D5  3  F0 03                beq :+
0026D7  3  4C E6 26             jmp f00172
0026DA  3               :
0026DA  3  A0 08                ldy #8
0026DC  3  B1 rr                lda (z80_ix),y
0026DE  3  38                   sec
0026DF  3  E9 02                sbc #2
0026E1  3  91 rr                sta (z80_ix),y
0026E3  3  4C EC 26             jmp f00186
0026E6  3  A9 00        f00172: lda #0
0026E8  3  A0 0B                ldy #11
0026EA  3  91 rr                sta (z80_ix),y
0026EC  3  A9 01        f00186: lda #1
0026EE  3  C5 rr                cmp vart
0026F0  3  F0 03                beq *+5
0026F2  3  4C 23 27             jmp f00310
0026F5  3  A0 0C                ldy #12
0026F7  3  B1 rr                lda (z80_ix),y
0026F9  3  18                   clc
0026FA  3  69 01                adc #1
0026FC  3                       ; ldy #12
0026FC  3  91 rr                sta (z80_ix),y
0026FE  3  A9 05                lda #5
002700  3                       ; ldy #12
002700  3  D1 rr                cmp (z80_ix),y
002702  3  90 03                bcc *+5
002704  3  4C 0B 27             jmp f00266
002707  3  A9 00                lda #0
002709  3                       ; ldy #12
002709  3  91 rr                sta (z80_ix),y
00270B  3  A0 0C        f00266: ldy #12
00270D  3  B1 rr                lda (z80_ix),y
00270F  3  C9 03                cmp #3
002711  3  90 03                bcc *+5
002713  3  4C 1E 27             jmp f00302
002716  3  A9 00                lda #0
002718  3  20 CB 1E             jsr animsp
00271B  3  4C 23 27             jmp f00310
00271E  3  A9 00        f00302: lda #0
002720  3  20 F1 1E             jsr animbk
002723  3  60           f00310: rts
002724  3               .out .sprintf("EVENT 5 SIZE = %d", (* - evnt05))
002724  3               
002724  3               evnt06:
002724  3  20 BC 20             jsr ifall
002727  3  20 DD 1A             jsr jump
00272A  3  A9 00                lda #0
00272C  3  A0 0B                ldy #11
00272E  3  D1 rr                cmp (z80_ix),y
002730  3  F0 03                beq *+5
002732  3  4C 52 27             jmp g00091
002735  3  20 07 19             jsr cangr
002738  3  F0 03                beq :+
00273A  3  4C 49 27             jmp g00073
00273D  3               :
00273D  3  A0 09                ldy #9
00273F  3  B1 rr                lda (z80_ix),y
002741  3  18                   clc
002742  3  69 02                adc #2
002744  3  91 rr                sta (z80_ix),y
002746  3  4C 4F 27             jmp g00086
002749  3  A9 01        g00073: lda #1
00274B  3  A0 0B                ldy #11
00274D  3  91 rr                sta (z80_ix),y
00274F  3  4C 6C 27     g00086: jmp g00145
002752  3  20 F5 18     g00091: jsr cangl
002755  3  F0 03                beq :+
002757  3  4C 66 27             jmp g00131
00275A  3               :
00275A  3  A0 09                ldy #9
00275C  3  B1 rr                lda (z80_ix),y
00275E  3  38                   sec
00275F  3  E9 02                sbc #2
002761  3  91 rr                sta (z80_ix),y
002763  3  4C 6C 27             jmp g00145
002766  3  A9 00        g00131: lda #0
002768  3  A0 0B                ldy #11
00276A  3  91 rr                sta (z80_ix),y
00276C  3  4C 32 20     g00145: jmp grav
00276F  3               .out .sprintf("EVENT 6 SIZE = %d", (* - evnt06))
00276F  3               
00276F  3               evnt07:
00276F  3  60                   rts
002770  3               .out .sprintf("EVENT 7 SIZE = %d", (* - evnt07))
002770  3               
002770  3               evnt08:
002770  3  A9 00                lda #0
002772  3  C5 rr                cmp vare
002774  3  F0 03                beq *+5
002776  3  4C 7D 27             jmp i00026
002779  3  60                   rts
00277A  3  4C 95 27             jmp i00078
00277D  3  A9 01        i00026: lda #1
00277F  3  A0 07                ldy #7
002781  3  91 rr                sta (z80_ix),y
002783  3  A9 00                lda #0
002785  3  85 rr                sta z80_b
002787  3  20 16 1F             jsr sktyp
00278A  3  B0 03                bcs :+
00278C  3  4C 95 27             jmp i00078
00278F  3               :
00278F  3  A9 01                lda #1
002791  3  85 rr                sta vara
002793  3                       ; lda #1
002793  3  85 rr                sta nexlev
002795  3  60           i00078: rts
002796  3               .out .sprintf("EVENT 8 SIZE = %d", (* - evnt08))
002796  3               
002796  3               evnt09:
002796  3  A9 00                lda #0
002798  3  A0 05                ldy #5
00279A  3  D1 rr                cmp (z80_ix),y
00279C  3  F0 03                beq *+5
00279E  3  4C A8 27             jmp j00053
0027A1  3                       ; lda #0
0027A1  3  A0 0B                ldy #11
0027A3  3  91 rr                sta (z80_ix),y
0027A5  3                       ; lda #0
0027A5  3  C8                   iny; ldy #12
0027A6  3  91 rr                sta (z80_ix),y
0027A8  3  60           j00053: rts
0027A9  3               .out .sprintf("EVENT 9 SIZE = %d", (* - evnt09))
0027A9  3               
0027A9  3               evnt10:
0027A9  3  A5 rr                lda vart
0027AB  3  18                   clc
0027AC  3  69 01                adc #1
0027AE  3  85 rr                sta vart
0027B0  3  A9 01                lda #1
0027B2  3  C5 rr                cmp vart
0027B4  3  90 03                bcc *+5
0027B6  3  4C BD 27             jmp k00042
0027B9  3  A9 00                lda #0
0027BB  3  85 rr                sta vart
0027BD  3  60           k00042: rts
0027BE  3               .out .sprintf("EVENT 10 SIZE = %d", (* - evnt10))
0027BE  3               
0027BE  3               evnt11:
0027BE  3  A9 00                lda #0
0027C0  3  C5 rr                cmp scno
0027C2  3  F0 03                beq *+5
0027C4  3  4C 0F 28             jmp l00159
0027C7  3  A9 01                lda #1
0027C9  3  C5 rr                cmp varm
0027CB  3  F0 03                beq *+5
0027CD  3  4C 0F 28             jmp l00159
0027D0  3  A9 02                lda #2
0027D2  3  85 rr                sta chary
0027D4  3  A9 0C                lda #12
0027D6  3  85 rr                sta charx
0027D8  3  A9 01                lda #1
0027DA  3  85 rr                sta prtmod
0027DC  3  A9 00                lda #0
0027DE  3  20 5F 1B             jsr dmsg
0027E1  3  A9 00                lda #0
0027E3  3  85 rr                sta prtmod
0027E5  3  A9 06                lda #6
0027E7  3  85 rr                sta chary
0027E9  3                       ; lda #6
0027E9  3  85 rr                sta charx
0027EB  3  A9 01                lda #1
0027ED  3  20 5F 1B             jsr dmsg
0027F0  3  A9 06                lda #6
0027F2  3  85 rr                sta charx
0027F4  3  A9 02                lda #2
0027F6  3  20 5F 1B             jsr dmsg
0027F9  3  A9 0C                lda #12
0027FB  3  85 rr                sta charx
0027FD  3  A9 03                lda #3
0027FF  3  20 5F 1B             jsr dmsg
002802  3  A9 06                lda #6
002804  3  85 rr                sta charx
002806  3  A9 04                lda #4
002808  3  20 5F 1B             jsr dmsg
00280B  3  A9 00                lda #0
00280D  3  85 rr                sta varm
00280F  3  A9 07        l00159: lda #7
002811  3  C5 rr                cmp scno
002813  3  F0 03                beq *+5
002815  3  4C 22 28             jmp l00197
002818  3  A5 rr                lda clock
00281A  3  85 rr                sta vara
00281C  3  A5 rr                lda clock
00281E  3  0A                   asl a
00281F  3  8D 2A 0F             sta sndtyp
002822  3  60           l00197: rts
002823  3               .out .sprintf("EVENT 11 SIZE = %d", (* - evnt11))
002823  3               
002823  3               evnt12:
002823  3  60                   rts
002824  3               .out .sprintf("EVENT 12 SIZE = %d", (* - evnt12))
002824  3               
002824  3               evnt13:
002824  3  A9 01                lda #1
002826  3  85 rr                sta varm
002828  3  A9 63                lda #99
00282A  3  85 rr                sta numlif
00282C  3  20 86 11             jsr cls
00282F  3  60                   rts
002830  3               .out .sprintf("EVENT 13 SIZE = %d", (* - evnt13))
002830  3               
002830  3               evnt14:
002830  3  A9 00                lda #0
002832  3  85 rr                sta vara
002834  3                       ; lda #0
002834  3  85 rr                sta vare
002836  3                       ; lda #0
002836  3  85 rr                sta vars
002838  3  60                   rts
002839  3               .out .sprintf("EVENT 14 SIZE = %d", (* - evnt14))
002839  3               
002839  3               evnt15:
002839  3  60                   rts
00283A  3               .out .sprintf("EVENT 15 SIZE = %d", (* - evnt15))
00283A  3               
00283A  3               evnt16:
00283A  3  A9 C8                lda #200
00283C  3  0A                   asl a
00283D  3  8D 2A 0F             sta sndtyp
002840  3  60                   rts
002841  3               .out .sprintf("EVENT 16 SIZE = %d", (* - evnt16))
002841  3               
002841  3               evnt17:
002841  3  A9 32                lda #50
002843  3  20 F7 0E             jsr delay
002846  3  60                   rts
002847  3               .out .sprintf("EVENT 17 SIZE = %d", (* - evnt17))
002847  3               
002847  3               evnt18:
002847  3  A9 32                lda #50
002849  3  20 F7 0E             jsr delay
00284C  3  60                   rts
00284D  3               .out .sprintf("EVENT 18 SIZE = %d", (* - evnt18))
00284D  3               
00284D  3               evnt19:
00284D  3  60                   rts
00284E  3               .out .sprintf("EVENT 19 SIZE = %d", (* - evnt19))
00284E  3               
00284E  3               evnt20:
00284E  3  60                   rts
00284F  3               .out .sprintf("EVENT 20 SIZE = %d", (* - evnt20))
00284F  3               
00284F  3  60           ptcusr: rts
002850  3               script_end:
002850  3               
002850  3               .out .sprintf("TOTAL SCRIPT SIZE = %d", (* - script_start))
002850  3               
002850  3               data_start:
002850  3               msgdat:
002850  3  44 4F 4F 44          .byte "DOODLEBUG!",141
002854  3  4C 45 42 55  
002858  3  47 21 8D     
00285B  3  47 4F 20 54          .byte "GO TO THE GREEN TICK",141
00285F  3  4F 20 54 48  
002863  3  45 20 47 52  
002870  3  54 48 45 4E          .byte "THEN GO TO THE EXIT.",141
002874  3  20 47 4F 20  
002878  3  54 4F 20 54  
002885  3  53 49 4D 50          .byte "SIMPLES!",141
002889  3  4C 45 53 21  
00288D  3  8D           
00288E  3  4B 45 59 53          .byte "KEYS: OP (Z-Pause)",141
002892  3  3A 20 4F 50  
002896  3  20 28 5A 2D  
0028A1  3               nummsg:
0028A1  3  05                   .byte 5
0028A2  3               .out .sprintf("MESSAGE SIZE = %d", (* - msgdat))
0028A2  3               
0028A2  3               chgfx:
0028A2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0028A6  3  00 00 00 00  
0028AA  3  FF 00 FF 00          .byte 255,0,255,0,255,0,255,0
0028AE  3  FF 00 FF 00  
0028B2  3  AA AA AA AA          .byte 170,170,170,170,170,170,170,170
0028B6  3  AA AA AA AA  
0028BA  3  AA 2A EA 0A          .byte 170,42,234,10,250,2,254,0
0028BE  3  FA 02 FE 00  
0028C2  3  FF 80 FF E0          .byte 255,128,255,224,255,240,255,252
0028C6  3  FF F0 FF FC  
0028CA  3  FF BF BF AF          .byte 255,191,191,175,175,171,171,170
0028CE  3  AF AB AB AA  
0028D2  3  00 00 18 FC          .byte 0,0,24,252,252,24,0,0
0028D6  3  FC 18 00 00  
0028DA  3  02 02 00 00          .byte 2,2,0,0,2,2,0,0
0028DE  3  02 02 00 00  
0028E2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0028E6  3  00 00 00 00  
0028EA  3  FE 82 AA 96          .byte 254,130,170,150,254,0,0,0
0028EE  3  FE 00 00 00  
0028F2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0028F6  3  00 00 00 00  
0028FA  3  FE 82 FE 00          .byte 254,130,254,0,239,40,239,0
0028FE  3  EF 28 EF 00  
002902  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002906  3  00 00 00 00  
00290A  3  00 00 01 02          .byte 0,0,1,2,4,136,80,32
00290E  3  04 88 50 20  
002912  3  82 64 14 18          .byte 130,100,20,24,36,66,194,0
002916  3  24 42 C2 00  
00291A  3  AA 55 AA 55          .byte 170,85,170,85,170,85,170,85
00291E  3  AA 55 AA 55  
002922  3               bprop:
002922  3  00                   .byte 0
002923  3  02                   .byte 2
002924  3  02                   .byte 2
002925  3  02                   .byte 2
002926  3  02                   .byte 2
002927  3  02                   .byte 2
002928  3  02                   .byte 2
002929  3  02                   .byte 2
00292A  3  00                   .byte 0
00292B  3  01                   .byte 1
00292C  3  01                   .byte 1
00292D  3  02                   .byte 2
00292E  3  02                   .byte 2
00292F  3  06                   .byte 6
002930  3  05                   .byte 5
002931  3  00                   .byte 0
002932  3               .out .sprintf("BLOCKS SIZE = %d", (* - chgfx))
002932  3               
002932  3               sprgfx:
002932  3  01 80 06 60          .byte 1,128,6,96,24,24,32,4,38,4,79,2,79,2,134,1,128,1,64,2,64,2,32,4,32,4,24,24,6,96,1,128
002936  3  18 18 20 04  
00293A  3  26 04 4F 02  
002952  3  00 60 01 98          .byte 0,96,1,152,6,6,8,1,9,129,147,192,147,192,97,128,96,0,144,0,144,0,8,1,8,1,6,6,1,152,0,96
002956  3  06 06 08 01  
00295A  3  09 81 93 C0  
002972  3  00 18 00 66          .byte 0,24,0,102,129,129,66,0,66,96,36,240,36,240,24,96,24,0,36,0,36,0,66,0,66,0,129,129,0,102,0,24
002976  3  81 81 42 00  
00297A  3  42 60 24 F0  
002992  3  00 06 80 19          .byte 0,6,128,25,96,96,16,128,16,152,9,60,9,60,6,24,6,0,9,0,9,0,16,128,16,128,96,96,128,25,0,6
002996  3  60 60 10 80  
00299A  3  10 98 09 3C  
0029B2  3  00 00 07 E0          .byte 0,0,7,224,24,24,32,4,32,4,70,2,79,2,143,1,134,1,128,1,64,2,64,2,64,2,48,12,12,48,3,192
0029B6  3  18 18 20 04  
0029BA  3  20 04 46 02  
0029D2  3  00 00 01 F8          .byte 0,0,1,248,6,6,8,1,8,1,145,128,147,192,99,192,97,128,96,0,144,0,144,0,144,0,12,3,3,12,0,240
0029D6  3  06 06 08 01  
0029DA  3  08 01 91 80  
0029F2  3  00 00 00 7E          .byte 0,0,0,126,129,129,66,0,66,0,36,96,36,240,24,240,24,96,24,0,36,0,36,0,36,0,195,0,0,195,0,60
0029F6  3  81 81 42 00  
0029FA  3  42 00 24 60  
002A12  3  00 00 80 1F          .byte 0,0,128,31,96,96,16,128,16,128,9,24,9,60,6,60,6,24,6,0,9,0,9,0,9,0,48,192,192,48,0,15
002A16  3  60 60 10 80  
002A1A  3  10 80 09 18  
002A32  3  00 00 00 00          .byte 0,0,0,0,7,224,24,24,32,4,64,2,70,2,143,1,143,1,134,1,128,1,64,2,64,2,32,4,24,24,7,224
002A36  3  07 E0 18 18  
002A3A  3  20 04 40 02  
002A52  3  00 00 00 00          .byte 0,0,0,0,1,248,6,6,8,1,144,0,145,128,99,192,99,192,97,128,96,0,144,0,144,0,8,1,6,6,1,248
002A56  3  01 F8 06 06  
002A5A  3  08 01 90 00  
002A72  3  00 00 00 00          .byte 0,0,0,0,0,126,129,129,66,0,36,0,36,96,24,240,24,240,24,96,24,0,36,0,36,0,66,0,129,129,0,126
002A76  3  00 7E 81 81  
002A7A  3  42 00 24 00  
002A92  3  00 00 00 00          .byte 0,0,0,0,128,31,96,96,16,128,9,0,9,24,6,60,6,60,6,24,6,0,9,0,9,0,16,128,96,96,128,31
002A96  3  80 1F 60 60  
002A9A  3  10 80 09 00  
002AB2  3  00 00 00 00          .byte 0,0,0,0,0,0,7,240,24,12,32,2,64,2,134,1,143,1,143,1,134,1,128,1,64,2,64,2,48,12,15,240
002AB6  3  00 00 07 F0  
002ABA  3  18 0C 20 02  
002AD2  3  00 00 00 00          .byte 0,0,0,0,0,0,1,252,6,3,136,0,144,0,97,128,99,192,99,192,97,128,96,0,144,0,144,0,12,3,3,252
002AD6  3  00 00 01 FC  
002ADA  3  06 03 88 00  
002AF2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,127,193,128,34,0,36,0,24,96,24,240,24,240,24,96,24,0,36,0,36,0,195,0,0,255
002AF6  3  00 00 00 7F  
002AFA  3  C1 80 22 00  
002B12  3  00 00 00 00          .byte 0,0,0,0,0,0,192,31,48,96,8,128,9,0,6,24,6,60,6,60,6,24,6,0,9,0,9,0,48,192,192,63
002B16  3  00 00 C0 1F  
002B1A  3  30 60 08 80  
002B32  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,199,227,224,7,232,23,48,12
002B36  3  20 04 40 02  
002B3A  3  8C 31 9E 79  
002B52  3  01 F8 06 06          .byte 1,248,6,6,8,1,144,0,99,12,103,158,111,159,110,151,102,150,147,12,8,1,150,6,241,248,248,1,250,5,12,3
002B56  3  08 01 90 00  
002B5A  3  63 0C 67 9E  
002B72  3  00 7E 81 81          .byte 0,126,129,129,66,0,36,0,24,195,153,231,219,231,219,165,153,165,36,195,66,0,165,129,60,126,126,0,126,129,195,0
002B76  3  42 00 24 00  
002B7A  3  18 C3 99 E7  
002B92  3  80 1F 60 60          .byte 128,31,96,96,16,128,9,0,198,48,230,121,246,249,118,233,102,105,201,48,16,128,105,96,143,31,31,128,95,160,48,192
002B96  3  10 80 09 00  
002B9A  3  C6 30 E6 79  
002BB2  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,71,226,224,7,116,46,56,28
002BB6  3  20 04 40 02  
002BBA  3  8C 31 9E 79  
002BD2  3  01 F8 06 06          .byte 1,248,6,6,8,1,144,0,99,12,103,158,111,159,110,151,102,150,147,12,8,1,150,6,145,248,248,1,157,11,14,7
002BD6  3  08 01 90 00  
002BDA  3  63 0C 67 9E  
002BF2  3  00 7E 81 81          .byte 0,126,129,129,66,0,36,0,24,195,153,231,219,231,219,165,153,165,36,195,66,0,165,129,36,126,126,0,231,66,195,129
002BF6  3  42 00 24 00  
002BFA  3  18 C3 99 E7  
002C12  3  80 1F 60 60          .byte 128,31,96,96,16,128,9,0,198,48,230,121,246,249,118,233,102,105,201,48,16,128,105,96,137,31,31,128,185,208,112,224
002C16  3  10 80 09 00  
002C1A  3  C6 30 E6 79  
002C32  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,71,226,112,14,58,92,28,56
002C36  3  20 04 40 02  
002C3A  3  8C 31 9E 79  
002C52  3  01 F8 06 06          .byte 1,248,6,6,8,1,144,0,99,12,103,158,111,159,110,151,102,150,147,12,8,1,150,6,145,248,156,3,14,151,7,14
002C56  3  08 01 90 00  
002C5A  3  63 0C 67 9E  
002C72  3  00 7E 81 81          .byte 0,126,129,129,66,0,36,0,24,195,153,231,219,231,219,165,153,165,36,195,66,0,165,129,36,126,231,0,195,165,129,195
002C76  3  42 00 24 00  
002C7A  3  18 C3 99 E7  
002C92  3  80 1F 60 60          .byte 128,31,96,96,16,128,9,0,198,48,230,121,246,249,118,233,102,105,201,48,16,128,105,96,137,31,57,192,112,233,224,112
002C96  3  10 80 09 00  
002C9A  3  C6 30 E6 79  
002CB2  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,103,230,56,28,29,184,14,112
002CB6  3  20 04 40 02  
002CBA  3  8C 31 9E 79  
002CD2  3  01 F8 06 06          .byte 1,248,6,6,8,1,144,0,99,12,103,158,111,159,110,151,102,150,147,12,8,1,150,6,153,249,14,7,7,110,3,156
002CD6  3  08 01 90 00  
002CDA  3  63 0C 67 9E  
002CF2  3  00 7E 81 81          .byte 0,126,129,129,66,0,36,0,24,195,153,231,219,231,219,165,153,165,36,195,66,0,165,129,102,126,195,129,129,219,0,231
002CF6  3  42 00 24 00  
002CFA  3  18 C3 99 E7  
002D12  3  80 1F 60 60          .byte 128,31,96,96,16,128,9,0,198,48,230,121,246,249,118,233,102,105,201,48,16,128,105,96,153,159,112,224,224,118,192,57
002D16  3  10 80 09 00  
002D1A  3  C6 30 E6 79  
002D32  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,64,2,128,1,129,129,66,194,67,194,129,129,128,1,64,2,64,2,32,4,25,152,6,96
002D36  3  20 04 40 02  
002D3A  3  40 02 80 01  
002D52  3  01 98 06 66          .byte 1,152,6,102,8,1,144,0,144,0,96,0,96,96,144,176,144,240,96,96,96,0,144,0,144,0,8,1,6,102,1,152
002D56  3  08 01 90 00  
002D5A  3  90 00 60 00  
002D72  3  00 66 81 99          .byte 0,102,129,153,66,0,36,0,36,0,24,0,24,24,36,44,36,60,24,24,24,0,36,0,36,0,66,0,129,153,0,102
002D76  3  42 00 24 00  
002D7A  3  24 00 18 00  
002D92  3  80 19 60 66          .byte 128,25,96,102,16,128,9,0,9,0,6,0,6,6,9,11,9,15,6,6,6,0,9,0,9,0,16,128,96,102,128,25
002D96  3  10 80 09 00  
002D9A  3  09 00 06 00  
002DB2  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,64,2,129,129,130,193,69,226,71,226,131,193,129,129,64,2,64,2,32,4,25,152,6,96
002DB6  3  20 04 40 02  
002DBA  3  40 02 81 81  
002DD2  3  01 98 06 66          .byte 1,152,6,102,8,1,144,0,144,0,96,96,96,176,145,120,145,248,96,240,96,96,144,0,144,0,8,1,6,102,1,152
002DD6  3  08 01 90 00  
002DDA  3  90 00 60 60  
002DF2  3  00 66 81 99          .byte 0,102,129,153,66,0,36,0,36,0,24,24,24,44,36,94,36,126,24,60,24,24,36,0,36,0,66,0,129,153,0,102
002DF6  3  42 00 24 00  
002DFA  3  24 00 18 18  
002E12  3  80 19 60 66          .byte 128,25,96,102,16,128,9,0,9,0,6,6,6,11,137,23,137,31,6,15,6,6,9,0,9,0,16,128,96,102,128,25
002E16  3  10 80 09 00  
002E1A  3  09 00 06 06  
002E32  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,65,130,135,225,132,225,76,242,79,242,135,225,135,225,65,130,64,2,32,4,25,152,6,96
002E36  3  20 04 40 02  
002E3A  3  41 82 87 E1  
002E52  3  01 98 06 66          .byte 1,152,6,102,8,1,144,0,144,96,97,248,97,56,147,60,147,252,97,248,97,248,144,96,144,0,8,1,6,102,1,152
002E56  3  08 01 90 00  
002E5A  3  90 60 61 F8  
002E72  3  00 66 81 99          .byte 0,102,129,153,66,0,36,0,36,24,24,126,24,78,36,207,36,255,24,126,24,126,36,24,36,0,66,0,129,153,0,102
002E76  3  42 00 24 00  
002E7A  3  24 18 18 7E  
002E92  3  80 19 60 66          .byte 128,25,96,102,16,128,9,0,9,6,134,31,134,19,201,51,201,63,134,31,134,31,9,6,9,0,16,128,96,102,128,25
002E96  3  10 80 09 00  
002E9A  3  09 06 86 1F  
002EB2  3  06 60 19 98          .byte 6,96,25,152,32,4,67,194,79,242,140,241,152,121,88,122,92,250,159,249,143,241,79,242,67,194,32,4,25,152,6,96
002EB6  3  20 04 43 C2  
002EBA  3  4F F2 8C F1  
002ED2  3  01 98 06 66          .byte 1,152,6,102,8,1,144,240,147,252,99,60,102,30,150,30,151,62,103,254,99,252,147,252,144,240,8,1,6,102,1,152
002ED6  3  08 01 90 F0  
002EDA  3  93 FC 63 3C  
002EF2  3  00 66 81 99          .byte 0,102,129,153,66,0,36,60,36,255,24,207,153,135,165,135,165,207,153,255,24,255,36,255,36,60,66,0,129,153,0,102
002EF6  3  42 00 24 3C  
002EFA  3  24 FF 18 CF  
002F12  3  80 19 60 66          .byte 128,25,96,102,16,128,9,15,201,63,198,51,230,97,233,97,233,115,230,127,198,63,201,63,9,15,16,128,96,102,128,25
002F16  3  10 80 09 0F  
002F1A  3  C9 3F C6 33  
002F32  3  18 00 7C 00          .byte 24,0,124,0,98,0,209,0,232,128,84,64,42,32,21,16,10,152,5,108,2,194,1,130,0,134,0,78,0,63,0,3
002F36  3  62 00 D1 00  
002F3A  3  E8 80 54 40  
002F52  3  06 00 1F 00          .byte 6,0,31,0,24,128,52,64,58,32,21,16,10,136,5,68,2,166,1,91,128,176,128,96,128,33,128,19,192,15,192,0
002F56  3  18 80 34 40  
002F5A  3  3A 20 15 10  
002F72  3  01 80 07 C0          .byte 1,128,7,192,6,32,13,16,14,136,5,68,2,162,1,81,128,169,192,86,32,44,32,24,96,8,224,4,240,3,48,0
002F76  3  06 20 0D 10  
002F7A  3  0E 88 05 44  
002F92  3  00 60 01 F0          .byte 0,96,1,240,1,136,3,68,3,162,1,81,128,168,64,84,96,42,176,21,8,11,8,6,24,2,56,1,252,0,12,0
002F96  3  01 88 03 44  
002F9A  3  03 A2 01 51  
002FB2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
002FB6  3  00 00 00 00  
002FBA  3  00 00 00 00  
002FD2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
002FD6  3  00 00 00 00  
002FDA  3  00 00 00 00  
002FF2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
002FF6  3  00 00 00 00  
002FFA  3  00 00 00 00  
003012  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003016  3  00 00 00 00  
00301A  3  00 00 00 00  
003032  3  FE C3 F0 E7          .byte 254,195,240,231,252,102,240,60,240,60,240,102,254,231,254,195,0,0,254,255,56,60,56,60,56,60,56,60,56,60,254,60
003036  3  FC 66 F0 3C  
00303A  3  F0 3C F0 66  
003052  3  FF B0 FC 39          .byte 255,176,252,57,191,25,60,15,60,15,188,25,255,185,255,176,0,0,255,191,14,15,14,15,14,15,14,15,14,15,63,143
003056  3  BF 19 3C 0F  
00305A  3  3C 0F BC 19  
003072  3  3F EC 7F 0E          .byte 63,236,127,14,111,198,207,3,207,3,111,6,127,238,63,236,0,0,255,239,195,131,195,131,195,131,195,131,195,131,207,227
003076  3  6F C6 CF 03  
00307A  3  CF 03 6F 06  
003092  3  0F FB 9F C3          .byte 15,251,159,195,155,241,243,192,243,192,155,193,159,251,15,251,0,0,255,251,240,224,240,224,240,224,240,224,240,224,243,248
003096  3  9B F1 F3 C0  
00309A  3  F3 C0 9B C1  
0030B2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0030B6  3  00 00 00 00  
0030BA  3  00 00 00 00  
0030D2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0030D6  3  00 00 00 00  
0030DA  3  00 00 00 00  
0030F2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
0030F6  3  00 00 00 00  
0030FA  3  00 00 00 00  
003112  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003116  3  00 00 00 00  
00311A  3  00 00 00 00  
003132  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003136  3  00 00 00 00  
00313A  3  00 00 00 00  
003152  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003156  3  00 00 00 00  
00315A  3  00 00 00 00  
003172  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003176  3  00 00 00 00  
00317A  3  00 00 00 00  
003192  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003196  3  00 00 00 00  
00319A  3  00 00 00 00  
0031B2  3               frmlst:
0031B2  3  00 04                .byte 0,4
0031B4  3  04 04                .byte 4,4
0031B6  3  08 04                .byte 8,4
0031B8  3  0C 01                .byte 12,1
0031BA  3  0D 02                .byte 13,2
0031BC  3  0F 02 11 00          .byte 15,2,17,0
0031C0  3               .out .sprintf("SPRITES SIZE = %d", (* - sprgfx))
0031C0  3               
0031C0  3               scdat:
0031C0  3  13 01 B5 00          .word 275,181,221,221,297,270,248,361
0031C4  3  DD 00 DD 00  
0031C8  3  29 01 0E 01  
0031D0  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,6,255,12,17,255,0,6,2,6,7,255,0,6
0031D4  3  1D 05 00 07  
0031D8  3  FF 00 1D 02  
0031F3  3  0C FF 00 0F          .byte 12,255,0,15,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12
0031F7  3  0C FF 00 06  
0031FB  3  02 00 07 FF  
003214  3  FF 00 06 02          .byte 255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0
003218  3  00 07 FF 00  
00321C  3  06 0C FF 00  
003235  3  07 FF 00 06          .byte 7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0,7,255,0,6,12
003239  3  0C FF 00 0F  
00323D  3  0C FF 00 06  
003256  3  FF 00 0F 0C          .byte 255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6
00325A  3  FF 00 06 02  
00325E  3  06 07 FF 00  
003279  3  02 06 07 FF          .byte 2,6,7,255,0,6,12,255,0,13,13,0,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7
00327D  3  00 06 0C FF  
003281  3  00 0D 0D 00  
00329A  3  FF 00 06 0C          .byte 255,0,6,12,255,11,15,12,255,0,6,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,0
00329E  3  FF 0B 0F 0C  
0032A2  3  FF 00 06 02  
0032BB  3  0E 00 0E 00          .byte 14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,2,0,7,255,0,29
0032BF  3  0E 00 0E 00  
0032C3  3  0E 00 0E 00  
0032DD  3  02 04 FF 01          .byte 2,4,255,1,30,3
0032E1  3  1E 03        
0032E3  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,13,13,255,0,15,2,0,7,255,0,29,2,6,7,255,0,29
0032E7  3  1D 05 00 07  
0032EB  3  FF 00 1D 02  
003304  3  02 00 07 FF          .byte 2,0,7,255,0,11,255,9,9,255,0,9,2,6,7,255,0,22,9,9,255,0,5,2,0,7,255,0,29,2,6,7,255,0,29
003308  3  00 0B FF 09  
00330C  3  09 FF 00 09  
003327  3  02 00 07 00          .byte 2,0,7,0,9,9,0,0,0,255,11,18,255,0,5,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,0,9,9
00332B  3  09 09 00 00  
00332F  3  00 FF 0B 12  
003348  3  FF 00 1A 02          .byte 255,0,26,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,11,19,0,0,0,9,9,255,0,5,2
00334C  3  00 07 FF 00  
003350  3  1A 09 09 00  
003369  3  06 07 FF 00          .byte 6,7,255,0,26,9,9,0,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29
00336D  3  1A 09 09 00  
003371  3  02 00 07 FF  
00338C  3  02 00 07 FF          .byte 2,0,7,255,0,29,2,4,255,1,30,3
003390  3  00 1D 02 04  
003394  3  FF 01 1E 03  
003398  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29
00339C  3  1D 05 00 07  
0033A0  3  FF 00 1D 02  
0033BB  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,5,14,0,0,0,14,255,0,4,14,255,0,14,2,6,7,255,9,19,11,0,0
0033BF  3  00 1D 02 00  
0033C3  3  07 FF 00 05  
0033DC  3  0B 09 09 09          .byte 11,9,9,9,0,0,0,2,0,7,255,0,19,11,0,0,11,255,0,6,2,6,7,9,9,255,0,15,13,0,11,0,0
0033E0  3  00 00 00 02  
0033E4  3  00 07 FF 00  
0033FD  3  0B FF 00 06          .byte 11,255,0,6,2,0,7,255,0,19,11,0,0,11,255,0,6,2,6,7,255,0,19,255,11,4,255,0,6,2,0,7,9,9
003401  3  02 00 07 FF  
003405  3  00 13 0B 00  
00341F  3  00 00 00 FF          .byte 0,0,0,255,9,18,255,0,6,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,9,9,255,0,27,2,0,7,255,0,29
003423  3  09 12 FF 00  
003427  3  06 02 06 07  
003442  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,9,9,255,0,27,2,6,7,255,0,29,2,0,7,255,0,5,14,255,0,4,14,255,0,4
003446  3  00 1D 02 00  
00344A  3  07 09 09 FF  
003464  3  0E FF 00 04          .byte 14,255,0,4,14,255,0,5,14,14,14,2,4,255,1,30,3
003468  3  0E FF 00 05  
00346C  3  0E 0E 0E 02  
003475  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,0,13,255,0,27,2,0,7,255,0,29,2,6,7,255,0,29,2,0
003479  3  1D 05 00 07  
00347D  3  FF 00 1D 02  
003496  3  07 09 09 09          .byte 7,9,9,9,255,0,26,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,9,6,0,0,9,9,255,0,4,9,9
00349A  3  FF 00 1A 02  
00349E  3  06 07 FF 00  
0034B8  3  00 00 09 09          .byte 0,0,9,9,0,0,0,9,9,255,0,4,2,0,7,255,0,29,2,6,7,255,0,26,9,9,0,2,0,7,255,0,29
0034BC  3  00 00 00 09  
0034C0  3  09 FF 00 04  
0034D9  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,6
0034DD  3  00 1D 02 00  
0034E1  3  07 FF 00 1A  
0034FA  3  0B 0B FF 00          .byte 11,11,255,0,8,11,11,255,0,8,11,11,0,2,0,7,255,0,6,11,11,255,0,8,11,11,255,0,8,11,11,0,2
0034FE  3  08 0B 0B FF  
003502  3  00 08 0B 0B  
00351B  3  06 07 00 0B          .byte 6,7,0,11,11,255,0,8,11,11,255,0,8,11,11,255,0,6,2,0,7,0,11,11,255,0,8,11,11,255,0,8,11,11
00351F  3  0B FF 00 08  
003523  3  0B 0B FF 00  
00353D  3  FF 00 06 02          .byte 255,0,6,2,6,7,255,0,29,2,0,7,255,14,29,2,4,255,1,30,3
003541  3  06 07 FF 00  
003545  3  1D 02 00 07  
003552  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,17,11,255,0,11,2,6,7,255,0,17,11,255,0,11,2,0,7,255,0,17,11,255,0,11
003556  3  1D 05 00 07  
00355A  3  FF 00 11 0B  
003575  3  02 06 07 FF          .byte 2,6,7,255,0,14,255,11,4,255,0,11,2,0,7,255,0,12,11,11,11,255,0,7,9,9,0,0,0,9,9,2,6
003579  3  00 0E FF 0B  
00357D  3  04 FF 00 0B  
003596  3  07 FF 00 06          .byte 7,255,0,6,255,11,7,255,0,16,2,0,7,255,0,29,2,6,7,255,0,27,9,9,2,0,7,255,0,29,2,6,7
00359A  3  FF 0B 07 FF  
00359E  3  00 10 02 00  
0035B7  3  FF 00 0A FF          .byte 255,0,10,255,9,5,0,0,0,9,9,11,0,0,0,11,11,0,0,0,2,0,7,255,0,12,11,255,0,7,11,255,0,6
0035BB  3  09 05 00 00  
0035BF  3  00 09 09 0B  
0035D9  3  09 09 02 06          .byte 9,9,2,6,7,255,0,12,11,255,0,7,11,255,0,8,2,0,7,255,0,10,9,9,11,9,9,0,0,0,9,9,11
0035DD  3  07 FF 00 0C  
0035E1  3  0B FF 00 07  
0035FA  3  FF 00 08 02          .byte 255,0,8,2,6,7,255,0,12,11,255,0,7,11,255,0,6,9,9,2,0,7,255,0,12,11,255,0,7,11,255,0,8
0035FE  3  06 07 FF 00  
003602  3  0C 0B FF 00  
00361B  3  02 06 07 FF          .byte 2,6,7,255,0,10,9,9,11,9,9,0,0,0,9,9,11,255,0,8,2,0,7,14,255,0,7,14,0,0,0,11,255,0,7
00361F  3  00 0A 09 09  
003623  3  0B 09 09 00  
00363E  3  0B 09 09 FF          .byte 11,9,9,255,0,4,9,9,2,6,7,255,11,13,255,0,7,11,255,0,8,2,0,7,255,0,18,9,9,11,255,0,8
003642  3  00 04 09 09  
003646  3  02 06 07 FF  
00365F  3  02 06 07 00          .byte 2,6,7,0,13,255,0,18,14,255,0,8,2,0,7,255,0,20,14,255,0,8,2,4,255,1,30,3
003663  3  0D FF 00 12  
003667  3  0E FF 00 08  
00367B  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,9,0,0,0,255,11,21
00367F  3  1D 05 00 07  
003683  3  FF 00 1D 02  
00369C  3  09 09 09 00          .byte 9,9,9,0,2,0,7,14,0,0,0,14,11,255,0,18,11,255,0,4,2,6,7,14,0,0,0,14,11,255,0,18,11
0036A0  3  02 00 07 0E  
0036A4  3  00 00 00 0E  
0036BD  3  FF 00 04 02          .byte 255,0,4,2,0,7,14,0,0,0,14,11,255,0,18,11,0,9,9,0,2,6,7,14,255,0,4,11,0,13,255,0,16
0036C1  3  00 07 0E 00  
0036C5  3  00 00 0E 0B  
0036DE  3  0B FF 00 04          .byte 11,255,0,4,2,0,7,14,255,0,4,11,255,0,18,11,255,0,4,2,6,7,14,255,0,4,11,255,0,18,11,0,9,9
0036E2  3  02 00 07 0E  
0036E6  3  FF 00 04 0B  
003700  3  00 02 00 07          .byte 0,2,0,7,14,255,0,4,11,255,9,4,255,0,4,255,9,5,255,0,5,11,255,0,4,2,6,7,14,255,0,21,9,9
003704  3  0E FF 00 04  
003708  3  0B FF 09 04  
003722  3  0B FF 00 04          .byte 11,255,0,4,2,0,7,14,255,0,23,11,0,9,9,0,2,6,7,14,255,0,23,11,255,0,4,2,0,7,255,0,4
003726  3  02 00 07 0E  
00372A  3  FF 00 17 0B  
003743  3  FF 0B 15 FF          .byte 255,11,21,255,0,4,2,6,7,255,0,9,14,255,0,9,14,255,0,6,9,9,0,2,0,7,255,0,29,2,6,7,255,0,29
003747  3  00 04 02 06  
00374B  3  07 FF 00 09  
003766  3  02 00 07 FF          .byte 2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,0,4,14,255,0,9,14,255,0,14,2,4,255,1,30
00376A  3  00 1A 09 09  
00376E  3  00 02 06 07  
003788  3  03                   .byte 3
003789  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,11,11,255,0,14,13,255,0,12,2,6,7,255,0,29
00378D  3  1D 05 00 07  
003791  3  FF 00 1D 02  
0037AC  3  02 00 07 FF          .byte 2,0,7,255,0,29,2,6,7,255,0,7,14,0,0,0,14,0,0,0,14,255,0,13,2,0,7,9,9,9,255,11,21
0037B0  3  00 1D 02 06  
0037B4  3  07 FF 00 07  
0037CD  3  FF 00 05 02          .byte 255,0,5,2,6,7,9,9,9,255,0,20,11,255,0,5,2,0,7,255,0,23,11,255,0,5,2,6,7,9,9,255,0,21
0037D1  3  06 07 09 09  
0037D5  3  09 FF 00 14  
0037EF  3  0B FF 00 05          .byte 11,255,0,5,2,0,7,255,0,23,11,255,0,5,2,6,7,9,9,255,0,21,11,255,0,5,2,0,7,255,0,23,11
0037F3  3  02 00 07 FF  
0037F7  3  00 17 0B FF  
003810  3  FF 00 05 02          .byte 255,0,5,2,6,7,0,0,0,9,9,255,0,4,9,9,255,0,4,9,9,255,0,4,9,9,11,255,0,5,2,0,7
003814  3  06 07 00 00  
003818  3  00 09 09 FF  
003831  3  FF 00 17 0B          .byte 255,0,23,11,255,0,5,2,6,7,255,0,23,11,255,0,5,2,0,7,255,0,21,9,9,11,255,0,5,2,6,7,0,0,0
003835  3  FF 00 05 02  
003839  3  06 07 FF 00  
003854  3  09 09 FF 00          .byte 9,9,255,0,4,9,9,255,0,4,9,9,255,0,12,2,0,7,9,9,255,0,27,2,6,7,255,0,29,2,0,7,255,0,10
003858  3  04 09 09 FF  
00385C  3  00 04 09 09  
003877  3  0E FF 00 12          .byte 14,255,0,18,2,4,255,1,30,3
00387B  3  02 04 FF 01  
00387F  3  1E 03        
003881  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,0,0,15,0,0,0,15,0,15,15,15,0,15,0,0,0,15,255,0,12
003885  3  1D 05 00 07  
003889  3  FF 00 1D 02  
0038A3  3  02 00 07 00          .byte 2,0,7,0,0,15,0,0,0,15,12,15,12,12,12,15,12,12,12,15,255,12,6,255,0,6,2,6,7,0,0,15,0
0038A7  3  00 0F 00 00  
0038AB  3  00 0F 0C 0F  
0038C4  3  0F 00 0F 00          .byte 15,0,15,0,15,15,0,0,15,0,0,0,15,255,0,5,12,255,0,6,2,0,7,0,0,15,0,15,0,15,0,15,0,0,0
0038C8  3  0F 0F 00 00  
0038CC  3  0F 00 00 00  
0038E7  3  0F 00 00 00          .byte 15,0,0,0,15,255,0,5,12,255,0,6,2,6,7,0,0,255,15,5,0,15,15,15,0,15,15,15,0,15,15,15,0,0,0
0038EB  3  0F FF 00 05  
0038EF  3  0C FF 00 06  
00390A  3  0C FF 00 06          .byte 12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,4,15,15,15,0,0,255,15,4,0
00390E  3  02 00 07 FF  
003912  3  00 06 0C FF  
00392B  3  0F 0F 0F 00          .byte 15,15,15,0,0,15,15,15,12,15,15,255,0,4,2,0,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0
00392F  3  00 0F 0F 0F  
003933  3  0C 0F 0F FF  
00394C  3  0F 00 0F 00          .byte 15,0,15,0,0,12,15,15,255,0,4,2,6,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0,15,0,15,15
003950  3  00 0C 0F 0F  
003954  3  FF 00 04 02  
00396E  3  00 0C 0F 0F          .byte 0,12,15,15,255,0,4,2,0,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0,15,0,15,0,0,12,255,0,6
003972  3  FF 00 04 02  
003976  3  00 07 FF 00  
003991  3  02 06 07 FF          .byte 2,6,7,255,0,4,15,15,15,0,0,255,15,4,0,15,0,0,15,0,15,15,15,12,15,15,255,0,4,2,0,7,255,0,29
003995  3  00 04 0F 0F  
003999  3  0F 00 00 FF  
0039B4  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7
0039B8  3  00 1D 02 00  
0039BC  3  07 FF 00 1D  
0039D5  3  FF 00 1D 02          .byte 255,0,29,2,6,7,255,11,29,2,0,7,255,0,29,2,4,255,1,30,3
0039D9  3  06 07 FF 0B  
0039DD  3  1D 02 00 07  
0039EA  3               numsc:
0039EA  3  08                   .byte 8
0039EB  3               .out .sprintf("SCREENS SIZE = %d", (* - scdat))
0039EB  3               
0039EB  3               nmedat:
0039EB  3  00 00 68 50          .byte 0,0,104,80,8,4,104,80,255
0039EF  3  08 04 68 50  
0039F3  3  FF           
0039F4  3  00 00 88 20          .byte 0,0,136,32,1,1,48,224,2,2,160,176,8,4,144,24,2,2,104,88,2,1,56,136,255
0039F8  3  01 01 30 E0  
0039FC  3  02 02 A0 B0  
003A0D  3  00 00 10 18          .byte 0,0,16,24,1,3,72,176,2,2,160,32,8,4,144,224,255
003A11  3  01 03 48 B0  
003A15  3  02 02 A0 20  
003A1E  3  00 00 50 18          .byte 0,0,80,24,1,2,8,104,1,2,104,144,4,1,80,64,8,4,120,24,1,2,104,64,255
003A22  3  01 02 08 68  
003A26  3  01 02 68 90  
003A37  3  00 00 08 88          .byte 0,0,8,136,3,2,160,80,4,1,56,136,8,4,16,168,1,2,32,40,1,3,104,208,255
003A3B  3  03 02 A0 50  
003A3F  3  04 01 38 88  
003A50  3  00 00 80 10          .byte 0,0,128,16,2,1,104,112,5,3,56,104,8,4,48,24,255
003A54  3  02 01 68 70  
003A58  3  05 03 38 68  
003A61  3  00 00 30 E0          .byte 0,0,48,224,4,1,8,176,1,3,80,64,1,3,104,112,1,3,136,160,8,4,40,16,255
003A65  3  04 01 08 B0  
003A69  3  01 03 50 40  
003A7A  3  00 00 08 30          .byte 0,0,8,48,6,0,24,176,6,0,80,56,6,0,24,120,6,0,80,136,255
003A7E  3  06 00 18 B0  
003A82  3  06 00 50 38  
003A8F  3               .out .sprintf("POSITIONS SIZE = %d", (* - nmedat))
003A8F  3               
003A8F  3               NUMOBJ = 1
003A8F  3               objdta:
003A8F  3  54 48 45 4E          .byte 84,72,69,78,32,71,79,32,84,79,32,84,72,69,32,69,88,73,84,46,13,83,73,77,80,76,69,83,0,0,0,0,254,56,120,254,56,120
003A93  3  20 47 4F 20  
003A97  3  54 4F 20 54  
003AB5  3               .out .sprintf("OBJECTS SIZE = %d", (* - objdta))
003AB5  3               
003AB5  3               font:
003AB5  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003AB9  3  00 00 00 00  
003ABD  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
003AC1  3  30 00 30 00  
003AC5  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
003AC9  3  00 00 00 00  
003ACD  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
003AD1  3  6C FE 6C 00  
003AD5  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
003AD9  3  7E 1E 7E 18  
003ADD  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
003AE1  3  30 6E CE 00  
003AE5  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
003AE9  3  7E CC 7E 00  
003AED  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
003AF1  3  00 00 00 00  
003AF5  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
003AF9  3  18 18 0C 00  
003AFD  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
003B01  3  30 30 60 00  
003B05  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
003B09  3  7E 18 3C 00  
003B0D  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
003B11  3  7E 18 18 00  
003B15  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
003B19  3  00 18 18 30  
003B1D  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
003B21  3  7E 00 00 00  
003B25  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
003B29  3  00 38 38 00  
003B2D  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
003B31  3  18 30 60 00  
003B35  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
003B39  3  F6 E6 7C 00  
003B3D  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
003B41  3  18 18 7E 00  
003B45  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
003B49  3  7C C0 FE 00  
003B4D  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
003B51  3  06 C6 7C 00  
003B55  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
003B59  3  D8 FE 18 00  
003B5D  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
003B61  3  06 C6 7C 00  
003B65  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
003B69  3  C6 C6 7C 00  
003B6D  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
003B71  3  18 30 30 00  
003B75  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
003B79  3  C6 C6 7C 00  
003B7D  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
003B81  3  7E 06 7C 00  
003B85  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
003B89  3  00 00 30 00  
003B8D  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
003B91  3  00 30 30 60  
003B95  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003B99  3  30 18 0C 00  
003B9D  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
003BA1  3  00 7E 00 00  
003BA5  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
003BA9  3  0C 18 30 00  
003BAD  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
003BB1  3  18 00 18 00  
003BB5  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
003BB9  3  FE C0 7C 00  
003BBD  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
003BC1  3  FE C6 C6 00  
003BC5  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
003BC9  3  C6 C6 FC 00  
003BCD  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
003BD1  3  C0 C6 7C 00  
003BD5  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
003BD9  3  C6 CC F8 00  
003BDD  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
003BE1  3  C0 C0 FE 00  
003BE5  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
003BE9  3  C0 C0 C0 00  
003BED  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
003BF1  3  DE C6 7C 00  
003BF5  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
003BF9  3  C6 C6 C6 00  
003BFD  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
003C01  3  18 18 7E 00  
003C05  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
003C09  3  C6 C6 7C 00  
003C0D  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
003C11  3  D8 CC C6 00  
003C15  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
003C19  3  C0 C0 FE 00  
003C1D  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
003C21  3  C6 C6 C6 00  
003C25  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
003C29  3  DE CE C6 00  
003C2D  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
003C31  3  C6 C6 7C 00  
003C35  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
003C39  3  FC C0 C0 00  
003C3D  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
003C41  3  F6 DE 7C 00  
003C45  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
003C49  3  FC CC C6 00  
003C4D  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
003C51  3  06 C6 7C 00  
003C55  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
003C59  3  30 30 30 00  
003C5D  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
003C61  3  C6 C6 7C 00  
003C65  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
003C69  3  C6 6C 38 00  
003C6D  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
003C71  3  C6 FE 6C 00  
003C75  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
003C79  3  38 6C C6 00  
003C7D  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
003C81  3  30 30 30 00  
003C85  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
003C89  3  30 60 FE 00  
003C8D  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
003C91  3  18 18 1E 00  
003C95  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003C99  3  30 18 0C 00  
003C9D  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
003CA1  3  30 30 F0 00  
003CA5  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
003CA9  3  30 30 30 00  
003CAD  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
003CB1  3  00 00 00 FF  
003CB5  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
003CB9  3  60 60 FE 00  
003CBD  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
003CC1  3  7C CC 7C 00  
003CC5  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
003CC9  3  66 66 7C 00  
003CCD  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
003CD1  3  60 60 3C 00  
003CD5  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
003CD9  3  CC CC 7C 00  
003CDD  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
003CE1  3  F8 C0 7C 00  
003CE5  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
003CE9  3  30 30 30 00  
003CED  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
003CF1  3  CC 7C 0C 78  
003CF5  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
003CF9  3  CC CC CC 00  
003CFD  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
003D01  3  30 30 78 00  
003D05  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
003D09  3  0C 0C 6C 38  
003D0D  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
003D11  3  70 78 6C 00  
003D15  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
003D19  3  30 30 1C 00  
003D1D  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
003D21  3  FC FC FC 00  
003D25  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
003D29  3  CC CC CC 00  
003D2D  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
003D31  3  CC CC 78 00  
003D35  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
003D39  3  CC F8 C0 C0  
003D3D  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
003D41  3  CC 7C 0C 0E  
003D45  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
003D49  3  60 60 60 00  
003D4D  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
003D51  3  78 0C F8 00  
003D55  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
003D59  3  30 30 1C 00  
003D5D  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
003D61  3  CC CC 78 00  
003D65  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
003D69  3  78 78 30 00  
003D6D  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
003D71  3  FC FC 78 00  
003D75  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003D79  3  30 78 CC 00  
003D7D  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
003D81  3  CC 7C 0C 78  
003D85  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003D89  3  30 60 FC 00  
003D8D  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
003D91  3  18 18 1E 00  
003D95  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003D99  3  18 18 18 00  
003D9D  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
003DA1  3  30 30 F0 00  
003DA5  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
003DA9  3  00 00 00 00  
003DAD  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
003DB1  3  E3 BB C6 7C  
003DB5  3               .out .sprintf("FONT SIZE = %d", (* - font))
003DB5  3               
003DB5  3  42 61 68 48  keys:   .byte 66,97,104,72,98,16,55,48,49,17,18
003DB9  3  62 10 37 30  
003DBD  3  31 11 12     
003DC0  3               .out .sprintf("KEYS SIZE = %d", (* - keys))
003DC0  3               
003DC0  3               data_end:
003DC0  3               .out .sprintf("TOTAL DATA SIZE = %d", (* - data_start))
003DC0  3               
003DC0  2               
003DC0  1               
003DC0  1               end_asm:
003DC0  1               
003DC0  1               ;----------------------------------------------------------------------
003DC0  1               ; RELOCATION OF BEEB CODE FROM LOAD ADDRESS
003DC0  1               ;----------------------------------------------------------------------
003DC0  1               
003DC0  1               relocate:
003DC0  1               ; Issue *TAPE otherwise DFS goes mental that we've overwritten workspace from &E00 - &1100
003DC0  1               
003DC0  1  A9 8C            lda #$8C
003DC2  1  A2 0C            ldx #$0C
003DC4  1  A0 00            ldy #$00
003DC6  1  20 F4 FF         jsr OSBYTE					; *FX &8C,0,0 - *TAPE 1200
003DC9  1               
003DC9  1               ; Other one off initialisation could happen here...
003DC9  1               
003DC9  1               ; Relocate all code down to &E00
003DC9  1  A2 30        	ldx #>(end_asm - start_asm) + 1
003DCB  1  A0 00        	ldy #0
003DCD  1               reloop:
003DCD  1  B9 00 12     	lda load_address, y
003DD0  1  99 00 0E     	sta asm_code, y
003DD3  1  C8           	iny
003DD4  1  D0 F7        	bne reloop
003DD6  1  EE CF 41     	inc reloop + 2 + load_address - asm_code
003DD9  1  EE D2 41     	inc reloop + 5 + load_address - asm_code
003DDC  1  CA           	dex
003DDD  1  D0 EE        	bne reloop
003DDF  1  4C 03 0E     	jmp boot_game
003DDF  1               
