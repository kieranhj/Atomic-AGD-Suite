ca65 V2.17 - Git cc5c093
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; BBC AGD Engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ; BBC Micro version by Kieran Connell 2018
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .DEFINE asm_code $0e00		; assembly address _BEEB
000000r 1               .DEFINE load_address $1200	; load address _BEEB
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; BBC MICRO PLATFORM DEFINES
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; _BEEB MOS calls
000000r 1               
000000r 1               	OSBYTE	 = $fff4
000000r 1               	OSFILE	 = $ffdd
000000r 1               	OSWRCH	 = $ffee
000000r 1               	OSASCI	 = $ffe3
000000r 1               	OSWORD	 = $fff1
000000r 1               	OSFIND	 = $ffce
000000r 1               	OSGBPB	 = $ffd1
000000r 1               	OSARGS	 = $ffda
000000r 1               
000000r 1               	EVENTV	 = $0220
000000r 1               
000000r 1               	PAL_black = 0 ^ 7
000000r 1               	PAL_red = 1 ^ 7
000000r 1               	PAL_green = 2 ^ 7
000000r 1               	PAL_yellow = 3 ^ 7
000000r 1               	PAL_blue = 4 ^ 7
000000r 1               	PAL_magenta = 5 ^ 7
000000r 1               	PAL_cyan = 6 ^ 7
000000r 1               	PAL_white = 7 ^ 7
000000r 1               
000000r 1               ; System constants
000000r 1               
000000r 1               	ScreenSize  = $1800	; Startaddress video RAM _BEEB
000000r 1               	ScreenAddr 	= $8000 - ScreenSize	; Screen size bytes _BEEB
000000r 1               	ScreenRowBytes = 256				; 40 columns
000000r 1               
000000r 1               	SpriteMaxY	= 177	; used for clipping bottom of screen
000000r 1               
000000r 1               ; AGD Engine Workspace
000000r 1               
000000r 1               	MAP 		= $300				; properties map buffer (3x256 bytes)
000000r 1               	SCADTB_lb	= MAP + $300
000000r 1               	SCADTB_hb	= SCADTB_lb + $100
000000r 1               
000000r 1               .if pflag
000000r 1                   SHRAPN 		= $B00 - (NUMSHR * SHRSIZ)	; shrapnel table (55x6 bytes)
000000r 1               .endif
000000r 1               
000000r 1               	sprtab		= $B00				; NUMSPR*TABSIZ
000000r 1               
000000r 1               	.macro DEBUG_PAL pal
000000r 1               		SET_PAL pal
000000r 1               	.endmacro
000000r 1               
000000r 1               	.macro SET_PAL pal
000000r 1               		lda #$00+pal
000000r 1               		sta $fe21
000000r 1               		lda #$10+pal
000000r 1               		sta $fe21
000000r 1               		lda #$20+pal
000000r 1               		sta $fe21
000000r 1               		lda #$30+pal
000000r 1               		sta $fe21
000000r 1               		lda #$40+pal
000000r 1               		sta $fe21
000000r 1               		lda #$50+pal
000000r 1               		sta $fe21
000000r 1               		lda #$60+pal
000000r 1               		sta $fe21
000000r 1               		lda #$70+pal
000000r 1               		sta $fe21
000000r 1               	.endmacro
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; ZERO PAGE SEGMENT
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               
000000r 1               .include "z80-zp.inc"
000000r 2               ;ws	 = $60
000000r 2               
000000r 2  xx           z80_f: .res 1;	 = ws+$00
000001r 2  xx           z80_a: .res 1;	 = ws+$01
000002r 2               z80_af	 = z80_f
000002r 2               
000002r 2  xx           z80_c: .res 1;	 = ws+$02
000003r 2  xx           z80_b: .res 1;	 = ws+$03
000004r 2               z80_bc	 = z80_c
000004r 2               
000004r 2  xx           z80_e: .res 1;	 = ws+$04
000005r 2  xx           z80_d: .res 1;	 = ws+$05
000006r 2               z80_de	 = z80_e
000006r 2               
000006r 2  xx           z80_l: .res 1;	 = ws+$06
000007r 2  xx           z80_h: .res 1;	 = ws+$07
000008r 2               z80_hl	 = z80_l
000008r 2               
000008r 2  xx           z80_x: .res 1;    = ws+$08
000009r 2  xx           z80_i: .res 1;    = ws+$09
00000Ar 2               z80_ix	 = z80_x
00000Ar 2               
00000Ar 2  xx xx        z80_iy: .res 2;	 = ws+$0a
00000Cr 2               
00000Cr 2  xx           z80_fp: .res 1;	 = ws+$0c
00000Dr 2  xx           z80_ap: .res 1;	 = ws+$0d
00000Er 2               
00000Er 2  xx           z80_cp: .res 1;	 = ws+$0e
00000Fr 2  xx           z80_bp: .res 1;	 = ws+$0f
000010r 2               z80_bcp	 = z80_cp
000010r 2               
000010r 2  xx           z80_ep: .res 1;	 = ws+$10
000011r 2  xx           z80_dp: .res 1;	 = ws+$11
000012r 2               z80_dep	 = z80_ep
000012r 2               
000012r 2  xx           z80_lp: .res 1;	 = ws+$12
000013r 2  xx           z80_hp: .res 1;	 = ws+$13
000014r 2               z80_hlp	 = z80_lp
000014r 2               
000014r 2  xx xx        z80_sp: .res 2;   = ws+$14
000016r 2               
000016r 2  xx           z80_reg0: .res 1; = ws+$16
000017r 2  xx           z80_reg1: .res 1; = ws+$17
000018r 2  xx           z80_reg2: .res 1; = ws+$18
000019r 2  xx           z80_reg3: .res 1; = ws+$19
00001Ar 2               
00001Ar 2               ;z80_r: .res 1;	 = ws+$1a
00001Ar 2               
00001Ar 1               .include "engine-zp.inc"
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               ; AGD 6502 Engine Zero Page Variables
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               
00001Ar 2               ; Variables start here.
00001Ar 2               
00001Ar 2  xx           scno:	.res 1			; present screen number.
00001Br 2  xx           numlif:	.res 1			; number of lives.
00001Cr 2               
00001Cr 2  xx           vara:	.res 1			; general-purpose variable.
00001Dr 2  xx           varb:	.res 1			; general-purpose variable.
00001Er 2  xx           varc:	.res 1			; general-purpose variable.
00001Fr 2  xx           vard:	.res 1			; general-purpose variable.
000020r 2  xx           vare:	.res 1			; general-purpose variable.
000021r 2  xx           varf:	.res 1			; general-purpose variable.
000022r 2  xx           varg:	.res 1			; general-purpose variable.
000023r 2  xx           varh:	.res 1			; general-purpose variable.
000024r 2  xx           vari:	.res 1			; general-purpose variable.
000025r 2  xx           varj:	.res 1			; general-purpose variable.
000026r 2  xx           vark:	.res 1			; general-purpose variable.
000027r 2  xx           varl:	.res 1			; general-purpose variable.
000028r 2  xx           varm:	.res 1			; general-purpose variable.
000029r 2  xx           varn:	.res 1			; general-purpose variable.
00002Ar 2  xx           varo:	.res 1			; general-purpose variable.
00002Br 2  xx           varp:	.res 1			; general-purpose variable.
00002Cr 2  xx           varq:	.res 1			; general-purpose variable.
00002Dr 2  xx           varr:	.res 1			; general-purpose variable.
00002Er 2  xx           vars:	.res 1			; general-purpose variable.
00002Fr 2  xx           vart:	.res 1			; general-purpose variable.
000030r 2  xx           varu:	.res 1			; general-purpose variable.
000031r 2  xx           varv:	.res 1			; general-purpose variable.
000032r 2  xx           varw:	.res 1			; general-purpose variable.
000033r 2  xx           varz:	.res 1			; general-purpose variable.
000034r 2               
000034r 2  xx           charx:	.res 1			; cursor x position.
000035r 2  xx           chary:	.res 1			; cursor y position.
000036r 2               
000036r 2  xx           clock:	.res 1			; last clock reading.
000037r 2  xx           varrnd:	.res 1	        ; last random number.
000038r 2  xx           varobj:	.res 1  	    ; last object number.
000039r 2  xx           varopt:	.res 1     		; last option chosen from menu.
00003Ar 2  xx           varblk:	.res 1  		; block type.
00003Br 2  xx           nexlev:	.res 1			; next level flag.
00003Cr 2  xx           restfl:	.res 1			; restart screen flag.
00003Dr 2  xx           deadf:	.res 1			; dead flag.
00003Er 2  xx           gamwon:	.res 1			; game won flag.
00003Fr 2  xx           dispx:	.res 1			; cursor x position.
000040r 2  xx           dispy:	.res 1			; cursor y position.
000041r 2               
000041r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000042r 2  xx           joyval:	.res 1			; joystick reading.
000043r 2  xx           frmno:	.res 1			; selected frame.
000044r 2               
000044r 2               ;----------------------------------------------------
000044r 2               ; Missing vars
000044r 2               ;----------------------------------------------------
000044r 2               
000044r 2  xx           loopa:		.res 1
000045r 2  xx           loopb:		.res 1
000046r 2  xx           loopc:		.res 1
000047r 2  xx xx        FontPtr:    .res 2
000049r 2               
000049r 2               ; Local vars
000049r 2               
000049r 2  xx xx        scraddr:    .res 2
00004Br 2  xx xx        fntaddr:    .res 2
00004Dr 2  xx xx        tileaddr:   .res 2
00004Fr 2  xx xx        bufaddr:    .res 2
000051r 2               
000051r 2  xx xx        tmp:        .res 2
000053r 2  xx xx        scr_l:      .res 2
000055r 2  xx xx        scr_r:      .res 2
000057r 2  xx xx        scr_txt:    .res 2
000059r 2               
000059r 2  xx           xtmp:	    .res 1
00005Ar 2  xx           spcnt:	    .res 1
00005Br 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
00005Dr 2  xx           seed:	    .res 1		; seed for random numbers.
00005Er 2               
00005Er 2  xx           ccnt:       .res 1
00005Fr 2  xx           flag:	    .res 1
000060r 2  xx           rcol:	    .res 1
000061r 2  xx           rrow:	    .res 1
000062r 2               
000062r 2  xx           combyt:	    .res 1		; byte type compressed.
000063r 2  xx           comcnt:	    .res 1		; compression counter.
000064r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
000065r 2  xx           qscnt:	    .res 1
000066r 2               
000066r 2  xx           sprptr:	    .res 1      ; not a ptr
000067r 2  xx           sprcnt:	    .res 1
000068r 2               
000068r 2  xx xx        skptr:	    .res 2		; search pointer.
00006Ar 2  xx           sktptr:	    .res 1      ; not a ptr
00006Br 2  xx           tmproom:	.res 1
00006Cr 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
00006Er 2               
00006Er 2  xx xx xx     spr:	    .res 3      ; static sprite data
000071r 2  xx           vsync_count:.res 1
000072r 2  xx           colpatt:	.res 1
000073r 2  xx           sprtmp:     .res 1
000074r 2               
000074r 2               .if mflag
000074r 2               TmpAddr:	.res 2
000074r 2               bwid:	    .res 1     ; box/menu width.
000074r 2               blen:	    .res 1     ; box/menu height.
000074r 2               btop:	    .res 1     ; box coordinates.
000074r 2               blft:	    .res 1
000074r 2               .endif
000074r 2               
000074r 2               .if pflag
000074r 2  xx           shrctr:	    .res 1
000075r 2  xx           explcnt:	.res 1
000076r 2  xx           seed3:	    .res 1
000077r 2               .endif
000077r 2               
000077r 1               
000077r 1               ;----------------------------------------------------------------------
000077r 1               ; ZCODE SEGMENT
000077r 1               ;----------------------------------------------------------------------
000077r 1               
000077r 1               .segment "CODE"
000000r 1               .org asm_code
000E00  1               
000E00  1               start_asm:
000E00  1               
000E00  1  4C 49 38     	jmp relocate + load_address - asm_code
000E03  1               
000E03  1               boot_game:
000E03  1               
000E03  1               ; Zero ZP vars
000E03  1               
000E03  1               clear_zp:
000E03  1  A2 00        	ldx #0
000E05  1  8A           	txa
000E06  1               	:
000E06  1  95 00        	sta $00, x
000E08  1  E8           	inx
000E09  1  E0 A0        	cpx #$a0
000E0B  1  D0 F9        	bne :-
000E0D  1               
000E0D  1               	; Init non-zero vars
000E0D  1  A9 03        	lda #3
000E0F  1  85 rr        	sta numlif
000E11  1               
000E11  1  A2 FF        	ldx #255
000E13  1  86 rr        	stx varrnd
000E15  1  86 rr        	stx varopt
000E17  1  86 rr        	stx varblk
000E19  1  CA           	dex
000E1A  1  86 rr        	stx varobj
000E1C  1               
000E1C  1  20 80 0E     	jsr bbcinit
000E1F  1               
000E1F  1               	; Call AGD Engine start game
000E1F  1  20 08 11     	jsr start_game
000E22  1               
000E22  1  20 9F 0E     	jsr bbckill
000E25  1               
000E25  1                   ; Wait for keypress
000E25  1  A2 FF        	ldx #$ff
000E27  1  A0 7F        	ldy #$7f
000E29  1  A9 81        	lda #$81
000E2B  1  20 F4 FF     	jsr OSBYTE
000E2E  1               
000E2E  1               	; Restart or exit
000E2E  1  4C 03 0E     	jmp boot_game
000E31  1               
000E31  1               ;----------------------------------------------------------------------
000E31  1               ; PLATFORM SPECIFIC ENGINE CODE
000E31  1               ;----------------------------------------------------------------------
000E31  1               
000E31  1               	.include "z80.asm"
000E31  2               ;------------------------------------------------------
000E31  2               ; z80.asm
000E31  2               ; spectrum stuff
000E31  2               ; adresses
000E31  2               
000E31  2               ;ws	 = $60
000E31  2               
000E31  2               ;z80_f	 = ws+$00
000E31  2               ;z80_a	 = ws+$01
000E31  2               ;z80_af	 = z80_f
000E31  2               
000E31  2               ;z80_c	 = ws+$02
000E31  2               ;z80_b	 = ws+$03
000E31  2               ;z80_bc	 = z80_c
000E31  2               
000E31  2               ;z80_e	 = ws+$04
000E31  2               ;z80_d	 = ws+$05
000E31  2               ;z80_de	 = z80_e
000E31  2               
000E31  2               ;z80_l	 = ws+$06
000E31  2               ;z80_h	 = ws+$07
000E31  2               ;z80_hl	 = z80_l
000E31  2               
000E31  2               ;z80_x    = ws+$08
000E31  2               ;z80_i    = ws+$09
000E31  2               ;z80_ix	 = z80_x
000E31  2               
000E31  2               ;z80_iy	 = ws+$0a
000E31  2               
000E31  2               ;z80_fp	 = ws+$0c
000E31  2               ;z80_ap	 = ws+$0d
000E31  2               
000E31  2               ;z80_cp	 = ws+$0e
000E31  2               ;z80_bp	 = ws+$0f
000E31  2               ;z80_bcp = z80_cp
000E31  2               
000E31  2               ;z80_ep	 = ws+$10
000E31  2               ;z80_dp	 = ws+$11
000E31  2               ;z80_dep = z80_ep
000E31  2               
000E31  2               ;z80_lp	 = ws+$12
000E31  2               ;z80_hp	 = ws+$13
000E31  2               ;z80_hlp = z80_lp
000E31  2               
000E31  2               ;z80_sp   = ws+$14
000E31  2               
000E31  2               ;z80_reg0 = ws+$16
000E31  2               ;z80_reg1 = ws+$17
000E31  2               ;z80_reg2 = ws+$18
000E31  2               ;z80_reg3 = ws+$19
000E31  2               
000E31  2               ;z80_r	 = ws+$1a
000E31  2               
000E31  2               ; Contains seperatly 1 bit set
000E31  2               ; _BEEB this is not safe memory to use as required by MOS
000E31  2               
000E31  2               _bitmem0	= $f8
000E31  2               _bitmem1	= $f9
000E31  2               _bitmem2	= $fa
000E31  2               _bitmem3	= $fb
000E31  2               _bitmem4	= $fc
000E31  2               _bitmem5	= $fd
000E31  2               _bitmem6	= $fe
000E31  2               _bitmem7	= $ff
000E31  2               
000E31  2               ; constants
000E31  2               _bitvalue0	= $01
000E31  2               _bitvalue1	= $02
000E31  2               _bitvalue2	= $04
000E31  2               _bitvalue3	= $08
000E31  2               _bitvalue4	= $10
000E31  2               _bitvalue5	= $20
000E31  2               _bitvalue6	= $40
000E31  2               _bitvalue7	= $80
000E31  2               
000E31  2               _notbitvalue0	= $fe
000E31  2               _notbitvalue1	= $fd
000E31  2               _notbitvalue2	= $fb
000E31  2               _notbitvalue3	= $f7
000E31  2               _notbitvalue4	= $ef
000E31  2               _notbitvalue5	= $df
000E31  2               _notbitvalue6	= $bf
000E31  2               _notbitvalue7	= $7f
000E31  2               
000E31  2               
000E31  2               ;add_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_de:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_de:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_bc:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_bc:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		cmp z80_c
000E31  2               ;		bne cmp_hl_bc_end
000E31  2               ;		lda z80_h
000E31  2               ;		cmp z80_b
000E31  2               ;cmp_hl_bc_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_iy_ix:
000E31  2               ;		lda z80_iy
000E31  2               ;		cmp z80_ix
000E31  2               ;		bne cmp_iy_ix_end
000E31  2               ;		lda z80_iy+1
000E31  2               ;		cmp z80_ix+1
000E31  2               ;cmp_iy_ix_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_hl:
000E31  2               ;		lda z80_l
000E31  2               ;		bne dec_hl_no_dec_h
000E31  2               ;		dec z80_h
000E31  2               ;dec_hl_no_dec_h:
000E31  2               ;		dec z80_l
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_ix:
000E31  2               ;		lda z80_ix
000E31  2               ;		bne dec_ix_no_dec_h
000E31  2               ;		dec z80_ix+1
000E31  2               ;dec_ix_no_dec_h:
000E31  2               ;		dec z80_ix
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_bc:
000E31  2               ;		lda z80_c
000E31  2               ;		bne dec_bc_no_dec_b
000E31  2               ;		dec z80_b
000E31  2               ;dec_bc_no_dec_b:
000E31  2               ;		dec z80_c
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_de:
000E31  2               ;		lda z80_e
000E31  2               ;		bne dec_de_no_dec_d
000E31  2               ;		dec z80_d
000E31  2               ;dec_de_no_dec_d:
000E31  2               ;		dec z80_e
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;ex_af_afs:
000E31  2               ;	rts
000E31  2               ;ex_de_hl:
000E31  2               ;		lda z80_e
000E31  2               ;		ldx z80_l
000E31  2               ;		stx z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_d
000E31  2               ;		ldx z80_h
000E31  2               ;		stx z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               exx:
000E31  2  A5 rr        		lda z80_c
000E33  2  A4 rr        		ldy z80_cp
000E35  2  84 rr        		sty z80_c
000E37  2  85 rr        		sta z80_cp
000E39  2  A5 rr        		lda z80_b
000E3B  2  A4 rr        		ldy z80_bp
000E3D  2  84 rr        		sty z80_b
000E3F  2  85 rr        		sta z80_bp
000E41  2  A5 rr        		lda z80_e
000E43  2  A4 rr        		ldy z80_ep
000E45  2  84 rr        		sty z80_e
000E47  2  85 rr        		sta z80_ep
000E49  2  A5 rr        		lda z80_d
000E4B  2  A4 rr        		ldy z80_dp
000E4D  2  84 rr        		sty z80_d
000E4F  2  85 rr        		sta z80_dp
000E51  2  A5 rr        		lda scraddr
000E53  2  A4 rr        		ldy z80_lp
000E55  2  84 rr        		sty scraddr
000E57  2  85 rr        		sta z80_lp
000E59  2  A5 rr        		lda scraddr+1
000E5B  2  A4 rr        		ldy z80_hp
000E5D  2  84 rr        		sty scraddr+1
000E5F  2  85 rr        		sta z80_hp
000E61  2  60           		rts
000E62  2               
000E62  2               ;ex_sp_hl:
000E62  2               ;		tsx
000E62  2               ;		lda $0103,x
000E62  2               ;		ldy z80_h
000E62  2               ;		sta z80_h
000E62  2               ;		tya
000E62  2               ;		sta $0103,x
000E62  2               ;		lda $0104,x
000E62  2               ;		ldy z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		tya
000E62  2               ;		sta $104,x
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;ldi:
000E62  2               ;	rts
000E62  2               ;ldir:
000E62  2               ;		ldy #$00
000E62  2               ;		ldx z80_b
000E62  2               ;		beq ldir_last_page
000E62  2               ;ldir_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		bne ldir_loop
000E62  2               ;		inc z80_h
000E62  2               ;		inc z80_d
000E62  2               ;		dex
000E62  2               ;		bne ldir_loop
000E62  2               ;ldir_last_page:
000E62  2               ;		lda z80_c
000E62  2               ;		beq ldir_end
000E62  2               ;ldir_last_page_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		cpy z80_c
000E62  2               ;		bne ldir_last_page_loop
000E62  2               ;ldir_end:
000E62  2               ;		stx z80_c
000E62  2               ;		stx z80_b
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_h
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_e
000E62  2               ;		sta z80_e
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_d
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;lddr:		ldy #$00
000E62  2               ;lddr_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		jsr dec_hl
000E62  2               ;		jsr dec_de
000E62  2               ;		jsr dec_bc
000E62  2               ;		lda z80_b
000E62  2               ;		ora z80_c
000E62  2               ;		bne lddr_loop
000E62  2               ;		rts
000E62  2               ;ei:
000E62  2               ;		rts
000E62  2               ;di:
000E62  2               ;		rts
000E62  2               
000E62  2               ;-------------------------------------------------------------
000E62  2               ; Set bits in bitmem
000E62  2               ;-------------------------------------------------------------
000E62  2               
000E62  2               .if 0
000E62  2               z80_init:
000E62  2               	ldx #$00
000E62  2               	lda #$01
000E62  2               z80_init_loop:
000E62  2               	sta _bitmem0,x
000E62  2               	inx
000E62  2               	asl a
000E62  2               	bne z80_init_loop
000E62  2               	rts
000E62  2               .endif
000E62  2               
000E62  2               push_af:
000E62  2               push_bc:
000E62  2               push_de:
000E62  2               push_hl:
000E62  2               
000E62  2               pop_af:
000E62  2               pop_bc:
000E62  2               pop_de:
000E62  2               pop_ix:
000E62  2               pop_hl:
000E62  2               
000E62  2               add_hl_hl:
000E62  2               
000E62  2               inc_bc:
000E62  2               inc_de:
000E62  2               inc_hl:
000E62  2               inc_ix:
000E62  2               inc_sp:
000E62  2               
000E62  2               cpir:
000E62  2               
000E62  2               ex_af_af:
000E62  2               ;	rts
000E62  2               
000E62  1               	.include "bbc.inc"
000E62  2               ;----------------------------------------------------------------------
000E62  2               ; BBC Platform Specific functions
000E62  2               ;----------------------------------------------------------------------
000E62  2               
000E62  2               ;--------------------------------------------------------
000E62  2               ; Keys
000E62  2               ;
000E62  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000E62  2               ;             ||||||||
000E62  2               ;             |||||||+> Right    KEY 0  - X
000E62  2               ;             ||||||+-> Left     KEY 1  - Z
000E62  2               ;             |||||+--> Down     KEY 2  - .
000E62  2               ;             ||||+---> Up       KEY 3  - ;
000E62  2               ;             |||+----> Fire1    KEY 4  - SPC
000E62  2               ;             ||+-----> Fire2    KEY 5  - Q
000E62  2               ;             |+------> Fire3    KEY 6  - P
000E62  2               ;             +-------> Not used
000E62  2               ;
000E62  2               ;                       Option1  KEY 7  - 1
000E62  2               ;                       Option2  KEY 8  - 2
000E62  2               ;                       Option3  KEY 9  - 3
000E62  2               ;                       Option4  KEY 10 - 4
000E62  2               ;--------------------------------------------------------
000E62  2               
000E62  2               ;              X   Z   .   ;  SPC  Q   P
000E62  2               ;keys:   .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E62  2               ;        .byte $30,$31,$11,$12                   ; menu options.
000E62  2               
000E62  2  42 61 68 48  jkeys:  .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E66  2  62 10 37     
000E69  2  30 31 11 12          .byte $30,$31,$11,$12                   ; menu options.
000E6D  2               
000E6D  2               ;----------------------------------------------------
000E6D  2               ; Wait for keypress.
000E6D  2               ;----------------------------------------------------
000E6D  2               
000E6D  2               prskey:
000E6D  2  8A           	txa
000E6E  2  48           	pha
000E6F  2               prsloop:
000E6F  2  20 0E 0F     	jsr vsync
000E72  2               
000E72  2  A9 79        	lda #$79
000E74  2  A2 01        	ldx #$01
000E76  2  20 F4 FF     	jsr OSBYTE
000E79  2               
000E79  2  E0 FF        	cpx #$ff
000E7B  2  F0 F2        	beq prsloop		; wait until key pressed
000E7D  2  68           	pla
000E7E  2  AA           	tax
000E7F  2  60           	rts
000E80  2               
000E80  2               bbcinit:
000E80  2  78           	sei
000E81  2  AD 20 02     	lda EVENTV
000E84  2  8D B4 0E     	sta old_eventv
000E87  2  AD 21 02     	lda EVENTV+1
000E8A  2  8D B5 0E     	sta old_eventv+1
000E8D  2               
000E8D  2  A9 B6        	lda #<event_handler
000E8F  2  8D 20 02     	sta EVENTV
000E92  2  A9 0E        	lda #>event_handler
000E94  2  8D 21 02     	sta EVENTV+1
000E97  2  58           	cli
000E98  2               
000E98  2               	; Enable VSYNC event.
000E98  2  A9 0E        	lda #14
000E9A  2  A2 04        	ldx #4
000E9C  2  4C F4 FF     	jmp OSBYTE
000E9F  2               
000E9F  2               bbckill:
000E9F  2  78           	sei
000EA0  2  AD B4 0E     	lda old_eventv
000EA3  2  8D 20 02     	sta EVENTV
000EA6  2  AD B5 0E     	lda old_eventv+1
000EA9  2  8D 21 02     	sta EVENTV+1
000EAC  2  58           	cli
000EAD  2               
000EAD  2               	; Disable VSYNC event.
000EAD  2  A9 0D        	lda #13
000EAF  2  A2 04        	ldx #4
000EB1  2  4C F4 FF     	jmp OSBYTE
000EB4  2               
000EB4  2               
000EB4  2               old_eventv:
000EB4  2  xx xx        	.res 2
000EB6  2               
000EB6  2               event_handler:
000EB6  2  08           	php
000EB7  2  C9 04        	cmp #4
000EB9  2  D0 02        	bne not_vsync
000EBB  2               
000EBB  2  E6 rr        	inc vsync_count
000EBD  2               
000EBD  2               not_vsync:
000EBD  2  28           	plp
000EBE  2  6C B4 0E     	jmp (old_eventv)
000EC1  2               
000EC1  2               bbcsync:
000EC1  2  A5 rr        	lda vsync_count
000EC3  2  C9 02        	cmp #2
000EC5  2  90 FA        	bcc bbcsync
000EC7  2  A9 00        	lda #0
000EC9  2  85 rr        	sta vsync_count
000ECB  2  60           	rts
000ECC  2               
000ECC  2               ;--------------------------------------------------------
000ECC  2               ; Keyboard test routine.
000ECC  2               ;
000ECC  2               ; Input:
000ECC  2               ;  A = key to read, high nibble=row and low nibble=col
000ECC  2               ;
000ECC  2               ; Output:
000ECC  2               ;  carry clr = key pressed
000ECC  2               ;  carry set = key not pressed
000ECC  2               ;--------------------------------------------------------
000ECC  2               
000ECC  2               ktest:
000ECC  2  85 rr        	sta z80_a		; save key
000ECE  2  98           	tya
000ECF  2  48           	pha
000ED0  2               
000ED0  2               ; _BEEB keyboard read
000ED0  2  A5 rr        	lda z80_a
000ED2  2  49 80        	eor #$80		; _BEEB just look for this key
000ED4  2  AA           	tax
000ED5  2               
000ED5  2  A9 79        	lda #$79
000ED7  2  20 F4 FF     	jsr OSBYTE
000EDA  2               
000EDA  2  8A           	txa
000EDB  2  30 04        	bmi pressed 	; _BEEB X is negative if key is pressed
000EDD  2               
000EDD  2  38           	sec			; key not pressed
000EDE  2  68           	pla
000EDF  2  A8           	tay
000EE0  2  60           	rts
000EE1  2               
000EE1  2               pressed:
000EE1  2  18           	clc			; key pressed
000EE2  2  68           	pla
000EE3  2  A8           	tay
000EE4  2  60           	rts
000EE5  2               
000EE5  2               ;---------------------------------------------------------------
000EE5  2               ; Getkey in column,row format
000EE5  2               ;
000EE5  2               ; Output:
000EE5  2               ;  A = high nibble=row and low nibble=column key in matrix
000EE5  2               ;---------------------------------------------------------------
000EE5  2               
000EE5  2               kget:
000EE5  2  86 rr        	stx xtmp
000EE7  2               
000EE7  2               kget1:
000EE7  2  A9 79        	lda #$79			; _BEEB read keyboard with OSBYTE &79
000EE9  2  A2 01        	ldx #$01
000EEB  2  20 F4 FF     	jsr OSBYTE
000EEE  2               
000EEE  2  E0 FF        	cpx #$ff
000EF0  2  F0 F5        	beq kget1
000EF2  2               
000EF2  2  8A           	txa
000EF3  2               
000EF3  2  A6 rr        	ldx xtmp
000EF5  2  60           	rts
000EF6  2               
000EF6  2               ;----------------------------------------------------
000EF6  2               ; AtoMMC joystick controls.
000EF6  2               ; _BEEB TODO
000EF6  2               ;----------------------------------------------------
000EF6  2               
000EF6  2               joyinit:
000EF6  2               joysin:
000EF6  2  60           	rts
000EF7  2               
000EF7  2               
000EF7  2               ;----------------------------------------------------
000EF7  2               ; Delay routine 1/50 sec
000EF7  2               ;
000EF7  2               ; Wait 1/60 sec = 16666 usec
000EF7  2               ; Wait 208 x 16 =  3328 usec
000EF7  2               ;                 19994 usec
000EF7  2               ; rts           =     6 usec
000EF7  2               ; Total         = 20000 usec
000EF7  2               ;----------------------------------------------------
000EF7  2               
000EF7  2               delay:
000EF7  2  85 rr        	sta xtmp
000EF9  2               del_loop:
000EF9  2  A9 13        	lda #19
000EFB  2  20 F4 FF     	jsr OSBYTE		; wait for vsync _BEEB
000EFE  2               
000EFE  2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
000F00  2               delay1:
000F00  2  61 80        	adc ($80,x)		;	 6 usec
000F02  2  61 80        	adc ($80,x)		;	 6 usec
000F04  2  88           	dey			;	 2 usec
000F05  2  D0 F9        	bne delay1		;	 2 usec
000F07  2  EA           	nop			; 2 usec
000F08  2  EA           	nop			; 2 usec
000F09  2               				; tot: 20000 usec
000F09  2  C6 rr        	dec xtmp
000F0B  2  D0 EC        	bne del_loop
000F0D  2  60           	rts
000F0E  2               
000F0E  2               ;-------------------------------------------------------------
000F0E  2               ; Screen synchronisation.
000F0E  2               ;
000F0E  2               ;  - read joystick/keyboard
000F0E  2               ;  - handle sound
000F0E  2               ;  - sync framerate with clock
000F0E  2               ;  - handle shrapnel every even frame
000F0E  2               ;-------------------------------------------------------------
000F0E  2               
000F0E  2               vsync:
000F0E  2  48           	pha
000F0F  2  98           	tya
000F10  2  48           	pha
000F11  2  8A           	txa
000F12  2  48           	pha
000F13  2  20 25 21     	jsr joykey		; read joystick/keyboard.
000F16  2               vsync1:
000F16  2               ; Don't sync to vsync here - we can sync to every other vsync in main loop
000F16  2               ;	lda #19
000F16  2               ;	jsr OSBYTE		; _BEEB vsync
000F16  2               
000F16  2  A5 rr        	lda clock
000F18  2  29 01        	and #1
000F1A  2  D0 03        	bne:+
000F1C  2  20 05 12     	jsr proshr		; handle shrapnel every even frame
000F1F  2               :
000F1F  2  AD 2A 0F     	lda sndtyp
000F22  2  F0 00        	beq sndskip
000F24  2               
000F24  2               ; _BEEB TODO SOUND
000F24  2               ;sndloop:
000F24  2               ;	lda SpeakerBit		; handle sound
000F24  2               ;	ldy sndtyp
000F24  2               ;sndwait:
000F24  2               ;	dey
000F24  2               ;	bne sndwait
000F24  2               ;	eor #4
000F24  2               ;	sta SpeakerBit
000F24  2               ;	dec sndtyp
000F24  2               ;	bne sndloop
000F24  2               
000F24  2               sndskip:
000F24  2  68           	pla
000F25  2  AA           	tax
000F26  2  68           	pla
000F27  2  A8           	tay
000F28  2  68           	pla
000F29  2  60           	rts
000F2A  2               
000F2A  2  00           sndtyp:	.byte 0
000F2B  2               
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               ; BBC video hardware fns
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               
000F2B  2               screeninit:
000F2B  2  A2 0D        	ldx #13
000F2D  2               crtcloop:
000F2D  2  8E 00 FE     	stx $FE00
000F30  2  BD 4D 0F     	lda crtc_regs_high,x
000F33  2  8D 01 FE     	sta $FE01
000F36  2  CA           	dex
000F37  2  10 F4        	bpl crtcloop
000F39  2               
000F39  2                   ; Set ULA
000F39  2  A9 88            lda #$88            ; MODE 4
000F3B  2  8D 48 02         sta $248            ; Tell the OS or it will mess with ULA settings at vsync
000F3E  2  8D 20 FE         sta $FE20
000F41  2               
000F41  2               ; fall through to palette
000F41  2               
000F41  2               setpal:
000F41  2  A2 0F        	ldx #15
000F43  2               palloop:
000F43  2  BD 5B 0F     	lda ula_pal,x
000F46  2  8D 21 FE     	sta $fe21
000F49  2  CA           	dex
000F4A  2  10 F7        	bpl palloop
000F4C  2  60           	rts
000F4D  2               
000F4D  2               crtc_regs_high:
000F4D  2  3F           	.byte 63				; R0  horizontal total
000F4E  2  20           	.byte 32				; R1  horizontal displayed
000F4F  2  31           	.byte 49				; R2  horizontal position
000F50  2  24           	.byte $24				; R3  sync width 40 = &28
000F51  2  26           	.byte 38				; R4  vertical total
000F52  2  00           	.byte 0					; R5  vertical total adjust
000F53  2  18           	.byte 24				; R6  vertical displayed
000F54  2  23           	.byte 35				; R7  vertical position; 35=top of screen
000F55  2  00           	.byte $00				; R8  interlace
000F56  2  07           	.byte 7					; R9  scanlines per row
000F57  2  20           	.byte 32				; R10 cursor start
000F58  2  08           	.byte 8					; R11 cursor end
000F59  2  0D           	.byte >(ScreenAddr/8)	; R12 screen start address, high
000F5A  2  00           	.byte <(ScreenAddr/8)	; R13 screen start address, low
000F5B  2               
000F5B  2               ula_pal:
000F5B  2  07           	.byte $00 + PAL_black
000F5C  2  17           	.byte $10 + PAL_black
000F5D  2  27           	.byte $20 + PAL_black
000F5E  2  37           	.byte $30 + PAL_black
000F5F  2  47           	.byte $40 + PAL_black
000F60  2  57           	.byte $50 + PAL_black
000F61  2  67           	.byte $60 + PAL_black
000F62  2  77           	.byte $70 + PAL_black
000F63  2  80           	.byte $80 + PAL_white
000F64  2  90           	.byte $90 + PAL_white
000F65  2  A0           	.byte $a0 + PAL_white
000F66  2  B0           	.byte $b0 + PAL_white
000F67  2  C0           	.byte $c0 + PAL_white
000F68  2  D0           	.byte $d0 + PAL_white
000F69  2  E0           	.byte $e0 + PAL_white
000F6A  2  F0           	.byte $f0 + PAL_white
000F6B  2               
000F6B  2               ;----------------------------------------------------
000F6B  2               ; Draw sprite
000F6B  2               ;----------------------------------------------------
000F6B  2               
000F6B  2               sprite:
000F6B  2  86 rr        	stx xtmp		; Save X-reg
000F6D  2  20 BD 0F     	jsr scadd 		; get screen address in scraddr.
000F70  2               
000F70  2  A5 rr        	lda dispx 		; x position.
000F72  2  29 07        	and #7 			; position straddling cells.
000F74  2  85 rr        	sta z80_b		; store in b register.
000F76  2               
000F76  2  A5 rr        	lda z80_l		; store sprite graphic address.
000F78  2  8D 89 0F     	sta sprit1+1
000F7B  2  8D 8F 0F     	sta sprit2+1
000F7E  2  A5 rr        	lda z80_h
000F80  2  8D 8A 0F     	sta sprit1+2
000F83  2  8D 90 0F     	sta sprit2+2
000F86  2               
000F86  2  A2 00        	ldx #0			; pixel height.
000F88  2               sprit1:
000F88  2  BD 18 31     	lda objdta,x		; fetch first byte.
000F8B  2  85 rr        	sta spr
000F8D  2  E8           	inx
000F8E  2               sprit2:
000F8E  2  BD 18 31     	lda objdta,x
000F91  2  85 rr        	sta spr+1
000F93  2               
000F93  2  A9 00        	lda #0
000F95  2  85 rr        	sta spr+2
000F97  2  20 9A 1D     	jsr sprit7		; shift sprite
000F9A  2               
000F9A  2  A5 rr        	lda spr			; fetch graphic.
000F9C  2  A0 00        	ldy #0			; _BEEB
000F9E  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA0  2  91 rr        	sta (scraddr),y		; write to screen.
000FA2  2               
000FA2  2  A5 rr        	lda spr+1		; fetch graphic.
000FA4  2  A0 08        	ldy #8			; _BEEB
000FA6  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA8  2  91 rr        	sta (scraddr),y		; write to screen.
000FAA  2               
000FAA  2  A5 rr        	lda spr+2		; fetch graphic.
000FAC  2  A0 10        	ldy #16			; _BEEB
000FAE  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FB0  2  91 rr        	sta (scraddr),y		; write to screen.
000FB2  2               
000FB2  2  20 49 10     	jsr nline
000FB5  2               
000FB5  2  E8           	inx			; next source byte.
000FB6  2  E0 20        	cpx #32
000FB8  2  D0 CE        	bne sprit1		; repeat
000FBA  2               
000FBA  2  A6 rr        	ldx xtmp		; retreive X-reg
000FBC  2  60           	rts
000FBD  2               
000FBD  2               ;------------------------------------------------------------------
000FBD  2               ; This routine returns a screen address for (dispx, dispy) in scraddr.
000FBD  2               ;------------------------------------------------------------------
000FBD  2               
000FBD  2               scadd:
000FBD  2  A6 rr        	ldx dispy
000FBF  2  A5 rr        	lda dispx
000FC1  2  29 F8        	and #$f8
000FC3  2  18           	clc
000FC4  2  7D 00 06     	adc SCADTB_lb,x
000FC7  2  85 rr        	sta scraddr
000FC9  2  BD 00 07     	lda SCADTB_hb,x
000FCC  2  69 00        	adc #0
000FCE  2  85 rr        	sta scraddr+1
000FD0  2  60           	rts
000FD1  2               
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               ; These are the sprite routines.
000FD1  2               ; sspria = single sprite, old (ix).
000FD1  2               ; ssprib = single sprite, new (ix+5).
000FD1  2               ; sspric = both sprites, old (ix) and new (ix+5).
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               
000FD1  2               sspria:
000FD1  2  20 73 24     	jsr gsprad		; get old sprite address.
000FD4  2               sspri2:
000FD4  2               
000FD4  2  A5 rr        	lda z80_e				; 3c
000FD6  2  8D 28 10     	sta dline_spraddr1+1	; 4c
000FD9  2  8D 40 10     	sta dline_spraddr2+1	; 4c
000FDC  2               
000FDC  2  A5 rr        	lda z80_d				; 3c
000FDE  2  8D 29 10     	sta dline_spraddr1+2	; 4c
000FE1  2  8D 41 10     	sta dline_spraddr2+2	; 4c
000FE4  2               
000FE4  2  A2 00        	ldx #0			; vertical lines.
000FE6  2               sspri0:
000FE6  2  20 27 10     	jsr dline		; draw a line.
000FE9  2  E0 20        	cpx #32
000FEB  2  D0 F9        	bne sspri0		; repeat 16 times x 2 bytes
000FED  2  60           	rts
000FEE  2               
000FEE  2               ;-----------------------------------------------------------------
000FEE  2               
000FEE  2               ssprib:
000FEE  2  20 54 24     	jsr gspran 		; get new sprite address.
000FF1  2  4C D4 0F     	jmp sspri2
000FF4  2               
000FF4  2               ;-----------------------------------------------------------------
000FF4  2               
000FF4  2               sspric:
000FF4  2  20 73 24     	jsr gsprad 		; get old sprite address.
000FF7  2               
000FF7  2  A5 rr        	lda z80_e				; 3c
000FF9  2  8D 9E 10     	sta ddline_spraddr3+1	; 4c
000FFC  2  8D B6 10     	sta ddline_spraddr4+1	; 4c
000FFF  2               
000FFF  2  A5 rr        	lda z80_d				; 3c
001001  2  8D 9F 10     	sta ddline_spraddr3+2	; 4c
001004  2  8D B7 10     	sta ddline_spraddr4+2	; 4c
001007  2               
001007  2  20 31 0E     	jsr exx  		; store addresses.
00100A  2  20 54 24     	jsr gspran 		; get new sprite addresses.
00100D  2               
00100D  2  A5 rr        	lda z80_e				; 3c
00100F  2  8D 63 10     	sta ddline_spraddr1+1	; 4c
001012  2  8D 7B 10     	sta ddline_spraddr2+1	; 4c
001015  2               
001015  2  A5 rr        	lda z80_d				; 3c
001017  2  8D 64 10     	sta ddline_spraddr1+2	; 4c
00101A  2  8D 7C 10     	sta ddline_spraddr2+2	; 4c
00101D  2               
00101D  2  A2 00        	ldx #0
00101F  2               lloop:
00101F  2  20 62 10     	jsr ddline 		; draw a line.
001022  2  E0 20        	cpx #32
001024  2  D0 F9        	bne lloop
001026  2  60           	rts
001027  2               
001027  2               ;-------------------------------------------------------------
001027  2               ; Drop through.
001027  2               ; Line drawn, now work out next target address.
001027  2               ;
001027  2               ; Input:
001027  2               ;  B  = right mask
001027  2               ;  C  = left mask
001027  2               ;  DE = spriteaddress
001027  2               ;  scraddr = screen address
001027  2               ;-------------------------------------------------------------
001027  2               
001027  2               dline:
001027  2               
001027  2               dline_spraddr1:
001027  2  BD FF FF     	lda $ffff,x 		; graphic data.
00102A  2               ;	lda (z80_de),y
00102A  2  85 rr        	sta sprtmp
00102C  2  25 rr        	and z80_c 			; mask away what's not needed.
00102E  2               
00102E  2               ; _BEEB screen arrangement
00102E  2  A0 00        	ldy #0
001030  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001032  2  91 rr        	sta (scraddr),y 	; bung it in.
001034  2               
001034  2  A5 rr        	lda sprtmp
001036  2  25 rr        	and z80_b 			; mask away unwanted
001038  2               
001038  2               ; _BEEB screen arrangement
001038  2  A0 10        	ldy #16
00103A  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00103C  2  91 rr        	sta (scraddr),y 	; bung it in.
00103E  2               
00103E  2  E8           	inx
00103F  2               dline_spraddr2:
00103F  2  BD FF FF     	lda $ffff,x 		; second bit of data.
001042  2               
001042  2               ; _BEEB screen arrangement
001042  2  A0 08        	ldy #8
001044  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001046  2  91 rr        	sta (scraddr),y 	; bung it in.
001048  2               
001048  2  E8           	inx
001049  2               
001049  2               ;----------------------------------------------------------------------
001049  2               ; Line drawn, now work out next target address.
001049  2               ;----------------------------------------------------------------------
001049  2               
001049  2               ; _BEEB screen arrangement
001049  2               
001049  2               nline:
001049  2  A5 rr        	lda scraddr 		; get low byte of address.
00104B  2  29 07        	and #7
00104D  2  C9 07        	cmp #7				; is this last line of row?
00104F  2  F0 03        	beq beeb_next_row
001051  2               
001051  2               	; within same row
001051  2  E6 rr        	inc scraddr			; new low byte of address.
001053  2               ;	bne :+
001053  2               ;	inc scraddr+1		; new high byte of address.
001053  2               :
001053  2  60           	rts
001054  2               
001054  2               beeb_next_row:
001054  2  18           	clc
001055  2  A5 rr        	lda scraddr
001057  2  69 F9        	adc #<(ScreenRowBytes-7)
001059  2  85 rr        	sta scraddr			; new low byte of address.
00105B  2  A5 rr        	lda scraddr+1
00105D  2  69 00        	adc #>(ScreenRowBytes-7)
00105F  2  85 rr        	sta scraddr+1		; new high byte of address.
001061  2  60           	rts
001062  2               
001062  2               ;-------------------------------------------------------------
001062  2               ; Drop through.
001062  2               ; Line drawn, now work out next target address.
001062  2               ;
001062  2               ; Input:
001062  2               ;  B  = right mask
001062  2               ;  C  = left mask
001062  2               ;  DE = spriteaddress
001062  2               ;  scraddr = screen address
001062  2               ;-------------------------------------------------------------
001062  2               
001062  2               ddline:
001062  2               
001062  2               ; NEW SPRITE
001062  2               
001062  2               ddline_spraddr1:
001062  2  BD FF FF     	lda $ffff,x 		; graphic data.
001065  2               ;	lda (z80_de),y
001065  2  85 rr        	sta sprtmp
001067  2  25 rr        	and z80_c 			; mask away what's not needed.
001069  2               
001069  2               ; _BEEB screen arrangement
001069  2  A0 00        	ldy #0
00106B  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00106D  2  91 rr        	sta (scraddr),y 	; bung it in.
00106F  2               
00106F  2  A5 rr        	lda sprtmp			; fetch data.
001071  2  25 rr        	and z80_b 			; mask away unwanted
001073  2               
001073  2               ; _BEEB screen arrangement
001073  2  A0 10        	ldy #16
001075  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001077  2  91 rr        	sta (scraddr),y 	; bung it in.
001079  2               
001079  2  E8           	inx
00107A  2               ddline_spraddr2:
00107A  2  BD FF FF     	lda $ffff,x 		; second bit of data.
00107D  2               
00107D  2               ; _BEEB screen arrangement
00107D  2  A0 08        	ldy #8
00107F  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001081  2  91 rr        	sta (scraddr),y 	; bung it in.
001083  2               
001083  2               ; _BEEB next row
001083  2               
001083  2  A5 rr        	lda scraddr 		; get low byte of address.
001085  2  29 07        	and #7
001087  2  C9 07        	cmp #7				; is this last line of row?
001089  2  F0 04        	beq :+
00108B  2               
00108B  2               	; within same row can't increment page
00108B  2  E6 rr        	inc scraddr			; new low byte of address.
00108D  2  D0 0D        	bne ddline2
00108F  2               
00108F  2               :
00108F  2  18           	clc
001090  2  A5 rr        	lda scraddr
001092  2  69 F9        	adc #<(ScreenRowBytes-7)
001094  2  85 rr        	sta scraddr			; new low byte of address.
001096  2  A5 rr        	lda scraddr+1
001098  2  69 00        	adc #>(ScreenRowBytes-7)
00109A  2  85 rr        	sta scraddr+1		; new high byte of address.
00109C  2               
00109C  2               ; OLD SPRITE
00109C  2               
00109C  2               ddline2:
00109C  2               
00109C  2  CA           	dex
00109D  2               ddline_spraddr3:
00109D  2  BD FF FF     	lda $ffff,x			; graphic data.
0010A0  2               ;	lda (z80_dep),y 	; graphic data.
0010A0  2  85 rr        	sta sprtmp
0010A2  2  25 rr        	and z80_cp 			; mask away what's not needed.
0010A4  2               
0010A4  2               ; _BEEB screen arrangement
0010A4  2  A0 00        	ldy #0
0010A6  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
0010A8  2  91 rr        	sta (z80_hlp),y 	; bung it in.
0010AA  2               
0010AA  2  A5 rr        	lda sprtmp 			; fetch data.
0010AC  2  25 rr        	and z80_bp 			; mask awayh unwanted
0010AE  2               
0010AE  2               ; _BEEB screen arrangement
0010AE  2  A0 10        	ldy #16
0010B0  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
0010B2  2  91 rr        	sta (z80_hlp),y 	; bung it in.
0010B4  2               
0010B4  2  E8           	inx
0010B5  2               ddline_spraddr4:
0010B5  2  BD FF FF     	lda $ffff,x 		; second bit of data.
0010B8  2               
0010B8  2               ; _BEEB screen arrangement
0010B8  2  A0 08        	ldy #8
0010BA  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
0010BC  2  91 rr        	sta (z80_hlp),y 	; bung it in.
0010BE  2               
0010BE  2  E8           	inx
0010BF  2               
0010BF  2               ; _BEEB screen arrangement
0010BF  2               
0010BF  2  A5 rr        	lda z80_lp 		; get low byte of address.
0010C1  2  29 07        	and #7
0010C3  2  C9 07        	cmp #7				; is this last line of row?
0010C5  2  F0 03        	beq :+
0010C7  2               
0010C7  2               	; within same row can't increment page
0010C7  2  E6 rr        	inc z80_lp			; new low byte of address.
0010C9  2  60           	rts
0010CA  2               
0010CA  2               :
0010CA  2  18           	clc
0010CB  2  A5 rr        	lda z80_lp
0010CD  2  69 F9        	adc #<(ScreenRowBytes-7)
0010CF  2  85 rr        	sta z80_lp			; new low byte of address.
0010D1  2  A5 rr        	lda z80_lp+1
0010D3  2  69 00        	adc #>(ScreenRowBytes-7)
0010D5  2  85 rr        	sta z80_lp+1		; new high byte of address.
0010D7  2  60           	rts
0010D8  2               
0010D8  2               ;----------------------------------------------------
0010D8  2               ; Display character in A at dispx,dispy.
0010D8  2               ;
0010D8  2               ; Input:
0010D8  2               ;  A 	   = character to print
0010D8  2               ;----------------------------------------------------
0010D8  2               
0010D8  2               pchar:
0010D8  2  85 rr        	sta fntaddr
0010DA  2  A9 00        	lda #0
0010DC  2  85 rr        	sta fntaddr+1
0010DE  2  06 rr        	asl fntaddr  		; multiply char by 8.
0010E0  2  26 rr        	rol fntaddr+1
0010E2  2  06 rr        	asl fntaddr
0010E4  2  26 rr        	rol fntaddr+1
0010E6  2  06 rr        	asl fntaddr
0010E8  2  26 rr        	rol fntaddr+1
0010EA  2               
0010EA  2  A5 rr        	lda fntaddr
0010EC  2  18           	clc
0010ED  2  65 rr        	adc FontPtr
0010EF  2  85 rr        	sta fntaddr		; that's the low byte.
0010F1  2  A5 rr        	lda fntaddr+1
0010F3  2  65 rr        	adc FontPtr+1
0010F5  2  85 rr        	sta fntaddr+1		; add displacement.
0010F7  2               pchark:
0010F7  2  20 ED 1C     	jsr gprad		; get screen address.
0010FA  2  A0 00        	ldy #0
0010FC  2               
0010FC  2               pchar0:
0010FC  2  B1 rr        	lda (fntaddr),y 	; get image byte.
0010FE  2  49 00        	eor #TxtInvert		; Invert
001100  2  91 rr        	sta (scraddr),y 	; copy to screen.
001102  2  C8           	iny					; next screen row down.
001103  2  C0 08        	cpy #8				; number lines
001105  2  90 F5        	bcc pchar0			; repeat.
001107  2  60           	rts
001108  2               
001108  2               
001108  1               
001108  1               ;----------------------------------------------------------------------
001108  1               ; AGD 6502 ENGINE CODE + COMPILED GAME SCRIPT
001108  1               ;----------------------------------------------------------------------
001108  1               
001108  1               start_game:
001108  1               
001108  1               	.include "game.inc"
001108  2               .include "test.inc"
001108  3               ; Game engine code --------------------------------------------------------------
001108  3               
001108  3               ; Arcade Game Designer.
001108  3               ; (C) 2008 Jonathan Cauldwell.
001108  3               ; ZX Spectrum Next Engine v0.1.
001108  3               
001108  3               ; Global definitions ------------------------------------------------------------
001108  3               
001108  3               	FONT = font			; Font address
001108  3               
001108  3               ; Block characteristics.
001108  3               
001108  3               	PLATFM = 1			; platform.
001108  3               	WALL = PLATFM + 1	; solid wall.
001108  3               	LADDER = WALL + 1	; ladder.
001108  3               	FODDER = LADDER + 1	; fodder block.
001108  3               	DEADLY = FODDER + 1	; deadly block.
001108  3               	CUSTOM = DEADLY + 1	; custom block.
001108  3               	WATER  = CUSTOM + 1	; water block.
001108  3                   COLECT = WATER + 1      ; collectable block.
001108  3                   NUMTYP = COLECT + 1     ; number of types.
001108  3               
001108  3               ; Sprites.
001108  3               
001108  3               	NUMSPR = 12			; number of sprites.
001108  3               	TABSIZ = 17			; size of each entry.
001108  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
001108  3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
001108  3               
001108  3               ; Sprite table variable offsets.
001108  3               
001108  3               	var_Type = 0		; sprite type
001108  3               	var_Image = 1		; sprite time number
001108  3               	var_Frame = 2		; sprite frame
001108  3               	var_Y = 3			; sprite y coordinate
001108  3               	var_X = 4			; sprite X coordinate
001108  3               
001108  3               	var_newType = 5		; sprite new type
001108  3               	var_newImage = 6	; sprite new image number
001108  3               	var_newFrame = 7	; sprite new frame
001108  3               	var_newY = 8		; sprite new y coordinate
001108  3               	var_newX = 9		; sprite new x coordinate
001108  3               
001108  3               	var_Direction = 10	; sprite direction
001108  3               	var_Param1 = 11		; sprite parameter 1
001108  3               	var_Param2 = 12		; sprite parameter 2
001108  3               
001108  3               	var_jumpLo = 13		; sprite jump ptr low
001108  3               	var_jumpHi = 14		; sprite jump ptr high
001108  3               	var_dataLo = 15		; sprite data ptr low
001108  3               	var_dataHi = 16		; sprite data ptr high
001108  3               
001108  3               ; Particle engine.
001108  3               
001108  3               	NUMSHR = 55			; pieces of shrapnel.
001108  3               	SHRSIZ = 6			; bytes per particle.
001108  3               
001108  3               ; Conditional compilation flags
001108  3               ; Flags are set in commandline assembly
001108  3               
001108  3               ;	mflag = 0 		; MENU + INV
001108  3               ;	pflag = 0		; Particle engine
001108  3               ;	sflag = 0		; scrollytext
001108  3               ;	fflag = 1		; Fontflag
001108  3               
001108  3               .if iflag
001108  3               	TxtInvert   = $ff	; Invert byte for character printing
001108  3               	ScrFillByte = $ff	; Screen fill byte for CLS
001108  3               .else
001108  3               	TxtInvert   = $00	; Invert byte for character printing
001108  3               	ScrFillByte = $00	; Screen fill byte for CLS
001108  3               .endif
001108  3               
001108  3               	ASCII_NEWLINE = 13
001108  3               
001108  3               ;===============================================================
001108  3               ; Game starts here
001108  3               ;===============================================================
001108  3               
001108  3               ;--------------------------------------------------------------
001108  3               ; If a font is required...
001108  3               ;--------------------------------------------------------------
001108  3               
001108  3  A9 3E        	lda #<(FONT-256)	; address of font.
00110A  3  85 rr        	sta FontPtr
00110C  3  A9 30        	lda #>(FONT-256)
00110E  3  85 rr        	sta FontPtr+1
001110  3               
001110  3  20 99 16     	jsr game	 		; start the game.
001113  3  60           	rts
001114  3               
001114  3               ; Don't change the order of these four.
001114  3               ; Menu routine relies on winlft following wintop.
001114  3               
001114  3  01           wintop:	.byte WINDOWTOP		; top of window.
001115  3  09           winlft:	.byte WINDOWLFT		; left edge.
001116  3  16           winhgt:	.byte WINDOWHGT		; window height.
001117  3  16           winwid:	.byte WINDOWWID		; window width.
001118  3  01           numob:	.byte NUMOBJ		; number of objects in game.
001119  3               
001119  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
001119  3               
001119  3  08           wntopx:	.byte (8 * WINDOWTOP)
00111A  3  48           wnlftx:	.byte (8 * WINDOWLFT)
00111B  3  A8           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
00111C  3  E6           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
00111D  3               
00111D  3               ; Make sure pointers are arranged in the same order as the data itself.
00111D  3               
00111D  3  AC 2F        frmptr:	.word frmlst         ; sprite frames.
00111F  3               
00111F  3               ; Assorted game routines which can go in contended memory.
00111F  3               
00111F  3               ;--------------------------------------------------------------
00111F  3               ; Modify for inventory.
00111F  3               ; called by the INV command
00111F  3               ;
00111F  3               ; Input:
00111F  3               ;  X   = message nr with objects seperated with ,
00111F  3               ;
00111F  3               ; Output:
00111F  3               ;  OPT = selected line nr of INV menu
00111F  3               ;--------------------------------------------------------------
00111F  3               
00111F  3               .if mflag
00111F  3               minve:
00111F  3               	lda #<(invdis)		; routine address.
00111F  3               	sta mod0+1		; set up menu routine.
00111F  3               	sta mod2+1		; set up count routine.
00111F  3               	lda #>(invdis)
00111F  3               	sta mod0+2
00111F  3               	sta mod2+2
00111F  3               	lda #<(fopt)		; find option from available objects.
00111F  3               	sta mod1+1		; set up routine.
00111F  3               	lda #>(fopt)
00111F  3               	sta mod1+1+1
00111F  3               	jmp dbox		; do menu routine.
00111F  3               
00111F  3               ;--------------------------------------------------------------
00111F  3               ; Modify for menu.
00111F  3               ; called by the MENU command
00111F  3               ;
00111F  3               ; Input:
00111F  3               ;  X   = message nr with menu items seperated with ,
00111F  3               ;
00111F  3               ; Output:
00111F  3               ;  OPT = selected line nr of MENU menu
00111F  3               ;--------------------------------------------------------------
00111F  3               
00111F  3               mmenu:
00111F  3               	lda #<(always)		; routine address.
00111F  3               	sta mod0+1		; set up routine.
00111F  3               	sta mod2+1		; set up count routine.
00111F  3               	lda #>(always)
00111F  3               	sta mod0+2
00111F  3               	sta mod2+2
00111F  3               
00111F  3               	lda #<(fstd)		; standard option selection.
00111F  3               	sta mod1+1		; set up routine.
00111F  3               	lda #>(fstd)
00111F  3               	sta mod1+2
00111F  3               
00111F  3               ; Drop through into box routine.
00111F  3               
00111F  3               ;--------------------------------------------------------------
00111F  3               ; Work out size of box for message or menu.
00111F  3               ;--------------------------------------------------------------
00111F  3               
00111F  3               dbox:
00111F  3               	lda #<(msgdat)		; pointer to messages.
00111F  3               	sta z80_l
00111F  3               	lda #>(msgdat)
00111F  3               	sta z80_h
00111F  3               
00111F  3               	jsr getwrd		; get message number.
00111F  3               
00111F  3               	lda z80_h		; store pointer to message.
00111F  3               	sta TmpAddr
00111F  3               	lda z80_l
00111F  3               	sta TmpAddr+1
00111F  3               
00111F  3               	lda #1			; height.
00111F  3               	sta z80_d
00111F  3               	lda #0			; start at object zero.
00111F  3               	sta combyt		; store number of object in combyt.
00111F  3               	sta z80_e		; maximum width.
00111F  3               dbox5:
00111F  3               	lda #0			; this line"s width.
00111F  3               	sta z80_b
00111F  3               mod2:
00111F  3               	jsr always		; item in player"s possession?
00111F  3               	cmp #255
00111F  3               	bne dbox6		; not in inventory, skip this line.
00111F  3               	inc z80_d		; add to tally.
00111F  3               dbox6:
00111F  3               	ldy #0			; get character.
00111F  3               	lda (z80_hl),y
00111F  3               	sta z80_a
00111F  3               	inc z80_l		; next character.
00111F  3               	bne :+
00111F  3               	inc z80_h
00111F  3               :
00111F  3               	lda z80_a		; reached end of line?
00111F  3               	cmp #','
00111F  3               	beq dbox3		; yes.
00111F  3               	cmp #ASCII_NEWLINE
00111F  3               	beq dbox3		; yes.
00111F  3               	inc z80_b		; add to this line"s width.
00111F  3               	lda z80_a
00111F  3               	bmi dbox4		; end of message? yes, end count.
00111F  3               	jmp dbox6		; repeat until we find the end.
00111F  3               dbox3:
00111F  3               	lda z80_e		; maximum line width.
00111F  3               	cmp z80_b		; have we exceeded longest so far?
00111F  3               	bpl dbox5		; no, carry on looking.
00111F  3               	lda z80_b		; make this the widest so far.
00111F  3               	sta z80_e
00111F  3               	jmp dbox5		; keep looking.
00111F  3               dbox4:
00111F  3               	lda z80_e		; maximum line width.
00111F  3               	cmp z80_b		; have we exceeded longest so far?
00111F  3               	bpl dbox8		; no, carry on looking.
00111F  3               	lda z80_b		; final line is the longest so far.
00111F  3               	sta z80_e
00111F  3               dbox8:
00111F  3               	dec z80_d		; decrement items found.
00111F  3               	bne :+			; total was zero.
00111F  3               	jmp dbox15
00111F  3               :
00111F  3               	lda z80_e		; longest line.
00111F  3               	bne :+			; was it zero?
00111F  3               	jmp dbox15		; total was zero.
00111F  3               :
00111F  3               	sta bwid		; set up size.
00111F  3               	lda z80_d
00111F  3               	sta blen
00111F  3               
00111F  3               ;--------------------------------------------------------------
00111F  3               ; That's set up our box size.
00111F  3               ;--------------------------------------------------------------
00111F  3               
00111F  3               	lda winhgt		; window height in characters.
00111F  3               	sec
00111F  3               	sbc z80_d		; subtract height of box.
00111F  3               	lsr a			; divide by 2.
00111F  3               	clc
00111F  3               	adc wintop		; add top edge of window.
00111F  3               	sta btop		; set up box top.
00111F  3               
00111F  3               	lda winwid		; window width in characters.
00111F  3               	sec
00111F  3               	sbc z80_e		; subtract box width.
00111F  3               	lsr a			; divide by 2.
00111F  3               	clc
00111F  3               	adc winlft		; add left edge of window.
00111F  3               	sta blft		; box left.
00111F  3               
00111F  3               	lda FontPtr		; font.
00111F  3               	sta grbase		; set up for text display.
00111F  3               	lda FontPtr+1
00111F  3               	sta grbase+1
00111F  3               
00111F  3               	lda TmpAddr+1		; restore message pointer.
00111F  3               	sta z80_l
00111F  3               	lda TmpAddr
00111F  3               	sta z80_h
00111F  3               
00111F  3               	lda btop		; box top.
00111F  3               	sta dispy		; set display coordinate.
00111F  3               	lda #0			; start at object zero.
00111F  3               	sta combyt		; store number of object in combyt.
00111F  3               dbox2:
00111F  3               	lda combyt		; get object number.
00111F  3               	sta z80_a
00111F  3               mod0:
00111F  3               	jsr always		; check inventory for display.
00111F  3               	cmp #255
00111F  3               	beq :+
00111F  3               	jmp dbox13		; not in inventory, skip this line.
00111F  3               :
00111F  3               	lda blft		; box left.
00111F  3               	sta dispx		; set left display position.
00111F  3               	lda bwid		; box width.
00111F  3               	sta z80_b		; store width.
00111F  3               dbox0:
00111F  3               	ldy #0			; get character.
00111F  3               	lda (z80_hl),y
00111F  3               	cmp #','		; end of line?
00111F  3               	beq dbox1		; yes, next one.
00111F  3               	cmp #ASCII_NEWLINE			; end of line?
00111F  3               	beq dbox1		; yes, next one.
00111F  3               
00111F  3               	dec z80_b		; one less to display.
00111F  3               	and #127		; remove terminator.
00111F  3               
00111F  3               	jsr pchr		; display on screen.
00111F  3               
00111F  3               	ldy #0
00111F  3               	lda (z80_hl),y		; get character.
00111F  3               	sta z80_a
00111F  3               	inc z80_l		; next character.
00111F  3               	bne :+
00111F  3               	inc z80_h
00111F  3               :
00111F  3               	lda z80_a
00111F  3               	cmp #128		; end of message?
00111F  3               	bmi :+
00111F  3               	jmp dbox7		; yes, job done.
00111F  3               :
00111F  3               	lda z80_b		; chars remaining.
00111F  3               	beq :+			; are any left?
00111F  3               	jmp dbox0		; yes, continue.
00111F  3               :
00111F  3               ;---------------------------------------------------
00111F  3               ; Reached limit of characters per line.
00111F  3               ;---------------------------------------------------
00111F  3               
00111F  3               dbox9:
00111F  3               	ldy #0
00111F  3               	lda (z80_hl),y		; get character.
00111F  3               	inc z80_l		; next one.
00111F  3               	bne :+
00111F  3               	inc z80_h
00111F  3               :
00111F  3               	cmp #','		; another line?
00111F  3               	beq dbox10		; yes, do next line.
00111F  3               	cmp #ASCII_NEWLINE			; another line?
00111F  3               	beq dbox10		; yes, do next line.
00111F  3               	cmp #128		; end of message?
00111F  3               	bcs :+
00111F  3               	jmp dbox11		; yes, finish message.
00111F  3               :
00111F  3               	jmp dbox9
00111F  3               
00111F  3               ;---------------------------------------------------
00111F  3               ; Fill box to end of line.
00111F  3               ;---------------------------------------------------
00111F  3               
00111F  3               dboxf:
00111F  3               	lda #32			; space character.
00111F  3               	jsr pchr		; display character.
00111F  3               	dec z80_b
00111F  3               	beq :+
00111F  3               	jmp dboxf		; repeat for remaining chars on line.
00111F  3               :
00111F  3               	rts
00111F  3               dbox1:
00111F  3               	inc z80_l		; skip character.
00111F  3               	bne :+
00111F  3               	inc z80_h
00111F  3               :
00111F  3               	jsr dboxf		; fill box out to right side.
00111F  3               dbox10:
00111F  3               	inc dispy		; y coordinate down a line next position.
00111F  3               	jmp dbox2		; next line.
00111F  3               dbox7:
00111F  3               	lda z80_b		; chars remaining.
00111F  3               	bne :+			; are any left?
00111F  3               	jmp dbox11		; no, nothing to draw.
00111F  3               :
00111F  3               	jsr dboxf		; fill message to line.
00111F  3               
00111F  3               ;------------------------------------------------------
00111F  3               ; Drawn the box menu, now select option.
00111F  3               ;------------------------------------------------------
00111F  3               
00111F  3               dbox11:
00111F  3               	lda btop		; box top.
00111F  3               	sta dispy		; set bar position.
00111F  3               dbox14:
00111F  3               	jsr joykey		; get controls.
00111F  3               	cmp #$7f		; anything pressed?
00111F  3               	bne dbox14		; yes, debounce it.
00111F  3               	jsr dbar		; draw bar.
00111F  3               dbox12:
00111F  3               	jsr joykey		; get controls.
00111F  3               	cmp #$7f		; anything pressed?
00111F  3               	beq dbox12		; no, nothing.
00111F  3               	and #16			; fire button pressed?
00111F  3               	bne :+
00111F  3               mod1:
00111F  3               	jmp fstd		; yes, job done.
00111F  3               :
00111F  3               	jsr dbar		; delete bar.
00111F  3               
00111F  3               	lda joyval		; joystick reading.
00111F  3               	and #8			; going up?
00111F  3               	beq dboxu		; yes, go up.
00111F  3               
00111F  3               	ldx dispy		; vertical position of bar.
00111F  3               	inx			; look down.
00111F  3               	txa
00111F  3               	sec
00111F  3               	sbc btop		; find distance from top.
00111F  3               	cmp blen		; top of box.
00111F  3               	bne :+
00111F  3               	jmp dbox14		; yes, go no further.
00111F  3               :
00111F  3               	inc dispy		; move bar.
00111F  3               	jmp dbox14		; continue.
00111F  3               dboxu:
00111F  3               	lda dispy		; vertical position of bar.
00111F  3               	cmp btop		; are we at the top?
00111F  3               	bne :+
00111F  3               	jmp dbox14		; yes, go no further.
00111F  3               :
00111F  3               	dec dispy		; move bar.
00111F  3               	jmp dbox14		; continue.
00111F  3               fstd:
00111F  3               	lda dispy		; bar position.
00111F  3               	sec
00111F  3               	sbc btop		; find selected option.
00111F  3               	sta varopt		; store the option.
00111F  3               	jmp redraw		; redraw the screen.
00111F  3               
00111F  3               ;------------------------------------------------------
00111F  3               ; Option not available.  Skip this line.
00111F  3               ;------------------------------------------------------
00111F  3               
00111F  3               dbox13:
00111F  3               	ldy #0
00111F  3               	lda (z80_hl),y		; get character.
00111F  3               	inc z80_l		; next one.
00111F  3               	bne :+
00111F  3               	inc z80_h
00111F  3               :
00111F  3               	cmp #','		; another line?
00111F  3               	bne :+
00111F  3               	jmp dbox2		; yes, do next line.
00111F  3               :
00111F  3               	cmp #ASCII_NEWLINE			; another line?
00111F  3               	bne :+
00111F  3               	jmp dbox2		; yes, do next line.
00111F  3               :
00111F  3               
00111F  3               	bpl :+			; end of message?
00111F  3               	jmp dbox11		; yes, finish message.
00111F  3               :
00111F  3               	jmp dbox13
00111F  3               dbox15:
00111F  3               	lda TmpAddr		; pop message pointer from the stack.
00111F  3               	sta z80_h
00111F  3               	lda TmpAddr+1
00111F  3               	sta z80_l
00111F  3               	rts
00111F  3               
00111F  3               ;------------------------------------------------------
00111F  3               ; Invert bar
00111F  3               ;------------------------------------------------------
00111F  3               
00111F  3               dbar:
00111F  3               	lda blft		; box left.
00111F  3               	sta dispx		; set display coordinate.
00111F  3               	jsr gprad		; get printing address.
00111F  3               
00111F  3               	lda bwid		; box width.
00111F  3               	sta z80_c		; loop counter in c.
00111F  3               	lda z80_h
00111F  3               	sta z80_d		; store screen address high byte.
00111F  3               dbar1:
00111F  3               	ldy #7			; pixel height in b.
00111F  3               dbar0:
00111F  3               	lda (scraddr),y		; get screen byte.
00111F  3               	eor #255		; reverse all bits.
00111F  3               	sta (scraddr),y		; write back to screen.
00111F  3               	dey			; next line down.
00111F  3               	bpl dbar0		; draw rest of character.
00111F  3               
00111F  3               	clc
00111F  3               	lda scraddr		; one char right.
00111F  3               	adc #8
00111F  3               	sta scraddr
00111F  3               	bcc :+
00111F  3               	inc scraddr+1
00111F  3               :
00111F  3               
00111F  3               	dec z80_c		; decrement character counter.
00111F  3               	beq :+
00111F  3               	jmp dbar1		; repeat for whole line.
00111F  3               :
00111F  3               	rts
00111F  3               
00111F  3               ;------------------------------------------------------
00111F  3               ; Point to object
00111F  3               ;
00111F  3               ; Input:
00111F  3               ;  -
00111F  3               ;
00111F  3               ; Output:
00111F  3               ;  A = object number, A=255 if already in possession
00111F  3               ;------------------------------------------------------
00111F  3               
00111F  3               invdis:
00111F  3               	lda z80_l		; store message text pointer.
00111F  3               	pha
00111F  3               	lda z80_h
00111F  3               	pha
00111F  3               	lda combyt		; object number.
00111F  3               	inc combyt		; ready for next one.
00111F  3               	jsr gotob		; check if we have object.
00111F  3               	tay
00111F  3               	pla
00111F  3               	sta z80_h
00111F  3               	pla
00111F  3               	sta z80_l
00111F  3               	tya
00111F  3               	rts
00111F  3               
00111F  3               ;------------------------------------------------------
00111F  3               ; Find option selected.
00111F  3               ;
00111F  3               ; Input:
00111F  3               ;  -
00111F  3               ;
00111F  3               ; Output:
00111F  3               ;  OPT = selected object
00111F  3               ;------------------------------------------------------
00111F  3               
00111F  3               fopt:
00111F  3               	lda dispy
00111F  3               	sec
00111F  3               	sbc btop		; find selected option.
00111F  3               	sta tmp+2		; option selected in b register.
00111F  3               	inc tmp+2
00111F  3               
00111F  3               	lda #0			; set to first item.
00111F  3               	sta combyt		; object number.
00111F  3               fopt0:
00111F  3               	jsr fobj		; find next object in inventory.
00111F  3               	dec tmp+2
00111F  3               	bne fopt0		; repeat for relevant steps down the list.
00111F  3               
00111F  3               	lda combyt		; get option.
00111F  3               	sta varopt		; store the option.
00111F  3               	dec varopt		; one less, due to where we increment combyt.
00111F  3               	jmp redraw		; redraw the screen.
00111F  3               fobj:
00111F  3               	ldy combyt		; object number.
00111F  3               	inc combyt		; ready for next item.
00111F  3               	tya
00111F  3               	jsr gotob		; do we have this item?
00111F  3               	cmp #255
00111F  3               	bne :+
00111F  3               	rts
00111F  3               :
00111F  3               	jmp fobj		; yes, it's on the list.
00111F  3               .endif
00111F  3               
00111F  3               ;----------------------------------------------------
00111F  3               ; Clear sprite table.
00111F  3               ;
00111F  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
00111F  3               ;----------------------------------------------------
00111F  3               
00111F  3               xspr:
00111F  3  A9 FF        	lda #255		; clear byte.
001121  3  A2 00        	ldx #0			; length of table.
001123  3               xspr0:
001123  3  9D 00 0B     	sta sprtab,x		; sprite table.
001126  3  E8           	inx			; move to next byte.
001127  3  E0 CC        	cpx #SPRBUF
001129  3  D0 F8        	bne xspr0		; repeat for rest of table.
00112B  3  60           	rts
00112C  3               
00112C  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00112C  3               ; Sound, NOT IMPLEMENTED!!!
00112C  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00112C  3               ;
00112C  3               ;silenc:
00112C  3               ;	jsr silen1 		; silence channel 1.
00112C  3               ;	jsr silen2 		; silence channel 2.
00112C  3               ;	jsr silen3 		; silence channel 3.
00112C  3               ;	jmp plsnd 		; play all channels to switch them off.
00112C  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00112C  3               
00112C  3               ;-------------------------------------------------------------
00112C  3               ; Initialise all objects.
00112C  3               ;
00112C  3               ; Reset current room,y,x to start room,y,x for all objects
00112C  3               ;-------------------------------------------------------------
00112C  3               
00112C  3               iniob:
00112C  3  A9 18        	lda #<objdta 		; objects table.
00112E  3  85 rr        	sta z80_x
001130  3  A9 31        	lda #>objdta
001132  3  85 rr        	sta z80_i
001134  3               
001134  3  AE 18 11     	ldx numob 		; number of objects in the game.
001137  3               iniob0:
001137  3  A0 23        	ldy #35
001139  3  B1 rr        	lda (z80_ix),y 		; start screen.
00113B  3  A0 20        	ldy #32
00113D  3  91 rr        	sta (z80_ix),y 		; set start screen.
00113F  3               
00113F  3  A0 24        	ldy #36
001141  3  B1 rr        	lda (z80_ix),y 		; find start y.
001143  3  A0 21        	ldy #33
001145  3  91 rr        	sta (z80_ix),y 		; set start y.
001147  3               
001147  3  A0 25        	ldy #37
001149  3  B1 rr        	lda (z80_ix),y 		; get initial x.
00114B  3  A0 22        	ldy #34
00114D  3  91 rr        	sta (z80_ix),y 		; set x coord.
00114F  3               
00114F  3  18           	clc 			; point to next object.
001150  3  A5 rr        	lda z80_x
001152  3  69 26        	adc #38			; distance between objects.
001154  3  85 rr        	sta z80_x
001156  3  90 02        	bcc :+
001158  3  E6 rr        	inc z80_i
00115A  3               :
00115A  3  CA           	dex 			; repeat.
00115B  3  D0 DA        	bne iniob0
00115D  3               
00115D  3  60           	rts
00115E  3               
00115E  3               ;-----------------------------------------------
00115E  3               ; Redraw the screen.
00115E  3               ;
00115E  3               ; Remove old copy of all sprites for redraw.
00115E  3               ;-----------------------------------------------
00115E  3               
00115E  3               redraw:
00115E  3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
001160  3  48           	pha
001161  3  A5 rr        	lda z80_x
001163  3  48           	pha
001164  3               
001164  3  20 DE 1D     	jsr droom		; show screen layout.
001167  3  20 D1 19     	jsr shwob		; draw objects.
00116A  3               numsp0:
00116A  3  A9 0C        	lda #NUMSPR		; sprites to draw.
00116C  3  85 rr        	sta tmp
00116E  3               
00116E  3  A9 00        	lda #<sprtab		; sprite table.
001170  3  85 rr        	sta z80_x
001172  3  A9 0B        	lda #>sprtab
001174  3  85 rr        	sta z80_i
001176  3               redrw0:
001176  3  A0 00        	ldy #0
001178  3  B1 rr        	lda (z80_ix),y		; old sprite type.
00117A  3  C9 FF        	cmp #255		; is it enabled?
00117C  3  F0 0B        	beq redrw1 		; no, find next one.
00117E  3               
00117E  3  A0 03        	ldy #var_Y
001180  3  B1 rr        	lda (z80_ix),y 		; sprite y.
001182  3  C9 B1        	cmp #177		; beyond maximum?
001184  3  B0 03        	bcs redrw1		; yes, nothing to draw.
001186  3               
001186  3  20 D1 0F     	jsr sspria		; show single sprite.
001189  3               
001189  3               redrw1:
001189  3  18           	clc			; next sprite.
00118A  3  A5 rr        	lda z80_x
00118C  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
00118E  3  85 rr        	sta z80_x
001190  3  90 02        	bcc :+
001192  3  E6 rr        	inc z80_i
001194  3               :
001194  3  C6 rr        	dec tmp			; repeat for remaining sprites.
001196  3  D0 DE        	bne redrw0
001198  3               
001198  3               rpblc1:
001198  3               ;	jsr dshrp		; redraw shrapnel.
001198  3               
001198  3  68           	pla			; retrieve sprite pointer.
001199  3  85 rr        	sta z80_x
00119B  3  68           	pla
00119C  3  85 rr        	sta z80_i
00119E  3               
00119E  3  60           	rts
00119F  3               
00119F  3               ;----------------------------------------------------------------------
00119F  3               ; Clear screen routine.
00119F  3               ;
00119F  3               ; Fill screenmem $8000-$97ff with ScrFillByte
00119F  3               ;----------------------------------------------------------------------
00119F  3               
00119F  3               cls:
00119F  3  A9 68        	lda #>ScreenAddr		; screen address.
0011A1  3  8D AA 11     	sta clsloop+2
0011A4  3  A9 00        	lda #ScrFillByte
0011A6  3  A0 00        	ldy #0
0011A8  3               clsloop:
0011A8  3  99 00 68     	sta ScreenAddr,y
0011AB  3  C8           	iny
0011AC  3  D0 FA        	bne clsloop
0011AE  3  EE AA 11     	inc clsloop+2
0011B1  3  AE AA 11     	ldx clsloop+2
0011B4  3  E0 80        	cpx #>(ScreenAddr+ScreenSize)		; _BEEB
0011B6  3  D0 F0        	bne clsloop
0011B8  3  60           	rts
0011B9  3               
0011B9  3               ;----------------------------------------------------------------------
0011B9  3               ; FODDER check
0011B9  3               ;----------------------------------------------------------------------
0011B9  3               
0011B9  3               fdchk:
0011B9  3  A0 00        	ldy #0
0011BB  3  B1 rr        	lda (z80_hl),y	 	; fetch cell.
0011BD  3  C9 04        	cmp #FODDER 		; is it fodder?
0011BF  3  F0 01        	beq :+
0011C1  3  60           	rts 			; no.
0011C2  3               :
0011C2  3  A9 00        	lda #0
0011C4  3  A0 00        	ldy #0
0011C6  3  91 rr        	sta (z80_hl),y 		; rewrite block type.
0011C8  3               
0011C8  3  A5 rr        	lda z80_h		; store pointer to block.
0011CA  3  48           	pha
0011CB  3  A5 rr        	lda z80_l
0011CD  3  48           	pha
0011CE  3               
0011CE  3  38           	sec			; set carry flag for subtraction.
0011CF  3  A5 rr        	lda z80_l 		; find simple displacement for block.
0011D1  3  E9 00        	sbc #<MAP
0011D3  3  85 rr        	sta z80_l
0011D5  3  A5 rr        	lda z80_h
0011D7  3  E9 03        	sbc #>MAP
0011D9  3  85 rr        	sta z80_h
0011DB  3               
0011DB  3  A5 rr        	lda z80_l		; low byte is y coordinate.
0011DD  3  29 1F        	and #31 		; column position 0 - 31.
0011DF  3  85 rr        	sta dispx		; set up x position.
0011E1  3               
0011E1  3  06 rr        	asl z80_l		; multiply displacement by 8.
0011E3  3  26 rr        	rol z80_h
0011E5  3  06 rr        	asl z80_l
0011E7  3  26 rr        	rol z80_h
0011E9  3  06 rr        	asl z80_l
0011EB  3  26 rr        	rol z80_h
0011ED  3               
0011ED  3  A5 rr        	lda z80_h		; x coordinate now in h.
0011EF  3  85 rr        	sta dispy		; set the display coordinate.
0011F1  3               
0011F1  3  A9 00        	lda #0 			; block to write.
0011F3  3  20 47 1D     	jsr pattr 		; write block.
0011F6  3               
0011F6  3  68           	pla 			; restore block pointer.
0011F7  3  85 rr        	sta z80_l
0011F9  3  68           	pla
0011FA  3  85 rr        	sta z80_h
0011FC  3               
0011FC  3  60           	rts
0011FD  3               
0011FD  3               ;----------------------------------------------------
0011FD  3               ; Scrolly text and puzzle variables.
0011FD  3               ;----------------------------------------------------
0011FD  3               
0011FD  3               .if sflag
0011FD  3  80           txtbit:	.byte 128		; bit to write.
0011FE  3  10           txtwid:	.byte 16		; width of ticker message.
0011FF  3  59 2D        txtpos:	.word msgdat
001201  3  59 2D        txtini:	.word msgdat
001203  3  00 68        txtscr:	.word ScreenAddr
001205  3               .endif
001205  3               
001205  3               ;----------------------------------------------------
001205  3               ; Specialist routines.
001205  3               ; Process shrapnel.
001205  3               ;----------------------------------------------------
001205  3               proshr:
001205  3               .if pflag
001205  3  A9 B6        	lda #<SHRAPN		; table.
001207  3  85 rr        	sta z80_x
001209  3  A9 09        	lda #>SHRAPN
00120B  3  85 rr        	sta z80_i
00120D  3               
00120D  3  A9 37        	lda #NUMSHR		; shrapnel pieces to process.
00120F  3  85 rr        	sta shrctr
001211  3               prosh0:
001211  3  A0 00        	ldy #0
001213  3  B1 rr        	lda (z80_ix),y		; on/off marker.
001215  3  0A           	asl a
001216  3               proshx:
001216  3  B0 03        	bcs :+
001218  3  20 2E 12     	jsr prosh1 		; on, so process it.
00121B  3               :
00121B  3  18           	clc
00121C  3  A5 rr        	lda z80_x
00121E  3  69 06        	adc #SHRSIZ
001220  3  85 rr        	sta z80_x
001222  3  90 02        	bcc :+
001224  3  E6 rr        	inc z80_i
001226  3               :
001226  3  C6 rr        	dec shrctr		; round again.
001228  3  D0 E7        	bne prosh0
00122A  3               .endif
00122A  3               .if sflag
00122A  3  20 00 29     	jsr scrly
00122D  3               .endif
00122D  3  60           	rts
00122E  3               
00122E  3               .if pflag
00122E  3               ;----------------------------------------------------
00122E  3               ; Proces shrapnel piece
00122E  3               ;----------------------------------------------------
00122E  3               
00122E  3               prosh1:
00122E  3  20 25 13     	jsr plot 		; delete the pixel.
001231  3               
001231  3  A9 5B        	lda #<shrptr		; shrapnel routine pointers.
001233  3  85 rr        	sta z80_l
001235  3  A9 12        	lda #>shrptr
001237  3  85 rr        	sta z80_h
001239  3               
001239  3  A0 00        	ldy #0
00123B  3  B1 rr        	lda (z80_ix),y		; restore shrapnel type.
00123D  3  20 4C 12     	jsr prosh2 		; run the routine.
001240  3  20 EF 12     	jsr chkxy		; check x and y are good before we redisplay.
001243  3               
001243  3  A9 06        	lda #<SHRSIZ 		; distance to next.
001245  3  85 rr        	sta z80_e
001247  3  A9 00        	lda #>SHRSIZ
001249  3  85 rr        	sta z80_d
00124B  3  60           	rts
00124C  3               
00124C  3               ;----------------------------------------------------
00124C  3               ; Run the routine
00124C  3               ;----------------------------------------------------
00124C  3               
00124C  3               prosh2:
00124C  3  0A           	asl a 			; 2 bytes per address.
00124D  3  A8           	tay
00124E  3  B9 5B 12     	lda shrptr,y
001251  3  85 rr        	sta z80_l
001253  3  B9 5C 12     	lda shrptr+1,y 		; fetch high byte from table.
001256  3  85 rr        	sta z80_h
001258  3  6C rr rr     	jmp (z80_hl) 		; jump to routine.
00125B  3               
00125B  3               ;----------------------------------------------------
00125B  3               ; Paricle routine table
00125B  3               ;----------------------------------------------------
00125B  3               
00125B  3  F5 13        shrptr:	.word laser		; laser.
00125D  3  A3 13        	.word trail		; vapour trail.
00125F  3  6B 12        	.word shrap		; shrapnel from explosion.
001261  3  C7 12        	.word dotl		; horizontal starfield left.
001263  3  D1 12        	.word dotr		; horizontal starfield right.
001265  3  DB 12        	.word dotu		; vertical starfield up.
001267  3  E5 12        	.word dotd		; vertical starfield down.
001269  3  58 2D        	.word ptcusr		; user particle.
00126B  3               
00126B  3               ;----------------------------------------------------
00126B  3               ; Explosion shrapnel.
00126B  3               ;----------------------------------------------------
00126B  3               
00126B  3               shrap:
00126B  3  A0 01        	ldy #1
00126D  3  B1 rr        	lda (z80_ix),y 		; get the angle.
00126F  3  18           	clc
001270  3  69 63        	adc #<shrsin		; shrapnel sine table.
001272  3  85 rr        	sta z80_l
001274  3  A9 13        	lda #>shrsin
001276  3  69 00        	adc #0
001278  3  85 rr        	sta z80_h
00127A  3               
00127A  3  A0 00        	ldy #0
00127C  3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
00127E  3  85 rr        	sta z80_e
001280  3  E6 rr        	inc z80_l 		; next byte of table.
001282  3  D0 02        	bne :+
001284  3  E6 rr        	inc z80_h
001286  3               :
001286  3  A0 00        	ldy #0
001288  3  B1 rr        	lda (z80_hl),y		; fetch value from table.
00128A  3  85 rr        	sta z80_d
00128C  3  E6 rr        	inc z80_l		; next byte of table.
00128E  3  D0 02        	bne :+
001290  3  E6 rr        	inc z80_h
001292  3               :
001292  3  A0 00        	ldy #0
001294  3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
001296  3  85 rr        	sta z80_c
001298  3  E6 rr        	inc z80_l 		; next byte of table.
00129A  3  D0 02        	bne :+
00129C  3  E6 rr        	inc z80_h
00129E  3               :
00129E  3  A0 00        	ldy #0
0012A0  3  B1 rr        	lda (z80_hl),y 		; fetch value from table.
0012A2  3  85 rr        	sta z80_b
0012A4  3               
0012A4  3  A0 02        	ldy #2
0012A6  3  B1 rr        	lda (z80_ix),y 		; x coordinate in hl.
0012A8  3  18           	clc
0012A9  3  65 rr        	adc z80_e		; add sine lb
0012AB  3  91 rr        	sta (z80_ix),y		; store new coordinate lb.
0012AD  3  A0 03        	ldy #3
0012AF  3  B1 rr        	lda (z80_ix),y
0012B1  3  65 rr        	adc z80_d		; add sine hb
0012B3  3  91 rr        	sta (z80_ix),y		; store new coordinate hb.
0012B5  3               
0012B5  3  A0 04        	ldy #4
0012B7  3  B1 rr        	lda (z80_ix),y	 	; y coordinate in hl.
0012B9  3  18           	clc
0012BA  3  65 rr        	adc z80_c		; add cosine lb
0012BC  3  91 rr        	sta (z80_ix),y		; store new coordinate lb.
0012BE  3  A0 05        	ldy #5
0012C0  3  B1 rr        	lda (z80_ix),y
0012C2  3  65 rr        	adc z80_b		; add cosine lb
0012C4  3  91 rr        	sta (z80_ix),y		; store new coordinate hb.
0012C6  3               
0012C6  3  60           	rts
0012C7  3               
0012C7  3               ;----------------------------------------------------
0012C7  3               ; Move dots
0012C7  3               ;----------------------------------------------------
0012C7  3               
0012C7  3               dotl:
0012C7  3  A0 05        	ldy #5
0012C9  3  B1 rr        	lda (z80_ix),y
0012CB  3  38           	sec
0012CC  3  E9 01        	sbc #1		 	; move left.
0012CE  3  91 rr        	sta (z80_ix),y
0012D0  3  60           	rts
0012D1  3               dotr:
0012D1  3  A0 05        	ldy #5
0012D3  3  B1 rr        	lda (z80_ix),y
0012D5  3  18           	clc
0012D6  3  69 01        	adc #1		 	; move left.
0012D8  3  91 rr        	sta (z80_ix),y
0012DA  3  60           	rts
0012DB  3               dotu:
0012DB  3  A0 03        	ldy #3
0012DD  3  B1 rr        	lda (z80_ix),y
0012DF  3  38           	sec
0012E0  3  E9 01        	sbc #1		 	; move up.
0012E2  3  91 rr        	sta (z80_ix),y
0012E4  3  60           	rts
0012E5  3               dotd:
0012E5  3  A0 03        	ldy #3
0012E7  3  B1 rr        	lda (z80_ix),y
0012E9  3  18           	clc
0012EA  3  69 01        	adc #1			; move down.
0012EC  3  91 rr        	sta (z80_ix),y
0012EE  3  60           	rts
0012EF  3               
0012EF  3               ;----------------------------------------------------
0012EF  3               ; Check if coordinates are ok before redrawing at new position.
0012EF  3               ;
0012EF  3               ; left:   X>L		X=L	Ok
0012EF  3               ; right:  R+15>X	X=R	Ok
0012EF  3               ; top:    Y>T		Y=T	Ok
0012EF  3               ; bottom: B+15>Y	Y=B	Ok
0012EF  3               ;----------------------------------------------------
0012EF  3               
0012EF  3               chkxy:
0012EF  3               
0012EF  3               ; top:    Y>T		Y=T	Ok
0012EF  3               
0012EF  3  A0 03        	ldy #3
0012F1  3  B1 rr        	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0012F3  3  CD 19 11     	cmp wntopx		; window top.
0012F6  3  B0 03        	bcs :+			; compare with top window limit.
0012F8  3  4C 5C 13     	jmp kilshr		; out of window, kill shrapnel.
0012FB  3               :
0012FB  3               ; left:   X>L		X=L	Ok
0012FB  3               
0012FB  3  A0 05        	ldy #5
0012FD  3  B1 rr        	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0012FF  3  CD 1A 11     	cmp wnlftx		; left edge.
001302  3  B0 03        	bcs :+			; compare with left window limit.
001304  3  4C 5C 13     	jmp kilshr		; out of window, kill shrapnel.
001307  3               :
001307  3               ; bottom: B+15>Y	Y=B	Ok
001307  3               
001307  3  AD 1B 11     	lda wnbotx		; point to bottom.
00130A  3  18           	clc
00130B  3  69 0F        	adc #15
00130D  3  A0 03        	ldy #3
00130F  3  D1 rr        	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
001311  3  B0 03        	bcs :+			; compare with shrapnel x coordinate.
001313  3  4C 5C 13     	jmp kilshr		; off screen, kill shrapnel..
001316  3               :
001316  3               ; right:  R+15>X	X=R	Ok
001316  3               
001316  3  AD 1C 11     	lda wnrgtx		; point to right edge.
001319  3  18           	clc
00131A  3  69 0F        	adc #15
00131C  3  A0 05        	ldy #5
00131E  3  D1 rr        	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
001320  3  B0 03        	bcs :+			; compare with window limit.
001322  3  4C 5C 13     	jmp kilshr		; off screen, kill shrapnel.
001325  3               :
001325  3               
001325  3               ;----------------------------------------------------
001325  3               ; Drop through.
001325  3               ; Display shrapnel.
001325  3               ;----------------------------------------------------
001325  3               
001325  3               plot:
001325  3  A0 03        	ldy #3
001327  3  B1 rr        	lda (z80_ix),y		; y integer.
001329  3  85 rr        	sta dispy	 	; workspace coordinates.
00132B  3  A0 05        	ldy #5
00132D  3  B1 rr        	lda (z80_ix),y	 	; x integer.
00132F  3  85 rr        	sta dispx 		; workspace coordinates.
001331  3               
001331  3  A0 00        	ldy #0
001333  3  B1 rr        	lda (z80_ix),y 		; type.
001335  3  D0 03        	bne :+			; is it a laser?
001337  3  4C 50 13     	jmp plot1 		; yes, draw laser instead.
00133A  3               :
00133A  3               plot0:
00133A  3  A5 rr        	lda dispx		; which pixel within byte do we
00133C  3  29 07        	and #7			; want to set first?
00133E  3  A8           	tay
00133F  3  B9 30 14     	lda dots,y 		; table of small pixel positions.
001342  3  85 rr        	sta z80_e 		; get value.
001344  3               
001344  3  20 BD 0F     	jsr scadd 		; screen address.
001347  3  A0 00        	ldy #0
001349  3  B1 rr        	lda (scraddr),y		; see what's already there.
00134B  3  45 rr        	eor z80_e
00134D  3  91 rr        	sta (scraddr),y 	; put back on screen.
00134F  3  60           	rts
001350  3               
001350  3               plot1:
001350  3  20 BD 0F     	jsr scadd 		; screen address.
001353  3  A0 00        	ldy #0
001355  3  B1 rr        	lda (scraddr),y 	; fetch byte there.
001357  3  49 FF        	eor #255 		; toggle all bits.
001359  3  91 rr        	sta (scraddr),y 	; new byte.
00135B  3  60           	rts
00135C  3               
00135C  3               ;----------------------------------------------------
00135C  3               ; Switch off shrapnel
00135C  3               ;----------------------------------------------------
00135C  3               
00135C  3               kilshr:
00135C  3  A9 80        	lda #128
00135E  3  A0 00        	ldy #0
001360  3  91 rr        	sta (z80_ix),y	; switch off shrapnel.
001362  3  60           	rts
001363  3               
001363  3               ;----------------------------------------------------
001363  3               ; Sine/cosine table
001363  3               ;----------------------------------------------------
001363  3               
001363  3  00 00 00 04  shrsin:	.word 0,1024,391,946,724,724,946,391
001367  3  87 01 B2 03  
00136B  3  D4 02 D4 02  
001373  3  00 04 00 00  	.word 1024,0,946,65144,724,64811,391,64589
001377  3  B2 03 78 FE  
00137B  3  D4 02 2B FD  
001383  3  00 00 00 FC  	.word 0,64512,65144,64589,64811,64811,64589,65144
001387  3  78 FE 4D FC  
00138B  3  2B FD 2B FD  
001393  3  00 FC 00 00  	.word 64512,0,64589,391,64811,724,65144,946
001397  3  4D FC 87 01  
00139B  3  2B FD D4 02  
0013A3  3               
0013A3  3               ;----------------------------------------------------
0013A3  3               ; Create trail
0013A3  3               ;----------------------------------------------------
0013A3  3               
0013A3  3               trail:
0013A3  3  A0 01        	ldy #1
0013A5  3  B1 rr        	lda (z80_ix),y 	; time remaining.
0013A7  3  38           	sec
0013A8  3  E9 01        	sbc #1
0013AA  3  91 rr        	sta (z80_ix),y
0013AC  3  D0 03        	bne :+
0013AE  3  4C EE 13     	jmp trailk		; time to switch it off.
0013B1  3               :
0013B1  3  20 13 16     	jsr qrand		; get a random number.
0013B4  3  4A           	lsr a 			; x or y axis?
0013B5  3  90 03        	bcc :+
0013B7  3  4C D4 13     	jmp trailv		; use y.
0013BA  3               :
0013BA  3               ; Trail horizontal
0013BA  3               
0013BA  3  4A           	lsr a 			; which direction?
0013BB  3  90 03        	bcc :+
0013BD  3  4C CA 13     	jmp traill		; go left.
0013C0  3               :
0013C0  3               ; Trail right
0013C0  3               
0013C0  3  A0 05        	ldy #5
0013C2  3  B1 rr        	lda (z80_ix),y
0013C4  3  18           	clc
0013C5  3  69 01        	adc #1	 		; go right.
0013C7  3  91 rr        	sta (z80_ix),y
0013C9  3  60           	rts
0013CA  3               
0013CA  3               ; Trail left
0013CA  3               
0013CA  3               traill:
0013CA  3  A0 05        	ldy #5
0013CC  3  B1 rr        	lda (z80_ix),y
0013CE  3  38           	sec
0013CF  3  E9 01        	sbc #1 			; go left.
0013D1  3  91 rr        	sta (z80_ix),y
0013D3  3  60           	rts
0013D4  3               
0013D4  3               ; Trail vertical
0013D4  3               
0013D4  3               trailv:
0013D4  3  4A           	lsr a		 	; which direction?
0013D5  3  90 03        	bcc :+
0013D7  3  4C E4 13     	jmp trailu		; go up.
0013DA  3               :
0013DA  3               ; Trail down
0013DA  3               
0013DA  3  A0 03        	ldy #3
0013DC  3  B1 rr        	lda (z80_ix),y
0013DE  3  18           	clc
0013DF  3  69 01        	adc #1 			; go down.
0013E1  3  91 rr        	sta (z80_ix),y
0013E3  3  60           	rts
0013E4  3               
0013E4  3               ; Trail up
0013E4  3               
0013E4  3               trailu:
0013E4  3  A0 03        	ldy #3
0013E6  3  B1 rr        	lda (z80_ix),y
0013E8  3  38           	sec
0013E9  3  E9 01        	sbc #1 			; go up.
0013EB  3  91 rr        	sta (z80_ix),y
0013ED  3  60           	rts
0013EE  3               
0013EE  3               ; Kill trail
0013EE  3               
0013EE  3               trailk:
0013EE  3  A9 C8        	lda #200		; set off-screen to kill vapour trail.
0013F0  3  A0 03        	ldy #3
0013F2  3  91 rr        	sta (z80_ix),y
0013F4  3  60           	rts
0013F5  3               
0013F5  3               ;----------------------------------------------------
0013F5  3               ; Create laser beam
0013F5  3               ;----------------------------------------------------
0013F5  3               
0013F5  3               laser:
0013F5  3  A0 01        	ldy #1
0013F7  3  B1 rr        	lda (z80_ix),y 		; direction.
0013F9  3  6A           	ror a 			; left or right?
0013FA  3  B0 03        	bcs :+
0013FC  3  4C 06 14     	jmp laserl		; move left.
0013FF  3               :
0013FF  3               ; Laser right
0013FF  3               
0013FF  3  A9 08        	lda #8			; distance to travel.
001401  3  85 rr        	sta z80_b
001403  3  4C 0A 14     	jmp laserm		; move laser.
001406  3               
001406  3               ; Laser left
001406  3               
001406  3               laserl:
001406  3  A9 F8        	lda #248		; distance to travel.
001408  3  85 rr        	sta z80_b
00140A  3               laserm:
00140A  3  A0 05        	ldy #5
00140C  3  B1 rr        	lda (z80_ix),y		; x position.
00140E  3  18           	clc
00140F  3  65 rr        	adc z80_b		; add distance.
001411  3  91 rr        	sta (z80_ix),y		; set new x coordinate.
001413  3               
001413  3               ; Test new block.
001413  3               
001413  3  85 rr        	sta dispx 		; set x for block collision detection purposes.
001415  3  A0 03        	ldy #3
001417  3  B1 rr        	lda (z80_ix),y 		; get y.
001419  3  85 rr        	sta dispy		; set coordinate for collision test.
00141B  3  20 A1 20     	jsr tstbl 		; get block type there.
00141E  3  C9 02        	cmp #WALL		; is it solid?
001420  3  D0 03        	bne :+
001422  3  4C EE 13     	jmp trailk		; yes, it cannot pass.
001425  3               :
001425  3  C9 04                cmp #FODDER             ; is it fodder?
001427  3  D0 06                bne :+
001429  3  20 B9 11             jsr fdchk               ; remove fodder block.
00142C  3  4C EE 13             jmp trailk              ; destroy laser.
00142F  3               :
00142F  3  60                   rts                     ; no, ignore it.
001430  3               
001430  3               ;----------------------------------------------------
001430  3               ; Dots mask
001430  3               ;----------------------------------------------------
001430  3               
001430  3  80 40 20 10  dots:	.byte 128,64,32,16,8,4,2,1
001434  3  08 04 02 01  
001438  3               
001438  3               
001438  3               ;----------------------------------------------------
001438  3               ; Plot, preserving de.
001438  3               ;----------------------------------------------------
001438  3               
001438  3               plotde:
001438  3  A5 rr        	lda z80_d 		; put de on stack.
00143A  3  48           	pha
00143B  3  A5 rr        	lda z80_e
00143D  3  48           	pha
00143E  3               
00143E  3  20 25 13     	jsr plot 		; plot pixel.
001441  3               
001441  3  68           	pla			; restore de from stack.
001442  3  85 rr        	sta z80_e
001444  3  68           	pla
001445  3  85 rr        	sta z80_d
001447  3               
001447  3  60           	rts
001448  3               
001448  3               ;----------------------------------------------------
001448  3               ; Shoot a laser.
001448  3               ;----------------------------------------------------
001448  3               
001448  3               shoot:
001448  3  85 rr        	sta z80_c		; store direction in c register.
00144A  3  A0 08        	ldy #8
00144C  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00144E  3               shoot1:
00144E  3  18           	clc
00144F  3  69 07        	adc #7 			; down 7 pixels.
001451  3  85 rr        	sta z80_l 		; puty y coordinate in l.
001453  3               
001453  3  A0 09        	ldy #9
001455  3  B1 rr        	lda (z80_ix),y 		; x coordinate in h.
001457  3  85 rr        	sta z80_h
001459  3               
001459  3  A5 rr        	lda z80_i		; store pointer to sprite.
00145B  3  48           	pha
00145C  3  A5 rr        	lda z80_x
00145E  3  48           	pha
00145F  3               
00145F  3  20 82 15     	jsr fpslot 		; find particle slot.
001462  3  B0 03        	bcs :+
001464  3  4C B2 14     	jmp vapou2		; failed, restore ix.
001467  3               :
001467  3  A9 00        	lda #0
001469  3  A0 00        	ldy #0
00146B  3  91 rr        	sta (z80_ix),y 		; set up a laser.
00146D  3               
00146D  3  A5 rr        	lda z80_c
00146F  3  A0 01        	ldy #1
001471  3  91 rr        	sta (z80_ix),y 		; set the direction.
001473  3               
001473  3  A5 rr        	lda z80_l
001475  3  A0 03        	ldy #3
001477  3  91 rr        	sta (z80_ix),y		; set y coordinate.
001479  3               
001479  3  66 rr        	ror z80_c		; check direction we want.
00147B  3  90 03        	bcc :+
00147D  3  4C 8B 14     	jmp shootr		; shoot right.
001480  3               :
001480  3  A5 rr        	lda z80_h		; X position.
001482  3               shoot0:
001482  3  29 F8        	and #248		; align on character boundary.
001484  3  A0 05        	ldy #5
001486  3  91 rr        	sta (z80_ix),y		; set x coordinate.
001488  3  4C D7 14     	jmp vapou0 		; draw first image.
00148B  3               shootr:
00148B  3  A5 rr        	lda z80_h		; x position.
00148D  3  18           	clc
00148E  3  69 0F        	adc #15			; look right.
001490  3  4C 82 14     	jmp shoot0		; align and continue.
001493  3               
001493  3               ;----------------------------------------------------
001493  3               ; Create a bit of vapour trail.
001493  3               ;----------------------------------------------------
001493  3               
001493  3               vapour:
001493  3  A5 rr        	lda z80_i		; store pointer to sprite.
001495  3  48           	pha
001496  3  A5 rr        	lda z80_x
001498  3  48           	pha
001499  3               
001499  3  A0 08        	ldy #8
00149B  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00149D  3  18           	clc
00149E  3  69 07        	adc #7			; mid-point of sprite.
0014A0  3  85 rr        	sta z80_l
0014A2  3               
0014A2  3  A0 09        	ldy #9
0014A4  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0014A6  3  69 07        	adc #7
0014A8  3  85 rr        	sta z80_h
0014AA  3               
0014AA  3  20 82 15     	jsr fpslot 		; find particle slot.
0014AD  3  90 03        	bcc :+
0014AF  3  4C B9 14     	jmp vapou1		; no, we can use it.
0014B2  3               :
0014B2  3               vapou2:
0014B2  3  68           	pla
0014B3  3  85 rr        	sta z80_x
0014B5  3  68           	pla
0014B6  3  85 rr        	sta z80_i
0014B8  3  60           	rts
0014B9  3               vapou1:
0014B9  3  A5 rr        	lda z80_l
0014BB  3  A0 03        	ldy #3
0014BD  3  91 rr        	sta (z80_ix),y		; set up y.
0014BF  3               
0014BF  3  A5 rr        	lda z80_h
0014C1  3  A0 05        	ldy #5
0014C3  3  91 rr        	sta (z80_ix),y 		; set up x coordinate.
0014C5  3               
0014C5  3  20 13 16     	jsr qrand		; get quick random number.
0014C8  3  29 0F        	and #15			; random time.
0014CA  3  18           	clc
0014CB  3  69 0F        	adc #15			; minimum time on screen.
0014CD  3  A0 01        	ldy #1
0014CF  3  91 rr        	sta (z80_ix),y		; set time on screen.
0014D1  3               
0014D1  3  A9 01        	lda #1
0014D3  3  A0 00        	ldy #0
0014D5  3  91 rr        	sta (z80_ix),y		; define particle as vapour trail.
0014D7  3               vapou0:
0014D7  3  20 EF 12     	jsr chkxy		; plot first position.
0014DA  3  4C B2 14     	jmp vapou2
0014DD  3               
0014DD  3               ;----------------------------------------------------
0014DD  3               ; Create a user particle.
0014DD  3               ;----------------------------------------------------
0014DD  3               
0014DD  3               ptusr:
0014DD  3  85 rr        	sta z80_f		; store timer.
0014DF  3               
0014DF  3  A0 08        	ldy #8
0014E1  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0014E3  3  18           	clc
0014E4  3  69 07        	adc #7			; mid-point of sprite.
0014E6  3  85 rr        	sta z80_l
0014E8  3               
0014E8  3  A0 09        	ldy #9
0014EA  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0014EC  3  18           	clc
0014ED  3  69 07        	adc #7			; mid-point of sprite.
0014EF  3  85 rr        	sta z80_h
0014F1  3               
0014F1  3  20 82 15     	jsr fpslot 		; find particle slot.
0014F4  3  B0 01        	bcs ptusr1
0014F6  3  60           	rts 			; out of slots, can't generate anything.
0014F7  3               ptusr1:
0014F7  3  A5 rr        	lda z80_l
0014F9  3  A0 03        	ldy #3
0014FB  3  91 rr        	sta (z80_ix),y 		; set up y.
0014FD  3               
0014FD  3  A5 rr        	lda z80_h
0014FF  3  A0 05        	ldy #5
001501  3  91 rr        	sta (z80_ix),y		; set up x coordinate.
001503  3               
001503  3  A5 rr        	lda z80_f 		; restore timer.
001505  3  A0 01        	ldy #1
001507  3  91 rr        	sta (z80_ix),y		; set time on screen.
001509  3               
001509  3  A9 07        	lda #7
00150B  3  A0 00        	ldy #0
00150D  3  91 rr        	sta (z80_ix),y		; define particle as user particle.
00150F  3               
00150F  3  4C EF 12     	jmp chkxy		; plot first position.
001512  3               
001512  3               ;----------------------------------------------------
001512  3               ; Create a vertical or horizontal star.
001512  3               ;----------------------------------------------------
001512  3               
001512  3               star:
001512  3  A5 rr        	lda z80_i		; store pointer to sprite.
001514  3  48           	pha
001515  3  A5 rr        	lda z80_x
001517  3  48           	pha
001518  3               
001518  3  20 82 15     	jsr fpslot 		; find particle slot.
00151B  3  B0 07        	bcs star7		; found one we can use.
00151D  3               star0:
00151D  3  68           	pla 			; restore sprite pointer.
00151E  3  85 rr        	sta z80_x
001520  3  68           	pla
001521  3  85 rr        	sta z80_i
001523  3  60           	rts 			; out of slots, can't generate anything.
001524  3               star7:
001524  3  A5 rr        	lda z80_c		; direction.
001526  3  29 03        	and #3 			; is it left?
001528  3  D0 03        	bne :+
00152A  3  4C 5C 15     	jmp star1 		; yes, it's left.
00152D  3               :
00152D  3  C9 01        	cmp #1 			; is it right?
00152F  3  D0 03        	bne :+
001531  3  4C 6C 15     	jmp star2 		; yes, it's right.
001534  3               :
001534  3  C9 02        	cmp #2 			; is it up?
001536  3  D0 03        	bne :+
001538  3  4C 79 15     	jmp star3 		; yes, it's up.
00153B  3               :
00153B  3  AC 19 11     	ldy wntopx 		; get edge of screen.
00153E  3  C8           	iny			; down one pixel.
00153F  3  98           	tya
001540  3               star8:
001540  3  A0 03        	ldy #3
001542  3  91 rr        	sta (z80_ix),y 		; set y coord.
001544  3  20 13 16     	jsr qrand 		; get quick random number.
001547  3               star9:
001547  3  A0 05        	ldy #5
001549  3  91 rr        	sta (z80_ix),y		; set x position.
00154B  3               
00154B  3  A5 rr        	lda z80_c		; direction.
00154D  3  29 03        	and #3			; zero to three.
00154F  3  18           	clc
001550  3  69 03        	adc #3			; 3 to 6 for starfield.
001552  3  A0 00        	ldy #0
001554  3  91 rr        	sta (z80_ix),y		; define particle as star.
001556  3  20 EF 12     	jsr chkxy		; plot first position.
001559  3  4C 1D 15     	jmp star0
00155C  3               star1:
00155C  3  20 13 16     	jsr qrand		; get quick random number.
00155F  3  A0 03        	ldy #3
001561  3  91 rr        	sta (z80_ix),y 		; set y coord.
001563  3               
001563  3  AD 1C 11     	lda wnrgtx 		; get edge of screen.
001566  3  18           	clc
001567  3  69 0F        	adc #15			; add width of sprite minus 1.
001569  3  4C 47 15     	jmp star9
00156C  3               star2:
00156C  3  20 13 16     	jsr qrand 		; get quick random number.
00156F  3  A0 03        	ldy #3
001571  3  91 rr        	sta (z80_ix),y		; set y coord.
001573  3               
001573  3  AD 1A 11     	lda wnlftx		; get edge of screen.
001576  3  4C 47 15     	jmp star9
001579  3               star3:
001579  3  AD 1B 11     	lda wnbotx 		; get edge of screen.
00157C  3  18           	clc
00157D  3  69 0F        	adc #15 		; height of sprite minus one pixel.
00157F  3  4C 40 15     	jmp star8
001582  3               
001582  3               ;----------------------------------------------------
001582  3               ; Find particle slot for lasers or vapour trail.
001582  3               ; can't use alternate accumulator.
001582  3               ;----------------------------------------------------
001582  3               
001582  3               fpslot:
001582  3  A9 B6        	lda #<SHRAPN 		; shrapnel table.
001584  3  85 rr        	sta z80_x
001586  3  A9 09        	lda #>SHRAPN
001588  3  85 rr        	sta z80_i
00158A  3               
00158A  3  A9 37        	lda #NUMSHR		; number of pieces in table.
00158C  3  85 rr        	sta z80_b
00158E  3               fpslt0:
00158E  3  A0 00        	ldy #0
001590  3  B1 rr        	lda (z80_ix),y		; get type.
001592  3  0A           	asl a  			; is this slot in use?
001593  3  90 01        	bcc :+
001595  3  60           	rts			; no, we can use it.
001596  3               :
001596  3  18           	clc			; point to more shrapnel.
001597  3  A5 rr        	lda z80_x
001599  3  69 06        	adc #SHRSIZ
00159B  3  85 rr        	sta z80_x
00159D  3  90 02        	bcc :+
00159F  3  E6 rr        	inc z80_i
0015A1  3               :
0015A1  3  C6 rr        	dec z80_b		; repeat for all shrapnel.
0015A3  3  D0 E9        	bne fpslt0
0015A5  3               
0015A5  3  18           	clc
0015A6  3  60           	rts 			; out of slots, can't generate anything.
0015A7  3               
0015A7  3               ;----------------------------------------------------
0015A7  3               ; Create an explosion at sprite position.
0015A7  3               ;----------------------------------------------------
0015A7  3               
0015A7  3               explod:
0015A7  3  85 rr        	sta z80_c 		; particles to create.
0015A9  3               
0015A9  3  A5 rr        	lda z80_i 		; store pointer to sprite.
0015AB  3  48           	pha
0015AC  3  A5 rr        	lda z80_x
0015AE  3  48           	pha
0015AF  3               
0015AF  3  A0 08        	ldy #8
0015B1  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0015B3  3  85 rr        	sta z80_l
0015B5  3  A0 09        	ldy #9
0015B7  3  B1 rr        	lda (z80_ix),y		; x coordinate.
0015B9  3  85 rr        	sta z80_h
0015BB  3               
0015BB  3  A9 B6        	lda #<SHRAPN		; shrapnel table.
0015BD  3  85 rr        	sta z80_x
0015BF  3  A9 09        	lda #>SHRAPN
0015C1  3  85 rr        	sta z80_i
0015C3  3               
0015C3  3  A9 37        	lda #NUMSHR		; number of pieces in table.
0015C5  3  85 rr        	sta explcnt
0015C7  3               expld0:
0015C7  3  A0 00        	ldy #0
0015C9  3  B1 rr        	lda (z80_ix),y		; get type.
0015CB  3  0A           	asl a 			; is this slot in use?
0015CC  3  B0 16        	bcs expld1		; no, we can use it.
0015CE  3               expld2:
0015CE  3  18           	clc
0015CF  3  A5 rr        	lda z80_x
0015D1  3  69 06        	adc #SHRSIZ
0015D3  3  85 rr        	sta z80_x
0015D5  3  90 02        	bcc :+
0015D7  3  E6 rr        	inc z80_i
0015D9  3               :
0015D9  3  C6 rr        	dec explcnt		; repeat for all shrapnel.
0015DB  3  D0 EA        	bne expld0
0015DD  3               expld3:
0015DD  3  68           	pla			; restore sprite pointer.
0015DE  3  85 rr        	sta z80_x
0015E0  3  68           	pla
0015E1  3  85 rr        	sta z80_i
0015E3  3  60           	rts 			; out of slots, can't generate any more.
0015E4  3               
0015E4  3               expld1:
0015E4  3  A5 rr        	lda z80_c		; shrapnel counter.
0015E6  3  29 0F        	and #15			; 0 to 15.
0015E8  3  18           	clc			; add to x.
0015E9  3  65 rr        	adc z80_l
0015EB  3  A0 03        	ldy #3
0015ED  3  91 rr        	sta (z80_ix),y		; y coord.
0015EF  3               
0015EF  3  A5 rr        	lda seed3 		; crap random number.
0015F1  3  29 0F        	and #15			; 0 to 15.
0015F3  3  18           	clc 			; add to y.
0015F4  3  65 rr        	adc z80_h
0015F6  3  A0 05        	ldy #5
0015F8  3  91 rr        	sta (z80_ix),y		; x coord.
0015FA  3               
0015FA  3  A9 02        	lda #2
0015FC  3  A0 00        	ldy #0
0015FE  3  91 rr        	sta (z80_ix),y		; switch it on.
001600  3               
001600  3  20 EF 12     	jsr chkxy		; plot first position.
001603  3  20 13 16     	jsr qrand		; quick random angle.
001606  3  29 3C        	and #60 		; keep within range.
001608  3  A0 01        	ldy #1
00160A  3  91 rr        	sta (z80_ix),y		; angle.
00160C  3               
00160C  3  C6 rr        	dec z80_c		; one less piece of shrapnel to generate.
00160E  3  D0 BE        	bne expld2 		; back to main explosion loop.
001610  3  4C DD 15     	jmp expld3 		; restore sprite pointer and exit.
001613  3               
001613  3               ;----------------------------------------------------
001613  3               ; Quick random
001613  3               ;----------------------------------------------------
001613  3               
001613  3               qrand:
001613  3  20 16 21     	jsr random		; r register.
001616  3  45 rr        	eor seed3		; combine with seed.
001618  3  85 rr        	sta seed3 		; new seed.
00161A  3  60           	rts
00161B  3               
00161B  3               ;----------------------------------------------------
00161B  3               ; Display all shrapnel.
00161B  3               ;----------------------------------------------------
00161B  3               
00161B  3               dshrp:
00161B  3  A9 38        	lda #<plotde		; display routine.
00161D  3  8D 17 12     	sta proshx+1
001620  3  A9 14        	lda #>plotde
001622  3  8D 18 12     	sta proshx+2
001625  3  20 05 12     	jsr proshr		; process shrapnel.
001628  3               
001628  3  A9 2E        	lda #<prosh1		; processing routine.
00162A  3  8D 17 12     	sta proshx+1
00162D  3  A9 12        	lda #>prosh1
00162F  3  8D 18 12     	sta proshx+2
001632  3  60           	rts
001633  3               
001633  3               ;------------------------------------------------------
001633  3               ; Particle engine.
001633  3               ;
001633  3               ; Init particle data for 55 particles in SHRAPN table.
001633  3               ; Every particle has 6 bytes.
001633  3               ;
001633  3               ; global:	-
001633  3               ; local:	x,y,hl
001633  3               ; calls:	-
001633  3               ;------------------------------------------------------
001633  3               
001633  3               inishr:
001633  3  A9 B6        	lda #<SHRAPN 		; table.
001635  3  85 rr        	sta z80_l
001637  3  A9 09        	lda #>SHRAPN
001639  3  85 rr        	sta z80_h
00163B  3               
00163B  3  A0 00        	ldy #0
00163D  3  A2 37        	ldx #NUMSHR		; shrapnel pieces to process.
00163F  3               inish0:
00163F  3  A9 FF        	lda #255 		; kill the shrapnel.
001641  3  91 rr        	sta (z80_hl),y
001643  3               
001643  3  18           	clc 			; point there.
001644  3  A5 rr        	lda z80_l
001646  3  69 06        	adc #SHRSIZ		; distance to next.
001648  3  85 rr        	sta z80_l
00164A  3  90 02        	bcc :+
00164C  3  E6 rr        	inc z80_h
00164E  3               :
00164E  3  CA           	dex
00164F  3  D0 EE        	bne inish0 		; round again.
001651  3  60           	rts
001652  3               
001652  3               ;------------------------------------------------------
001652  3               ; Check for collision between laser and sprite.
001652  3               ;------------------------------------------------------
001652  3               
001652  3               lcol:
001652  3  A9 B6        	lda #<SHRAPN		; shrapnel table.
001654  3  85 rr        	sta z80_l
001656  3  A9 09        	lda #>SHRAPN
001658  3  85 rr        	sta z80_h
00165A  3               
00165A  3  A9 37        	lda #NUMSHR		; number of pieces in table.
00165C  3  85 rr        	sta z80_b
00165E  3               lcol0:
00165E  3  A0 00        	ldy #0
001660  3  B1 rr        	lda (z80_hl),y 		; get type.
001662  3  F0 10        	beq lcol1		; yes, check collision.
001664  3               lcol3:
001664  3  18           	clc			; point to more shrapnel.
001665  3  A5 rr        	lda z80_l
001667  3  69 06        	adc #SHRSIZ
001669  3  85 rr        	sta z80_l
00166B  3  90 02        	bcc :+
00166D  3  E6 rr        	inc z80_h
00166F  3               :
00166F  3  C6 rr        	dec z80_b		; repeat for all shrapnel.
001671  3  D0 EB        	bne lcol0
001673  3  60           	rts 			; no collision, carry not set.
001674  3               lcol1:
001674  3  A0 03        	ldy #3
001676  3  B1 rr        	lda (z80_hl),y		; get y.
001678  3  38           	sec
001679  3  A0 08        	ldy #8
00167B  3  F1 rr        	sbc (z80_ix),y		; subtract sprite y.
00167D  3               lcolh:
00167D  3  C9 10        	cmp #16 		; within range?
00167F  3  90 03        	bcc :+
001681  3  4C 94 16     	jmp lcol2		; no, missed.
001684  3               :
001684  3  A0 05        	ldy #5
001686  3  B1 rr        	lda (z80_hl),y 		; get x.
001688  3  38           	sec
001689  3  A0 09        	ldy #9
00168B  3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
00168D  3  C9 10        	cmp #16			; within range?
00168F  3  B0 03        	bcs :+
001691  3  4C 97 16     	jmp lcol4 		; yes, collision occurred.
001694  3               :
001694  3               lcol2:
001694  3  4C 64 16     	jmp lcol3
001697  3               lcol4:
001697  3  38           	sec
001698  3  60           	rts 			; return with carry set for collision.
001699  3               .endif
001699  3               
001699  3               ;------------------------------------------------------
001699  3               ; Main game engine code starts here.
001699  3               ; After initialisation, mloop is the main loop
001699  3               ;------------------------------------------------------
001699  3               
001699  3               game:
001699  3               
001699  3               ; Set up screen address table.
001699  3               
001699  3               setsat:
001699  3  A9 00        	lda #<ScreenAddr		; start of screen.
00169B  3  85 rr        	sta scraddr
00169D  3  A9 68        	lda #>ScreenAddr
00169F  3  85 rr        	sta scraddr+1
0016A1  3               
0016A1  3  A0 00        	ldy #0			; vertical lines on screen.
0016A3  3               setsa0:
0016A3  3  A5 rr        	lda scraddr
0016A5  3  99 00 06     	sta SCADTB_lb,y		; write low byte.
0016A8  3  A5 rr        	lda scraddr+1
0016AA  3  99 00 07     	sta SCADTB_hb,y		; write high byte.
0016AD  3  20 49 10     	jsr nline		; next line down.
0016B0  3  C8           	iny			; next position in table.
0016B1  3  D0 F0        	bne setsa0
0016B3  3               
0016B3  3               ; Init graphics mode
0016B3  3               
0016B3  3  20 2B 0F     	jsr screeninit
0016B6  3               
0016B6  3               ; Init AtoMMC joystick
0016B6  3  20 F6 0E     	jsr joyinit		; AtoMMC joystick on PORT B
0016B9  3               
0016B9  3               rpblc2:
0016B9  3               .if pflag
0016B9  3  20 33 16     	jsr inishr 		; initialise particle engine.
0016BC  3               .endif
0016BC  3               evintr:
0016BC  3  20 CB 2B     	jsr evnt12 		; call intro/menu event.
0016BF  3               
0016BF  3  A9 02        	lda #WALL 		; write default property.
0016C1  3  A2 00        	ldx #0
0016C3  3               clrmap:
0016C3  3  9D 00 03     	sta MAP,x 		; block properties.
0016C6  3  9D 00 04     	sta MAP+256,x
0016C9  3  9D 00 05     	sta MAP+512,x
0016CC  3  E8           	inx			; next byte.
0016CD  3  D0 F4        	bne clrmap
0016CF  3               
0016CF  3  20 2C 11     	jsr iniob 		; initialise objects.
0016D2  3               
0016D2  3  A9 00        	lda #0			; put zero in accumulator.
0016D4  3  85 rr        	sta gamwon		; reset game won flag.
0016D6  3               
0016D6  3  20 81 19     	jsr inisc 		; init the score.
0016D9  3               mapst:
0016D9  3  AD 1F 2A     	lda stmap 		; start position on map.
0016DC  3  8D 0D 2A     	sta roomtb		; set up position in table, if there is one.
0016DF  3               
0016DF  3               inipbl:
0016DF  3  20 D2 25     	jsr initsc 		; set up first screen.
0016E2  3               
0016E2  3  A9 FC        	lda #<ssprit 		; default to spare sprite in table.
0016E4  3  85 rr        	sta z80_x
0016E6  3  A9 29        	lda #>ssprit
0016E8  3  85 rr        	sta z80_i
0016EA  3               evini:
0016EA  3  20 F1 2C     	jsr evnt13 		; initialisation.
0016ED  3               
0016ED  3               ; Two restarts.
0016ED  3               ; First restart - clear all sprites and initialise everything.
0016ED  3               
0016ED  3               rstrt:
0016ED  3  20 21 19     	jsr rsevt 		; restart events.
0016F0  3  20 1F 11     	jsr xspr 		; clear sprite table.
0016F3  3  20 34 27     	jsr sprlst 		; fetch pointer to screen sprites.
0016F6  3  20 BD 27     	jsr ispr 		; initialise sprite table.
0016F9  3               
0016F9  3  4C 08 17     	jmp rstrt0
0016FC  3               
0016FC  3               ; Second restart - clear all but player, and don't initialise him.
0016FC  3               
0016FC  3               rstrtn:
0016FC  3  20 21 19     	jsr rsevt		; restart events.
0016FF  3  20 61 27     	jsr nspr 		; clear all non-player sprites.
001702  3  20 34 27     	jsr sprlst 		; fetch pointer to screen sprites.
001705  3  20 FA 27     	jsr kspr 		; initialise sprite table, no more players.
001708  3               
001708  3               ; Set up the player and/or enemy sprites.
001708  3               
001708  3               rstrt0:
001708  3  A9 00        	lda #0 			; zero in accumulator.
00170A  3  85 rr        	sta nexlev 		; reset next level flag.
00170C  3  85 rr        	sta restfl 		; reset restart flag.
00170E  3  85 rr        	sta deadf 		; reset dead flag.
001710  3  20 DE 1D     	jsr droom 		; show screen layout.
001713  3               rpblc0:
001713  3               .if pflag
001713  3  20 33 16     	jsr inishr 		; initialise particle engine.
001716  3               .endif
001716  3  20 D1 19     	jsr shwob		; draw objects.
001719  3               
001719  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
00171B  3  85 rr        	sta z80_x
00171D  3  A9 0B        	lda #>sprtab
00171F  3  85 rr        	sta z80_i
001721  3               
001721  3  20 A3 23     	jsr dspr 		; display sprites.
001724  3               
001724  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
001726  3  85 rr        	sta z80_x
001728  3  A9 0B        	lda #>(sprtab+TABSIZ)
00172A  3  85 rr        	sta z80_i
00172C  3  20 A3 23     	jsr dspr 		; display sprites.
00172F  3               
00172F  3               mloop:
00172F  3  20 C1 0E     	jsr bbcsync
001732  3               
001732  3  20 0E 0F     	jsr vsync 		; synchronise with display.
001735  3               
001735  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
001737  3  85 rr        	sta z80_x
001739  3  A9 0B        	lda #>sprtab
00173B  3  85 rr        	sta z80_i
00173D  3               
00173D  3  A9 06 8D 21  DEBUG_PAL PAL_red
001741  3  FE A9 16 8D  
001745  3  21 FE A9 26  
001765  3  20 A3 23     	jsr dspr 		; display even sprites.
001768  3  A9 07 8D 21  DEBUG_PAL PAL_black
00176C  3  FE A9 17 8D  
001770  3  21 FE A9 27  
001790  3               
001790  3  20 D0 19     	jsr plsnd 		; play sounds.
001793  3  20 0E 0F     	jsr vsync 		; synchronise with display.
001796  3               
001796  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
001798  3  85 rr        	sta z80_x
00179A  3  A9 0B        	lda #>(sprtab+TABSIZ)
00179C  3  85 rr        	sta z80_i
00179E  3               
00179E  3  A9 06 8D 21  DEBUG_PAL PAL_red
0017A2  3  FE A9 16 8D  
0017A6  3  21 FE A9 26  
0017C6  3  20 A3 23     	jsr dspr 		; display odd sprites.
0017C9  3  A9 07 8D 21  DEBUG_PAL PAL_black
0017CD  3  FE A9 17 8D  
0017D1  3  21 FE A9 27  
0017F1  3               
0017F1  3  A9 FC        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
0017F3  3  85 rr        	sta z80_x
0017F5  3  A9 29        	lda #>(ssprit)
0017F7  3  85 rr        	sta z80_i
0017F9  3               evlp1:
0017F9  3  A9 05 8D 21  DEBUG_PAL PAL_green
0017FD  3  FE A9 15 8D  
001801  3  21 FE A9 25  
001821  3  20 B2 2B     	jsr evnt10 		; called once per main loop.
001824  3  20 21 23     	jsr pspr 		; process sprites.
001827  3  A9 07 8D 21  DEBUG_PAL PAL_black
00182B  3  FE A9 17 8D  
00182F  3  21 FE A9 27  
00184F  3               
00184F  3               ; Main loop events.
00184F  3               
00184F  3  A9 FC        	lda #<ssprit 		; point to spare sprite for spawning purposes.
001851  3  85 rr        	sta z80_x
001853  3  A9 29        	lda #>ssprit
001855  3  85 rr        	sta z80_i
001857  3  A9 05 8D 21  DEBUG_PAL PAL_green
00185B  3  FE A9 15 8D  
00185F  3  21 FE A9 25  
00187F  3               evlp2:
00187F  3  20 CA 2B     	jsr evnt11 		; called once per main loop.
001882  3               bsortx:
001882  3  20 97 22     	jsr bsort 		; sort sprites.
001885  3  A9 07 8D 21  DEBUG_PAL PAL_black
001889  3  FE A9 17 8D  
00188D  3  21 FE A9 27  
0018AD  3               
0018AD  3  A5 rr        	lda nexlev		; finished level flag.
0018AF  3  D0 1F        	bne newlev		; is set, go to next level.
0018B1  3  A5 rr        	lda gamwon		; finished game flag.
0018B3  3  D0 2A        	bne evwon		; is set, finish the game.
0018B5  3  A5 rr        	lda restfl 		; finished level flag.
0018B7  3  C9 01        	cmp #1			; has it been set?
0018B9  3  D0 03        	bne :+
0018BB  3  4C ED 16     	jmp rstrt		; yes, go to next level.
0018BE  3               :
0018BE  3  C9 02        	cmp #2			; has it been set?
0018C0  3  D0 03        	bne :+
0018C2  3  4C FC 16     	jmp rstrtn		; yes, go to next level.
0018C5  3               :
0018C5  3  A5 rr        	lda deadf 		; dead flag.
0018C7  3  D0 1C        	bne pdead		; yes, player dead.
0018C9  3               
0018C9  3               ; back to start of main loop.
0018C9  3               
0018C9  3  E6 rr        	inc frmno
0018CB  3  E6 rr        	inc clock
0018CD  3  4C 2F 17     	jmp mloop		; switched to a jmp mloop during test mode.
0018D0  3               
0018D0  3               ;----------------------------------------------------------
0018D0  3               ; New level
0018D0  3               ;----------------------------------------------------------
0018D0  3               
0018D0  3               newlev:
0018D0  3  A5 rr        	lda scno 			; current screen.
0018D2  3  18           	clc
0018D3  3  69 01        	adc #1				; next screen.
0018D5  3  CD F4 30     	cmp numsc			; total number of screens.
0018D8  3  B0 05        	bcs evwon			; yes, game finished.
0018DA  3  85 rr        	sta scno			; set new level number.
0018DC  3  4C ED 16     	jmp rstrt			; restart, clearing all aliens.
0018DF  3               
0018DF  3               evwon:
0018DF  3  20 33 2D     	jsr evnt18		 	; game completed.
0018E2  3  4C F6 18     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0018E5  3               
0018E5  3               ;----------------------------------------------------------
0018E5  3               ; Player dead.
0018E5  3               ;----------------------------------------------------------
0018E5  3               
0018E5  3               pdead:
0018E5  3  A9 00        	lda #0				; zeroise accumulator.
0018E7  3  85 rr        	sta deadf			; reset dead flag.
0018E9  3               evdie:
0018E9  3  20 10 2D     	jsr evnt16 			; death subroutine.
0018EC  3  A5 rr        	lda numlif			; number of lives.
0018EE  3  F0 03        	beq :+
0018F0  3  4C ED 16     	jmp rstrt 			; restart game.
0018F3  3               :
0018F3  3               evfail:
0018F3  3  20 18 2D     	jsr evnt17 			; failure event.
0018F6  3               
0018F6  3               ;----------------------------------------------------------
0018F6  3               ; Tidy things up
0018F6  3               ;----------------------------------------------------------
0018F6  3               
0018F6  3               tidyup:
0018F6  3  A0 00        	ldy #0				; digits to check.
0018F8  3               tidyu2:
0018F8  3  B9 9B 1B     	lda score,y 			; get score digit.
0018FB  3  CD A1 1B     	cmp hiscor 			; are we larger than high score digit?
0018FE  3  90 07        	bcc tidyu0			; high score is bigger.
001900  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
001902  3  C8           	iny				; next digit of high score.
001903  3  C0 06        	cpy #6
001905  3  D0 F1        	bne tidyu2			; repeat for all digits
001907  3               tidyu0:
001907  3  A9 9B        	lda #<score			; return pointing to score.
001909  3  85 rr        	sta z80_c
00190B  3  A9 1B        	lda #>score
00190D  3  85 rr        	sta z80_b
00190F  3  60           	rts
001910  3               tidyu1:
001910  3  A0 05        	ldy #5
001912  3               tidyu3:
001912  3  B9 9B 1B     	lda score,y			; score.
001915  3  99 A1 1B     	sta hiscor,y			; high score.
001918  3  88           	dey
001919  3  10 F7        	bpl tidyu3 			; copy score to high score.
00191B  3               evnewh:
00191B  3  20 49 2D     	jsr evnt19			; new high score event.
00191E  3  4C 07 19     	jmp tidyu0			; tidy up.
001921  3               
001921  3               ;--------------------------------------------------
001921  3               ; Restart event.
001921  3               ;--------------------------------------------------
001921  3               
001921  3               rsevt:
001921  3  A9 FC        	lda #<ssprit 			; default to spare element in table.
001923  3  85 rr        	sta z80_x
001925  3  A9 29        	lda #>ssprit
001927  3  85 rr        	sta z80_i
001929  3               evrs:
001929  3  4C F6 2C     	jmp evnt14	 		; call restart event.
00192C  3               
00192C  3               ;------------------------------------------------------------------
00192C  3               ; Copy number passed in a to string position bc, right-justified.
00192C  3               ;
00192C  3               ; Input:
00192C  3               ;  A  = number
00192C  3               ;  BC = string address
00192C  3               ;
00192C  3               ; Output:
00192C  3               ;  BC = string with number
00192C  3               ;-----------------------------------------------------------------
00192C  3               
00192C  3               num2ch:
00192C  3  85 rr        	sta z80_d		; Save number
00192E  3               
00192E  3  A9 00        	lda #0
001930  3  85 rr        	sta flag
001932  3               numdg3:
001932  3  A2 64        	ldx #100		; hundreds column.
001934  3  86 rr        	stx z80_e
001936  3  20 46 19     	jsr numdg		; show digit.
001939  3               numdg2:
001939  3  A2 0A        	ldx #10			; tens column.
00193B  3  86 rr        	stx z80_e
00193D  3  20 46 19     	jsr numdg		; show digit.
001940  3               
001940  3  E6 rr        	inc flag
001942  3  A2 01        	ldx #1			; units column.
001944  3  86 rr        	stx z80_e
001946  3               numdg:
001946  3  A9 30        	lda #48			; clear digit.
001948  3  85 rr        	sta z80_a
00194A  3               numdg1:
00194A  3  A5 rr        	lda z80_d
00194C  3  C5 rr        	cmp z80_e
00194E  3  90 0E        	bcc numdg0		; nothing to show.
001950  3  38           	sec
001951  3  A5 rr        	lda z80_d
001953  3  E5 rr        	sbc z80_e		; subtract from column.
001955  3  85 rr        	sta z80_d
001957  3  E6 rr        	inc z80_a		; increment digit.
001959  3  E6 rr        	inc flag
00195B  3  4C 4A 19     	jmp numdg1		; repeat until column is zero.
00195E  3               numdg0:
00195E  3  A0 00        	ldy #0
001960  3  A5 rr        	lda z80_a
001962  3  91 rr        	sta (z80_bc),y		; write digit to buffer.
001964  3  A5 rr        	lda flag
001966  3  F0 06        	beq :+
001968  3  E6 rr        	inc z80_c		; next buffer position.
00196A  3  D0 02        	bne :+
00196C  3  E6 rr        	inc z80_b
00196E  3               :
00196E  3  60           	rts
00196F  3               num2dd:
00196F  3  85 rr        	sta z80_d		; Save number
001971  3               
001971  3  A9 01        	lda #1
001973  3  85 rr        	sta flag
001975  3               
001975  3  4C 39 19     	jmp numdg2
001978  3               num2td:
001978  3  85 rr        	sta z80_d		; Save number
00197A  3               
00197A  3  A9 01        	lda #1
00197C  3  85 rr        	sta flag
00197E  3  4C 32 19     	jmp numdg3
001981  3               
001981  3               ;---------------------------------------------------------
001981  3               ; Reset score to "000000"
001981  3               ;---------------------------------------------------------
001981  3               
001981  3               inisc:
001981  3  A9 30        	lda #'0'
001983  3  A2 05        	ldx #5			; digits to initialise.
001985  3               inisc0:
001985  3  9D 9B 1B     	sta score,x 		; write zero digit.
001988  3  CA           	dex			; next column.
001989  3  10 FA        	bpl inisc0		; repeat for all digits.
00198B  3               
00198B  3  60           	rts
00198C  3               
00198C  3               ;-----------------------------------------------------
00198C  3               ; Multiply h by d and return in hl.
00198C  3               ;
00198C  3               ; Input:
00198C  3               ;  H = first number
00198C  3               ;  D = second number
00198C  3               ;
00198C  3               ; Output:
00198C  3               ;  HL = result H x D
00198C  3               ;-----------------------------------------------------
00198C  3               
00198C  3               imul:
00198C  3  A5 rr        	lda z80_d		; HL = H * D
00198E  3  85 rr        	sta z80_e
001990  3  A5 rr        	lda z80_h
001992  3  85 rr        	sta z80_c		; make c first multiplier.
001994  3               imul0:
001994  3  A9 00        	lda #0			; zeroise total.
001996  3  85 rr        	sta z80_l
001998  3  85 rr        	sta z80_h
00199A  3               
00199A  3  A5 rr        	lda z80_h
00199C  3  85 rr        	sta z80_d		; zeroise high byte.
00199E  3               
00199E  3  A9 08        	lda #8			; repeat 8 times.
0019A0  3  85 rr        	sta z80_b
0019A2  3               imul1:
0019A2  3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
0019A4  3  90 0E        	bcc imul2		; wasn't set.
0019A6  3  18           	clc			; bit was set, so add de.
0019A7  3  A5 rr        	lda z80_l
0019A9  3  65 rr        	adc z80_e
0019AB  3  85 rr        	sta z80_l
0019AD  3  A5 rr        	lda z80_h
0019AF  3  65 rr        	adc z80_d
0019B1  3  85 rr        	sta z80_h
0019B3  3  18           	clc 			; reset carry.
0019B4  3               imul2:
0019B4  3  06 rr        	asl z80_e 		; shift de 1 bit left.
0019B6  3  26 rr        	rol z80_d
0019B8  3  C6 rr        	dec z80_b
0019BA  3  D0 E6        	bne imul1		; repeat 8 times.
0019BC  3               
0019BC  3  60           	rts
0019BD  3               
0019BD  3               ;-----------------------------------------------
0019BD  3               ; Divide d by e and return in d, remainder in a.
0019BD  3               ;
0019BD  3               ; Input:
0019BD  3               ;  D = first number
0019BD  3               ;  E = second number
0019BD  3               ;
0019BD  3               ; Output:
0019BD  3               ;  D = result D/E
0019BD  3               ;  A = remainder
0019BD  3               ;-----------------------------------------------
0019BD  3               
0019BD  3               idiv:
0019BD  3  A9 00        	lda #0
0019BF  3  A0 08        	ldy #8		 	; bits to shift.
0019C1  3  06 rr        	asl z80_d
0019C3  3               idiv0:
0019C3  3  2A           	rol a 			; multiply d by 2.
0019C4  3  C5 rr        	cmp z80_e 		; test if e is smaller.
0019C6  3  90 02        	bcc idiv1		; e is greater, no division this time.
0019C8  3  E5 rr        	sbc z80_e		; subtract it.
0019CA  3               idiv1:
0019CA  3  26 rr        	rol z80_d		; rotate into d.
0019CC  3  88           	dey
0019CD  3  D0 F4        	bne idiv0		; repeat
0019CF  3  60           	rts
0019D0  3               
0019D0  3               ;---------------------------------------------------
0019D0  3               ; Play AY sound effect
0019D0  3               ;---------------------------------------------------
0019D0  3               
0019D0  3               plsnd:
0019D0  3  60           	rts
0019D1  3               
0019D1  3               ;---------------------------------------------------
0019D1  3               ; Objects handling.
0019D1  3               ; 32 bytes for image
0019D1  3               ; 3 for room, y and x
0019D1  3               ; 3 for starting room, y and x.
0019D1  3               ; 254 = disabled.
0019D1  3               ; 255 = object in player"s pockets.
0019D1  3               ;---------------------------------------------------
0019D1  3               
0019D1  3               ;---------------------------------------------------
0019D1  3               ; Show items present.
0019D1  3               ;---------------------------------------------------
0019D1  3               
0019D1  3               shwob:
0019D1  3  A9 18        	lda #<objdta 			; objects table.
0019D3  3  85 rr        	sta z80_l
0019D5  3  A9 31        	lda #>objdta
0019D7  3  85 rr        	sta z80_h
0019D9  3               
0019D9  3  AD 18 11     	lda numob 			; number of objects in the game.
0019DC  3  85 rr        	sta sprcnt
0019DE  3               shwob0:
0019DE  3  A0 20        	ldy #32 			; distance to room number.
0019E0  3  B1 rr        	lda (z80_hl),y 			; same as an item?
0019E2  3  C5 rr        	cmp scno 			; current location.
0019E4  3  D0 03        	bne :+
0019E6  3  20 FB 19     	jsr dobj 			; yes, display object.
0019E9  3               :
0019E9  3  18           	clc
0019EA  3  A5 rr        	lda z80_l
0019EC  3  69 26        	adc #38 			; distance to next item.
0019EE  3  85 rr        	sta z80_l
0019F0  3  A5 rr        	lda z80_h
0019F2  3  69 00        	adc #0
0019F4  3  85 rr        	sta z80_h	 		; point to it.
0019F6  3  C6 rr        	dec sprcnt
0019F8  3  D0 E4        	bne shwob0 			; repeat for others.
0019FA  3  60           	rts
0019FB  3               
0019FB  3               ;---------------------------------------------------
0019FB  3               ; Display object.
0019FB  3               ; hl must point to object's start address.
0019FB  3               ;
0019FB  3               ; Input:
0019FB  3               ;  HL = object address
0019FB  3               ;---------------------------------------------------
0019FB  3               
0019FB  3               dobj:
0019FB  3  A0 21        	ldy #33
0019FD  3  B1 rr        	lda (z80_hl),y 			; point to y.
0019FF  3  85 rr        	sta dispy
001A01  3  C8           	iny
001A02  3  B1 rr        	lda (z80_hl),y 			; point to x.
001A04  3  85 rr        	sta dispx
001A06  3               dobj1:
001A06  3  4C 6B 0F     	jmp sprite 			; draw this sprite.
001A09  3               
001A09  3               ;--------------------------------------
001A09  3               ; Remove an object.
001A09  3               ;
001A09  3               ; Input:
001A09  3               ;  A = object number
001A09  3               ;--------------------------------------
001A09  3               
001A09  3               remob:
001A09  3  CD 18 11     	cmp numob			; number of objects in game.
001A0C  3  90 01        	bcc :+				; are we checking past the end?
001A0E  3  60           	rts				; yes, can't get non-existent item.
001A0F  3               :
001A0F  3  48           	pha				; remember object.
001A10  3  20 1E 1A     	jsr getob			; pick it up if we haven't already got it.
001A13  3  68           	pla				; retrieve object number.
001A14  3  20 4D 1A     	jsr gotob			; get its address.
001A17  3  A9 FE        	lda #254
001A19  3  A0 20        	ldy #32
001A1B  3  91 rr        	sta (z80_hl),y			; remove it.
001A1D  3  60           	rts
001A1E  3               
001A1E  3               ;---------------------------------------------------
001A1E  3               ; Pick up object number held in the accumulator.
001A1E  3               ;
001A1E  3               ; Input:
001A1E  3               ;  A = object number
001A1E  3               ;---------------------------------------------------
001A1E  3               
001A1E  3               getob:
001A1E  3  CD 18 11     	cmp numob 		; number of objects in game.
001A21  3  90 01        	bcc :+			; are we checking past the end?
001A23  3  60           	rts			; yes, can't get non-existent item.
001A24  3               :
001A24  3  20 4D 1A     	jsr gotob 		; check if we already have it.
001A27  3  C9 FF        	cmp #255
001A29  3  D0 01        	bne :+
001A2B  3  60           	rts			; we already do.
001A2C  3               :
001A2C  3  A0 20        	ldy #32
001A2E  3  B1 rr        	lda (z80_hl),y		; is it on this screen?
001A30  3  C5 rr        	cmp scno 		; current screen.
001A32  3  D0 14        	bne getob0		; not on screen, so nothing to delete.
001A34  3               
001A34  3  A9 FF        	lda #255
001A36  3  91 rr        	sta (z80_hl),y		; pick it up.
001A38  3  C8           	iny 			; point to y coord.
001A39  3               getob1:
001A39  3  A0 21        	ldy #33
001A3B  3  B1 rr        	lda (z80_hl),y		; y coord.
001A3D  3  85 rr        	sta dispy
001A3F  3  A0 22        	ldy #34
001A41  3  B1 rr        	lda (z80_hl),y 		; x coord.
001A43  3  85 rr        	sta dispx
001A45  3  4C 06 1A     	jmp dobj1 		; delete object sprite.
001A48  3               getob0:
001A48  3  A9 FF        	lda #255
001A4A  3  91 rr        	sta (z80_hl),y 		; pick it up.
001A4C  3  60           	rts
001A4D  3               
001A4D  3               ;-----------------------------------------------------------------
001A4D  3               ; Got object check.
001A4D  3               ; Call with object in accumulator, returns zero set if in pockets.
001A4D  3               ;
001A4D  3               ; Input:
001A4D  3               ;  A = object number
001A4D  3               ;-----------------------------------------------------------------
001A4D  3               
001A4D  3               gotob:
001A4D  3  CD 18 11     	cmp numob 		; number of objects in game.
001A50  3  90 03        	bcc :+ 			; are we checking past the end?
001A52  3  4C 59 1A     	jmp gotob0 		; yes, we can't have a non-existent object.
001A55  3               :
001A55  3  20 5E 1A     	jsr findob		; find the object.
001A58  3               gotob1:
001A58  3  60           	rts
001A59  3               
001A59  3               gotob0:
001A59  3  A9 FE        	lda #254 		; missing.
001A5B  3  4C 58 1A     	jmp gotob1
001A5E  3               
001A5E  3               findob:
001A5E  3  48           	pha			; save object number
001A5F  3  A9 18        	lda #<objdta 		; objects.
001A61  3  85 rr        	sta z80_l
001A63  3  A9 31        	lda #>objdta
001A65  3  85 rr        	sta z80_h
001A67  3  68           	pla			; retreive object number
001A68  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
001A6A  3  AA           	tax 			; loop counter
001A6B  3               fndob2:
001A6B  3  18           	clc
001A6C  3  A5 rr        	lda z80_l
001A6E  3  69 26        	adc #38 		; size of each object.
001A70  3  85 rr        	sta z80_l
001A72  3  90 02        	bcc :+
001A74  3  E6 rr        	inc z80_h
001A76  3               :
001A76  3  CA           	dex 			; repeat until we find address.
001A77  3  D0 F2        	bne fndob2
001A79  3               fndob1:
001A79  3  A0 20        	ldy #32			; distance to room it's in.
001A7B  3  B1 rr        	lda (z80_hl),y		; fetch status.
001A7D  3  60           	rts
001A7E  3               
001A7E  3               ;---------------------------------------------
001A7E  3               ; Drop object number at (dispx, dispy).
001A7E  3               ;
001A7E  3               ; Input:
001A7E  3               ;  A = object number
001A7E  3               ;---------------------------------------------
001A7E  3               
001A7E  3               drpob:
001A7E  3  CD 18 11     	cmp numob 		; are we checking past the end?
001A81  3  90 01        	bcc :+
001A83  3  60           	rts			; yes, can't drop non-existent item.
001A84  3               :
001A84  3  20 4D 1A     	jsr gotob		; make sure object is in inventory.
001A87  3  C5 rr        	cmp scno		; already on this screen?
001A89  3  D0 01        	bne :+
001A8B  3  60           	rts			; yes, nothing to do.
001A8C  3               :
001A8C  3  A0 20        	ldy #32
001A8E  3  A5 rr        	lda scno
001A90  3  91 rr        	sta (z80_hl),y		; bring onto screen.
001A92  3  A5 rr        	lda dispy		; sprite y coordinate.
001A94  3  C8           	iny
001A95  3  91 rr        	sta (z80_hl),y		; point to object y.
001A97  3  A5 rr        	lda dispx 		; sprite x coordinate.
001A99  3  C8           	iny
001A9A  3  91 rr        	sta (z80_hl),y 		; point to object x
001A9C  3  4C FB 19     	jmp dobj		; draw the object sprite.
001A9F  3               
001A9F  3               ;-----------------------------------------------
001A9F  3               ; Seek objects at sprite position.
001A9F  3               ;
001A9F  3               ; Output:
001A9F  3               ;  A = object number, if not found A=255
001A9F  3               ;-----------------------------------------------
001A9F  3               
001A9F  3               skobj:
001A9F  3  A9 18        	lda #<objdta 		; pointer to objects.
001AA1  3  85 rr        	sta z80_l
001AA3  3  A9 31        	lda #>objdta
001AA5  3  85 rr        	sta z80_h
001AA7  3               
001AA7  3  AD 18 11     	lda numob 		; number of objects in game.
001AAA  3  85 rr        	sta z80_b 		; set up the loop counter.
001AAC  3               skobj0:
001AAC  3  A5 rr        	lda scno		; current room number.
001AAE  3  A0 20        	ldy #32
001AB0  3  D1 rr        	cmp (z80_hl),y		; is object in here?
001AB2  3  D0 03        	bne :+
001AB4  3  20 C9 1A     	jsr skobj1		; yes, check coordinates.
001AB7  3               :
001AB7  3  18           	clc			; point to next object in table.
001AB8  3  A5 rr        	lda z80_l
001ABA  3  69 26        	adc #38			; size of each object.
001ABC  3  85 rr        	sta z80_l
001ABE  3  90 02        	bcc :+
001AC0  3  E6 rr        	inc z80_h
001AC2  3               :
001AC2  3  C6 rr        	dec z80_b
001AC4  3  D0 E6        	bne skobj0		; repeat for all objects.
001AC6  3               
001AC6  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
001AC8  3  60           	rts
001AC9  3               
001AC9  3               skobj1:
001AC9  3  A0 21        	ldy #33			; point to y coordinate.
001ACB  3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
001ACD  3  38           	sec
001ACE  3  A0 08        	ldy #var_newY
001AD0  3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
001AD2  3  18           	clc
001AD3  3  69 0F        	adc #15			; add sprite height minus one.
001AD5  3  C9 1F        	cmp #31			; within range?
001AD7  3  90 03        	bcc :+
001AD9  3  4C F7 1A     	jmp skobj2		; no, ignore object.
001ADC  3               :
001ADC  3  A0 22        	ldy #34			; point to x coordinate now.
001ADE  3  B1 rr        	lda (z80_hl),y 		; get coordinate.
001AE0  3  38           	sec
001AE1  3  A0 09        	ldy #var_newX
001AE3  3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
001AE5  3  18           	clc			; add sprite width minus one.
001AE6  3  69 0F        	adc #15
001AE8  3  C9 1F        	cmp #31			; within range?
001AEA  3  90 03        	bcc :+
001AEC  3  4C F7 1A     	jmp skobj2		; no, ignore object.
001AEF  3               :
001AEF  3  68           	pla			; remove return address from stack.
001AF0  3  68           	pla
001AF1  3               
001AF1  3  AD 18 11     	lda numob 		; objects in game.
001AF4  3  38           	sec
001AF5  3  E5 rr        	sbc z80_b		; subtract loop counter.
001AF7  3               skobj2:
001AF7  3  60           	rts			; accumulator now points to object.
001AF8  3               
001AF8  3               
001AF8  3               ;---------------------------------------------------------------------
001AF8  3               ; Spawn a new sprite.
001AF8  3               ;---------------------------------------------------------------------
001AF8  3               
001AF8  3               spawn:
001AF8  3  A9 00        	lda #<sprtab		; sprite table.
001AFA  3  85 rr        	sta z80_l
001AFC  3  A9 0B        	lda #>sprtab
001AFE  3  85 rr        	sta z80_h
001B00  3               numsp1:
001B00  3  A9 0C        	lda #NUMSPR		; number of sprites.
001B02  3  85 rr        	sta spcnt
001B04  3               spaw0:
001B04  3  A0 00        	ldy #var_Type
001B06  3  B1 rr        	lda (z80_hl),y		; get sprite type.
001B08  3  C9 FF        	cmp #255		; is it an unused slot?
001B0A  3  F0 0F        	beq spaw1 		; yes, we can use this one.
001B0C  3               
001B0C  3  18           	clc 			; point to next sprite in table.
001B0D  3  A5 rr        	lda z80_l
001B0F  3  69 11        	adc #TABSIZ		; size of each entry.
001B11  3  85 rr        	sta z80_l
001B13  3  90 02        	bcc :+
001B15  3  E6 rr        	inc z80_h
001B17  3               :
001B17  3  C6 rr        	dec spcnt		; one less iteration.
001B19  3  D0 E9        	bne spaw0		; keep going until we find a slot.
001B1B  3               
001B1B  3               ; Didn't find one but drop through and set up a dummy sprite instead.
001B1B  3               
001B1B  3               spaw1:
001B1B  3  A5 rr        	lda z80_i		; address of original sprite.
001B1D  3  48           	pha
001B1E  3  A5 rr        	lda z80_x
001B20  3  48           	pha
001B21  3               
001B21  3  A5 rr        	lda z80_l		; store spawned sprite address.
001B23  3  85 rr        	sta spptr
001B25  3  A5 rr        	lda z80_h
001B27  3  85 rr        	sta spptr+1
001B29  3               
001B29  3  A5 rr        	lda z80_c
001B2B  3  A0 00        	ldy #var_Type
001B2D  3  91 rr        	sta (z80_hl),y 		; set the type.
001B2F  3  A0 05        	ldy #var_newType
001B31  3  91 rr        	sta (z80_hl),y		; copy
001B33  3               
001B33  3  A5 rr        	lda z80_b
001B35  3  A0 01        	ldy #var_Image
001B37  3  91 rr        	sta (z80_hl),y		; set the image.
001B39  3  A0 06        	ldy #var_newImage
001B3B  3  91 rr        	sta (z80_hl),y		; copy
001B3D  3               
001B3D  3  A9 00        	lda #0 				; frame zero.
001B3F  3  A0 02        	ldy #var_Frame
001B41  3  91 rr        	sta (z80_hl),y		; set frame.
001B43  3  A0 07        	ldy #var_newFrame
001B45  3  91 rr        	sta (z80_hl),y		; copy
001B47  3               
001B47  3  A0 09        	ldy #9
001B49  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001B4B  3  A0 04        	ldy #var_X
001B4D  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001B4F  3  A0 09        	ldy #var_newX
001B51  3  91 rr        	sta (z80_hl),y		; copy
001B53  3               
001B53  3  A0 08        	ldy #8
001B55  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001B57  3  A0 03        	ldy #var_Y
001B59  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001B5B  3  A0 08        	ldy #var_newY
001B5D  3  91 rr        	sta (z80_hl),y		; copy
001B5F  3               
001B5F  3  A0 0A        	ldy #10				; direction of original.
001B61  3  B1 rr        	lda (z80_ix),y
001B63  3  A0 0A        	ldy #var_Direction
001B65  3  91 rr        	sta (z80_hl),y		; direction
001B67  3               
001B67  3  A9 00        	lda #0
001B69  3  A0 0D        	ldy #var_jumpLo
001B6B  3  91 rr        	sta (z80_hl),y		; reset parameter.
001B6D  3  C8           	iny
001B6E  3  91 rr        	sta (z80_hl),y		; reset parameter.
001B70  3  C8           	iny
001B71  3  91 rr        	sta (z80_hl),y		; reset parameter.
001B73  3  C8           	iny
001B74  3  91 rr        	sta (z80_hl),y		; reset parameter.
001B76  3               rtssp:
001B76  3  A5 rr        	lda spptr			; address of new sprite.
001B78  3  85 rr        	sta z80_x
001B7A  3  A5 rr        	lda spptr+1
001B7C  3  85 rr        	sta z80_i
001B7E  3               evis1:
001B7E  3  20 B1 2B     	jsr evnt09 			; call sprite initialisation event.
001B81  3               
001B81  3  A5 rr        	lda spptr 			; address of new sprite.
001B83  3  85 rr        	sta z80_x
001B85  3  A5 rr        	lda spptr+1
001B87  3  85 rr        	sta z80_i
001B89  3               
001B89  3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
001B89  3  A0 03        	ldy #var_Y
001B8B  3  B1 rr        	lda (z80_hl), y		; old x coord
001B8D  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001B8F  3  B0 03        	bcs :+				; yes, don't draw it.
001B91  3               
001B91  3  20 D1 0F     	jsr sspria 			; display the new sprite.
001B94  3               :
001B94  3  68           	pla					; address of original sprite.
001B95  3  85 rr        	sta z80_x
001B97  3  68           	pla
001B98  3  85 rr        	sta z80_i
001B9A  3               
001B9A  3  60           	rts
001B9B  3               
001B9B  3  30 30 30 30  score:	.byte "000000"		; player"s score.
001B9F  3  30 30        
001BA1  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
001BA5  3  30 30        
001BA7  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
001BAB  3  30 30        
001BAD  3  00 68        grbase:	.word ScreenAddr	; graphics base address.
001BAF  3               
001BAF  3               ;----------------------------------------------------
001BAF  3               ; Check y-pos
001BAF  3               ;----------------------------------------------------
001BAF  3               
001BAF  3               checkx:
001BAF  3  A5 rr        	lda dispy		; y position.
001BB1  3  C9 18        	cmp #24			; off screen?
001BB3  3  B0 01        	bcs :+
001BB5  3  60           	rts			; no, it's okay.
001BB6  3               :
001BB6  3  68           	pla			; remove return address from stack.
001BB7  3  85 rr        	sta z80_l
001BB9  3  68           	pla
001BBA  3  85 rr        	sta z80_h
001BBC  3  60           	rts
001BBD  3               
001BBD  3               ;-----------------------------------------------
001BBD  3               ; Displays the current high score.
001BBD  3               ;-----------------------------------------------
001BBD  3               
001BBD  3               dhisc:
001BBD  3  A9 A1        	lda #<hiscor 		; high score text.
001BBF  3  85 rr        	sta z80_l
001BC1  3  A9 1B        	lda #>hiscor
001BC3  3  85 rr        	sta z80_h
001BC5  3  4C D0 1B     	jmp dscor1		; check in printable range then show 6 digits.
001BC8  3               
001BC8  3               ;------------------------------------------------------
001BC8  3               ; Displays the current score.
001BC8  3               ;------------------------------------------------------
001BC8  3               
001BC8  3               dscor:
001BC8  3  A9 9B        	lda #<score		; score text.
001BCA  3  85 rr        	sta z80_l
001BCC  3  A9 1B        	lda #>score
001BCE  3  85 rr        	sta z80_h
001BD0  3               dscor1:
001BD0  3  20 6B 22     	jsr preprt		; set up font and print position.
001BD3  3  20 AF 1B     	jsr checkx		; make sure we're in a printable range.
001BD6  3               
001BD6  3  A9 06        	lda #6			; digits to display.
001BD8  3  85 rr        	sta z80_b
001BDA  3  A5 rr        	lda prtmod		; get print mode.
001BDC  3  F0 03        	beq :+			; standard size text?
001BDE  3  4C FD 1B     	jmp bscor0		; no, show double-height.
001BE1  3               :
001BE1  3               dscor0:
001BE1  3  A0 00        	ldy #0
001BE3  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001BE5  3  20 D8 10     	jsr pchar 		; display character.
001BE8  3  E6 rr        	inc dispx		; move along x coordinate
001BEA  3               
001BEA  3  E6 rr        	inc z80_l		; next score column.
001BEC  3  D0 02        	bne :+
001BEE  3  E6 rr        	inc z80_h
001BF0  3               :
001BF0  3  C6 rr        	dec z80_b
001BF2  3  D0 ED        	bne dscor0 		; repeat for all digits.
001BF4  3               dscor2:
001BF4  3  A5 rr        	lda dispx 		; set up display coordinates.
001BF6  3  85 rr        	sta charx
001BF8  3  A5 rr        	lda dispy
001BFA  3  85 rr        	sta chary
001BFC  3  60           	rts
001BFD  3               
001BFD  3               ;------------------------------------------------------
001BFD  3               ; Displays the current score in double-height characters.
001BFD  3               ;
001BFD  3               ; Input:
001BFD  3               ;  B  = digit number
001BFD  3               ;  HL = score string
001BFD  3               ;------------------------------------------------------
001BFD  3               
001BFD  3               bscor0:
001BFD  3  A0 00        	ldy #0
001BFF  3               
001BFF  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001C01  3  20 EE 21     	jsr bchar 		; display big char.
001C04  3               
001C04  3  E6 rr        	inc z80_l 		; next score column.
001C06  3  D0 02        	bne :+
001C08  3  E6 rr        	inc z80_h
001C0A  3               :
001C0A  3  C6 rr        	dec z80_b
001C0C  3  F0 03        	beq :+
001C0E  3  4C FD 1B     	jmp bscor0 		; repeat for all digits.
001C11  3               :
001C11  3  4C F4 1B     	jmp dscor2 		; tidy up line and column variables.
001C14  3               
001C14  3               ;-----------------------------------------------------
001C14  3               ; Adds number in the hl pair to the score.
001C14  3               ;-----------------------------------------------------
001C14  3               
001C14  3               addsc:
001C14  3  A9 9C        	lda #<(score+1) 	; ten thousands column.
001C16  3  85 rr        	sta z80_e
001C18  3  A9 1B        	lda #>(score+1)
001C1A  3  85 rr        	sta z80_d
001C1C  3  A9 10        	lda #<10000		; amount to add each time.
001C1E  3  85 rr        	sta z80_c
001C20  3  A9 27        	lda #>10000
001C22  3  85 rr        	sta z80_b
001C24  3  20 68 1C     	jsr incsc		; add to score.
001C27  3               
001C27  3  E6 rr        	inc z80_e		; thousands column.
001C29  3  D0 02        	bne :+
001C2B  3  E6 rr        	inc z80_d
001C2D  3               :
001C2D  3  A9 E8        	lda #<1000		; amount to add each time.
001C2F  3  85 rr        	sta z80_c
001C31  3  A9 03        	lda #>1000
001C33  3  85 rr        	sta z80_b
001C35  3  20 68 1C     	jsr incsc 		; add to score.
001C38  3               
001C38  3  E6 rr        	inc z80_e		; hundreds column.
001C3A  3  D0 02        	bne :+
001C3C  3  E6 rr        	inc z80_d
001C3E  3               :
001C3E  3  A9 64        	lda #<100		; amount to add each time.
001C40  3  85 rr        	sta z80_c
001C42  3  A9 00        	lda #>100
001C44  3  85 rr        	sta z80_b
001C46  3  20 68 1C     	jsr incsc		; add to score.
001C49  3               
001C49  3  E6 rr        	inc z80_e 		; tens column.
001C4B  3  D0 02        	bne :+
001C4D  3  E6 rr        	inc z80_d
001C4F  3               :
001C4F  3  A9 0A        	lda #<10		; amount to add each time.
001C51  3  85 rr        	sta z80_c
001C53  3  A9 00        	lda #>10
001C55  3  85 rr        	sta z80_b
001C57  3  20 68 1C     	jsr incsc 		; add to score.
001C5A  3               
001C5A  3  E6 rr        	inc z80_e		; units column.
001C5C  3  D0 02        	bne :+
001C5E  3  E6 rr        	inc z80_d
001C60  3               :
001C60  3  A9 01        	lda #<1			; units.
001C62  3  85 rr        	sta z80_c
001C64  3  A9 00        	lda #>1
001C66  3  85 rr        	sta z80_b
001C68  3               incsc:
001C68  3  A5 rr        	lda z80_h		; store amount to add.
001C6A  3  48           	pha
001C6B  3  A5 rr        	lda z80_l
001C6D  3  48           	pha
001C6E  3               
001C6E  3  38           	sec			; subtract from amount to add.
001C6F  3  A5 rr        	lda z80_l
001C71  3  E5 rr        	sbc z80_c
001C73  3  85 rr        	sta z80_l
001C75  3  A5 rr        	lda z80_h
001C77  3  E5 rr        	sbc z80_b
001C79  3  85 rr        	sta z80_h
001C7B  3  90 14        	bcc incsc0		; too much, restore value.
001C7D  3               
001C7D  3  68           	pla			; delete the previous amount from the stack.
001C7E  3  68           	pla
001C7F  3               
001C7F  3  A5 rr        	lda z80_d 		; store column position.
001C81  3  48           	pha
001C82  3  A5 rr        	lda z80_e
001C84  3  48           	pha
001C85  3  20 98 1C     	jsr incsc2		; do the increment.
001C88  3               
001C88  3  68           	pla			; restore column.
001C89  3  85 rr        	sta z80_e
001C8B  3  68           	pla
001C8C  3  85 rr        	sta z80_d
001C8E  3  4C 68 1C     	jmp incsc		; repeat until all added.
001C91  3               
001C91  3               incsc0:
001C91  3  68           	pla			; restore previous value.
001C92  3  85 rr        	sta z80_l
001C94  3  68           	pla
001C95  3  85 rr        	sta z80_h
001C97  3  60           	rts
001C98  3               incsc2:
001C98  3  A0 00        	ldy #0
001C9A  3  B1 rr        	lda (z80_de),y 		; get amount.
001C9C  3  18           	clc
001C9D  3  69 01        	adc #1			; add one to column.
001C9F  3  91 rr        	sta (z80_de),y		; write new column total.
001CA1  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
001CA3  3  B0 01        	bcs :+
001CA5  3  60           	rts			; no, carry on.
001CA6  3               :
001CA6  3  A9 30        	lda #'0'		; make it zero.
001CA8  3  91 rr        	sta (z80_de),y		; write new column total.
001CAA  3  C6 rr        	dec z80_e		; back one column.
001CAC  3  D0 02        	bne :+
001CAE  3  C6 rr        	dec z80_d
001CB0  3               :
001CB0  3  4C 98 1C     	jmp incsc2
001CB3  3               
001CB3  3               ;------------------------------------
001CB3  3               ; Add bonus to score and reset bonus
001CB3  3               ;------------------------------------
001CB3  3               
001CB3  3               addbo:
001CB3  3  A2 05        	ldx #5			; last digit.
001CB5  3  18           	clc			; clear carry.
001CB6  3               addbo0:
001CB6  3  BD 9B 1B     	lda score,x		; get score.
001CB9  3  7D A7 1B     	adc bonus,x		; add bonus.
001CBC  3  38           	sec			; 0 to 18.
001CBD  3  E9 30        	sbc #48
001CBF  3  48           	pha
001CC0  3  A9 30        	lda #'0'
001CC2  3  9D A7 1B     	sta bonus,x		; zeroise bonus.
001CC5  3  68           	pla
001CC6  3  C9 3A        	cmp #58			; carried?
001CC8  3  B0 07        	bcs addbo2		; no, do next one.
001CCA  3  38           	sec
001CCB  3  E9 0A        	sbc #10			; subtract 10.
001CCD  3  38           	sec
001CCE  3  4C D2 1C     	jmp addbo1
001CD1  3               addbo2:
001CD1  3  18           	clc
001CD2  3               addbo1:
001CD2  3  9D 9B 1B     	sta score,x		; write new score.
001CD5  3  CA           	dex			; next digit.
001CD6  3  10 DE        	bpl addbo0		; repeat for all 6 digits.
001CD8  3  60           	rts
001CD9  3               
001CD9  3               ;------------------------------------
001CD9  3               ; Swap score and bonus.
001CD9  3               ;------------------------------------
001CD9  3               
001CD9  3               swpsb:
001CD9  3  A2 05        	ldx #5			; digits to add.
001CDB  3               swpsb0:
001CDB  3  BD 9B 1B     	lda score,x 		; get score digits.
001CDE  3  48           	pha			; save digit
001CDF  3  BD A7 1B     	lda bonus,x 		; get bonus digits.
001CE2  3  9D 9B 1B     	sta score,x		; switch score-bonus
001CE5  3  68           	pla
001CE6  3  9D A7 1B     	sta bonus,x
001CE9  3  CA           	dex 			; repeat for all 6 digits.
001CEA  3  10 EF        	bpl swpsb0
001CEC  3  60           	rts
001CED  3               
001CED  3               ;----------------------------------------------------
001CED  3               ; Get print address.
001CED  3               ;----------------------------------------------------
001CED  3               
001CED  3               gprad:
001CED  3  98           	tya
001CEE  3  48           	pha
001CEF  3               
001CEF  3  A5 rr        	lda dispx 		; x coordinate.
001CF1  3  85 rr        	sta scraddr
001CF3  3  A9 00        	lda #0
001CF5  3  85 rr        	sta scraddr+1
001CF7  3  06 rr        	asl scraddr  	; multiply char by 8
001CF9  3  26 rr        	rol scraddr+1
001CFB  3  06 rr        	asl scraddr
001CFD  3  26 rr        	rol scraddr+1
001CFF  3  06 rr        	asl scraddr
001D01  3  26 rr        	rol scraddr+1
001D03  3               
001D03  3  A5 rr        	lda dispy		; y coordinate.
001D05  3  0A           	asl a
001D06  3  0A           	asl a
001D07  3  0A           	asl a			; multiply char by 8
001D08  3  A8           	tay
001D09  3               
001D09  3  18           	clc
001D0A  3  A5 rr        	lda scraddr
001D0C  3  79 00 06     	adc SCADTB_lb,y
001D0F  3  85 rr        	sta scraddr
001D11  3  A5 rr        	lda scraddr+1
001D13  3  79 00 07     	adc SCADTB_hb,y
001D16  3  85 rr        	sta scraddr+1
001D18  3               
001D18  3  68           	pla
001D19  3  A8           	tay
001D1A  3  60           	rts
001D1B  3               
001D1B  3               ;--------------------------------------------------------------
001D1B  3               ; Get property buffer address of char at (dispx, dispy) in hl.
001D1B  3               ;
001D1B  3               ; Output:
001D1B  3               ;  bufaddr = MAP + dispy*32 + dispx
001D1B  3               ;--------------------------------------------------------------
001D1B  3               
001D1B  3               pradd:
001D1B  3  A5 rr        	lda dispy 		; y coordinate.
001D1D  3  85 rr        	sta bufaddr
001D1F  3  A9 00        	lda #0
001D21  3  85 rr        	sta bufaddr+1
001D23  3  06 rr        	asl bufaddr  		; multiply char by 32
001D25  3  26 rr        	rol bufaddr+1
001D27  3  06 rr        	asl bufaddr
001D29  3  26 rr        	rol bufaddr+1
001D2B  3  06 rr        	asl bufaddr
001D2D  3  26 rr        	rol bufaddr+1
001D2F  3  06 rr        	asl bufaddr
001D31  3  26 rr        	rol bufaddr+1
001D33  3  06 rr        	asl bufaddr
001D35  3  26 rr        	rol bufaddr+1
001D37  3  18           	clc			; add address of MAP graphics.
001D38  3  A5 rr        	lda bufaddr
001D3A  3  65 rr        	adc dispx
001D3C  3  69 00        	adc #<MAP
001D3E  3  85 rr        	sta bufaddr
001D40  3  A5 rr        	lda bufaddr+1
001D42  3  69 03        	adc #>MAP
001D44  3  85 rr        	sta bufaddr+1
001D46  3  60           	rts
001D47  3               
001D47  3               ;----------------------------------------------
001D47  3               ; Print attributes, properties and pixels.
001D47  3               ;
001D47  3               ; Input:
001D47  3               ;  A	= tile number
001D47  3               ;----------------------------------------------
001D47  3               
001D47  3               pattr:
001D47  3  85 rr        	sta z80_b		; store cell in b register for now.
001D49  3  AA           	tax
001D4A  3  BD 2A 2E     	lda bprop,x 		; block properties.
001D4D  3  85 rr        	sta z80_c
001D4F  3  C9 08        	cmp #COLECT
001D51  3  D0 04        	bne :+
001D53  3  A5 rr        	lda z80_b
001D55  3  85 rr        	sta colpatt
001D57  3               :
001D57  3  20 1B 1D     	jsr pradd 		; get property buffer address.
001D5A  3  A5 rr        	lda z80_c
001D5C  3  A0 00        	ldy #0
001D5E  3  91 rr        	sta (bufaddr),y 	; write property.
001D60  3  A5 rr        	lda z80_b 		; restore cell.
001D62  3               
001D62  3               ; Print attributes, no properties.
001D62  3               
001D62  3               panp:
001D62  3  85 rr        	sta z80_e		; displacement in e.
001D64  3  A9 00        	lda #0
001D66  3  85 rr        	sta z80_d		; no high byte.
001D68  3  06 rr        	asl z80_e  		; multiply char by 8.
001D6A  3  26 rr        	rol z80_d
001D6C  3  06 rr        	asl z80_e
001D6E  3  26 rr        	rol z80_d
001D70  3  06 rr        	asl z80_e
001D72  3  26 rr        	rol z80_d
001D74  3  18           	clc
001D75  3  A5 rr        	lda z80_e
001D77  3  69 1A        	adc #<chgfx 		; address of graphics.
001D79  3  85 rr        	sta tileaddr
001D7B  3  A5 rr        	lda z80_d
001D7D  3  69 2E        	adc #>chgfx
001D7F  3  85 rr        	sta tileaddr+1
001D81  3  20 ED 1C     	jsr gprad 		; get screen address.
001D84  3  A0 07        	ldy #7			; number of pixel rows to write.
001D86  3               panp0:
001D86  3  B1 rr        	lda (tileaddr),y 	; get image byte.
001D88  3  49 00        	eor #TxtInvert		; Invert
001D8A  3  91 rr        	sta (scraddr),y 	; copy to screen.
001D8C  3  88           	dey	 		; repeat for 8 pixel rows.
001D8D  3  10 F7        	bpl panp0
001D8F  3  E6 rr        	inc dispx 		; move along one.
001D91  3  E6 rr        	inc charx
001D93  3  60           	rts
001D94  3               
001D94  3               ;----------------------------------------------
001D94  3               ; Print character pixels, no more.
001D94  3               ;
001D94  3               ; Input:
001D94  3               ;  A	= character to print
001D94  3               ;----------------------------------------------
001D94  3               
001D94  3               pchr:
001D94  3  20 D8 10     	jsr pchar 		; show character in accumulator.
001D97  3  E6 rr        	inc dispx		; move along one.
001D99  3  60           	rts
001D9A  3               
001D9A  3               ;----------------------------------------------------
001D9A  3               ; Shifter sprite routine for objects.
001D9A  3               ;----------------------------------------------------
001D9A  3               
001D9A  3               sprit7:
001D9A  3  A5 rr        	lda z80_b
001D9C  3  F0 0A        	beq sprit0
001D9E  3  A8           	tay
001D9F  3               sprit3:
001D9F  3  46 rr        	lsr spr			; shift into position.
001DA1  3  66 rr        	ror spr+1
001DA3  3  66 rr        	ror spr+2
001DA5  3  88           	dey				; one less iteration.
001DA6  3  D0 F7        	bne sprit3
001DA8  3               sprit0:
001DA8  3  60           	rts 			; now apply to screen.
001DA9  3               
001DA9  3               ;-----------------------------------------------------------
001DA9  3               ; Get room address.
001DA9  3               ;-----------------------------------------------------------
001DA9  3               
001DA9  3               groom:
001DA9  3  A6 rr        	ldx scno 		; screen number.
001DAB  3  A0 00        	ldy #0
001DAD  3               groomx:
001DAD  3  A9 B2        	lda #<scdat 		; pointer to screens.
001DAF  3  85 rr        	sta z80_l
001DB1  3  A9 2F        	lda #>scdat
001DB3  3  85 rr        	sta z80_h
001DB5  3               groom1:
001DB5  3  E0 00        	cpx #0			; is it the first one?
001DB7  3  F0 15        	beq groom0 		; no more screens to skip.
001DB9  3               
001DB9  3  18           	clc
001DBA  3  A5 rr        	lda z80_l
001DBC  3  79 B2 2F     	adc scdat,y 		; low byte of screen size.
001DBF  3  85 rr        	sta z80_l
001DC1  3  C8           	iny			; point to high byte.
001DC2  3  A5 rr        	lda z80_h
001DC4  3  79 B2 2F     	adc scdat,y 		; high byte of screen size.
001DC7  3  85 rr        	sta z80_h
001DC9  3  C8           	iny			; next address.
001DCA  3               
001DCA  3  CA           	dex 			; one less iteration.
001DCB  3  4C B5 1D     	jmp groom1 		; loop until we reach the end.
001DCE  3               groom0:
001DCE  3  AD F4 30     	lda numsc 		; add displacement.
001DD1  3  0A           	asl a
001DD2  3  18           	clc			; add double displacement to address.
001DD3  3  65 rr        	adc z80_l
001DD5  3  85 rr        	sta z80_l
001DD7  3  A5 rr        	lda z80_h
001DD9  3  69 00        	adc #0
001DDB  3  85 rr        	sta z80_h
001DDD  3  60           	rts
001DDE  3               
001DDE  3               ;-----------------------------------------------------------
001DDE  3               ; Draw present room.
001DDE  3               ;-----------------------------------------------------------
001DDE  3               
001DDE  3               droom:
001DDE  3  AD 14 11     	lda wintop 		; window top.
001DE1  3  85 rr        	sta dispy		; set cursor y position.
001DE3  3               droom2:
001DE3  3  20 A9 1D     	jsr groom 		; get address of current room.
001DE6  3  A9 00        	lda #0	 		; zero in accumulator.
001DE8  3  85 rr        	sta comcnt 		; reset compression counter.
001DEA  3  AD 16 11     	lda winhgt 		; height of window.
001DED  3  85 rr        	sta rrow		; set row counter
001DEF  3               droom0:
001DEF  3  AD 15 11     	lda winlft 		; window left edge.
001DF2  3  85 rr        	sta dispx 		; set cursor x position.
001DF4  3  AD 17 11     	lda winwid 		; width of window.
001DF7  3  85 rr        	sta rcol		; set column counter
001DF9  3               droom1:
001DF9  3  20 0A 1E     	jsr flbyt 		; decompress next byte on the fly.
001DFC  3  20 47 1D     	jsr pattr 		; show attributes and block.
001DFF  3  C6 rr        	dec rcol		; one less column.
001E01  3  D0 F6        	bne droom1 		; repeat for entire line.
001E03  3  E6 rr        	inc dispy		; move down one line.
001E05  3  C6 rr        	dec rrow 		; one less row.
001E07  3  D0 E6        	bne droom0 		; repeat for all rows.
001E09  3  60           	rts
001E0A  3               
001E0A  3               ;----------------------------------------------
001E0A  3               ; Decompress bytes on-the-fly.
001E0A  3               ;----------------------------------------------
001E0A  3               
001E0A  3               flbyt:
001E0A  3  A5 rr        	lda comcnt 		; compression counter.
001E0C  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
001E0E  3               
001E0E  3  A0 00        	ldy #0
001E10  3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
001E12  3  E6 rr        	inc z80_l 		; point to next cell.
001E14  3  D0 02        	bne :+
001E16  3  E6 rr        	inc z80_h
001E18  3               :
001E18  3  C9 FF        	cmp #255 		; is this byte a control code?
001E1A  3  F0 01        	beq :+
001E1C  3  60           	rts 			; no, this byte is uncompressed.
001E1D  3               :
001E1D  3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
001E1F  3  85 rr        	sta combyt 		; set up the type.
001E21  3  E6 rr        	inc z80_l 		; point to quantity.
001E23  3  D0 02        	bne :+
001E25  3  E6 rr        	inc z80_h
001E27  3               :
001E27  3  B1 rr        	lda (z80_hl),y 		; get quantity.
001E29  3  E6 rr        	inc z80_l 		; point to next byte.
001E2B  3  D0 02        	bne :+
001E2D  3  E6 rr        	inc z80_h
001E2F  3               :
001E2F  3               flbyt1:
001E2F  3  85 rr        	sta comcnt 		; store new quantity.
001E31  3  C6 rr        	dec comcnt		; one less.
001E33  3  A5 rr        	lda combyt 		; byte to expand.
001E35  3  60           	rts
001E36  3               
001E36  3               ;------------------------------------------
001E36  3               ; Ladder down check.
001E36  3               ;
001E36  3               ; Input:
001E36  3               ;  IX = sprite pointer
001E36  3               ;------------------------------------------
001E36  3               
001E36  3               laddd:
001E36  3  A0 09        	ldy #9
001E38  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001E3A  3  85 rr        	sta dispx
001E3C  3               
001E3C  3  A0 08        	ldy #8
001E3E  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001E40  3  29 FE        	and #254		; make it even.
001E42  3  91 rr        	sta (z80_ix),y 		; reset it.
001E44  3               numsp5:
001E44  3  18           	clc 			; look down 16 pixels.
001E45  3  69 10        	adc #16
001E47  3  85 rr        	sta dispy		; coords in dispx,dispy.
001E49  3  4C 5F 1E     	jmp laddv
001E4C  3               
001E4C  3               ;------------------------------------------
001E4C  3               ; Ladder up check.
001E4C  3               ;
001E4C  3               ; Input:
001E4C  3               ;  IX = sprite pointer
001E4C  3               ;
001E4C  3               ; Output:
001E4C  3               ;  A  = 0 is ok, A <>0 is not ok
001E4C  3               ;------------------------------------------
001E4C  3               
001E4C  3               laddu:
001E4C  3  A0 09        	ldy #9
001E4E  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001E50  3  85 rr        	sta dispx
001E52  3               
001E52  3  A0 08        	ldy #8
001E54  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001E56  3  29 FE        	and #254 		; make it even.
001E58  3  91 rr        	sta (z80_ix),y		; reset it.
001E5A  3               numsp6:
001E5A  3  18           	clc 			; look 2 pixels above feet.
001E5B  3  69 0E        	adc #14
001E5D  3  85 rr        	sta dispy		; coords in dispx,dispy.
001E5F  3               laddv:
001E5F  3  20 A1 20     	jsr tstbl 		; get map address.
001E62  3  20 6C 1F     	jsr ldchk 		; standard ladder check.
001E65  3  F0 01        	beq :+
001E67  3  60           	rts 			; no way through.
001E68  3               :
001E68  3  E6 rr        	inc bufaddr 		; look right one cell.
001E6A  3  D0 02        	bne :+
001E6C  3  E6 rr        	inc bufaddr+1
001E6E  3               :
001E6E  3  20 6C 1F     	jsr ldchk 		; do the check.
001E71  3  F0 01        	beq :+
001E73  3  60           	rts 			; impassable.
001E74  3               :
001E74  3  A5 rr        	lda dispx 		; y coordinate.
001E76  3  29 07        	and #7 			; position straddling block cells.
001E78  3  D0 01        	bne :+
001E7A  3  60           	rts 			; no more checks needed.
001E7B  3               :
001E7B  3  E6 rr        	inc bufaddr 		; look to third cell.
001E7D  3  D0 02        	bne :+
001E7F  3  E6 rr        	inc bufaddr+1
001E81  3               :
001E81  3  20 6C 1F     	jsr ldchk 		; do the check.
001E84  3  60           	rts  			; return with zero flag set accordingly.
001E85  3               
001E85  3               ;---------------------------------------------------------
001E85  3               ; Can go up check.
001E85  3               ;
001E85  3               ; Input:
001E85  3               ;  IX = sprite pointer
001E85  3               ;
001E85  3               ; Output:
001E85  3               ;  A  = 0 is ok, A <>0 is not ok
001E85  3               ;---------------------------------------------------------
001E85  3               
001E85  3               cangu:
001E85  3  A0 09        	ldy #9
001E87  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001E89  3  85 rr        	sta dispx
001E8B  3  A0 08        	ldy #8
001E8D  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001E8F  3  38           	sec
001E90  3  E9 02        	sbc #2
001E92  3  85 rr        	sta dispy		; coords in dispx,dispy.
001E94  3  20 A1 20     	jsr tstbl 		; get map address.
001E97  3  20 37 1F     	jsr lrchk 		; standard left/right check.
001E9A  3  F0 01        	beq :+
001E9C  3  60           	rts			; no way through.
001E9D  3               :
001E9D  3  E6 rr        	inc bufaddr		; look right one cell.
001E9F  3  D0 02        	bne :+
001EA1  3  E6 rr        	inc bufaddr+1
001EA3  3               :
001EA3  3  20 37 1F     	jsr lrchk 		; do the check.
001EA6  3  F0 01        	beq :+
001EA8  3  60           	rts			; impassable.
001EA9  3               :
001EA9  3  A5 rr        	lda dispx		; x coordinate.
001EAB  3  29 07        	and #7			; position straddling block cells.
001EAD  3  D0 01        	bne :+
001EAF  3  60           	rts			; no more checks needed.
001EB0  3               :
001EB0  3  E6 rr        	inc bufaddr		; look to third cell.
001EB2  3  D0 02        	bne :+
001EB4  3  E6 rr        	inc bufaddr+1
001EB6  3               :
001EB6  3  20 37 1F     	jsr lrchk		; do the check.
001EB9  3  60           	rts 			; return with zero flag set accordingly.
001EBA  3               
001EBA  3               ;---------------------------------------------------------
001EBA  3               ; Can go down check.
001EBA  3               ;
001EBA  3               ; Input:
001EBA  3               ;  IX = sprite pointer
001EBA  3               ;
001EBA  3               ; Output:
001EBA  3               ;  A  = 0 is ok, A <>0 is not ok
001EBA  3               ;---------------------------------------------------------
001EBA  3               
001EBA  3               cangd:
001EBA  3  A0 09        	ldy #9
001EBC  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001EBE  3  85 rr        	sta dispx
001EC0  3  A0 08        	ldy #8
001EC2  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001EC4  3               numsp3:
001EC4  3  18           	clc
001EC5  3  69 10        	adc #16 		; look down 16 pixels.
001EC7  3  85 rr        	sta dispy		; coords in dispx,dispy.
001EC9  3  20 A1 20     	jsr tstbl 		; get map address.
001ECC  3  20 4C 1F     	jsr plchk 		; block, platform check.
001ECF  3  F0 01        	beq :+
001ED1  3  60           	rts			; no way through.
001ED2  3               :
001ED2  3  E6 rr        	inc bufaddr		; look right one cell.
001ED4  3  D0 02        	bne :+
001ED6  3  E6 rr        	inc bufaddr+1
001ED8  3               :
001ED8  3  20 4C 1F     	jsr plchk		; block, platform check.
001EDB  3  F0 01        	beq :+
001EDD  3  60           	rts			; impassable.
001EDE  3               :
001EDE  3  A5 rr        	lda dispx		; x coordinate.
001EE0  3  29 07        	and #7			; position straddling block cells.
001EE2  3  D0 01        	bne :+
001EE4  3  60           	rts			; no more checks needed.
001EE5  3               :
001EE5  3  E6 rr        	inc bufaddr		; look to third cell.
001EE7  3  D0 02        	bne :+
001EE9  3  E6 rr        	inc bufaddr+1
001EEB  3               :
001EEB  3  20 4C 1F     	jsr plchk		; block, platform check.
001EEE  3  60           	rts			; return with zero flag set accordingly.
001EEF  3               
001EEF  3               ;---------------------------------------------------------
001EEF  3               ; Can go left check.
001EEF  3               ;
001EEF  3               ; Input:
001EEF  3               ;  IX = sprite pointer
001EEF  3               ;
001EEF  3               ; Output:
001EEF  3               ;  A  = 0 is ok, A <>0 is not ok
001EEF  3               ;---------------------------------------------------------
001EEF  3               
001EEF  3               cangl:
001EEF  3  A0 08        	ldy #8
001EF1  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001EF3  3  85 rr        	sta dispy
001EF5  3  A0 09        	ldy #9
001EF7  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001EF9  3  38           	sec
001EFA  3  E9 02        	sbc #2			; look left 2 pixels.
001EFC  3  85 rr        	sta dispx		; coords in dispx,dispy.
001EFE  3  4C 10 1F     	jmp cangh		; test if we can go there.
001F01  3               
001F01  3               ;---------------------------------------------------------
001F01  3               ; Can go right check.
001F01  3               ;
001F01  3               ; Input:
001F01  3               ;  IX = sprite pointer
001F01  3               ;
001F01  3               ; Output:
001F01  3               ;  A  = 0 is ok, A <>0 is not ok
001F01  3               ;---------------------------------------------------------
001F01  3               
001F01  3               cangr:
001F01  3  A0 08        	ldy #8
001F03  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001F05  3  85 rr        	sta dispy
001F07  3  A0 09        	ldy #9
001F09  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001F0B  3  18           	clc
001F0C  3  69 10        	adc #16			; look right 16 pixels.
001F0E  3  85 rr        	sta dispx		; coords in dispx,dispy.
001F10  3               cangh:
001F10  3               cangh2:
001F10  3  A9 03        	lda #3			; default rows to write.
001F12  3  85 rr        	sta z80_b
001F14  3  A5 rr        	lda dispy		; y position.
001F16  3  29 07        	and #7			; does x straddle cells?
001F18  3  D0 02        	bne cangh0		; yes, loop counter is good.
001F1A  3  C6 rr        	dec z80_b		; one less row to write.
001F1C  3               cangh0:
001F1C  3  20 A1 20     	jsr tstbl		; get map address.
001F1F  3               cangh1:
001F1F  3  20 37 1F     	jsr lrchk		; standard left/right check.
001F22  3  F0 01        	beq :+
001F24  3  60           	rts			; no way through.
001F25  3               :
001F25  3  48           	pha
001F26  3  18           	clc
001F27  3  A5 rr        	lda bufaddr
001F29  3  69 20        	adc #32			; look down.
001F2B  3  85 rr        	sta bufaddr
001F2D  3  90 02        	bcc :+
001F2F  3  E6 rr        	inc bufaddr+1
001F31  3               :
001F31  3  68           	pla
001F32  3               
001F32  3  C6 rr        	dec z80_b
001F34  3  D0 E9        	bne cangh1
001F36  3  60           	rts
001F37  3               
001F37  3               ;-------------------------------------
001F37  3               ; Check left/right movement is okay.
001F37  3               ;
001F37  3               ; Input:
001F37  3               ;  bufaddr = MAP + x/8 + y/8*32
001F37  3               ;
001F37  3               ; Output:
001F37  3               ;  A  = 0 is ok, A <>0 is not ok
001F37  3               ;-------------------------------------
001F37  3               
001F37  3               lrchk:
001F37  3  A0 00        	ldy #0
001F39  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
001F3B  3  C9 02        	cmp #WALL 		; is it passable?
001F3D  3  F0 0A        	beq lrchkx		; no.
001F3F  3               
001F3F  3  C9 04        	cmp #FODDER		; fodder has to be dug.
001F41  3  F0 06        	beq lrchkx		; not passable.
001F43  3  A9 00        	lda #0
001F45  3  60           	rts
001F46  3               
001F46  3               ;--------------------------------------------------------------
001F46  3               ; Called by mmenu
001F46  3               ;--------------------------------------------------------------
001F46  3               
001F46  3               always:
001F46  3  A9 FF        	lda #255		; report it as okay.
001F48  3  60           	rts
001F49  3               
001F49  3               lrchkx:
001F49  3  A9 01        	lda #1 			; reset all bits.
001F4B  3  60           	rts
001F4C  3               
001F4C  3               
001F4C  3               ;--------------------------------------------------------------
001F4C  3               ; Check platform or solid item is not in way.
001F4C  3               ;
001F4C  3               ; Input:
001F4C  3               ;  bufaddr = MAP + x/8 + y/8*32
001F4C  3               ;
001F4C  3               ; Output:
001F4C  3               ;  A  = 0 is ok, A <>0 is not ok
001F4C  3               ;--------------------------------------------------------------
001F4C  3               
001F4C  3               plchk:
001F4C  3  A0 00        	ldy #0
001F4E  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
001F50  3  C9 02        	cmp #WALL 		; is it passable?
001F52  3  F0 F5        	beq lrchkx		; no.
001F54  3               
001F54  3  C9 04        	cmp #FODDER		; fodder has to be dug.
001F56  3  F0 F1        	beq lrchkx		; not passable.
001F58  3               
001F58  3  C9 01        	cmp #PLATFM		; platform is solid.
001F5A  3  F0 07        	beq plchkx		; not passable.
001F5C  3               
001F5C  3  C9 03        	cmp #LADDER		; is it a ladder?
001F5E  3  F0 E9        	beq lrchkx		; on ladder, deny movement.
001F60  3               plchk0:
001F60  3  A9 00        	lda #0			; report as ok
001F62  3  60           	rts
001F63  3               plchkx:
001F63  3  A5 rr        	lda dispy		; x coordinate.
001F65  3  29 07        	and #7			; position straddling blocks.
001F67  3  F0 E0        	beq lrchkx		; on platform, deny movement.
001F69  3  4C 60 1F     	jmp plchk0
001F6C  3               
001F6C  3               ;--------------------------------------------------------------
001F6C  3               ; Check ladder is available.
001F6C  3               ;
001F6C  3               ; Input:
001F6C  3               ;  bufaddr = MAP + x/8 + y/8*32
001F6C  3               ;
001F6C  3               ; Output:
001F6C  3               ;  A  = 0 is ok, A <>0 is not ok
001F6C  3               ;--------------------------------------------------------------
001F6C  3               
001F6C  3               ldchk:
001F6C  3  A0 00        	ldy #0
001F6E  3  B1 rr        	lda (bufaddr),y 	; fetch cell.
001F70  3  C9 03        	cmp #LADDER 		; is it a ladder?
001F72  3  F0 03        	beq :+
001F74  3  A9 01        	lda #1
001F76  3  60           	rts  			; return with zero flag set accordingly.
001F77  3               :
001F77  3  A9 00        	lda #0
001F79  3  60           	rts
001F7A  3               
001F7A  3               ;--------------------------------------------------------------
001F7A  3               ; Get collectables.
001F7A  3               ;--------------------------------------------------------------
001F7A  3               
001F7A  3               getcol:
001F7A  3  A9 08            lda #COLECT             ; collectable blocks.
001F7C  3  85 rr            sta z80_b
001F7E  3  20 E6 1F         jsr tded                ; test for collectable blocks.
001F81  3  C5 rr            cmp z80_b               ; did we find one?
001F83  3  F0 01            beq :+
001F85  3  60               rts                     ; none were found, job done.
001F86  3               :
001F86  3  20 8F 1F         jsr gtblk               ; get block.
001F89  3               
001F89  3  20 57 2D         jsr evnt20              ; collected block event.
001F8C  3  4C 7A 1F         jmp getcol              ; repeat until none left.
001F8F  3               
001F8F  3               ; Get collectable block.
001F8F  3               
001F8F  3               gtblk:
001F8F  3  A0 00        	ldy #0
001F91  3  B1 rr        	lda (bufaddr),y
001F93  3  85 rr        	sta z80_a
001F95  3  A9 00                lda #0
001F97  3  91 rr                sta (bufaddr),y		; make it empty now.
001F99  3               
001F99  3  A5 rr        	lda bufaddr		; set dispx
001F9B  3  29 1F        	and #31
001F9D  3  85 rr        	sta dispx
001F9F  3               
001F9F  3  A5 rr        	lda bufaddr+1		; Set dispy
001FA1  3  38           	sec
001FA2  3  E9 03        	sbc #>MAP
001FA4  3  85 rr        	sta bufaddr+1
001FA6  3  06 rr        	asl bufaddr
001FA8  3  26 rr        	rol bufaddr+1
001FAA  3  06 rr        	asl bufaddr
001FAC  3  26 rr        	rol bufaddr+1
001FAE  3  06 rr        	asl bufaddr
001FB0  3  26 rr        	rol bufaddr+1
001FB2  3  A5 rr        	lda bufaddr+1
001FB4  3  85 rr        	sta dispy
001FB6  3               
001FB6  3  A5 rr        	lda colpatt		; get blocknr
001FB8  3  85 rr        	sta z80_e		; displacement in e.
001FBA  3  A9 00        	lda #0
001FBC  3  85 rr        	sta z80_d		; no high byte.
001FBE  3  06 rr        	asl z80_e  		; multiply char by 8.
001FC0  3  26 rr        	rol z80_d
001FC2  3  06 rr        	asl z80_e
001FC4  3  26 rr        	rol z80_d
001FC6  3  06 rr        	asl z80_e
001FC8  3  26 rr        	rol z80_d
001FCA  3  18           	clc
001FCB  3  A5 rr        	lda z80_e
001FCD  3  69 1A        	adc #<chgfx 		; address of graphics.
001FCF  3  85 rr        	sta tileaddr
001FD1  3  A5 rr        	lda z80_d
001FD3  3  69 2E        	adc #>chgfx
001FD5  3  85 rr        	sta tileaddr+1
001FD7  3  20 ED 1C     	jsr gprad 		; get screen address.
001FDA  3  A0 07        	ldy #7			; number of pixel rows to write.
001FDC  3               gtblk0:
001FDC  3  B1 rr        	lda (tileaddr),y 	; get image byte.
001FDE  3  51 rr        	eor (scraddr),y 	; XOR tile on screen
001FE0  3  91 rr        	sta (scraddr),y 	; copy to screen.
001FE2  3  88           	dey	 		; repeat for 8 pixel rows.
001FE3  3  10 F7        	bpl gtblk0
001FE5  3  60           	rts
001FE6  3               
001FE6  3               ;--------------------------------------------------------------
001FE6  3               ; Touched deadly block check.
001FE6  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
001FE6  3               ;
001FE6  3               ; Input:
001FE6  3               ;  IX = sprite address
001FE6  3               ;
001FE6  3               ; Output:
001FE6  3               ;  A  = 0 is ok, A=5 is not ok
001FE6  3               ;--------------------------------------------------------------
001FE6  3               
001FE6  3               tded:
001FE6  3  A0 08        	ldy #8
001FE8  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001FEA  3  85 rr        	sta dispy
001FEC  3  C8           	iny
001FED  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001FEF  3  85 rr        	sta dispx		; coords in dispx,dispy.
001FF1  3  20 A1 20     	jsr tstbl		; get map address.
001FF4  3  48           	pha
001FF5  3  A9 1F        	lda #31			; default distance to next line down.
001FF7  3  85 rr        	sta z80_e
001FF9  3  68           	pla
001FFA  3  C5 rr        	cmp z80_b		; is this the required block?
001FFC  3  D0 01        	bne :+
001FFE  3  60           	rts			; yes.
001FFF  3               :
001FFF  3  E6 rr        	inc bufaddr 		; next cell.
002001  3  D0 02        	bne :+
002003  3  E6 rr        	inc bufaddr+1
002005  3               :
002005  3  A0 00        	ldy #0
002007  3  B1 rr        	lda (bufaddr),y		; fetch type.
002009  3  C5 rr        	cmp z80_b 		; is this deadly/custom?
00200B  3  D0 01        	bne :+
00200D  3  60           	rts			; yes.
00200E  3               :
00200E  3  A5 rr        	lda dispx		; horizontal position.
002010  3  85 rr        	sta z80_c 		; store column in c register.
002012  3  29 07        	and #7			; is it straddling cells?
002014  3  D0 03        	bne :+
002016  3  4C 2A 20     	jmp tded0		; no.
002019  3               :
002019  3  E6 rr        	inc bufaddr 		; last cell.
00201B  3  D0 02        	bne :+
00201D  3  E6 rr        	inc bufaddr+1
00201F  3               :
00201F  3  A0 00        	ldy #0
002021  3  B1 rr        	lda (bufaddr),y 	; fetch type.
002023  3  C5 rr        	cmp z80_b		; is this the block?
002025  3  D0 01        	bne :+
002027  3  60           	rts			; yes.
002028  3               :
002028  3  C6 rr        	dec z80_e		; one less cell to next row down.
00202A  3               tded0:
00202A  3  18           	clc 			; point to next row.
00202B  3  A5 rr        	lda bufaddr
00202D  3  65 rr        	adc z80_e
00202F  3  85 rr        	sta bufaddr
002031  3  90 02        	bcc :+
002033  3  E6 rr        	inc bufaddr+1
002035  3               :
002035  3  A0 00        	ldy #0
002037  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
002039  3  C5 rr        	cmp z80_b		; is this fatal?
00203B  3  D0 01        	bne :+
00203D  3  60           	rts			; yes.
00203E  3               :
00203E  3  E6 rr        	inc bufaddr 		; next cell.
002040  3  D0 02        	bne :+
002042  3  E6 rr        	inc bufaddr+1
002044  3               :
002044  3  A0 00        	ldy #0
002046  3  B1 rr        	lda (bufaddr),y 	; fetch type.
002048  3  C5 rr        	cmp z80_b		; is this fatal?
00204A  3  D0 01        	bne :+
00204C  3  60           	rts			; yes.
00204D  3               :
00204D  3  A5 rr        	lda z80_c		; horizontal position.
00204F  3  29 07        	and #7			; is it straddling cells?
002051  3  D0 03        	bne :+
002053  3  4C 65 20     	jmp tded1 		; no.
002056  3               :
002056  3  E6 rr        	inc bufaddr		; last cell.
002058  3  D0 02        	bne :+
00205A  3  E6 rr        	inc bufaddr+1
00205C  3               :
00205C  3  A0 00        	ldy #0
00205E  3  B1 rr        	lda (bufaddr),y		; fetch type.
002060  3  C5 rr        	cmp z80_b		; is this fatal?
002062  3  D0 01        	bne :+
002064  3  60           	rts			; yes.
002065  3               :
002065  3               tded1:
002065  3  A5 rr        	lda dispy		; vertical position.
002067  3  29 07        	and #7 			; is it straddling cells?
002069  3  D0 01        	bne :+
00206B  3  60           	rts			; no, job done.
00206C  3               :
00206C  3  18           	clc			; point to next row.
00206D  3  A5 rr        	lda bufaddr
00206F  3  65 rr        	adc z80_e
002071  3  85 rr        	sta bufaddr
002073  3  90 02        	bcc :+
002075  3  E6 rr        	inc bufaddr+1
002077  3               :
002077  3  A0 00        	ldy #0
002079  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
00207B  3  C5 rr        	cmp z80_b		; is this fatal?
00207D  3  D0 01        	bne :+
00207F  3  60           	rts			; yes.
002080  3               :
002080  3  E6 rr        	inc bufaddr		; next cell.
002082  3  D0 02        	bne :+
002084  3  E6 rr        	inc bufaddr+1
002086  3               :
002086  3  A0 00        	ldy #0
002088  3  B1 rr        	lda (bufaddr),y 	; fetch type.
00208A  3  C5 rr        	cmp z80_b		; is this fatal?
00208C  3  D0 01        	bne :+
00208E  3  60           	rts			; yes.
00208F  3               :
00208F  3  A5 rr        	lda z80_c		; horizontal position.
002091  3  29 07        	and #7			; is it straddling cells?
002093  3  D0 01        	bne :+
002095  3  60           	rts			; no.
002096  3               :
002096  3  E6 rr        	inc bufaddr		; last cell.
002098  3  D0 02        	bne :+
00209A  3  E6 rr        	inc bufaddr+1
00209C  3               :
00209C  3  A0 00        	ldy #0
00209E  3  B1 rr        	lda (bufaddr),y		; fetch final type.
0020A0  3  60           	rts 			; return with final type in accumulator.
0020A1  3               
0020A1  3               ;---------------------------------------------------
0020A1  3               ; Fetch block type at (dispx, dispy).
0020A1  3               ;
0020A1  3               ; Output:
0020A1  3               ;  A = block type
0020A1  3               ;---------------------------------------------------
0020A1  3               
0020A1  3               tstbl:
0020A1  3  A5 rr        	lda dispy 		; fetch y coord.
0020A3  3  4A           	lsr a			; bufaddr = y/8
0020A4  3  4A           	lsr a
0020A5  3  4A           	lsr a
0020A6  3  85 rr        	sta bufaddr
0020A8  3  A9 00        	lda #0
0020AA  3  85 rr        	sta bufaddr+1
0020AC  3               
0020AC  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
0020AE  3  26 rr        	rol bufaddr+1
0020B0  3  06 rr        	asl bufaddr
0020B2  3  26 rr        	rol bufaddr+1
0020B4  3  06 rr        	asl bufaddr
0020B6  3  26 rr        	rol bufaddr+1
0020B8  3  06 rr        	asl bufaddr
0020BA  3  26 rr        	rol bufaddr+1
0020BC  3  06 rr        	asl bufaddr
0020BE  3  26 rr        	rol bufaddr+1
0020C0  3               
0020C0  3  A5 rr        	lda dispx		; x/8
0020C2  3  4A           	lsr a
0020C3  3  4A           	lsr a
0020C4  3  4A           	lsr a
0020C5  3               
0020C5  3  18           	clc			; bufaddr = MAP + x/8 + y/8*32
0020C6  3  65 rr        	adc bufaddr
0020C8  3  69 00        	adc #<MAP
0020CA  3  85 rr        	sta bufaddr
0020CC  3  A5 rr        	lda bufaddr+1
0020CE  3  69 03        	adc #>MAP
0020D0  3  85 rr        	sta bufaddr+1
0020D2  3               
0020D2  3  A0 00        	ldy #0
0020D4  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
0020D6  3  60           	rts
0020D7  3               
0020D7  3               ;-------------------------------------------------------------------
0020D7  3               ; Jump - if we can.
0020D7  3               ; Requires initial speed to be set up in accumulator prior to call.
0020D7  3               ;
0020D7  3               ; Input:
0020D7  3               ;  IX = sprite address
0020D7  3               ;-------------------------------------------------------------------
0020D7  3               
0020D7  3               jump:
0020D7  3  A0 0D        	ldy #var_jumpLo
0020D9  3  B1 rr        	lda (z80_ix),y		; jump table low.
0020DB  3  A0 0E        	ldy #var_jumpHi
0020DD  3  11 rr        	ora (z80_ix),y		; jump table high.
0020DF  3  F0 01        	beq :+
0020E1  3  60           	rts			; already in the air.
0020E2  3               :
0020E2  3  A9 21        	lda #>jtab
0020E4  3  A0 0E        	ldy #var_jumpHi
0020E6  3  91 rr        	sta (z80_ix),y		; set jump high.
0020E8  3  A9 00        	lda #<jtab		; jump table start.
0020EA  3  A0 0D        	ldy #var_jumpLo
0020EC  3  91 rr        	sta (z80_ix),y		; set jump low.
0020EE  3  60           	rts
0020EF  3               
0020EF  3               ; Jump table.
0020EF  3  xx xx xx xx  .align 32
0020F3  3  xx xx xx xx  
0020F7  3  xx xx xx xx  
002100  3               jtab:
002100  3  F8 FA FC     	.byte 248,250,252
002103  3  FE FE FF     	.byte 254,254,255
002106  3  FF FF 00 00  	.byte 255,255,0,0
00210A  3  00 01 01 01  	.byte 0,1,1,1,2,2
00210E  3  02 02        
002110  3  04 06 08 08  	.byte 4,6,8,8,8,99
002114  3  08 63        
002116  3               .align 1
002116  3               
002116  3               ;------------------------------------------------
002116  3               ; Random numbers code.
002116  3               ; Pseudo-random number generator, 8-bit.
002116  3               ;
002116  3               ; Output:
002116  3               ;  RND = random number
002116  3               ;------------------------------------------------
002116  3               
002116  3               random:
002116  3  A5 rr        	lda seed		; get last random number.
002118  3  0A           	asl a
002119  3  0A           	asl a
00211A  3  18           	clc
00211B  3  65 rr        	adc seed
00211D  3  18           	clc
00211E  3  69 45        	adc #$45
002120  3  85 rr        	sta seed		; store new seed.
002122  3  85 rr        	sta varrnd		; return number in variable.
002124  3  60           	rts
002125  3               
002125  3               ;-------------------------------------------------------
002125  3               ; Joystick and keyboard reading routines.
002125  3               ;
002125  3               ; contrl = 0, Keyboard
002125  3               ;          1, JoyKeyb
002125  3               ;          2, JoyMMC
002125  3               ;-------------------------------------------------------
002125  3               
002125  3               joykey:
002125  3  A5 rr        	lda contrl 		; control flag.
002127  3  C9 01        	cmp #1
002129  3  D0 03        	bne :+
00212B  3  4C 49 21     	jmp joyjoy 		; read keyboard joystick
00212E  3               :
00212E  3  C9 02        	cmp #2
002130  3  D0 03        	bne :+
002132  3  4C F6 0E     	jmp joysin 		; read MMC joystick.
002135  3               :
002135  3               ; Keyboard controls.
002135  3               
002135  3  A9 00        	lda #0		 	; zero reading.
002137  3  85 rr        	sta z80_e
002139  3               
002139  3  A0 06        	ldy #6	 		; address of last key.
00213B  3               joyke0:
00213B  3  B9 3E 34     	lda keys,y 		; get key from table.
00213E  3  20 CC 0E     	jsr ktest		; being pressed?
002141  3  26 rr        	rol z80_e 		; rotate into reading.
002143  3               
002143  3  88           	dey		 	; next key.
002144  3  10 F5        	bpl joyke0 		; repeat for all keys.
002146  3  4C 5A 21     	jmp joyjo1 		; store the value.
002149  3               
002149  3               ; Keyboard joystick controls.
002149  3               
002149  3               joyjoy:
002149  3  A9 00        	lda #0		 	; zero reading.
00214B  3  85 rr        	sta z80_e
00214D  3               
00214D  3  A0 06        	ldy #6	 		; address of last key.
00214F  3               joyjo3:
00214F  3  B9 62 0E     	lda jkeys,y 		; get key from table.
002152  3  20 CC 0E     	jsr ktest		; being pressed?
002155  3  26 rr        	rol z80_e 		; rotate into reading.
002157  3               
002157  3  88           	dey		 	; next key.
002158  3  10 F5        	bpl joyjo3 		; repeat for all keys.
00215A  3               joyjo1:
00215A  3  A5 rr        	lda z80_e 		; copy e register to accumulator.
00215C  3               joyjo2:
00215C  3  85 rr        	sta joyval		; remember value.
00215E  3  60           	rts
00215F  3               
00215F  3               ;---------------------------------------------------------------
00215F  3               ; Display message.
00215F  3               ;
00215F  3               ; Input:
00215F  3               ;  A = message number
00215F  3               ;---------------------------------------------------------------
00215F  3               
00215F  3               dmsg:
00215F  3  AA           	tax
002160  3  A9 59        	lda #<msgdat		; pointer to messages.
002162  3  85 rr        	sta z80_l
002164  3  A9 2D        	lda #>msgdat
002166  3  85 rr        	sta z80_h
002168  3  20 7E 22     	jsr getwrd		; get message number.
00216B  3               dmsg3:
00216B  3  20 6B 22     	jsr preprt		; pre-printing stuff.
00216E  3  20 AF 1B     	jsr checkx		; make sure we"re in a printable range.
002171  3  A5 rr        	lda prtmod		; print mode.
002173  3  D0 47        	bne bmsg1		; no, double-height text.
002175  3               dmsg0:
002175  3  A5 rr        	lda z80_h		; store string pointer.
002177  3  48           	pha
002178  3  A5 rr        	lda z80_l
00217A  3  48           	pha
00217B  3               
00217B  3  A0 00        	ldy #0
00217D  3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
00217F  3  29 7F        	and #127		; remove any end marker.
002181  3  C9 0D        	cmp #ASCII_NEWLINE
002183  3  F0 24        	beq dmsg1
002185  3  20 D8 10     	jsr pchar		; display character.
002188  3  20 56 22     	jsr nexpos 		; display position.
00218B  3  D0 03        	bne dmsg2		; not on a new line.
00218D  3  20 5D 22     	jsr nexlin		; next line down.
002190  3               dmsg2:
002190  3  68           	pla			; retrieve string pointer
002191  3  85 rr        	sta z80_l
002193  3  68           	pla
002194  3  85 rr        	sta z80_h
002196  3               
002196  3  A0 00        	ldy #0
002198  3  B1 rr        	lda (z80_hl),y		; fetch last character.
00219A  3  0A           	asl a  			; was it the end?
00219B  3  90 03        	bcc :+
00219D  3  4C F4 1B     	jmp dscor2		; yes, job done.
0021A0  3               :
0021A0  3  E6 rr        	inc z80_l		; next character to display.
0021A2  3  D0 02        	bne :+
0021A4  3  E6 rr        	inc z80_h
0021A6  3               :
0021A6  3  4C 75 21     	jmp dmsg0
0021A9  3               dmsg1:
0021A9  3  E6 rr        	inc dispy
0021AB  3  A5 rr        	lda dispy
0021AD  3  C9 18        	cmp #24
0021AF  3  90 04        	bcc dmsg4
0021B1  3  A9 00        	lda #0
0021B3  3  85 rr        	sta dispy
0021B5  3               dmsg4:
0021B5  3  A9 00        	lda #0
0021B7  3  85 rr        	sta dispx
0021B9  3  4C 90 21     	jmp dmsg2
0021BC  3               
0021BC  3               ;----------------------------------------------------------
0021BC  3               ; Display message in big text.
0021BC  3               ;
0021BC  3               ; Input:
0021BC  3               ;  HL = string pointer
0021BC  3               ;----------------------------------------------------------
0021BC  3               
0021BC  3               bmsg1:
0021BC  3  A0 00        	ldy #0
0021BE  3  B1 rr        	lda (z80_hl),y 		; get character to display.
0021C0  3  29 7F        	and #127		; only want 7 bits.
0021C2  3  C9 0D        	cmp #ASCII_NEWLINE
0021C4  3  F0 13        	beq bmsg2
0021C6  3  20 EE 21     	jsr bchar 		; display big char.
0021C9  3               bmsg3:
0021C9  3  A0 00        	ldy #0
0021CB  3  B1 rr        	lda (z80_hl),y 		; look at last character.
0021CD  3  48           	pha
0021CE  3  E6 rr        	inc z80_l 		; next character in list.
0021D0  3  D0 02        	bne :+
0021D2  3  E6 rr        	inc z80_h
0021D4  3               :
0021D4  3  68           	pla
0021D5  3  0A           	asl a  			; was terminator flag set?
0021D6  3  90 E4        	bcc bmsg1		; no, keep going.
0021D8  3               :
0021D8  3  60           	rts
0021D9  3               bmsg2:
0021D9  3  A9 00        	lda #0
0021DB  3  85 rr        	sta dispx
0021DD  3  E6 rr        	inc dispy
0021DF  3  E6 rr        	inc dispy
0021E1  3  A5 rr        	lda dispy
0021E3  3  C9 17        	cmp #23
0021E5  3  90 E2        	bcc bmsg3
0021E7  3  A9 00        	lda #0
0021E9  3  85 rr        	sta dispy
0021EB  3  4C C9 21     	jmp bmsg3
0021EE  3               
0021EE  3               ;----------------------------------------------------------
0021EE  3               ; Big character display.
0021EE  3               ;
0021EE  3               ; Input:
0021EE  3               ;  A = character
0021EE  3               ;----------------------------------------------------------
0021EE  3               
0021EE  3               bchar:
0021EE  3  85 rr        	sta z80_e		; save char in lb
0021F0  3  A9 00        	lda #0
0021F2  3  85 rr        	sta z80_d		; reset hb
0021F4  3               
0021F4  3  06 rr        	asl z80_e 		; multiply char by 8.
0021F6  3  26 rr        	rol z80_d
0021F8  3  06 rr        	asl z80_e
0021FA  3  26 rr        	rol z80_d
0021FC  3  06 rr        	asl z80_e
0021FE  3  26 rr        	rol z80_d		; de = a*8
002200  3               
002200  3  18           	clc			; de = FontPtr + a*8
002201  3  A5 rr        	lda z80_e
002203  3  65 rr        	adc FontPtr 		; address of font.
002205  3  85 rr        	sta z80_e
002207  3  A5 rr        	lda z80_d
002209  3  65 rr        	adc FontPtr+1
00220B  3  85 rr        	sta z80_d
00220D  3               
00220D  3  20 ED 1C     	jsr gprad 		; get screen address.
002210  3               
002210  3  A2 00        	ldx #0			; height of character in font.
002212  3               bchar0:
002212  3  A0 00        	ldy #0
002214  3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
002216  3               
002216  3  49 00        	eor #TxtInvert		; Invert
002218  3               
002218  3  91 rr        	sta (scraddr),y
00221A  3  48           	pha
00221B  3  20 49 10     	jsr nline 		; next line down.
00221E  3  68           	pla
00221F  3  91 rr        	sta (scraddr),y
002221  3  20 49 10     	jsr nline 		; next line down.
002224  3               
002224  3  18           	clc
002225  3  E6 rr        	inc z80_e 		; next line of font.
002227  3  D0 02        	bne :+
002229  3  E6 rr        	inc z80_d
00222B  3               :
00222B  3  E8           	inx
00222C  3  E0 08        	cpx #8
00222E  3  D0 E2        	bne bchar0
002230  3               
002230  3  20 56 22     	jsr nexpos		; display position.
002233  3  D0 05        	bne bchar2 		; not on a new line.
002235  3               bchar3:
002235  3  E6 rr        	inc dispy
002237  3  20 5D 22     	jsr nexlin 		; next line check.
00223A  3               bchar2:
00223A  3  4C F4 1B     	jmp dscor2		; tidy up line and column variables.
00223D  3               
00223D  3               
00223D  3               ;-------------------------------------------------
00223D  3               ; Display a character.
00223D  3               ;
00223D  3               ; Input:
00223D  3               ;  A = character
00223D  3               ;-------------------------------------------------
00223D  3               
00223D  3               achar:
00223D  3  85 rr        	sta z80_b 		; copy to b.
00223F  3  20 6B 22     	jsr preprt 		; get ready to print.
002242  3  A5 rr        	lda z80_b		; character in accumulator.
002244  3  A6 rr        	ldx prtmod 		; print mode.
002246  3  F0 03        	beq :+
002248  3  4C EE 21     	jmp bchar 		; no, double-height text.
00224B  3               :
00224B  3  20 D8 10     	jsr pchar 		; display character.
00224E  3  20 56 22     	jsr nexpos 		; display position.
002251  3  F0 E2        	beq bchar3		; next line down.
002253  3  4C 3A 22     	jmp bchar2 		; tidy up.
002256  3               
002256  3               
002256  3               ;-------------------------------------------------
002256  3               ; Get next print column position.
002256  3               ;-------------------------------------------------
002256  3               
002256  3               nexpos:
002256  3  E6 rr        	inc dispx		; move along one position.
002258  3  A5 rr        	lda dispx 		; get coordinate.
00225A  3  29 1F        	and #31
00225C  3  60           	rts 			; return with status in zero flag.
00225D  3               
00225D  3               ;-------------------------------------------------
00225D  3               ; Get next print line position.
00225D  3               ;-------------------------------------------------
00225D  3               
00225D  3               nexlin:
00225D  3  E6 rr        	inc dispy 		; newline.
00225F  3  A5 rr        	lda dispy		; vertical position.
002261  3  C9 18        	cmp #24			; past screen edge?
002263  3  B0 01        	bcs :+
002265  3  60           	rts			; no, still okay.
002266  3               :
002266  3  A9 00        	lda #0			; restart at top.
002268  3  85 rr        	sta dispy
00226A  3  60           	rts
00226B  3               
00226B  3               ;--------------------------------------------------------
00226B  3               ; Pre-print preliminaries.
00226B  3               ;--------------------------------------------------------
00226B  3               
00226B  3               preprt:
00226B  3  A5 rr        	lda FontPtr		; font pointer.
00226D  3  8D AD 1B     	sta grbase		; set up graphics base.
002270  3  A5 rr        	lda FontPtr+1
002272  3  8D AE 1B     	sta grbase+1
002275  3               prescr:
002275  3  A5 rr        	lda charx 		; display coordinates.
002277  3  85 rr        	sta dispx		; set up general coordinates.
002279  3  A5 rr        	lda chary
00227B  3  85 rr        	sta dispy
00227D  3  60           	rts
00227E  3               
00227E  3               ;--------------------------------------------------------------
00227E  3               ; Get messagenr x in hl
00227E  3               ;
00227E  3               ; Input:
00227E  3               ;  HL = pointer to message list
00227E  3               ;  X  = message number.
00227E  3               ;--------------------------------------------------------------
00227E  3               
00227E  3               getwrd:
00227E  3  E0 00        	cpx #0
002280  3  D0 01        	bne:+ 			; first word in list?
002282  3  60           	rts 			; yep, don't search.
002283  3               :
002283  3  A0 00        	ldy #0
002285  3               getwd0:
002285  3  B1 rr        	lda (z80_hl),y
002287  3  48           	pha
002288  3  E6 rr        	inc z80_l
00228A  3  D0 02        	bne :+
00228C  3  E6 rr        	inc z80_h
00228E  3               :
00228E  3  68           	pla
00228F  3  C9 80        	cmp #128		; found end?
002291  3  30 F2        	bmi getwd0		; no, carry on.
002293  3  CA           	dex			; until we have right number.
002294  3  D0 EF        	bne getwd0
002296  3  60           	rts
002297  3               
002297  3               ;-----------------------------------------------------------
002297  3               ; Bubble sort.
002297  3               ;-----------------------------------------------------------
002297  3               
002297  3               bsort:
002297  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
002299  3  85 rr        	sta qscnt
00229B  3               
00229B  3  A9 00        	lda #<sprtab 		; sprite table.
00229D  3  85 rr        	sta z80_x
00229F  3  A9 0B        	lda #>sprtab
0022A1  3  85 rr        	sta z80_i
0022A3  3               bsort0:
0022A3  3  A0 00        	ldy #0
0022A5  3  B1 rr        	lda (z80_ix),y 		; first sprite type.
0022A7  3  C9 FF        	cmp #255 		; is it switched off?
0022A9  3  F0 30        	beq swemp		; yes, may need to switch another in here.
0022AB  3               
0022AB  3  A0 11        	ldy #TABSIZ
0022AD  3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
0022AF  3  C9 FF        	cmp #255 		; is it enabled?
0022B1  3  F0 0A        	beq bsort2 		; no, nothing to swap.
0022B3  3               
0022B3  3  A0 14        	ldy #TABSIZ+3
0022B5  3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
0022B7  3  A0 03        	ldy #3
0022B9  3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
0022BB  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
0022BD  3               bsort2:
0022BD  3  18           	clc
0022BE  3  A5 rr        	lda z80_x
0022C0  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
0022C2  3  85 rr        	sta z80_x
0022C4  3  90 02        	bcc :+
0022C6  3  E6 rr        	inc z80_i
0022C8  3               :
0022C8  3  C6 rr        	dec qscnt
0022CA  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
0022CC  3  60           	rts
0022CD  3               
0022CD  3               bsort1:
0022CD  3  A0 11        	ldy #TABSIZ
0022CF  3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
0022D1  3  C9 FF        	cmp #255		; is it enabled?
0022D3  3  F0 E8        	beq bsort2		; no, nothing to swap.
0022D5  3  20 E9 22     	jsr swspr		; swap positions.
0022D8  3  4C BD 22     	jmp bsort2
0022DB  3               swemp:
0022DB  3  A0 11        	ldy #TABSIZ
0022DD  3  B1 rr        	lda (z80_ix),y		; next table entry.
0022DF  3  C9 FF        	cmp #255		; is that one on?
0022E1  3  F0 DA        	beq bsort2		; no, nothing to swap.
0022E3  3  20 E9 22     	jsr swspr		; swap positions.
0022E6  3  4C BD 22     	jmp bsort2
0022E9  3               
0022E9  3               ; Swap sprites.
0022E9  3               
0022E9  3               swspr:
0022E9  3  A5 rr        	lda z80_x		; table address
0022EB  3  85 rr        	sta z80_e		; copy to de pair.
0022ED  3  85 rr        	sta z80_l		; copy to hl pair.
0022EF  3  A5 rr        	lda z80_i
0022F1  3  85 rr        	sta z80_h
0022F3  3  85 rr        	sta z80_d
0022F5  3               
0022F5  3  18           	clc
0022F6  3  A5 rr        	lda z80_l
0022F8  3  69 11        	adc #TABSIZ		; distance to second entry.
0022FA  3  85 rr        	sta z80_l
0022FC  3  90 02        	bcc :+
0022FE  3  E6 rr        	inc z80_h
002300  3               :
002300  3  A9 11        	lda #TABSIZ		; bytes to swap.
002302  3  85 rr        	sta z80_b
002304  3  A0 00        	ldy #0
002306  3               swspr0:
002306  3  B1 rr        	lda (z80_hl),y		; fetch second byte.
002308  3  48           	pha
002309  3  B1 rr        	lda (z80_de),y 		; fetch first byte.
00230B  3  91 rr        	sta (z80_hl),y 		; copy to second.
00230D  3  68           	pla
00230E  3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
002310  3               
002310  3  E6 rr        	inc z80_e 		; next byte.
002312  3  D0 02        	bne :+
002314  3  E6 rr        	inc z80_d
002316  3               :
002316  3  E6 rr        	inc z80_l 		; next byte.
002318  3  D0 02        	bne :+
00231A  3  E6 rr        	inc z80_h
00231C  3               :
00231C  3  C6 rr        	dec z80_b
00231E  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
002320  3  60           	rts
002321  3               
002321  3               ;----------------------------------------------------
002321  3               ; Process sprites.
002321  3               ;----------------------------------------------------
002321  3               
002321  3               pspr:
002321  3  A9 0C        	lda #NUMSPR		; sprites to process.
002323  3  85 rr        	sta sprptr
002325  3               
002325  3  A9 00        	lda #<sprtab 		; sprite table.
002327  3  85 rr        	sta z80_x
002329  3  A9 0B        	lda #>sprtab
00232B  3  85 rr        	sta z80_i
00232D  3               pspr1:
00232D  3  A0 00        	ldy #0
00232F  3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
002331  3  C9 09        	cmp #9 			; within range of sprite types?
002333  3  B0 03        	bcs :+
002335  3  20 48 23     	jsr pspr2 		; yes, process this one.
002338  3               :
002338  3  18           	clc
002339  3  A5 rr        	lda z80_x
00233B  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
00233D  3  85 rr        	sta z80_x
00233F  3  90 02        	bcc :+
002341  3  E6 rr        	inc z80_i		; next sprite.
002343  3               :
002343  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
002345  3  D0 E6        	bne pspr1
002347  3  60           	rts
002348  3               
002348  3               pspr2:
002348  3  A5 rr        	lda z80_x 		; store original sprite pointer.
00234A  3  85 rr        	sta ogptr
00234C  3  A5 rr        	lda z80_i
00234E  3  85 rr        	sta ogptr+1
002350  3  20 5C 23     	jsr pspr3		; do the routine.
002353  3               rtorg:
002353  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
002355  3  85 rr        	sta z80_x
002357  3  A5 rr        	lda ogptr+1
002359  3  85 rr        	sta z80_i
00235B  3               rtorg0:
00235B  3  60           	rts
00235C  3               
00235C  3               pspr3:
00235C  3  A9 91        	lda #<evtyp0		; sprite type events list.
00235E  3  85 rr        	sta z80_l
002360  3  A9 23        	lda #>evtyp0
002362  3  85 rr        	sta z80_h
002364  3               pspr4:
002364  3  B1 rr        	lda (z80_ix),y
002366  3  0A           	asl a			; double accumulator.
002367  3  18           	clc
002368  3  65 rr        	adc z80_l
00236A  3  85 rr        	sta z80_l
00236C  3  90 02        	bcc :+
00236E  3  E6 rr        	inc z80_h
002370  3               :
002370  3  B1 rr        	lda (z80_hl),y
002372  3  85 rr        	sta z80_e 		; copy to de.
002374  3  48           	pha
002375  3               
002375  3  E6 rr        	inc z80_l 		; next byte of address.
002377  3  D0 02        	bne :+
002379  3  E6 rr        	inc z80_h
00237B  3               :
00237B  3  B1 rr        	lda (z80_hl),y 		; address high.
00237D  3  85 rr        	sta z80_d
00237F  3               
00237F  3  48           	pha	 		; swap address into hl.
002380  3  A5 rr        	lda z80_h
002382  3  85 rr        	sta z80_d
002384  3  68           	pla
002385  3  85 rr        	sta z80_h
002387  3  68           	pla
002388  3  85 rr        	sta z80_l
00238A  3  A5 rr        	lda z80_l
00238C  3  85 rr        	sta z80_e
00238E  3               
00238E  3  6C rr rr     	jmp (z80_hl) 		; go there.
002391  3               
002391  3               ; Address of each sprite type's routine.
002391  3               
002391  3  20 2A        evtyp0:	.word evnt00
002393  3  10 2B        evtyp1:	.word evnt01
002395  3  AA 2B        evtyp2:	.word evnt02
002397  3  AB 2B        evtyp3:	.word evnt03
002399  3  AC 2B        evtyp4:	.word evnt04
00239B  3  AD 2B        evtyp5:	.word evnt05
00239D  3  AE 2B        evtyp6:	.word evnt06
00239F  3  AF 2B        evtyp7:	.word evnt07
0023A1  3  B0 2B        evtyp8:	.word evnt08
0023A3  3               
0023A3  3               ;--------------------------------------------------------------
0023A3  3               ; Display sprites.
0023A3  3               ;
0023A3  3               ; Input:
0023A3  3               ;  IX = sprite table
0023A3  3               ;--------------------------------------------------------------
0023A3  3               
0023A3  3               dspr:
0023A3  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
0023A5  3  85 rr        	sta sprcnt
0023A7  3               
0023A7  3               dspr0:
0023A7  3  A0 00        	ldy #var_Type
0023A9  3  B1 rr        	lda (z80_ix),y 		; get sprite type.
0023AB  3  C9 FF        	cmp #255 			; is it enabled?
0023AD  3  D0 45        	bne dspr1 			; yes, it needs deleting.
0023AF  3               
0023AF  3               dspr5:
0023AF  3  A0 05        	ldy #var_newType
0023B1  3  B1 rr        	lda (z80_ix),y 		; new type.
0023B3  3  C9 FF        	cmp #255			; is it enabled?
0023B5  3  F0 03        	beq dspr2			; no, skip
0023B7  3  4C 43 24     	jmp dspr3 			; yes, it needs drawing.
0023BA  3               
0023BA  3               dspr2:
0023BA  3  A0 05        	ldy #var_newType
0023BC  3  B1 rr        	lda (z80_ix),y 		; copy new type.
0023BE  3  A0 00        	ldy #var_Type
0023C0  3  91 rr        	sta (z80_ix),y
0023C2  3  A0 06        	ldy #var_newImage
0023C4  3  B1 rr        	lda (z80_ix),y 		; copy new image number.
0023C6  3  A0 01        	ldy #var_Image
0023C8  3  91 rr        	sta (z80_ix),y
0023CA  3  A0 07        	ldy #var_newFrame
0023CC  3  B1 rr        	lda (z80_ix),y 		; copy new frame.
0023CE  3  A0 02        	ldy #var_Frame
0023D0  3  91 rr        	sta (z80_ix),y
0023D2  3  A0 08        	ldy #var_newY
0023D4  3  B1 rr        	lda (z80_ix),y 		; copy new y.
0023D6  3  A0 03        	ldy #var_Y
0023D8  3  91 rr        	sta (z80_ix),y
0023DA  3  A0 09        	ldy #var_newX
0023DC  3  B1 rr        	lda (z80_ix),y 		; copy new x.
0023DE  3  A0 04        	ldy #var_X
0023E0  3  91 rr        	sta (z80_ix),y
0023E2  3               
0023E2  3  18           	clc
0023E3  3  A5 rr        	lda z80_x
0023E5  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
0023E7  3  85 rr        	sta z80_x
0023E9  3  A5 rr        	lda z80_i
0023EB  3  69 00        	adc #0
0023ED  3  85 rr        	sta z80_i 			; next sprite.
0023EF  3  C6 rr        	dec sprcnt
0023F1  3  D0 B4        	bne dspr0			; repeat for remaining sprites.
0023F3  3  60           	rts
0023F4  3               
0023F4  3               dspr1:
0023F4  3               	; _BEEB clipping code copied from CPC Engine
0023F4  3  A0 03        	ldy #var_Y
0023F6  3  B1 rr        	lda (z80_ix), y		; old x coord
0023F8  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
0023FA  3  B0 B3        	bcs dspr5			; yes, don't delete it.
0023FC  3               
0023FC  3  A0 05        	ldy #var_newType
0023FE  3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
002400  3  C9 FF        	cmp #255			; is this enabled?
002402  3  D0 06        	bne dspr4 			; yes, display both.
002404  3               
002404  3               dspr6:
002404  3  20 D1 0F     	jsr sspria 			; show single sprite.
002407  3  4C BA 23     	jmp dspr2
00240A  3               
00240A  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
00240A  3               
00240A  3               dspr4:
00240A  3               	; _BEEB clipping code copied from CPC Engine
00240A  3  A0 08        	ldy #var_newY
00240C  3  B1 rr        	lda (z80_ix), y		; old x coord
00240E  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
002410  3  B0 F2        	bcs dspr6			; yes, don't display it.
002412  3               
002412  3  A0 04        	ldy #var_X
002414  3  B1 rr        	lda (z80_ix),y		; old x.
002416  3  A0 09        	ldy #var_newX
002418  3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
00241A  3  D0 21        	bne dspr7 			; they differ, need to redraw.
00241C  3               
00241C  3  A0 03        	ldy #var_Y
00241E  3  B1 rr        	lda (z80_ix),y		; old y.
002420  3  A0 08        	ldy #var_newY
002422  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002424  3  D0 17        	bne dspr7			; they differ, need to redraw.
002426  3               
002426  3  A0 02        	ldy #var_Frame
002428  3  B1 rr        	lda (z80_ix),y 		; old frame.
00242A  3  A0 07        	ldy #var_newFrame
00242C  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
00242E  3  D0 0D        	bne dspr7 			; they differ, need to redraw.
002430  3               
002430  3  A0 01        	ldy #var_Image
002432  3  B1 rr        	lda (z80_ix),y 		; old image.
002434  3  A0 06        	ldy #var_newImage
002436  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002438  3  D0 03        	bne dspr7 			; they differ, need to redraw.
00243A  3  4C BA 23     	jmp dspr2			; everything is the same, don't redraw.
00243D  3               
00243D  3               dspr7:
00243D  3  20 F4 0F     	jsr sspric 			; delete old sprite, draw new one simultaneously.
002440  3  4C BA 23     	jmp dspr2
002443  3               
002443  3               dspr3:
002443  3               	; _BEEB clipping code copied from CPC Engine
002443  3  A0 08        	ldy #var_newY
002445  3  B1 rr        	lda (z80_ix), y		; old x coord
002447  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
002449  3  90 03        	bcc :+				; no, continue
00244B  3  4C BA 23     	jmp dspr2			; yes, don't display it.
00244E  3               :
00244E  3  20 EE 0F     	jsr ssprib 			; show single sprite.
002451  3  4C BA 23     	jmp dspr2
002454  3               
002454  3               ;-----------------------------------------
002454  3               ; Get sprite address calculations.
002454  3               ; gspran = new sprite, gsprad = old sprite.
002454  3               ;
002454  3               ; Input:
002454  3               ;  IX = sprite address
002454  3               ;-----------------------------------------
002454  3               
002454  3               gspran:
002454  3  A0 08        	ldy #var_newY
002456  3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
002458  3  85 rr        	sta dispy
00245A  3  A0 09        	ldy #var_newX
00245C  3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
00245E  3  85 rr        	sta dispx
002460  3  A0 06        	ldy #var_newImage
002462  3  B1 rr        	lda (z80_ix),y 		; new sprite image.
002464  3  20 25 27     	jsr gfrm		; fetch start frame for this sprite.
002467  3               
002467  3  A0 00        	ldy #0
002469  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
00246B  3  A0 07        	ldy #var_newFrame
00246D  3  18           	clc
00246E  3  71 rr        	adc (z80_ix),y 		; new add frame number.
002470  3  4C 8F 24     	jmp gspra0
002473  3               
002473  3               ;-----------------------------------------
002473  3               ; Calculate old sprite address
002473  3               ;
002473  3               ; Input:
002473  3               ;  IX = sprite address
002473  3               ;
002473  3               ; Output:
002473  3               ;  B  = right byte mask
002473  3               ;  C  = left byte mask
002473  3               ;  DE = spriteframe address
002473  3               ;  scraddr = screenaddress(dispx,dispy)
002473  3               ;-----------------------------------------
002473  3               
002473  3               gsprad:
002473  3  A0 03        	ldy #var_Y
002475  3  B1 rr        	lda (z80_ix),y		; y coordinate.
002477  3  85 rr        	sta dispy
002479  3  A0 04        	ldy #var_X
00247B  3  B1 rr        	lda (z80_ix),y		; x coordinate.
00247D  3  85 rr        	sta dispx
00247F  3  A0 01        	ldy #var_Image
002481  3  B1 rr        	lda (z80_ix),y 		; sprite image.
002483  3  20 25 27     	jsr gfrm 		; fetch start frame for this sprite.
002486  3               
002486  3  A0 00        	ldy #0
002488  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
00248A  3  A0 02        	ldy #var_Frame
00248C  3  18           	clc
00248D  3  71 rr        	adc (z80_ix),y 		; add frame number.
00248F  3               
00248F  3               gspra0:
00248F  3  4A           	lsr a	  		; multiply by 128.
002490  3  85 rr        	sta z80_d 		; store in d.
002492  3  A9 00        	lda #0
002494  3  6A           	ror a
002495  3  85 rr        	sta z80_e 		; got low byte.
002497  3               
002497  3  18           	clc 			; address of play sprites.
002498  3  A5 rr        	lda z80_e
00249A  3  69 2C        	adc #<sprgfx
00249C  3  85 rr        	sta z80_e
00249E  3  A5 rr        	lda z80_d
0024A0  3  69 2E        	adc #>sprgfx
0024A2  3  85 rr        	sta z80_d
0024A4  3               
0024A4  3  A5 rr        	lda dispx 		; y coordinate.
0024A6  3  29 06        	and #6 			; position within byte boundary.
0024A8  3  AA           	tax	 		; low byte of table displacement.
0024A9  3               
0024A9  3  0A           	asl a	  		; multiply by 32.
0024AA  3  0A           	asl a  			; already a multiple
0024AB  3  0A           	asl a  			; of 2, so just 4
0024AC  3  0A           	asl a  			; shifts needed.
0024AD  3               
0024AD  3  18           	clc 			; add to sprite address.
0024AE  3  65 rr        	adc z80_e
0024B0  3  85 rr        	sta z80_e
0024B2  3  90 02        	bcc :+
0024B4  3  E6 rr        	inc z80_d
0024B6  3               :
0024B6  3  BD C3 24     	lda spmask,x		 ; pointer to mask table.
0024B9  3  85 rr        	sta z80_c 		; left mask.
0024BB  3  BD C4 24     	lda spmask+1,x
0024BE  3  85 rr        	sta z80_b 		; right mask.
0024C0  3               ; Drop into screen address routine.
0024C0  3  4C BD 0F     	jmp scadd
0024C3  3               
0024C3  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
0024C7  3  0F F0 03 FC  
0024CB  3               
0024CB  3               
0024CB  3               ;-----------------------------------------------------------
0024CB  3               ; Animates a sprite.
0024CB  3               ;
0024CB  3               ; Input:
0024CB  3               ;  IX = sprite address
0024CB  3               ;  HL = last sprite address
0024CB  3               ;-----------------------------------------------------------
0024CB  3               
0024CB  3               animsp:
0024CB  3  25 rr        	and frmno
0024CD  3  F0 01        	beq :+
0024CF  3  60           	rts
0024D0  3               :
0024D0  3  A0 06        	ldy #var_newImage
0024D2  3  B1 rr        	lda (z80_ix),y		; sprite image
0024D4  3  20 25 27     	jsr gfrm		; get frame data.
0024D7  3               
0024D7  3  E6 rr        	inc z80_l		; point to frames.
0024D9  3  D0 02        	bne :+
0024DB  3  E6 rr        	inc z80_h
0024DD  3               :
0024DD  3  A0 07        	ldy #var_newFrame
0024DF  3  B1 rr        	lda (z80_ix),y		; sprite frame.
0024E1  3  18           	clc
0024E2  3  69 01        	adc #1			; next one along.
0024E4  3  A0 00        	ldy #0
0024E6  3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
0024E8  3  90 02        	bcc anims0		; no, not yet.
0024EA  3  A9 00        	lda #0			; start at first frame.
0024EC  3               anims0:
0024EC  3  A0 07        	ldy #var_newFrame
0024EE  3  91 rr        	sta (z80_ix),y		; new frame.
0024F0  3  60           	rts
0024F1  3               
0024F1  3               ;--------------------------------------------------------------
0024F1  3               ; Animate back
0024F1  3               ;
0024F1  3               ; Input:
0024F1  3               ;  IX = sprite address
0024F1  3               ;  HL = last sprite address
0024F1  3               ;--------------------------------------------------------------
0024F1  3               
0024F1  3               animbk:
0024F1  3  25 rr        	and frmno
0024F3  3  F0 01        	beq :+
0024F5  3  60           	rts
0024F6  3               :
0024F6  3  A0 06        	ldy #var_newImage
0024F8  3  B1 rr        	lda (z80_ix),y		; sprite image.
0024FA  3  20 25 27     	jsr gfrm		; get frame data.
0024FD  3               
0024FD  3  E6 rr        	inc z80_l 		; point to frames.
0024FF  3  D0 02        	bne :+
002501  3  E6 rr        	inc z80_h
002503  3               :
002503  3  A0 07        	ldy #var_newFrame
002505  3  B1 rr        	lda (z80_ix),y 		; sprite frame.
002507  3  F0 03        	beq :+
002509  3  4C 10 25     	jmp rtanb0 		; yes, start at end.
00250C  3               :
00250C  3  A0 00        	ldy #0
00250E  3  B1 rr        	lda (z80_hl),y 		; last sprite.
002510  3               rtanb0:
002510  3  38           	sec
002511  3  E9 01        	sbc #1			; next one along.
002513  3  4C EC 24     	jmp anims0		; set new frame.
002516  3               
002516  3               ;--------------------------------------------------------------
002516  3               ; Check for collision with other sprite, strict enforcement.
002516  3               ;
002516  3               ; Input:
002516  3               ;  b		= sprite to test for
002516  3               ;  ix		= current sprite pointer
002516  3               ;
002516  3               ; global:	b
002516  3               ; local:	x,y,hl,de,skptr
002516  3               ; calls:	-
002516  3               ;--------------------------------------------------------------
002516  3               
002516  3               sktyp:
002516  3  A9 00        	lda #<sprtab				; sprite table.
002518  3  85 rr        	sta z80_l
00251A  3  A9 0B        	lda #>sprtab
00251C  3  85 rr        	sta z80_h
00251E  3               numsp2:
00251E  3  A9 0C        	lda #NUMSPR				; number of sprites.
002520  3  85 rr        	sta sktptr
002522  3               sktyp0:
002522  3  A5 rr        	lda z80_l 				; store pointer to sprite.
002524  3  85 rr        	sta skptr
002526  3  A5 rr        	lda z80_h
002528  3  85 rr        	sta skptr+1
00252A  3               
00252A  3  A0 00        	ldy #0
00252C  3  B1 rr        	lda (z80_hl),y 				; get sprite type.
00252E  3  C5 rr        	cmp z80_b				; is it the type we seek?
002530  3  F0 1D        	beq coltyp				; yes, we can use this one.
002532  3               :
002532  3               sktyp1:
002532  3  18           	clc
002533  3  A5 rr        	lda skptr				; retrieve sprite pointer.
002535  3  69 11        	adc #TABSIZ				; size of each entry.
002537  3  85 rr        	sta z80_l
002539  3  A5 rr        	lda skptr+1
00253B  3  69 00        	adc #0
00253D  3  85 rr        	sta z80_h
00253F  3  C6 rr        	dec sktptr					; one less iteration.
002541  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
002543  3               :
002543  3  A9 00        	lda #0					; default to ROM address - no sprite.
002545  3  85 rr        	sta z80_l
002547  3  85 rr        	sta z80_h
002549  3  85 rr        	sta skptr				; store pointer to sprite.
00254B  3  85 rr        	sta skptr+1
00254D  3               
00254D  3  18           	clc					; don't return with zero flag set.
00254E  3  60           	rts 					; didn't find one.
00254F  3               
00254F  3               coltyp:
00254F  3  A0 00        	ldy #0
002551  3  B1 rr        	lda (z80_ix),y				; current sprite type.
002553  3  C5 rr        	cmp z80_b				; seeking sprite of same type?
002555  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
002557  3               colty0:
002557  3  A0 09        	ldy #9					; distance to x position in table.
002559  3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
00255B  3  85 rr        	sta z80_e
00255D  3  88           	dey
00255E  3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
002560  3  85 rr        	sta z80_d
002562  3               
002562  3               ; Drop into collision detection.
002562  3               
002562  3               colc16:
002562  3  A0 09        	ldy #9
002564  3  B1 rr        	lda (z80_ix),y			 	; x coord.
002566  3  38           	sec					; subtract x.
002567  3  E5 rr        	sbc z80_e
002569  3  B0 05        	bcs  colc1a 				; result is positive.
00256B  3  49 FF        	eor #$ff				; make negative positive.
00256D  3  18           	clc
00256E  3  69 01        	adc #1
002570  3               colc1a:
002570  3  C9 10        	cmp #16 				; within x range?
002572  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
002574  3  85 rr        	sta z80_c				; store difference.
002576  3               
002576  3  A0 08        	ldy #8
002578  3  B1 rr        	lda (z80_ix),y				; y coord.
00257A  3  38           	sec
00257B  3  E5 rr        	sbc z80_d				; subtract y.
00257D  3  B0 05        	bcs colc1b				; result is positive.
00257F  3  49 FF        	eor #$ff				; make negative positive.
002581  3  18           	clc
002582  3  69 01        	adc #1
002584  3               colc1b:
002584  3  C9 10        	cmp #16					; within y range?
002586  3  B0 AA        	bcs sktyp1 				; no - they've missed.
002588  3  18           	clc					; add x difference.
002589  3  65 rr        	adc z80_c
00258B  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
00258D  3  B0 02        	bcs :+
00258F  3  38           	sec
002590  3  60           	rts 					; carry set if there's a collision.
002591  3               :
002591  3  4C 32 25     	jmp sktyp1				; try next sprite in table.
002594  3               colty1:
002594  3  A5 rr        	lda z80_x  				; compare the two.
002596  3  C5 rr        	cmp z80_l
002598  3  D0 09        	bne end_col
00259A  3  A5 rr        	lda z80_i
00259C  3  C5 rr        	cmp z80_h
00259E  3  D0 03        	bne end_col
0025A0  3  4C 32 25     	jmp sktyp1 				; addresses are identical.
0025A3  3               end_col:
0025A3  3  4C 57 25     	jmp colty0
0025A6  3               
0025A6  3               ;-----------------------------------------------------------
0025A6  3               ; Display number, left aligned
0025A6  3               ;
0025A6  3               ; Input:
0025A6  3               ;  a		= number
0025A6  3               ;
0025A6  3               ; global:	-
0025A6  3               ; local:	a,y,bc,hl,displ0
0025A6  3               ; calls:	num2ch,dmsg3
0025A6  3               ;-----------------------------------------------------------
0025A6  3               
0025A6  3               disply:
0025A6  3  85 rr        	sta z80_a
0025A8  3  A9 CE        	lda #<displ0				; display workspace.
0025AA  3  85 rr        	sta z80_c
0025AC  3  A9 25        	lda #>displ0
0025AE  3  85 rr        	sta z80_b
0025B0  3  A5 rr        	lda z80_a
0025B2  3  20 2C 19     	jsr num2ch				; convert accumulator to string.
0025B5  3               displ1:
0025B5  3  C6 rr        	dec z80_c				; back one character.
0025B7  3  D0 02        	bne :+
0025B9  3  C6 rr        	dec z80_b
0025BB  3               :
0025BB  3  A0 00        	ldy #0
0025BD  3  B1 rr        	lda (z80_bc),y				; fetch digit.
0025BF  3  09 80        	ora #128				; insert end marker.
0025C1  3  91 rr        	sta (z80_bc),y				; new value.
0025C3  3               
0025C3  3  A9 CE        	lda #<displ0				; display space.
0025C5  3  85 rr        	sta z80_l
0025C7  3  A9 25        	lda #>displ0
0025C9  3  85 rr        	sta z80_h
0025CB  3  4C 6B 21     	jmp dmsg3				; display the string.
0025CE  3               
0025CE  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0025D2  3               
0025D2  3               ;----------------------------------------------------------------
0025D2  3               ; Initialise screen.
0025D2  3               ;
0025D2  3               ; global:	roomtb,scno
0025D2  3               ; local:	-
0025D2  3               ; calls:	tstcs
0025D2  3               ;----------------------------------------------------------------
0025D2  3               
0025D2  3               initsc:
0025D2  3  AD 0D 2A     	lda roomtb 			; whereabouts in the map are we?
0025D5  3  20 DF 25     	jsr tstsc 			; find displacement.
0025D8  3  C9 FF        	cmp #255 			; is it valid?
0025DA  3  F0 02        	beq init_end 			; no, it's rubbish.
0025DC  3  85 rr        	sta scno			; store new room number.
0025DE  3               init_end:
0025DE  3  60           	rts
0025DF  3               
0025DF  3               ;----------------------------------------------------------------
0025DF  3               ; Test screen.
0025DF  3               ;
0025DF  3               ; global:	-
0025DF  3               ; local:	x
0025DF  3               ; calls:	-
0025DF  3               ;----------------------------------------------------------------
0025DF  3               
0025DF  3               tstsc:
0025DF  3  85 rr        	sta tmproom
0025E1  3  18           	clc
0025E2  3  69 04        	adc #MAPWID 			; add width in case we"re negative.
0025E4  3  AA           	tax 				; add displacement to map data.
0025E5  3  BD 0F 2A     	lda mapdat-MAPWID,x 		; find room number there.
0025E8  3  60           	rts
0025E9  3               
0025E9  3               ;--------------------------
0025E9  3               ; Screen left.
0025E9  3               ;--------------------------
0025E9  3               
0025E9  3               scrl:
0025E9  3  AD 0D 2A     	lda roomtb 			; present room table pointer.
0025EC  3  38           	sec
0025ED  3  E9 01        	sbc #1				; room left.
0025EF  3               scrl0:
0025EF  3  20 DF 25     	jsr tstsc			; test screen.
0025F2  3  C9 FF        	cmp #255			; is there a screen this way?
0025F4  3  D0 01        	bne :+
0025F6  3  60           	rts				; no, return to loop.
0025F7  3               :
0025F7  3  A5 rr        	lda tmproom			; restore room displacement.
0025F9  3  8D 0D 2A     	sta roomtb			; new room table position.
0025FC  3               scrl1:
0025FC  3  20 D2 25     	jsr initsc 			; set new screen.
0025FF  3  A9 02        	lda #2
002601  3  85 rr        	sta restfl 			; set it.
002603  3  60           	rts
002604  3               scrr:
002604  3  AD 0D 2A     	lda roomtb 			; room table pointer.
002607  3  18           	clc
002608  3  69 01        	adc #1				; room right.
00260A  3  4C EF 25     	jmp scrl0
00260D  3               scru:
00260D  3  AD 0D 2A     	lda roomtb 			; room table pointer.
002610  3  38           	sec
002611  3  E9 04        	sbc #MAPWID 			; room up.
002613  3  4C EF 25     	jmp scrl0
002616  3               scrd:
002616  3  AD 0D 2A     	lda roomtb 			; room table pointer.
002619  3  18           	clc
00261A  3  69 04        	adc #MAPWID 			; room down.
00261C  3  4C EF 25     	jmp scrl0
00261F  3               
00261F  3               ;-----------------------------------------
00261F  3               ; Jump to new screen.
00261F  3               ;-----------------------------------------
00261F  3               
00261F  3               nwscr:
00261F  3  A2 00        	ldx #0				; start of map data.
002621  3               nwscr0:
002621  3  DD 13 2A     	cmp mapdat,x
002624  3  F0 06        	beq nwscr1			; have we found a match for screen?
002626  3  E8           	inx 				; next room.
002627  3  E0 50        	cpx #80				; zero room count, 80 to search.
002629  3  D0 F6        	bne nwscr0			; keep looking.
00262B  3  60           	rts
00262C  3               nwscr1:
00262C  3  8E 0D 2A     	stx roomtb			; set the map position.
00262F  3  4C FC 25     	jmp scrl1			; draw new room.
002632  3               
002632  3               
002632  3               ;----------------------------------------------------------
002632  3               ; Gravity processing.
002632  3               ;----------------------------------------------------------
002632  3               
002632  3               grav:
002632  3  A0 0D        	ldy #var_jumpLo
002634  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002636  3  85 rr        	sta z80_l
002638  3  A0 0E        	ldy #var_jumpHi
00263A  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
00263C  3  85 rr        	sta z80_h
00263E  3  05 rr        	ora z80_l			; merge in low byte.
002640  3  D0 01        	bne :+
002642  3  60           	rts				; if neither is set, we're not in the air.
002643  3               :
002643  3  A0 00        	ldy #0
002645  3  B1 rr        	lda (z80_hl),y			; pixels to move.
002647  3  85 rr        	sta z80_a
002649  3  C9 63        	cmp #99				; reached the end?
00264B  3  D0 06        	bne grav0			; no, continue.
00264D  3               grav2:
00264D  3  C6 rr        	dec z80_l			; go back to previous value.
00264F  3               	; 6502 WARNING - not updating 16-bit pointer properly!
00264F  3  B1 rr        	lda (z80_hl),y			; fetch that from table.
002651  3  85 rr        	sta z80_a
002653  3               grav0:
002653  3  E6 rr        	inc z80_l			; point to next table entry.
002655  3               	; 6502 WARNING - not updating 16-bit pointer properly!
002655  3  A5 rr        	lda z80_l
002657  3  A0 0D        	ldy #var_jumpLo
002659  3  91 rr        	sta (z80_ix),y			; store new pointer low.
00265B  3  A5 rr        	lda z80_h
00265D  3  A0 0E        	ldy #var_jumpHi
00265F  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002661  3               grav1:
002661  3  A5 rr        	lda z80_a
002663  3  D0 01        	bne :+				; any movement required?
002665  3  60           	rts				; no, not this time.
002666  3               :
002666  3  A5 rr        	lda z80_a
002668  3  C9 80        	cmp #128			; is it up or down?
00266A  3  B0 15        	bcs gravu			; it's up.
00266C  3               gravd:
00266C  3  85 rr        	sta z80_b			; set pixels to move.
00266E  3               gravd0:
00266E  3  20 BA 1E     	jsr cangd			; can we go down?
002671  3  D0 28        	bne gravst			; can't move down, so stop.
002673  3  A0 08        	ldy #8
002675  3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
002677  3  18           	clc
002678  3  69 01        	adc #1
00267A  3  91 rr        	sta (z80_ix),y
00267C  3  C6 rr        	dec z80_b
00267E  3  D0 EE        	bne gravd0
002680  3  60           	rts
002681  3               gravu:
002681  3  49 FF        	eor #$ff			; flip the sign so it's positive.
002683  3  18           	clc
002684  3  69 01        	adc #1
002686  3  85 rr        	sta z80_b			; set pixels to move.
002688  3               gravu0:
002688  3  20 85 1E     	jsr cangu			; can we go up?
00268B  3  D0 6E        	bne ifalls			; can't move up, go down next.
00268D  3  A0 08        	ldy #8
00268F  3  B1 rr        	lda (z80_ix),y
002691  3  38           	sec
002692  3  E9 01        	sbc #1
002694  3  91 rr        	sta (z80_ix),y			; adjust new x coord.
002696  3  C6 rr        	dec z80_b
002698  3  D0 EE        	bne gravu0
00269A  3  60           	rts
00269B  3               gravst:
00269B  3  A0 0D        	ldy #var_jumpLo
00269D  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
00269F  3  85 rr        	sta z80_l
0026A1  3  A0 0E        	ldy #var_jumpHi
0026A3  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
0026A5  3  85 rr        	sta z80_h
0026A7  3               
0026A7  3  A9 00        	lda #0				; null value in pointer.
0026A9  3  A0 0D        	ldy #var_jumpLo
0026AB  3  91 rr        	sta (z80_ix),y			; store new pointer low.
0026AD  3  C8           	iny
0026AE  3  91 rr        	sta (z80_ix),y			; store new pointer high.
0026B0  3               
0026B0  3  A0 00        	ldy #0
0026B2  3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
0026B4  3  C9 63        	cmp #99				; is it the end marker?
0026B6  3               evftf:
0026B6  3  F0 01        	beq :+				; yes, fallen too far.
0026B8  3  60           	rts
0026B9  3               :
0026B9  3  4C 0F 2D     	jmp evnt15			; EVENT FELLTOOFAR
0026BC  3               
0026BC  3               ;------------------------------------------------
0026BC  3               ; Initiate fall check.
0026BC  3               ;------------------------------------------------
0026BC  3               
0026BC  3               ifall:
0026BC  3  A0 0D        	ldy #var_jumpLo
0026BE  3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
0026C0  3  85 rr        	sta z80_l
0026C2  3  A0 0E        	ldy #var_jumpHi
0026C4  3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
0026C6  3  85 rr        	sta z80_h			; high byte in accumulator.
0026C8  3  05 rr        	ora z80_l			; merge in low byte.
0026CA  3  F0 01        	beq :+
0026CC  3  60           	rts				; if either is set, we're already in the air.
0026CD  3               :
0026CD  3  A0 09        	ldy #9
0026CF  3  B1 rr        	lda (z80_ix),y			; y coordinate.
0026D1  3  85 rr        	sta dispx
0026D3  3               numsp7:
0026D3  3  A0 08        	ldy #8
0026D5  3  B1 rr        	lda (z80_ix),y			; look x coordinate.
0026D7  3  18           	clc
0026D8  3  69 10        	adc #16				; add 16 pixels.
0026DA  3  85 rr        	sta dispy			; set up test coordinates.
0026DC  3  20 A1 20     	jsr tstbl			; get map address.
0026DF  3  20 4C 1F     	jsr plchk			; block, platform check.
0026E2  3  F0 01        	beq :+
0026E4  3  60           	rts				; it's solid, don't fall.
0026E5  3               :
0026E5  3  E6 rr        	inc bufaddr			; look right one cell.
0026E7  3  20 4C 1F     	jsr plchk			; block, platform check.
0026EA  3  F0 01        	beq :+
0026EC  3  60           	rts				; it's solid, don't fall.
0026ED  3               :
0026ED  3  A5 rr        	lda dispx			; y coordinate.
0026EF  3  29 07        	and #7				; position straddling block cells.
0026F1  3  F0 08        	beq ifalls			; no more checks needed.
0026F3  3  E6 rr        	inc bufaddr			; look to third cell.
0026F5  3  20 4C 1F     	jsr plchk			; block, platform check.
0026F8  3  F0 01        	beq :+
0026FA  3  60           	rts				; it's solid, don't fall.
0026FB  3               :
0026FB  3               ifalls:
0026FB  3  A9 00        	lda #<jtab			; jump table start.
0026FD  3  85 rr        	sta z80_l
0026FF  3  A9 21        	lda #>jtab
002701  3  85 rr        	sta z80_h
002703  3               ifal0:
002703  3  E6 rr        	inc z80_l			; point to next value.
002705  3  D0 02        	bne :+
002707  3  E6 rr        	inc z80_h
002709  3               :
002709  3  A0 00        	ldy #0
00270B  3  B1 rr        	lda (z80_hl),y			; fetch value.
00270D  3  F0 F4        	beq ifal0			; no, get next value.
00270F  3  C9 63        	cmp #99				; reached end of table?
002711  3  D0 01        	bne :+
002713  3  60           	rts				; yes, don't fall.
002714  3               :
002714  3  C9 80        	cmp #128			; is it going up?
002716  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
002718  3               
002718  3  A0 0D        	ldy #var_jumpLo
00271A  3  A5 rr        	lda z80_l
00271C  3  91 rr        	sta (z80_ix),y 			; set jump low.
00271E  3  A0 0E        	ldy #var_jumpHi
002720  3  A5 rr        	lda z80_h
002722  3  91 rr        	sta (z80_ix),y 			; set jump high.
002724  3  60           	rts
002725  3               
002725  3               
002725  3               ;----------------------------------------------------
002725  3               ; Get frame data for a particular sprite.
002725  3               ; Input:
002725  3               ;  a		= framenumer
002725  3               ; Output:
002725  3               ;  hl		= frame address
002725  3               ;
002725  3               ; global:	hl,frmptr
002725  3               ; local:	-
002725  3               ; calls:	-
002725  3               ;----------------------------------------------------
002725  3               
002725  3               gfrm:
002725  3  0A           	asl a	 		 	; multiple of 2.
002726  3  18           	clc
002727  3  6D 1D 11     	adc frmptr 			; frames used by game.
00272A  3  85 rr        	sta z80_l
00272C  3  AD 1E 11     	lda frmptr+1
00272F  3  69 00        	adc #0
002731  3  85 rr        	sta z80_h 			; point to frame start.
002733  3  60           	rts
002734  3               
002734  3               ;----------------------------------------------------
002734  3               ; Find sprite list for current room.
002734  3               ;
002734  3               ; global:	hl
002734  3               ; local:	x,y
002734  3               ; calls:	-
002734  3               ;----------------------------------------------------
002734  3               
002734  3               sprlst:
002734  3  A9 F5        	lda #<nmedat 			; list of enemy sprites.
002736  3  85 rr        	sta z80_l
002738  3  A9 30        	lda #>nmedat
00273A  3  85 rr        	sta z80_h
00273C  3  A6 rr        	ldx scno 			; screen number.
00273E  3  D0 01        	bne sprls2 			; is it the first screen?
002740  3  60           	rts 				; yes, don't need to search data.
002741  3               sprls2:
002741  3  A0 00        	ldy #0
002743  3               sprls1:
002743  3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
002745  3  C9 FF        	cmp #255			; is it an end marker?
002747  3  F0 0E        	beq sprls0 			; yes, end of this room.
002749  3               
002749  3  18           	clc 				; point to next sprite in list.
00274A  3  A5 rr        	lda z80_l
00274C  3  69 04        	adc #NMESIZ
00274E  3  85 rr        	sta z80_l
002750  3  90 02        	bcc :+
002752  3  E6 rr        	inc z80_h
002754  3               :
002754  3  4C 43 27     	jmp sprls1 			; continue until end of room.
002757  3               sprls0:
002757  3  E6 rr        	inc z80_l 			; point to start of next screen.s
002759  3  D0 02        	bne :+
00275B  3  E6 rr        	inc z80_h
00275D  3               :
00275D  3  CA           	dex
00275E  3  D0 E3        	bne sprls1 			; continue until room found.
002760  3  60           	rts
002761  3               
002761  3               
002761  3               ;----------------------------------------------------
002761  3               ; Clear all but a single player sprite.
002761  3               ;
002761  3               ; global:	-
002761  3               ; local:	x,y,ix
002761  3               ; calls:	-
002761  3               ;----------------------------------------------------
002761  3               
002761  3               nspr:
002761  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002763  3  85 rr        	sta sprcnt
002765  3  A9 00        	lda #<sprtab 			; sprite table.
002767  3  85 rr        	sta z80_x
002769  3  A9 0B        	lda #>sprtab
00276B  3  85 rr        	sta z80_i
00276D  3               nspr0:
00276D  3  A0 00        	ldy #0 				; fetch sprite type.
00276F  3  B1 rr        	lda (z80_ix),y 			; is it a player?
002771  3  F0 1A        	beq nspr1 			; yes, keep this one.
002773  3               
002773  3  A9 FF        	lda #255
002775  3  A0 00        	ldy #0 				; fetch sprite type.
002777  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002779  3  A0 05        	ldy #5
00277B  3  91 rr        	sta (z80_ix),y 			; remove next type.
00277D  3               
00277D  3  18           	clc	 			; next sprite.
00277E  3  A5 rr        	lda z80_x
002780  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002782  3  85 rr        	sta z80_x
002784  3  90 02        	bcc :+
002786  3  E6 rr        	inc z80_i
002788  3               :
002788  3  C6 rr        	dec sprcnt	 			; one less space in the table.
00278A  3  D0 E1        	bne nspr0
00278C  3  60           	rts
00278D  3               nspr1:
00278D  3  A9 FF        	lda #255
00278F  3  A0 00        	ldy #0
002791  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002793  3               
002793  3  18           	clc	 			; point to next sprite.
002794  3  A5 rr        	lda z80_x
002796  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002798  3  85 rr        	sta z80_x
00279A  3  90 02        	bcc :+
00279C  3  E6 rr        	inc z80_i
00279E  3               :
00279E  3  C6 rr        	dec sprcnt	 			; one less to do.
0027A0  3  D0 01        	bne nspr2
0027A2  3  60           	rts
0027A3  3               nspr2:
0027A3  3  A9 FF        	lda #255
0027A5  3  A0 00        	ldy #0
0027A7  3  91 rr        	sta (z80_ix),y 			; delete sprite.
0027A9  3  A0 05        	ldy #5
0027AB  3  91 rr        	sta (z80_ix),y 			; remove next type.
0027AD  3               
0027AD  3  18           	clc	 			; next sprite.
0027AE  3  A5 rr        	lda z80_x
0027B0  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0027B2  3  85 rr        	sta z80_x
0027B4  3  90 02        	bcc :+
0027B6  3  E6 rr        	inc z80_i
0027B8  3               :
0027B8  3  C6 rr        	dec sprcnt	 			; one less space in table.
0027BA  3  D0 E7        	bne nspr2
0027BC  3  60           	rts
0027BD  3               
0027BD  3               ;----------------------------------------------------------
0027BD  3               ; Two initialisation routines.
0027BD  3               ; Initialise sprites - copy everything from list to table.
0027BD  3               ;
0027BD  3               ; global:	-
0027BD  3               ; local:	x,y,ix
0027BD  3               ; calls:	cpsp
0027BD  3               ;----------------------------------------------------------
0027BD  3               
0027BD  3               ispr:
0027BD  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0027BF  3  85 rr        	sta sprcnt
0027C1  3  A9 00        	lda #<sprtab			; sprite table.
0027C3  3  85 rr        	sta z80_x
0027C5  3  A9 0B        	lda #>sprtab
0027C7  3  85 rr        	sta z80_i
0027C9  3               ispr2:
0027C9  3  A0 00        	ldy #0
0027CB  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0027CD  3  C9 FF        	cmp #255 			; is it an end marker?
0027CF  3  D0 01        	bne :+
0027D1  3  60           	rts 				; yes, no more to do.
0027D2  3               :
0027D2  3               ispr1:
0027D2  3  A0 00        	ldy #0
0027D4  3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
0027D6  3  C9 FF        	cmp #255 			; is it enabled yet?
0027D8  3  D0 08        	bne ispr4			; yes, try another slot.
0027DA  3               
0027DA  3  A0 05        	ldy #5
0027DC  3  B1 rr        	lda (z80_ix),y		 	; next type.
0027DE  3  C9 FF        	cmp #255 			; is it enabled yet?
0027E0  3  F0 10        	beq ispr3 			; no, process this one.
0027E2  3               ispr4:
0027E2  3  18           	clc 				; next sprite.
0027E3  3  A5 rr        	lda z80_x
0027E5  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0027E7  3  85 rr        	sta z80_x
0027E9  3  90 02        	bcc :+
0027EB  3  E6 rr        	inc z80_i
0027ED  3               :
0027ED  3  C6 rr        	dec sprcnt
0027EF  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
0027F1  3  60           	rts  				; no more room in table.
0027F2  3               ispr3:
0027F2  3  20 45 28     	jsr cpsp			; initialise a sprite.
0027F5  3  C6 rr        	dec sprcnt			; one less space in the table.
0027F7  3  D0 D0        	bne ispr2
0027F9  3  60           	rts
0027FA  3               
0027FA  3               
0027FA  3               ;-----------------------------------------------------------------------
0027FA  3               ; Initialise sprites - but not player, we're keeping the old one.
0027FA  3               ;
0027FA  3               ; global:	-
0027FA  3               ; local:	x,y,ix
0027FA  3               ; calls:	cpsp
0027FA  3               ;-----------------------------------------------------------------------
0027FA  3               
0027FA  3               kspr:
0027FA  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
0027FC  3  A9 00        	lda #<sprtab 			; sprite table.
0027FE  3  85 rr        	sta z80_x
002800  3  A9 0B        	lda #>sprtab
002802  3  85 rr        	sta z80_i
002804  3               kspr2:
002804  3  A0 00        	ldy #0
002806  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
002808  3  C9 FF        	cmp #255 			; is it an end marker?
00280A  3  D0 01        	bne :+
00280C  3  60           	rts 				; yes, no more to do.
00280D  3               :
00280D  3  C9 00        	cmp #0
00280F  3  D0 0E        	bne kspr1 			; no, add to table as normal.
002811  3               
002811  3  18           	clc 				; next sprite.
002812  3  A5 rr        	lda z80_l
002814  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
002816  3  85 rr        	sta z80_l
002818  3  90 02        	bcc :+
00281A  3  E6 rr        	inc z80_h
00281C  3               :
00281C  3  4C 04 28     	jmp kspr2
00281F  3               kspr1:
00281F  3  A0 00        	ldy #0 				; fetch sprite type.
002821  3  B1 rr        	lda (z80_ix),y
002823  3  C9 FF        	cmp #255 			; is it enabled yet?
002825  3  D0 08        	bne kspr4 			; yes, try another slot.
002827  3               
002827  3  A0 05        	ldy #5 				; next type.
002829  3  B1 rr        	lda (z80_ix),y
00282B  3  C9 FF        	cmp #255 			; is it enabled yet?
00282D  3  F0 0F        	beq kspr3 			; no, process this one.
00282F  3               kspr4:
00282F  3  18           	clc 				; next sprite.
002830  3  A5 rr        	lda z80_x
002832  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
002834  3  85 rr        	sta z80_x
002836  3  90 02        	bcc :+
002838  3  E6 rr        	inc z80_i
00283A  3               :
00283A  3  CA           	dex	 			; repeat for remaining sprites.
00283B  3  D0 E2        	bne kspr1
00283D  3  60           	rts  				; no more room in table.
00283E  3               kspr3:
00283E  3  20 45 28     	jsr cpsp 			; copy sprite to table.
002841  3  CA           	dex	 			; one less space in the table.
002842  3  D0 C0        	bne kspr2
002844  3  60           	rts
002845  3               
002845  3               ;----------------------------------------------
002845  3               ; Copy sprite from list to table.
002845  3               ;
002845  3               ; global:	hl,ix
002845  3               ; local:	y
002845  3               ; calls:	evnt09
002845  3               ;----------------------------------------------
002845  3               
002845  3               cpsp:
002845  3  A0 00        	ldy #0					; fetch byte from table.
002847  3  B1 rr        	lda (z80_hl),y
002849  3               	; y=var_Type
002849  3  91 rr        	sta (z80_ix),y			; set up type.
00284B  3  A0 05        	ldy #var_newType
00284D  3  91 rr        	sta (z80_ix),y 			; set up type.
00284F  3               
00284F  3  E6 rr        	inc z80_l 				; move to next byte.
002851  3  D0 02        	bne :+
002853  3  E6 rr        	inc z80_h
002855  3               :
002855  3  A0 00        	ldy #0 					; fetch byte from table.
002857  3  B1 rr        	lda (z80_hl),y
002859  3  A0 06        	ldy #var_newImage
00285B  3  91 rr        	sta (z80_ix),y			; set up image.
00285D  3               
00285D  3  E6 rr        	inc z80_l 				; move to next byte.
00285F  3  D0 02        	bne :+
002861  3  E6 rr        	inc z80_h
002863  3               :
002863  3  A0 00        	ldy #0
002865  3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
002867  3  A0 08        	ldy #var_newY
002869  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
00286B  3               
00286B  3  A9 C8        	lda #200 				; set initial coordinate off screen.
00286D  3  A0 03        	ldy #var_Y
00286F  3  91 rr        	sta (z80_ix),y
002871  3               
002871  3  E6 rr        	inc z80_l 				; move to next byte.
002873  3  D0 02        	bne :+
002875  3  E6 rr        	inc z80_h
002877  3               :
002877  3  A0 00        	ldy #0 					; fetch byte from table.
002879  3  B1 rr        	lda (z80_hl),y
00287B  3  A0 09        	ldy #var_newX
00287D  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
00287F  3               
00287F  3  E6 rr        	inc z80_l 				; move to next byte.
002881  3  D0 02        	bne :+
002883  3  E6 rr        	inc z80_h
002885  3               :
002885  3  A9 00        	lda #0					; zeroes in accumulator.
002887  3  A0 07        	ldy #var_newFrame 		; reset frame number.
002889  3  91 rr        	sta (z80_ix),y
00288B  3  A0 0A        	ldy #var_Direction 		; reset direction.
00288D  3  91 rr        	sta (z80_ix),y
00288F  3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
002891  3  91 rr        	sta (z80_ix),y
002893  3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
002895  3  91 rr        	sta (z80_ix),y
002897  3               
002897  3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
002899  3  A0 10        	ldy #var_dataHi
00289B  3  91 rr        	sta (z80_ix),y
00289D  3               evis0:
00289D  3  A5 rr        	lda z80_i
00289F  3  48           	pha
0028A0  3  A5 rr        	lda z80_x
0028A2  3  48           	pha
0028A3  3  A5 rr        	lda z80_h
0028A5  3  48           	pha
0028A6  3  A5 rr        	lda z80_l
0028A8  3  48           	pha
0028A9  3               
0028A9  3  20 B1 2B     	jsr evnt09 				; perform event.
0028AC  3               
0028AC  3  68           	pla
0028AD  3  85 rr        	sta z80_l
0028AF  3  68           	pla
0028B0  3  85 rr        	sta z80_h
0028B2  3  68           	pla
0028B3  3  85 rr        	sta z80_x
0028B5  3  68           	pla
0028B6  3  85 rr        	sta z80_i
0028B8  3               
0028B8  3  18           	clc
0028B9  3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
0028BB  3  69 11        	adc #TABSIZ		 	; next sprite.
0028BD  3  85 rr        	sta z80_x
0028BF  3  90 02        	bcc :+
0028C1  3  E6 rr        	inc z80_i
0028C3  3               :
0028C3  3  60           	rts
0028C4  3               
0028C4  3               
0028C4  3               ;-------------------------------------
0028C4  3               ; Clear the play area window.
0028C4  3               ;-------------------------------------
0028C4  3               
0028C4  3               clw:
0028C4  3  AD 14 11     	lda wintop			; get coordinates of window.
0028C7  3  85 rr        	sta dispy			; put into dispx for calculation.
0028C9  3  AD 15 11     	lda winlft
0028CC  3  85 rr        	sta dispx
0028CE  3               
0028CE  3  AD 16 11     	lda winhgt			; height of window.
0028D1  3  85 rr        	sta rrow			; copy to b register.
0028D3  3               clw3:
0028D3  3  AD 17 11     	lda winwid 			; width of window.
0028D6  3  85 rr        	sta rcol
0028D8  3               clw2:
0028D8  3  20 ED 1C     	jsr gprad 			; get print address.
0028DB  3  A9 00        	lda #0				; zero byte to write.
0028DD  3  A0 07        	ldy #7				; pixel height of each cell.
0028DF  3               clw1:
0028DF  3  91 rr        	sta (scraddr),y 	; copy to screen.
0028E1  3  88           	dey					; next screen row down.
0028E2  3  10 FB        	bpl clw1
0028E4  3               
0028E4  3  E6 rr        	inc dispx			; next column.
0028E6  3  C6 rr        	dec rcol			; one less to do.
0028E8  3  D0 EE        	bne clw2			; repeat for remaining columns.
0028EA  3               
0028EA  3  AD 15 11     	lda winlft			; get left edge.
0028ED  3  85 rr        	sta dispx 			; reset x.
0028EF  3  E6 rr        	inc dispy 			; next line down.
0028F1  3               
0028F1  3  C6 rr        	dec rrow
0028F3  3  D0 DE        	bne clw3			; repeat down the screen.
0028F5  3               
0028F5  3  AD 14 11     	lda wintop			; get coordinates of window.
0028F8  3  85 rr        	sta chary			; put into display position.
0028FA  3  AD 15 11     	lda winlft
0028FD  3  85 rr        	sta charx
0028FF  3  60           	rts
002900  3               
002900  3               
002900  3               ;----------------------------------------------------------
002900  3               ; Effects code.
002900  3               ; Ticker routine is called 25 times per second.
002900  3               ;
002900  3               ; HL = txtscr = left text screen address
002900  3               ; DE = txtscr+txtwid-1 = right text screen address
002900  3               ; BC = txtpos = text scroller position
002900  3               ;
002900  3               ;----------------------------------------------------------
002900  3               
002900  3               .if sflag
002900  3               scrly:
002900  3  60           	rts
002901  3  03 12        	.word txtscr         	; get left screen address.
002903  3  85 rr        	sta scr_l
002905  3  AD 04 12     	lda txtscr+1
002908  3  85 rr        	sta scr_l+1
00290A  3  85 rr        	sta scr_r+1
00290C  3               
00290C  3  86 rr        	stx xtmp
00290E  3               
00290E  3  18           	clc         		; get right screen address.
00290F  3  A5 rr        	lda scr_l
002911  3  6D FE 11     	adc txtwid
002914  3  85 rr        	sta scr_r
002916  3  C6 rr        	dec scr_r
002918  3               scrly1:
002918  3  AC FE 11     	ldy txtwid		; set txtwide
00291B  3  88           	dey
00291C  3  18           	clc
00291D  3               scrly0:
00291D  3  B1 rr        	lda (scr_l),y		; scroll 1 line
00291F  3  2A           	rol a
002920  3  91 rr        	sta (scr_l),y
002922  3  88           	dey
002923  3  10 F8        	bpl scrly0
002925  3               
002925  3  18           	clc			; point to next line
002926  3  A5 rr        	lda scr_l
002928  3  69 20        	adc #32
00292A  3  85 rr        	sta scr_l
00292C  3  90 EA        	bcc scrly1		; repeat 8 times
00292E  3               
00292E  3  AD FF 11     	lda txtpos 		; get text pointer.
002931  3  85 rr        	sta scr_txt
002933  3  AD 00 12     	lda txtpos+1
002936  3  85 rr        	sta scr_txt+1
002938  3               
002938  3  A0 00        	ldy #0
00293A  3  B1 rr        	lda (scr_txt),y 		; find character we're displaying.
00293C  3  29 7F        	and #127 		; remove end marker bit if applicable.
00293E  3  C9 0D        	cmp #ASCII_NEWLINE			; is it newline?
002940  3  D0 02        	bne scrly5 		; no, it's okay.
002942  3  A9 20        	lda #32			; convert to a space instead.
002944  3               scrly5:
002944  3  85 rr        	sta fntaddr		; calculate char address
002946  3  A9 00        	lda #0
002948  3  85 rr        	sta fntaddr+1
00294A  3  06 rr        	asl fntaddr  		; multiply char by 8.
00294C  3  26 rr        	rol fntaddr+1
00294E  3  06 rr        	asl fntaddr
002950  3  26 rr        	rol fntaddr+1
002952  3  06 rr        	asl fntaddr
002954  3  26 rr        	rol fntaddr+1
002956  3  A5 rr        	lda fntaddr
002958  3  18           	clc
002959  3  65 rr        	adc FontPtr
00295B  3  8D 68 29     	sta scrly3+1		; that's the low byte.
00295E  3  A5 rr        	lda fntaddr+1
002960  3  65 rr        	adc FontPtr+1
002962  3  8D 69 29     	sta scrly3+2		; add displacement.
002965  3               
002965  3  A2 00        	ldx #0
002967  3               scrly3:
002967  3  BD 33 33     	lda $3333,x		; get image of char line.
00296A  3  2D FD 11     	and txtbit
00296D  3  F0 0A        	beq scrly2		; don't plot pixel
00296F  3  BC AA 29     	ldy scrline,x
002972  3  B1 rr        	lda (scr_r),y
002974  3  18           	clc
002975  3  09 01        	ora #1
002977  3  91 rr        	sta (scr_r),y		; plot pixel
002979  3               scrly2:
002979  3  E8           	inx			; next line of char.
00297A  3  E0 08        	cpx #8
00297C  3  D0 E9        	bne scrly3
00297E  3               
00297E  3  4E FD 11     	lsr txtbit		; bit of text to display.
002981  3  B0 01        	bcs :+
002983  3  60           	rts
002984  3               :
002984  3  A0 00        	ldy #0
002986  3  B1 rr        	lda (scr_txt),y 	; what was the character?
002988  3  0A           	asl a	  		; end of message?
002989  3  B0 0B        	bcs scrly4
00298B  3  EE FF 11     	inc txtpos
00298E  3  D0 03        	bne :+
002990  3  EE 00 12     	inc txtpos+1
002993  3               :
002993  3  4C A2 29     	jmp scrly6 		; not yet - continue.
002996  3               scrly4:
002996  3  AD 01 12     	lda txtini 		; start of scrolling message.
002999  3  8D FF 11     	sta txtpos
00299C  3  AD 02 12     	lda txtini+1
00299F  3  8D 00 12     	sta txtpos+1
0029A2  3               scrly6:
0029A2  3  A9 80        	lda #128
0029A4  3  8D FD 11     	sta txtbit
0029A7  3  A6 rr        	ldx xtmp
0029A9  3  60           	rts
0029AA  3               
0029AA  3  00 20 40 60  scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
0029AE  3  80 A0 C0 E0  
0029B2  3               
0029B2  3               ;-------------------------------------------------------
0029B2  3               ; Entry TICKER command
0029B2  3               ;
0029B2  3               ; Entry:
0029B2  3               ;  z80_b = message nr
0029B2  3               ;  z80_c = width
0029B2  3               ;-------------------------------------------------------
0029B2  3               
0029B2  3               iscrly:
0029B2  3  20 75 22     	jsr prescr 		; set up display position.
0029B5  3               
0029B5  3  A9 59        	lda #<msgdat 		; text messages.
0029B7  3  85 rr        	sta z80_l
0029B9  3  A9 2D        	lda #>msgdat
0029BB  3  85 rr        	sta z80_h
0029BD  3               
0029BD  3  A5 rr        	lda z80_c 		; width.
0029BF  3  38           	sec
0029C0  3  E9 01        	sbc #1			; subtract one.
0029C2  3  C9 20        	cmp #32 		; is it between 1 and 32?
0029C4  3  90 05        	bcc :+
0029C6  3  A9 60        	lda #$60
0029C8  3  4C DC 29     	jmp iscrl0		; no, disable messages.
0029CB  3               :
0029CB  3  A6 rr        	ldx z80_b		; message number.
0029CD  3  20 7E 22     	jsr getwrd 		; find message start.
0029D0  3               
0029D0  3  A5 rr        	lda z80_l		; set initial text position.
0029D2  3  8D 01 12     	sta txtini
0029D5  3  A5 rr        	lda z80_h
0029D7  3  8D 02 12     	sta txtini+1
0029DA  3               
0029DA  3  A9 AD        	lda #$ad		; code for lda adrr
0029DC  3               iscrl0:
0029DC  3  8D 00 29     	sta scrly		; enable/disable scrolling routine.
0029DF  3               
0029DF  3  20 75 22     	jsr prescr 		; set up display position.
0029E2  3  20 ED 1C     	jsr gprad 		; get print address.
0029E5  3               
0029E5  3  A5 rr        	lda scraddr 		; set text screen address.
0029E7  3  8D 03 12     	sta txtscr
0029EA  3  A5 rr        	lda scraddr+1
0029EC  3  8D 04 12     	sta txtscr+1
0029EF  3               
0029EF  3  A5 rr        	lda z80_c		; width.
0029F1  3  8D FE 11     	sta txtwid		; set width in working storage.
0029F4  3               
0029F4  3  A9 80        	lda #128 		; start with leftmost bit.
0029F6  3  8D FD 11     	sta txtbit
0029F9  3               
0029F9  3  4C 96 29     	jmp scrly4
0029FC  3               .endif
0029FC  3               
0029FC  3               ;------------------------------------------------------------------
0029FC  3               ; Sprite table
0029FC  3               ;------------------------------------------------------------------
0029FC  3               
0029FC  3               
0029FC  3               ; ix+0  = type.
0029FC  3               ; ix+1  = sprite image number.
0029FC  3               ; ix+2  = frame.
0029FC  3               ; ix+3  = y coord.
0029FC  3               ; ix+4  = x coord.
0029FC  3               
0029FC  3               ; ix+5  = new type.
0029FC  3               ; ix+6  = new image number.
0029FC  3               ; ix+7  = new frame.
0029FC  3               ; ix+8  = new y coord.
0029FC  3               ; ix+9  = new x coord.
0029FC  3               
0029FC  3               ; ix+10 = direction.
0029FC  3               ; ix+11 = parameter 1.
0029FC  3               ; ix+12 = parameter 2.
0029FC  3               ; ix+13 = jump pointer low.
0029FC  3               ; ix+14 = jump pointer high.
0029FC  3               ; ix+15 = data pointer low.
0029FC  3               ; ix+16 = data pointer high.
0029FC  3               
0029FC  3               ; block NUMSPR * TABSIZ,255
0029FC  3               ; sprtab NUMSPR*TABSIZ,255
0029FC  3               
0029FC  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
002A00  3  FF FF FF 00  
002A04  3  C0 78 00 00  
002A0D  3  07           roomtb:	.byte 7                      ; start room map offset.
002A0E  3               
002A0E  3               ; User routine.  Put your own code in here to be called with USER instruction.
002A0E  3               ; if USER has an argument it will be passed in the accumulator.
002A0E  3               
002A0E  3               user:
002A0E  3  60           	rts
002A0F  3               
002A0F  3               ; Everything below here will be generated by the editors.
002A0F  3               
002A0F  3               script_start:
002A0F  3               
002A0F  3               WINDOWTOP = 1
002A0F  3               WINDOWLFT = 9
002A0F  3               WINDOWHGT = 22
002A0F  3               WINDOWWID = 22 ;
002A0F  3               MAPWID = 4
002A0F  3  FF FF FF FF          .byte 255,255,255,255
002A13  3               mapdat:
002A13  3  FF 01 00 FF          .byte 255,1,0,255,255,2,255,255
002A17  3  FF 02 FF FF  
002A1B  3  FF FF FF FF          .byte 255,255,255,255
002A1F  3  02           stmap:  .byte 2
002A20  3               
002A20  3               evnt00:
002A20  3                       ; SPRITEINK command
002A20  3  20 9F 1A             jsr skobj
002A23  3  85 rr                sta varobj
002A25  3  A9 00                lda #0
002A27  3  C5 rr                cmp varobj
002A29  3  F0 03                beq *+5
002A2B  3  4C 33 2A             jmp a00044
002A2E  3  A5 rr                lda varobj
002A30  3  20 1E 1A             jsr getob
002A33  3  A5 rr        a00044: lda joyval
002A35  3  29 08                and #8
002A37  3  F0 03                beq :+
002A39  3  4C 67 2A             jmp a00147
002A3C  3               :
002A3C  3  AD 19 11             lda wntopx
002A3F  3  A0 08                ldy #8
002A41  3  D1 rr                cmp (z80_ix),y
002A43  3  B0 03                bcs *+5
002A45  3  4C 56 2A             jmp a00111
002A48  3  20 0D 26             jsr scru
002A4B  3  AD 1B 11             lda wnbotx
002A4E  3  A0 08                ldy #8
002A50  3  91 rr                sta (z80_ix),y
002A52  3  60                   rts
002A53  3  4C 67 2A             jmp a00147
002A56  3  20 85 1E     a00111: jsr cangu
002A59  3  F0 03                beq :+
002A5B  3  4C 67 2A             jmp a00147
002A5E  3               :
002A5E  3  A0 08                ldy #8
002A60  3  B1 rr                lda (z80_ix),y
002A62  3  38                   sec
002A63  3  E9 02                sbc #2
002A65  3  91 rr                sta (z80_ix),y
002A67  3  A5 rr        a00147: lda joyval
002A69  3  29 04                and #4
002A6B  3  F0 03                beq :+
002A6D  3  4C 9A 2A             jmp a00249
002A70  3               :
002A70  3  AD 1B 11             lda wnbotx
002A73  3  A0 08                ldy #8
002A75  3  D1 rr                cmp (z80_ix),y
002A77  3  F0 02                beq *+4
002A79  3  B0 0E                bcs a00213
002A7B  3  20 16 26             jsr scrd
002A7E  3  AD 19 11             lda wntopx
002A81  3  A0 08                ldy #8
002A83  3  91 rr                sta (z80_ix),y
002A85  3  60                   rts
002A86  3  4C 9A 2A             jmp a00249
002A89  3  20 BA 1E     a00213: jsr cangd
002A8C  3  F0 03                beq :+
002A8E  3  4C 9A 2A             jmp a00249
002A91  3               :
002A91  3  A0 08                ldy #8
002A93  3  B1 rr                lda (z80_ix),y
002A95  3  18                   clc
002A96  3  69 02                adc #2
002A98  3  91 rr                sta (z80_ix),y
002A9A  3  A5 rr        a00249: lda joyval
002A9C  3  29 02                and #2
002A9E  3  F0 03                beq :+
002AA0  3  4C CE 2A             jmp a00351
002AA3  3               :
002AA3  3  AD 1A 11             lda wnlftx
002AA6  3  A0 09                ldy #9
002AA8  3  D1 rr                cmp (z80_ix),y
002AAA  3  B0 03                bcs *+5
002AAC  3  4C BD 2A             jmp a00316
002AAF  3  20 E9 25             jsr scrl
002AB2  3  AD 1C 11             lda wnrgtx
002AB5  3  A0 09                ldy #9
002AB7  3  91 rr                sta (z80_ix),y
002AB9  3  60                   rts
002ABA  3  4C CE 2A             jmp a00351
002ABD  3  20 EF 1E     a00316: jsr cangl
002AC0  3  F0 03                beq :+
002AC2  3  4C CE 2A             jmp a00351
002AC5  3               :
002AC5  3  A0 09                ldy #9
002AC7  3  B1 rr                lda (z80_ix),y
002AC9  3  38                   sec
002ACA  3  E9 02                sbc #2
002ACC  3  91 rr                sta (z80_ix),y
002ACE  3  A5 rr        a00351: lda joyval
002AD0  3  29 01                and #1
002AD2  3  F0 03                beq :+
002AD4  3  4C 01 2B             jmp a00453
002AD7  3               :
002AD7  3  AD 1C 11             lda wnrgtx
002ADA  3  A0 09                ldy #9
002ADC  3  D1 rr                cmp (z80_ix),y
002ADE  3  F0 02                beq *+4
002AE0  3  B0 0E                bcs a00418
002AE2  3  20 04 26             jsr scrr
002AE5  3  AD 1A 11             lda wnlftx
002AE8  3  A0 09                ldy #9
002AEA  3  91 rr                sta (z80_ix),y
002AEC  3  60                   rts
002AED  3  4C 01 2B             jmp a00453
002AF0  3  20 01 1F     a00418: jsr cangr
002AF3  3  F0 03                beq :+
002AF5  3  4C 01 2B             jmp a00453
002AF8  3               :
002AF8  3  A0 09                ldy #9
002AFA  3  B1 rr                lda (z80_ix),y
002AFC  3  18                   clc
002AFD  3  69 02                adc #2
002AFF  3  91 rr                sta (z80_ix),y
002B01  3  A5 rr        a00453: lda joyval
002B03  3  29 10                and #16
002B05  3  F0 03                beq :+
002B07  3  4C 0F 2B             jmp a00480
002B0A  3               :
002B0A  3  A9 10                lda #16
002B0C  3  20 A7 15             jsr explod
002B0F  3               a00480: ; SPRITEINK command
002B0F  3  60                   rts
002B10  3               .out .sprintf("EVENT 0 SIZE = %d", (* - evnt00))
002B10  3               
002B10  3               evnt01:
002B10  3  A9 00                lda #0
002B12  3  A0 0A                ldy #10
002B14  3  D1 rr                cmp (z80_ix),y
002B16  3  F0 03                beq *+5
002B18  3  4C 38 2B             jmp b00082
002B1B  3  20 85 1E             jsr cangu
002B1E  3  F0 03                beq :+
002B20  3  4C 2F 2B             jmp b00064
002B23  3               :
002B23  3  A0 08                ldy #8
002B25  3  B1 rr                lda (z80_ix),y
002B27  3  38                   sec
002B28  3  E9 02                sbc #2
002B2A  3  91 rr                sta (z80_ix),y
002B2C  3  4C 35 2B             jmp b00078
002B2F  3  A9 01        b00064: lda #1
002B31  3  A0 0A                ldy #10
002B33  3  91 rr                sta (z80_ix),y
002B35  3  4C 52 2B     b00078: jmp b00136
002B38  3  20 BA 1E     b00082: jsr cangd
002B3B  3  F0 03                beq :+
002B3D  3  4C 4C 2B             jmp b00123
002B40  3               :
002B40  3  A0 08                ldy #8
002B42  3  B1 rr                lda (z80_ix),y
002B44  3  18                   clc
002B45  3  69 02                adc #2
002B47  3  91 rr                sta (z80_ix),y
002B49  3  4C 52 2B             jmp b00136
002B4C  3  A9 00        b00123: lda #0
002B4E  3  A0 0A                ldy #10
002B50  3  91 rr                sta (z80_ix),y
002B52  3  A9 00        b00136: lda #0
002B54  3  A0 0B                ldy #11
002B56  3  D1 rr                cmp (z80_ix),y
002B58  3  F0 03                beq *+5
002B5A  3  4C 7A 2B             jmp b00217
002B5D  3  20 EF 1E             jsr cangl
002B60  3  F0 03                beq :+
002B62  3  4C 71 2B             jmp b00199
002B65  3               :
002B65  3  A0 09                ldy #9
002B67  3  B1 rr                lda (z80_ix),y
002B69  3  38                   sec
002B6A  3  E9 02                sbc #2
002B6C  3  91 rr                sta (z80_ix),y
002B6E  3  4C 77 2B             jmp b00212
002B71  3  A9 01        b00199: lda #1
002B73  3  A0 0B                ldy #11
002B75  3  91 rr                sta (z80_ix),y
002B77  3  4C 94 2B     b00212: jmp b00271
002B7A  3  20 01 1F     b00217: jsr cangr
002B7D  3  F0 03                beq :+
002B7F  3  4C 8E 2B             jmp b00257
002B82  3               :
002B82  3  A0 09                ldy #9
002B84  3  B1 rr                lda (z80_ix),y
002B86  3  18                   clc
002B87  3  69 02                adc #2
002B89  3  91 rr                sta (z80_ix),y
002B8B  3  4C 94 2B             jmp b00271
002B8E  3  A9 00        b00257: lda #0
002B90  3  A0 0B                ldy #11
002B92  3  91 rr                sta (z80_ix),y
002B94  3               b00271: ; SPRITEINK command
002B94  3  A9 00                lda #0
002B96  3  20 CB 24             jsr animsp
002B99  3  A9 00                lda #0
002B9B  3  85 rr                sta z80_b
002B9D  3  20 16 25             jsr sktyp
002BA0  3  B0 03                bcs :+
002BA2  3  4C A9 2B             jmp b00316
002BA5  3               :
002BA5  3  A9 01                lda #1
002BA7  3  85 rr                sta deadf
002BA9  3  60           b00316: rts
002BAA  3               .out .sprintf("EVENT 1 SIZE = %d", (* - evnt01))
002BAA  3               
002BAA  3               evnt02:
002BAA  3  60                   rts
002BAB  3               .out .sprintf("EVENT 2 SIZE = %d", (* - evnt02))
002BAB  3               
002BAB  3               evnt03:
002BAB  3  60                   rts
002BAC  3               .out .sprintf("EVENT 3 SIZE = %d", (* - evnt03))
002BAC  3               
002BAC  3               evnt04:
002BAC  3  60                   rts
002BAD  3               .out .sprintf("EVENT 4 SIZE = %d", (* - evnt04))
002BAD  3               
002BAD  3               evnt05:
002BAD  3  60                   rts
002BAE  3               .out .sprintf("EVENT 5 SIZE = %d", (* - evnt05))
002BAE  3               
002BAE  3               evnt06:
002BAE  3  60                   rts
002BAF  3               .out .sprintf("EVENT 6 SIZE = %d", (* - evnt06))
002BAF  3               
002BAF  3               evnt07:
002BAF  3  60                   rts
002BB0  3               .out .sprintf("EVENT 7 SIZE = %d", (* - evnt07))
002BB0  3               
002BB0  3               evnt08:
002BB0  3  60                   rts
002BB1  3               .out .sprintf("EVENT 8 SIZE = %d", (* - evnt08))
002BB1  3               
002BB1  3               evnt09:
002BB1  3  60                   rts
002BB2  3               .out .sprintf("EVENT 9 SIZE = %d", (* - evnt09))
002BB2  3               
002BB2  3               evnt10:
002BB2  3  A9 00                lda #0
002BB4  3  C5 rr                cmp scno
002BB6  3  F0 03                beq *+5
002BB8  3  4C C9 2B             jmp k00049
002BBB  3                       ; lda #0
002BBB  3  20 4D 1A             jsr gotob
002BBE  3  C9 FF                cmp #255
002BC0  3  F0 03                beq :+
002BC2  3  4C C9 2B             jmp k00049
002BC5  3               :
002BC5  3  A9 01                lda #1
002BC7  3  85 rr                sta gamwon
002BC9  3  60           k00049: rts
002BCA  3               .out .sprintf("EVENT 10 SIZE = %d", (* - evnt10))
002BCA  3               
002BCA  3               evnt11:
002BCA  3  60                   rts
002BCB  3               .out .sprintf("EVENT 11 SIZE = %d", (* - evnt11))
002BCB  3               
002BCB  3               evnt12:
002BCB  3                       ; COLOUR command
002BCB  3  20 9F 11             jsr cls
002BCE  3  A9 04                lda #4
002BD0  3  85 rr                sta chary
002BD2  3  A9 08                lda #8
002BD4  3  85 rr                sta charx
002BD6  3  A9 00                lda #0
002BD8  3  20 5F 21             jsr dmsg
002BDB  3  A9 08                lda #8
002BDD  3  85 rr                sta chary
002BDF  3                       ; lda #8
002BDF  3  85 rr                sta charx
002BE1  3  A9 01                lda #1
002BE3  3  20 5F 21             jsr dmsg
002BE6  3  A9 0A                lda #10
002BE8  3  85 rr                sta chary
002BEA  3  A9 08                lda #8
002BEC  3  85 rr                sta charx
002BEE  3  A9 02                lda #2
002BF0  3  20 5F 21             jsr dmsg
002BF3  3  A9 0C                lda #12
002BF5  3  85 rr                sta chary
002BF7  3  A9 08                lda #8
002BF9  3  85 rr                sta charx
002BFB  3  A9 03                lda #3
002BFD  3  20 5F 21             jsr dmsg
002C00  3  A9 0E                lda #14
002C02  3  85 rr                sta chary
002C04  3  A9 08                lda #8
002C06  3  85 rr                sta charx
002C08  3  A9 04                lda #4
002C0A  3  20 5F 21             jsr dmsg
002C0D  3                       ; INK command
002C0D  3  A9 00                lda #0
002C0F  3  85 rr                sta chary
002C11  3  A9 01                lda #1
002C13  3  85 rr                sta charx
002C15  3  A9 1E                lda #30
002C17  3  85 rr                sta z80_c
002C19  3  A9 05                lda #5
002C1B  3  85 rr                sta z80_b
002C1D  3  20 B2 29             jsr iscrly
002C20  3  20 6D 0E             jsr prskey
002C23  3  A9 60                lda #96
002C25  3  8D 00 29             sta scrly
002C28  3  A0 07                ldy #7
002C2A  3  B9 3E 34             lda keys,y
002C2D  3  20 CC 0E             jsr ktest
002C30  3  90 03                bcc :+
002C32  3  4C 39 2C             jmp m00223
002C35  3               :
002C35  3  A9 00                lda #0
002C37  3  85 rr                sta contrl
002C39  3  A0 08        m00223: ldy #8
002C3B  3  B9 3E 34             lda keys,y
002C3E  3  20 CC 0E             jsr ktest
002C41  3  90 03                bcc :+
002C43  3  4C 4A 2C             jmp m00253
002C46  3               :
002C46  3  A9 01                lda #1
002C48  3  85 rr                sta contrl
002C4A  3  A0 09        m00253: ldy #9
002C4C  3  B9 3E 34             lda keys,y
002C4F  3  20 CC 0E             jsr ktest
002C52  3  90 03                bcc :+
002C54  3  4C 5B 2C             jmp m00284
002C57  3               :
002C57  3  A9 02                lda #2
002C59  3  85 rr                sta contrl
002C5B  3  A0 0A        m00284: ldy #10
002C5D  3  B9 3E 34             lda keys,y
002C60  3  20 CC 0E             jsr ktest
002C63  3  90 03                bcc :+
002C65  3  4C ED 2C             jmp m00559
002C68  3               :
002C68  3  A9 32                lda #50
002C6A  3  20 F7 0E             jsr delay
002C6D  3  20 9F 11             jsr cls
002C70  3                       ; INK command
002C70  3  A9 02                lda #2
002C72  3  85 rr                sta chary
002C74  3  A9 04                lda #4
002C76  3  85 rr                sta charx
002C78  3  A9 06                lda #6
002C7A  3  20 5F 21             jsr dmsg
002C7D  3  A9 05                lda #5
002C7F  3  85 rr                sta chary
002C81  3  A9 0F                lda #15
002C83  3  85 rr                sta charx
002C85  3                       ; INK command
002C85  3  A9 07                lda #7
002C87  3  20 5F 21             jsr dmsg
002C8A  3  A9 03                lda #3
002C8C  3  AA                   tax
002C8D  3  20 E5 0E             jsr kget
002C90  3  9D 3E 34             sta keys,x
002C93  3  A9 19                lda #25
002C95  3  20 F7 0E             jsr delay
002C98  3  A9 07                lda #7
002C9A  3  85 rr                sta chary
002C9C  3  A9 0E                lda #14
002C9E  3  85 rr                sta charx
002CA0  3  A9 08                lda #8
002CA2  3  20 5F 21             jsr dmsg
002CA5  3  A9 02                lda #2
002CA7  3  AA                   tax
002CA8  3  20 E5 0E             jsr kget
002CAB  3  9D 3E 34             sta keys,x
002CAE  3  A9 19                lda #25
002CB0  3  20 F7 0E             jsr delay
002CB3  3  A9 09                lda #9
002CB5  3  85 rr                sta chary
002CB7  3  A9 0E                lda #14
002CB9  3  85 rr                sta charx
002CBB  3  A9 09                lda #9
002CBD  3  20 5F 21             jsr dmsg
002CC0  3  A9 01                lda #1
002CC2  3  AA                   tax
002CC3  3  20 E5 0E             jsr kget
002CC6  3  9D 3E 34             sta keys,x
002CC9  3  A9 19                lda #25
002CCB  3  20 F7 0E             jsr delay
002CCE  3  A9 0B                lda #11
002CD0  3  85 rr                sta chary
002CD2  3  A9 0D                lda #13
002CD4  3  85 rr                sta charx
002CD6  3  A9 0A                lda #10
002CD8  3  20 5F 21             jsr dmsg
002CDB  3  A9 00                lda #0
002CDD  3  AA                   tax
002CDE  3  20 E5 0E             jsr kget
002CE1  3  9D 3E 34             sta keys,x
002CE4  3  A9 19                lda #25
002CE6  3  20 F7 0E             jsr delay
002CE9  3  A9 00                lda #0
002CEB  3  85 rr                sta contrl
002CED  3  20 9F 11     m00559: jsr cls
002CF0  3  60                   rts
002CF1  3               .out .sprintf("EVENT 12 SIZE = %d", (* - evnt12))
002CF1  3               
002CF1  3               evnt13:
002CF1  3  A9 03                lda #3
002CF3  3  85 rr                sta numlif
002CF5  3  60                   rts
002CF6  3               .out .sprintf("EVENT 13 SIZE = %d", (* - evnt13))
002CF6  3               
002CF6  3               evnt14:
002CF6  3                       ; INK command
002CF6  3  A9 02                lda #2
002CF8  3  85 rr                sta chary
002CFA  3  A9 01                lda #1
002CFC  3  85 rr                sta charx
002CFE  3  A9 0B                lda #11
002D00  3  20 5F 21             jsr dmsg
002D03  3                       ; INK command
002D03  3  A9 03                lda #3
002D05  3  85 rr                sta chary
002D07  3                       ; lda #3
002D07  3  85 rr                sta charx
002D09  3  A5 rr                lda numlif
002D0B  3  20 A6 25             jsr disply
002D0E  3  60                   rts
002D0F  3               .out .sprintf("EVENT 14 SIZE = %d", (* - evnt14))
002D0F  3               
002D0F  3               evnt15:
002D0F  3  60                   rts
002D10  3               .out .sprintf("EVENT 15 SIZE = %d", (* - evnt15))
002D10  3               
002D10  3               evnt16:
002D10  3  A5 rr                lda numlif
002D12  3  38                   sec
002D13  3  E9 01                sbc #1
002D15  3  85 rr                sta numlif
002D17  3  60                   rts
002D18  3               .out .sprintf("EVENT 16 SIZE = %d", (* - evnt16))
002D18  3               
002D18  3               evnt17:
002D18  3  A9 0B                lda #11
002D1A  3  85 rr                sta chary
002D1C  3  A9 10                lda #16
002D1E  3  85 rr                sta charx
002D20  3  A9 0C                lda #12
002D22  3  20 5F 21             jsr dmsg
002D25  3  A9 0C                lda #12
002D27  3  85 rr                sta chary
002D29  3  A9 10                lda #16
002D2B  3  85 rr                sta charx
002D2D  3  A9 0D                lda #13
002D2F  3  20 5F 21             jsr dmsg
002D32  3  60                   rts
002D33  3               .out .sprintf("EVENT 17 SIZE = %d", (* - evnt17))
002D33  3               
002D33  3               evnt18:
002D33  3  20 9F 11             jsr cls
002D36  3                       ; INK command
002D36  3                       ; PAPER command
002D36  3  A9 05                lda #5
002D38  3  85 rr                sta chary
002D3A  3  A9 0A                lda #10
002D3C  3  85 rr                sta charx
002D3E  3  A9 0E                lda #14
002D40  3  20 5F 21             jsr dmsg
002D43  3  A9 96                lda #150
002D45  3  20 F7 0E             jsr delay
002D48  3  60                   rts
002D49  3               .out .sprintf("EVENT 18 SIZE = %d", (* - evnt18))
002D49  3               
002D49  3               evnt19:
002D49  3  A9 04                lda #4
002D4B  3  85 rr                sta chary
002D4D  3  A9 09                lda #9
002D4F  3  85 rr                sta charx
002D51  3  A9 0F                lda #15
002D53  3  20 5F 21             jsr dmsg
002D56  3  60                   rts
002D57  3               .out .sprintf("EVENT 19 SIZE = %d", (* - evnt19))
002D57  3               
002D57  3               evnt20:
002D57  3  60                   rts
002D58  3               .out .sprintf("EVENT 20 SIZE = %d", (* - evnt20))
002D58  3               
002D58  3  60           ptcusr: rts
002D59  3               script_end:
002D59  3               
002D59  3               .out .sprintf("TOTAL SCRIPT SIZE = %d", (* - script_start))
002D59  3               
002D59  3               data_start:
002D59  3               msgdat:
002D59  3  53 49 4D 50          .byte "SIMPLE TEST GAM",197
002D5D  3  4C 45 20 54  
002D61  3  45 53 54 20  
002D69  3  31 2E 20 4B          .byte "1. KEYBOAR",196
002D6D  3  45 59 42 4F  
002D71  3  41 52 C4     
002D74  3  32 2E 20 4A          .byte "2. JOYSTICK ",176
002D78  3  4F 59 53 54  
002D7C  3  49 43 4B 20  
002D81  3  33 2E 20 4A          .byte "3. JOYSTICK ",177
002D85  3  4F 59 53 54  
002D89  3  49 43 4B 20  
002D8E  3  34 2E 20 52          .byte "4. REDEFINE KEY",211
002D92  3  45 44 45 46  
002D96  3  49 4E 45 20  
002D9E  3  43 4F 4C 4C          .byte "COLLECT THE BARREL THEN RETURN TO THE START SCREEN",160
002DA2  3  45 43 54 20  
002DA6  3  54 48 45 20  
002DD1  3  50 52 45 53          .byte "PRESS KEY FOR",186
002DD5  3  53 20 4B 45  
002DD9  3  59 20 46 4F  
002DDF  3  55 D0                .byte "U",208
002DE1  3  44 4F 57 CE          .byte "DOW",206
002DE5  3  4C 45 46 D4          .byte "LEF",212
002DE9  3  52 49 47 48          .byte "RIGH",212
002DED  3  D4           
002DEE  3  4C 49 56 45          .byte "LIVE",211
002DF2  3  D3           
002DF3  3  47 41 4D C5          .byte "GAM",197
002DF7  3  4F 56 45 D2          .byte "OVE",210
002DFB  3  43 4F 4E 47          .byte "CONGRATULATIONS",161
002DFF  3  52 41 54 55  
002E03  3  4C 41 54 49  
002E0B  3  4E 45 57 20          .byte "NEW HIGH SCOR",197
002E0F  3  48 49 47 48  
002E13  3  20 53 43 4F  
002E19  3               nummsg:
002E19  3  10                   .byte 16
002E1A  3               .out .sprintf("MESSAGE SIZE = %d", (* - msgdat))
002E1A  3               
002E1A  3               chgfx:
002E1A  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002E1E  3  00 00 00 00  
002E22  3  FE FE FE 00          .byte 254,254,254,0,239,239,239,0
002E26  3  EF EF EF 00  
002E2A  3               bprop:
002E2A  3  00                   .byte 0
002E2B  3  02                   .byte 2
002E2C  3               .out .sprintf("BLOCKS SIZE = %d", (* - chgfx))
002E2C  3               
002E2C  3               sprgfx:
002E2C  3  07 E0 1F F8          .byte 7,224,31,248,63,252,127,254,127,254,255,255,255,255,255,255,255,255,255,255,255,255,127,254,127,254,63,252,31,248,7,224
002E30  3  3F FC 7F FE  
002E34  3  7F FE FF FF  
002E4C  3  01 F8 07 FE          .byte 1,248,7,254,15,255,159,255,159,255,255,255,255,255,255,255,255,255,255,255,255,255,159,255,159,255,15,255,7,254,1,248
002E50  3  0F FF 9F FF  
002E54  3  9F FF FF FF  
002E6C  3  00 7E 81 FF          .byte 0,126,129,255,195,255,231,255,231,255,255,255,255,255,255,255,255,255,255,255,255,255,231,255,231,255,195,255,129,255,0,126
002E70  3  C3 FF E7 FF  
002E74  3  E7 FF FF FF  
002E8C  3  80 1F E0 7F          .byte 128,31,224,127,240,255,249,255,249,255,255,255,255,255,255,255,255,255,255,255,255,255,249,255,249,255,240,255,224,127,128,31
002E90  3  F0 FF F9 FF  
002E94  3  F9 FF FF FF  
002EAC  3  FF FF 80 01          .byte 255,255,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,128,1,255,255
002EB0  3  80 01 80 01  
002EB4  3  80 01 80 01  
002ECC  3  FF FF 60 00          .byte 255,255,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,96,0,255,255
002ED0  3  60 00 60 00  
002ED4  3  60 00 60 00  
002EEC  3  FF FF 18 00          .byte 255,255,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,24,0,255,255
002EF0  3  18 00 18 00  
002EF4  3  18 00 18 00  
002F0C  3  FF FF 06 00          .byte 255,255,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,6,0,255,255
002F10  3  06 00 06 00  
002F14  3  06 00 06 00  
002F2C  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
002F30  3  FF FF FF FF  
002F34  3  FF FF FF FF  
002F4C  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
002F50  3  FF FF FF FF  
002F54  3  FF FF FF FF  
002F6C  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
002F70  3  FF FF FF FF  
002F74  3  FF FF FF FF  
002F8C  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255
002F90  3  FF FF FF FF  
002F94  3  FF FF FF FF  
002FAC  3               frmlst:
002FAC  3  00 01                .byte 0,1
002FAE  3  01 02 03 00          .byte 1,2,3,0
002FB2  3               .out .sprintf("SPRITES SIZE = %d", (* - sprgfx))
002FB2  3               
002FB2  3               scdat:
002FB2  3  64 00 6A 00          .word 100,106,110
002FB6  3  6E 00        
002FB8  3  FF 01 17 FF          .byte 255,1,23,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1
002FBC  3  00 14 01 01  
002FC0  3  FF 00 14 01  
002FD9  3  FF 00 14 01          .byte 255,0,20,1,1,255,0,20,1,255,0,21,1,255,0,21,1,255,0,21,1,255,0,21,1,1,255,0,20,1,1,255,0,20
002FDD  3  01 FF 00 14  
002FE1  3  01 FF 00 15  
002FFB  3  01 01 FF 00          .byte 1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,255,1,23
002FFF  3  14 01 01 FF  
003003  3  00 14 01 01  
00301C  3  FF 01 17 FF          .byte 255,1,23,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1
003020  3  00 14 01 01  
003024  3  FF 00 14 01  
00303D  3  FF 00 14 01          .byte 255,0,20,1,1,255,0,20,1,1,255,0,21,1,255,0,21,1,255,0,21,1,255,0,21,1,255,0,20,1,1,255,0,20
003041  3  01 FF 00 14  
003045  3  01 01 FF 00  
00305F  3  01 01 FF 00          .byte 1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,255,1,10
003063  3  14 01 01 FF  
003067  3  00 14 01 01  
003080  3  FF 00 04 FF          .byte 255,0,4,255,1,9
003084  3  01 09        
003086  3  FF 01 09 FF          .byte 255,1,9,255,0,4,255,1,10,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1
00308A  3  00 04 FF 01  
00308E  3  0A FF 00 14  
0030A8  3  FF 00 14 01          .byte 255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20
0030AC  3  01 FF 00 14  
0030B0  3  01 01 FF 00  
0030C9  3  01 01 FF 00          .byte 1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20,1,1,255,0,20
0030CD  3  14 01 01 FF  
0030D1  3  00 14 01 01  
0030EC  3  01 01 FF 00          .byte 1,1,255,0,20,255,1,23
0030F0  3  14 FF 01 17  
0030F4  3               numsc:
0030F4  3  03                   .byte 3
0030F5  3               .out .sprintf("SCREENS SIZE = %d", (* - scdat))
0030F5  3               
0030F5  3               nmedat:
0030F5  3  00 00 80 80          .byte 0,0,128,128,1,1,32,88,255
0030F9  3  01 01 20 58  
0030FD  3  FF           
0030FE  3  00 00 80 80          .byte 0,0,128,128,1,1,88,160,1,1,136,96,255
003102  3  01 01 58 A0  
003106  3  01 01 88 60  
00310B  3  00 00 80 80          .byte 0,0,128,128,1,1,88,160,0,0,128,128,255
00310F  3  01 01 58 A0  
003113  3  00 00 80 80  
003118  3               .out .sprintf("POSITIONS SIZE = %d", (* - nmedat))
003118  3               
003118  3               NUMOBJ = 1
003118  3               objdta:
003118  3  1F F0 2A A8          .byte 31,240,42,168,86,212,64,4,128,2,182,218,182,218,182,218,182,218,182,218,182,218,128,2,64,4,86,212,42,168,31,240,2,160,104,2,160,104
00311C  3  56 D4 40 04  
003120  3  80 02 B6 DA  
00313E  3               .out .sprintf("OBJECTS SIZE = %d", (* - objdta))
00313E  3               
00313E  3               font:
00313E  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003142  3  00 00 00 00  
003146  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
00314A  3  30 00 30 00  
00314E  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
003152  3  00 00 00 00  
003156  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
00315A  3  6C FE 6C 00  
00315E  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
003162  3  7E 1E 7E 18  
003166  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
00316A  3  30 6E CE 00  
00316E  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
003172  3  7E CC 7E 00  
003176  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
00317A  3  00 00 00 00  
00317E  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
003182  3  18 18 0C 00  
003186  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
00318A  3  30 30 60 00  
00318E  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
003192  3  7E 18 3C 00  
003196  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
00319A  3  7E 18 18 00  
00319E  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0031A2  3  00 18 18 30  
0031A6  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
0031AA  3  7E 00 00 00  
0031AE  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
0031B2  3  00 38 38 00  
0031B6  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
0031BA  3  18 30 60 00  
0031BE  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
0031C2  3  F6 E6 7C 00  
0031C6  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
0031CA  3  18 18 7E 00  
0031CE  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
0031D2  3  7C C0 FE 00  
0031D6  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
0031DA  3  06 C6 7C 00  
0031DE  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
0031E2  3  D8 FE 18 00  
0031E6  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
0031EA  3  06 C6 7C 00  
0031EE  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
0031F2  3  C6 C6 7C 00  
0031F6  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
0031FA  3  18 30 30 00  
0031FE  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
003202  3  C6 C6 7C 00  
003206  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
00320A  3  7E 06 7C 00  
00320E  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
003212  3  00 00 30 00  
003216  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
00321A  3  00 30 30 60  
00321E  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003222  3  30 18 0C 00  
003226  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
00322A  3  00 7E 00 00  
00322E  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
003232  3  0C 18 30 00  
003236  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
00323A  3  18 00 18 00  
00323E  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
003242  3  FE C0 7C 00  
003246  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
00324A  3  FE C6 C6 00  
00324E  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
003252  3  C6 C6 FC 00  
003256  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
00325A  3  C0 C6 7C 00  
00325E  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
003262  3  C6 CC F8 00  
003266  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
00326A  3  C0 C0 FE 00  
00326E  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
003272  3  C0 C0 C0 00  
003276  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
00327A  3  DE C6 7C 00  
00327E  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
003282  3  C6 C6 C6 00  
003286  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
00328A  3  18 18 7E 00  
00328E  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
003292  3  C6 C6 7C 00  
003296  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
00329A  3  D8 CC C6 00  
00329E  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
0032A2  3  C0 C0 FE 00  
0032A6  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
0032AA  3  C6 C6 C6 00  
0032AE  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
0032B2  3  DE CE C6 00  
0032B6  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
0032BA  3  C6 C6 7C 00  
0032BE  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
0032C2  3  FC C0 C0 00  
0032C6  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
0032CA  3  F6 DE 7C 00  
0032CE  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
0032D2  3  FC CC C6 00  
0032D6  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
0032DA  3  06 C6 7C 00  
0032DE  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
0032E2  3  30 30 30 00  
0032E6  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
0032EA  3  C6 C6 7C 00  
0032EE  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
0032F2  3  C6 6C 38 00  
0032F6  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
0032FA  3  C6 FE 6C 00  
0032FE  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
003302  3  38 6C C6 00  
003306  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
00330A  3  30 30 30 00  
00330E  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
003312  3  30 60 FE 00  
003316  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
00331A  3  18 18 1E 00  
00331E  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003322  3  30 18 0C 00  
003326  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
00332A  3  30 30 F0 00  
00332E  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
003332  3  30 30 30 00  
003336  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
00333A  3  00 00 00 FF  
00333E  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
003342  3  60 60 FE 00  
003346  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
00334A  3  7C CC 7C 00  
00334E  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
003352  3  66 66 7C 00  
003356  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
00335A  3  60 60 3C 00  
00335E  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
003362  3  CC CC 7C 00  
003366  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
00336A  3  F8 C0 7C 00  
00336E  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
003372  3  30 30 30 00  
003376  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
00337A  3  CC 7C 0C 78  
00337E  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
003382  3  CC CC CC 00  
003386  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
00338A  3  30 30 78 00  
00338E  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
003392  3  0C 0C 6C 38  
003396  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
00339A  3  70 78 6C 00  
00339E  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
0033A2  3  30 30 1C 00  
0033A6  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
0033AA  3  FC FC FC 00  
0033AE  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
0033B2  3  CC CC CC 00  
0033B6  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
0033BA  3  CC CC 78 00  
0033BE  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
0033C2  3  CC F8 C0 C0  
0033C6  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
0033CA  3  CC 7C 0C 0E  
0033CE  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
0033D2  3  60 60 60 00  
0033D6  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
0033DA  3  78 0C F8 00  
0033DE  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
0033E2  3  30 30 1C 00  
0033E6  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
0033EA  3  CC CC 78 00  
0033EE  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
0033F2  3  78 78 30 00  
0033F6  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
0033FA  3  FC FC 78 00  
0033FE  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003402  3  30 78 CC 00  
003406  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
00340A  3  CC 7C 0C 78  
00340E  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003412  3  30 60 FC 00  
003416  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
00341A  3  18 18 1E 00  
00341E  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003422  3  18 18 18 00  
003426  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
00342A  3  30 30 F0 00  
00342E  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
003432  3  00 00 00 00  
003436  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
00343A  3  E3 BB C6 7C  
00343E  3               .out .sprintf("FONT SIZE = %d", (* - font))
00343E  3               
00343E  3  42 61 68 48  keys:   .byte 66,97,104,72,98,16,55,48,49,17,18
003442  3  62 10 37 30  
003446  3  31 11 12     
003449  3               .out .sprintf("KEYS SIZE = %d", (* - keys))
003449  3               
003449  3               data_end:
003449  3               .out .sprintf("TOTAL DATA SIZE = %d", (* - data_start))
003449  3               
003449  2               
003449  1               
003449  1               end_asm:
003449  1               
003449  1               ;----------------------------------------------------------------------
003449  1               ; RELOCATION OF BEEB CODE FROM LOAD ADDRESS
003449  1               ;----------------------------------------------------------------------
003449  1               
003449  1               relocate:
003449  1               ; Issue *TAPE otherwise DFS goes mental that we've overwritten workspace from &E00 - &1100
003449  1               
003449  1  A9 8C            lda #$8C
00344B  1  A2 0C            ldx #$0C
00344D  1  A0 00            ldy #$00
00344F  1  20 F4 FF         jsr OSBYTE					; *FX &8C,0,0 - *TAPE 1200
003452  1               
003452  1               ; Other one off initialisation could happen here...
003452  1               
003452  1               ; Relocate all code down to &E00
003452  1  A2 27        	ldx #>(end_asm - start_asm) + 1
003454  1  A0 00        	ldy #0
003456  1               reloop:
003456  1  B9 00 12     	lda load_address, y
003459  1  99 00 0E     	sta asm_code, y
00345C  1  C8           	iny
00345D  1  D0 F7        	bne reloop
00345F  1  EE 58 38     	inc reloop + 2 + load_address - asm_code
003462  1  EE 5B 38     	inc reloop + 5 + load_address - asm_code
003465  1  CA           	dex
003466  1  D0 EE        	bne reloop
003468  1  4C 03 0E     	jmp boot_game
003468  1               
