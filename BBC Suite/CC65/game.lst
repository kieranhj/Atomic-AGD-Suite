ca65 V2.17 - Git cc5c093
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; BBC AGD Engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ; BBC Micro version by Kieran Connell 2018
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .DEFINE asm_code $0e00		; assembly address _BEEB
000000r 1               .DEFINE load_address $1200	; load address _BEEB
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; BBC MICRO PLATFORM DEFINES
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; _BEEB MOS calls
000000r 1               
000000r 1               	OSBYTE	 = $fff4
000000r 1               	OSFILE	 = $ffdd
000000r 1               	OSWRCH	 = $ffee
000000r 1               	OSASCI	 = $ffe3
000000r 1               	OSWORD	 = $fff1
000000r 1               	OSFIND	 = $ffce
000000r 1               	OSGBPB	 = $ffd1
000000r 1               	OSARGS	 = $ffda
000000r 1               
000000r 1               	EVENTV	 = $0220
000000r 1               
000000r 1               	PAL_black = 0 ^ 7
000000r 1               	PAL_red = 1 ^ 7
000000r 1               	PAL_green = 2 ^ 7
000000r 1               	PAL_yellow = 3 ^ 7
000000r 1               	PAL_blue = 4 ^ 7
000000r 1               	PAL_magenta = 5 ^ 7
000000r 1               	PAL_cyan = 6 ^ 7
000000r 1               	PAL_white = 7 ^ 7
000000r 1               
000000r 1               ; System constants
000000r 1               
000000r 1               	ScreenSize  = $1800	; Startaddress video RAM _BEEB
000000r 1               	ScreenAddr 	= $8000 - ScreenSize	; Screen size bytes _BEEB
000000r 1               	ScreenRowBytes = 256				; 40 columns
000000r 1               
000000r 1               	SpriteMaxY	= 177	; used for clipping bottom of screen
000000r 1               
000000r 1               ; AGD Engine Workspace
000000r 1               
000000r 1               	MAP 		= $300				; properties map buffer (3x256 bytes)
000000r 1               	SCADTB_lb	= MAP + $300
000000r 1               	SCADTB_hb	= SCADTB_lb + $100
000000r 1               
000000r 1               .if pflag
000000r 1                   SHRAPN 		= $B00 - (NUMSHR * SHRSIZ)	; shrapnel table (55x6 bytes)
000000r 1               .endif
000000r 1               
000000r 1               	sprtab		= $B00				; NUMSPR*TABSIZ
000000r 1               
000000r 1               	.macro DEBUG_PAL pal
000000r 1               	;	SET_PAL pal
000000r 1               	.endmacro
000000r 1               
000000r 1               	.macro SET_PAL pal
000000r 1               		lda #$00+pal
000000r 1               		sta $fe21
000000r 1               		lda #$10+pal
000000r 1               		sta $fe21
000000r 1               		lda #$20+pal
000000r 1               		sta $fe21
000000r 1               		lda #$30+pal
000000r 1               		sta $fe21
000000r 1               		lda #$40+pal
000000r 1               		sta $fe21
000000r 1               		lda #$50+pal
000000r 1               		sta $fe21
000000r 1               		lda #$60+pal
000000r 1               		sta $fe21
000000r 1               		lda #$70+pal
000000r 1               		sta $fe21
000000r 1               	.endmacro
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; ZERO PAGE SEGMENT
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               
000000r 1               .include "z80-zp.inc"
000000r 2               ;ws	 = $60
000000r 2               
000000r 2  xx           z80_f: .res 1;	 = ws+$00
000001r 2  xx           z80_a: .res 1;	 = ws+$01
000002r 2               z80_af	 = z80_f
000002r 2               
000002r 2  xx           z80_c: .res 1;	 = ws+$02
000003r 2  xx           z80_b: .res 1;	 = ws+$03
000004r 2               z80_bc	 = z80_c
000004r 2               
000004r 2  xx           z80_e: .res 1;	 = ws+$04
000005r 2  xx           z80_d: .res 1;	 = ws+$05
000006r 2               z80_de	 = z80_e
000006r 2               
000006r 2  xx           z80_l: .res 1;	 = ws+$06
000007r 2  xx           z80_h: .res 1;	 = ws+$07
000008r 2               z80_hl	 = z80_l
000008r 2               
000008r 2  xx           z80_x: .res 1;    = ws+$08
000009r 2  xx           z80_i: .res 1;    = ws+$09
00000Ar 2               z80_ix	 = z80_x
00000Ar 2               
00000Ar 2  xx xx        z80_iy: .res 2;	 = ws+$0a
00000Cr 2               
00000Cr 2  xx           z80_fp: .res 1;	 = ws+$0c
00000Dr 2  xx           z80_ap: .res 1;	 = ws+$0d
00000Er 2               
00000Er 2  xx           z80_cp: .res 1;	 = ws+$0e
00000Fr 2  xx           z80_bp: .res 1;	 = ws+$0f
000010r 2               z80_bcp	 = z80_cp
000010r 2               
000010r 2  xx           z80_ep: .res 1;	 = ws+$10
000011r 2  xx           z80_dp: .res 1;	 = ws+$11
000012r 2               z80_dep	 = z80_ep
000012r 2               
000012r 2  xx           z80_lp: .res 1;	 = ws+$12
000013r 2  xx           z80_hp: .res 1;	 = ws+$13
000014r 2               z80_hlp	 = z80_lp
000014r 2               
000014r 2  xx xx        z80_sp: .res 2;   = ws+$14
000016r 2               
000016r 2  xx           z80_reg0: .res 1; = ws+$16
000017r 2  xx           z80_reg1: .res 1; = ws+$17
000018r 2  xx           z80_reg2: .res 1; = ws+$18
000019r 2  xx           z80_reg3: .res 1; = ws+$19
00001Ar 2               
00001Ar 2               ;z80_r: .res 1;	 = ws+$1a
00001Ar 2               
00001Ar 1               .include "engine-zp.inc"
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               ; AGD 6502 Engine Zero Page Variables
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               
00001Ar 2               ; Variables start here.
00001Ar 2               
00001Ar 2  xx           scno:	.res 1			; present screen number.
00001Br 2  xx           numlif:	.res 1			; number of lives.
00001Cr 2               
00001Cr 2  xx           vara:	.res 1			; general-purpose variable.
00001Dr 2  xx           varb:	.res 1			; general-purpose variable.
00001Er 2  xx           varc:	.res 1			; general-purpose variable.
00001Fr 2  xx           vard:	.res 1			; general-purpose variable.
000020r 2  xx           vare:	.res 1			; general-purpose variable.
000021r 2  xx           varf:	.res 1			; general-purpose variable.
000022r 2  xx           varg:	.res 1			; general-purpose variable.
000023r 2  xx           varh:	.res 1			; general-purpose variable.
000024r 2  xx           vari:	.res 1			; general-purpose variable.
000025r 2  xx           varj:	.res 1			; general-purpose variable.
000026r 2  xx           vark:	.res 1			; general-purpose variable.
000027r 2  xx           varl:	.res 1			; general-purpose variable.
000028r 2  xx           varm:	.res 1			; general-purpose variable.
000029r 2  xx           varn:	.res 1			; general-purpose variable.
00002Ar 2  xx           varo:	.res 1			; general-purpose variable.
00002Br 2  xx           varp:	.res 1			; general-purpose variable.
00002Cr 2  xx           varq:	.res 1			; general-purpose variable.
00002Dr 2  xx           varr:	.res 1			; general-purpose variable.
00002Er 2  xx           vars:	.res 1			; general-purpose variable.
00002Fr 2  xx           vart:	.res 1			; general-purpose variable.
000030r 2  xx           varu:	.res 1			; general-purpose variable.
000031r 2  xx           varv:	.res 1			; general-purpose variable.
000032r 2  xx           varw:	.res 1			; general-purpose variable.
000033r 2  xx           varz:	.res 1			; general-purpose variable.
000034r 2               
000034r 2  xx           charx:	.res 1			; cursor x position.
000035r 2  xx           chary:	.res 1			; cursor y position.
000036r 2               
000036r 2  xx           clock:	.res 1			; last clock reading.
000037r 2  xx           varrnd:	.res 1	        ; last random number.
000038r 2  xx           varobj:	.res 1  	    ; last object number.
000039r 2  xx           varopt:	.res 1     		; last option chosen from menu.
00003Ar 2  xx           varblk:	.res 1  		; block type.
00003Br 2  xx           nexlev:	.res 1			; next level flag.
00003Cr 2  xx           restfl:	.res 1			; restart screen flag.
00003Dr 2  xx           deadf:	.res 1			; dead flag.
00003Er 2  xx           gamwon:	.res 1			; game won flag.
00003Fr 2  xx           dispx:	.res 1			; cursor x position.
000040r 2  xx           dispy:	.res 1			; cursor y position.
000041r 2               
000041r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000042r 2  xx           joyval:	.res 1			; joystick reading.
000043r 2  xx           frmno:	.res 1			; selected frame.
000044r 2               
000044r 2               ;----------------------------------------------------
000044r 2               ; Missing vars
000044r 2               ;----------------------------------------------------
000044r 2               
000044r 2  xx           loopa:		.res 1
000045r 2  xx           loopb:		.res 1
000046r 2  xx           loopc:		.res 1
000047r 2  xx xx        FontPtr:    .res 2
000049r 2               
000049r 2               ; Local vars
000049r 2               
000049r 2  xx xx        scraddr:    .res 2
00004Br 2  xx xx        fntaddr:    .res 2
00004Dr 2  xx xx        tileaddr:   .res 2
00004Fr 2  xx xx        bufaddr:    .res 2
000051r 2               
000051r 2  xx xx        tmp:        .res 2
000053r 2  xx xx        scr_l:      .res 2
000055r 2  xx xx        scr_r:      .res 2
000057r 2  xx xx        scr_txt:    .res 2
000059r 2               
000059r 2  xx           xtmp:	    .res 1
00005Ar 2  xx           spcnt:	    .res 1
00005Br 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
00005Dr 2  xx           seed:	    .res 1		; seed for random numbers.
00005Er 2               
00005Er 2  xx           ccnt:       .res 1
00005Fr 2  xx           flag:	    .res 1
000060r 2  xx           rcol:	    .res 1
000061r 2  xx           rrow:	    .res 1
000062r 2               
000062r 2  xx           combyt:	    .res 1		; byte type compressed.
000063r 2  xx           comcnt:	    .res 1		; compression counter.
000064r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
000065r 2  xx           qscnt:	    .res 1
000066r 2               
000066r 2  xx           sprptr:	    .res 1      ; not a ptr
000067r 2  xx           sprcnt:	    .res 1
000068r 2               
000068r 2  xx xx        skptr:	    .res 2		; search pointer.
00006Ar 2  xx           sktptr:	    .res 1      ; not a ptr
00006Br 2  xx           tmproom:	.res 1
00006Cr 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
00006Er 2               
00006Er 2  xx xx xx     spr:	    .res 3      ; static sprite data
000071r 2  xx           vsync_count:.res 1
000072r 2  xx           colpatt:	.res 1
000073r 2  xx           sprtmp:     .res 1
000074r 2  xx           sprtmp2:    .res 1
000075r 2  xx           sprshft:    .res 1
000076r 2               
000076r 2               .if mflag
000076r 2               TmpAddr:	.res 2
000076r 2               bwid:	    .res 1     ; box/menu width.
000076r 2               blen:	    .res 1     ; box/menu height.
000076r 2               btop:	    .res 1     ; box coordinates.
000076r 2               blft:	    .res 1
000076r 2               .endif
000076r 2               
000076r 2               .if pflag
000076r 2               shrctr:	    .res 1
000076r 2               explcnt:	.res 1
000076r 2               seed3:	    .res 1
000076r 2               .endif
000076r 2               
000076r 1               
000076r 1               ;----------------------------------------------------------------------
000076r 1               ; ZCODE SEGMENT
000076r 1               ;----------------------------------------------------------------------
000076r 1               
000076r 1               .segment "CODE"
000000r 1               .org asm_code
000E00  1               
000E00  1               start_asm:
000E00  1               
000E00  1  4C B5 40     	jmp relocate + load_address - asm_code
000E03  1               
000E03  1               boot_game:
000E03  1               
000E03  1               ; Zero ZP vars
000E03  1               
000E03  1               clear_zp:
000E03  1  A2 00        	ldx #0
000E05  1  8A           	txa
000E06  1               	:
000E06  1  95 00        	sta $00, x
000E08  1  E8           	inx
000E09  1  E0 A0        	cpx #$a0
000E0B  1  D0 F9        	bne :-
000E0D  1               
000E0D  1               	; Init non-zero vars
000E0D  1  A9 03        	lda #3
000E0F  1  85 rr        	sta numlif
000E11  1               
000E11  1  A2 FF        	ldx #255
000E13  1  86 rr        	stx varrnd
000E15  1  86 rr        	stx varopt
000E17  1  86 rr        	stx varblk
000E19  1  CA           	dex
000E1A  1  86 rr        	stx varobj
000E1C  1               
000E1C  1  20 80 0E     	jsr bbcinit
000E1F  1               
000E1F  1               	; Call AGD Engine start game
000E1F  1  20 00 16     	jsr start_game
000E22  1               
000E22  1  20 9F 0E     	jsr bbckill
000E25  1               
000E25  1                   ; Wait for keypress
000E25  1  A2 FF        	ldx #$ff
000E27  1  A0 7F        	ldy #$7f
000E29  1  A9 81        	lda #$81
000E2B  1  20 F4 FF     	jsr OSBYTE
000E2E  1               
000E2E  1               	; Restart or exit
000E2E  1  4C 03 0E     	jmp boot_game
000E31  1               
000E31  1               ;----------------------------------------------------------------------
000E31  1               ; PLATFORM SPECIFIC ENGINE CODE
000E31  1               ;----------------------------------------------------------------------
000E31  1               
000E31  1               	.include "z80.asm"
000E31  2               ;------------------------------------------------------
000E31  2               ; z80.asm
000E31  2               ; spectrum stuff
000E31  2               ; adresses
000E31  2               
000E31  2               ;ws	 = $60
000E31  2               
000E31  2               ;z80_f	 = ws+$00
000E31  2               ;z80_a	 = ws+$01
000E31  2               ;z80_af	 = z80_f
000E31  2               
000E31  2               ;z80_c	 = ws+$02
000E31  2               ;z80_b	 = ws+$03
000E31  2               ;z80_bc	 = z80_c
000E31  2               
000E31  2               ;z80_e	 = ws+$04
000E31  2               ;z80_d	 = ws+$05
000E31  2               ;z80_de	 = z80_e
000E31  2               
000E31  2               ;z80_l	 = ws+$06
000E31  2               ;z80_h	 = ws+$07
000E31  2               ;z80_hl	 = z80_l
000E31  2               
000E31  2               ;z80_x    = ws+$08
000E31  2               ;z80_i    = ws+$09
000E31  2               ;z80_ix	 = z80_x
000E31  2               
000E31  2               ;z80_iy	 = ws+$0a
000E31  2               
000E31  2               ;z80_fp	 = ws+$0c
000E31  2               ;z80_ap	 = ws+$0d
000E31  2               
000E31  2               ;z80_cp	 = ws+$0e
000E31  2               ;z80_bp	 = ws+$0f
000E31  2               ;z80_bcp = z80_cp
000E31  2               
000E31  2               ;z80_ep	 = ws+$10
000E31  2               ;z80_dp	 = ws+$11
000E31  2               ;z80_dep = z80_ep
000E31  2               
000E31  2               ;z80_lp	 = ws+$12
000E31  2               ;z80_hp	 = ws+$13
000E31  2               ;z80_hlp = z80_lp
000E31  2               
000E31  2               ;z80_sp   = ws+$14
000E31  2               
000E31  2               ;z80_reg0 = ws+$16
000E31  2               ;z80_reg1 = ws+$17
000E31  2               ;z80_reg2 = ws+$18
000E31  2               ;z80_reg3 = ws+$19
000E31  2               
000E31  2               ;z80_r	 = ws+$1a
000E31  2               
000E31  2               ; Contains seperatly 1 bit set
000E31  2               ; _BEEB this is not safe memory to use as required by MOS
000E31  2               
000E31  2               _bitmem0	= $f8
000E31  2               _bitmem1	= $f9
000E31  2               _bitmem2	= $fa
000E31  2               _bitmem3	= $fb
000E31  2               _bitmem4	= $fc
000E31  2               _bitmem5	= $fd
000E31  2               _bitmem6	= $fe
000E31  2               _bitmem7	= $ff
000E31  2               
000E31  2               ; constants
000E31  2               _bitvalue0	= $01
000E31  2               _bitvalue1	= $02
000E31  2               _bitvalue2	= $04
000E31  2               _bitvalue3	= $08
000E31  2               _bitvalue4	= $10
000E31  2               _bitvalue5	= $20
000E31  2               _bitvalue6	= $40
000E31  2               _bitvalue7	= $80
000E31  2               
000E31  2               _notbitvalue0	= $fe
000E31  2               _notbitvalue1	= $fd
000E31  2               _notbitvalue2	= $fb
000E31  2               _notbitvalue3	= $f7
000E31  2               _notbitvalue4	= $ef
000E31  2               _notbitvalue5	= $df
000E31  2               _notbitvalue6	= $bf
000E31  2               _notbitvalue7	= $7f
000E31  2               
000E31  2               
000E31  2               ;add_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_de:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_de:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		clc
000E31  2               ;		adc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		adc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_ix_bc:
000E31  2               ;		lda z80_ix
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_ix
000E31  2               ;		lda z80_ix+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_ix+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;add_iy_bc:
000E31  2               ;		lda z80_iy
000E31  2               ;		clc
000E31  2               ;		adc z80_c
000E31  2               ;		sta z80_iy
000E31  2               ;		lda z80_iy+1
000E31  2               ;		adc z80_b
000E31  2               ;		sta z80_iy+1
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_de:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;sbc_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		sbc z80_c
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_h
000E31  2               ;		sbc z80_b
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_hl_bc:
000E31  2               ;		lda z80_l
000E31  2               ;		cmp z80_c
000E31  2               ;		bne cmp_hl_bc_end
000E31  2               ;		lda z80_h
000E31  2               ;		cmp z80_b
000E31  2               ;cmp_hl_bc_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;cmp_iy_ix:
000E31  2               ;		lda z80_iy
000E31  2               ;		cmp z80_ix
000E31  2               ;		bne cmp_iy_ix_end
000E31  2               ;		lda z80_iy+1
000E31  2               ;		cmp z80_ix+1
000E31  2               ;cmp_iy_ix_end:
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_hl:
000E31  2               ;		lda z80_l
000E31  2               ;		bne dec_hl_no_dec_h
000E31  2               ;		dec z80_h
000E31  2               ;dec_hl_no_dec_h:
000E31  2               ;		dec z80_l
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_ix:
000E31  2               ;		lda z80_ix
000E31  2               ;		bne dec_ix_no_dec_h
000E31  2               ;		dec z80_ix+1
000E31  2               ;dec_ix_no_dec_h:
000E31  2               ;		dec z80_ix
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_bc:
000E31  2               ;		lda z80_c
000E31  2               ;		bne dec_bc_no_dec_b
000E31  2               ;		dec z80_b
000E31  2               ;dec_bc_no_dec_b:
000E31  2               ;		dec z80_c
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;dec_de:
000E31  2               ;		lda z80_e
000E31  2               ;		bne dec_de_no_dec_d
000E31  2               ;		dec z80_d
000E31  2               ;dec_de_no_dec_d:
000E31  2               ;		dec z80_e
000E31  2               ;		rts
000E31  2               ;
000E31  2               ;ex_af_afs:
000E31  2               ;	rts
000E31  2               ;ex_de_hl:
000E31  2               ;		lda z80_e
000E31  2               ;		ldx z80_l
000E31  2               ;		stx z80_e
000E31  2               ;		sta z80_l
000E31  2               ;		lda z80_d
000E31  2               ;		ldx z80_h
000E31  2               ;		stx z80_d
000E31  2               ;		sta z80_h
000E31  2               ;		rts
000E31  2               ;
000E31  2               exx:
000E31  2  A5 rr        		lda z80_c
000E33  2  A4 rr        		ldy z80_cp
000E35  2  84 rr        		sty z80_c
000E37  2  85 rr        		sta z80_cp
000E39  2  A5 rr        		lda z80_b
000E3B  2  A4 rr        		ldy z80_bp
000E3D  2  84 rr        		sty z80_b
000E3F  2  85 rr        		sta z80_bp
000E41  2  A5 rr        		lda z80_e
000E43  2  A4 rr        		ldy z80_ep
000E45  2  84 rr        		sty z80_e
000E47  2  85 rr        		sta z80_ep
000E49  2  A5 rr        		lda z80_d
000E4B  2  A4 rr        		ldy z80_dp
000E4D  2  84 rr        		sty z80_d
000E4F  2  85 rr        		sta z80_dp
000E51  2  A5 rr        		lda scraddr
000E53  2  A4 rr        		ldy z80_lp
000E55  2  84 rr        		sty scraddr
000E57  2  85 rr        		sta z80_lp
000E59  2  A5 rr        		lda scraddr+1
000E5B  2  A4 rr        		ldy z80_hp
000E5D  2  84 rr        		sty scraddr+1
000E5F  2  85 rr        		sta z80_hp
000E61  2  60           		rts
000E62  2               
000E62  2               ;ex_sp_hl:
000E62  2               ;		tsx
000E62  2               ;		lda $0103,x
000E62  2               ;		ldy z80_h
000E62  2               ;		sta z80_h
000E62  2               ;		tya
000E62  2               ;		sta $0103,x
000E62  2               ;		lda $0104,x
000E62  2               ;		ldy z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		tya
000E62  2               ;		sta $104,x
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;ldi:
000E62  2               ;	rts
000E62  2               ;ldir:
000E62  2               ;		ldy #$00
000E62  2               ;		ldx z80_b
000E62  2               ;		beq ldir_last_page
000E62  2               ;ldir_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		bne ldir_loop
000E62  2               ;		inc z80_h
000E62  2               ;		inc z80_d
000E62  2               ;		dex
000E62  2               ;		bne ldir_loop
000E62  2               ;ldir_last_page:
000E62  2               ;		lda z80_c
000E62  2               ;		beq ldir_end
000E62  2               ;ldir_last_page_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		iny
000E62  2               ;		cpy z80_c
000E62  2               ;		bne ldir_last_page_loop
000E62  2               ;ldir_end:
000E62  2               ;		stx z80_c
000E62  2               ;		stx z80_b
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_l
000E62  2               ;		sta z80_l
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_h
000E62  2               ;		tya
000E62  2               ;		clc
000E62  2               ;		adc z80_e
000E62  2               ;		sta z80_e
000E62  2               ;		bcc *+4
000E62  2               ;		inc z80_d
000E62  2               ;		rts
000E62  2               ;
000E62  2               ;lddr:		ldy #$00
000E62  2               ;lddr_loop:
000E62  2               ;		lda (z80_hl),y
000E62  2               ;		sta (z80_de),y
000E62  2               ;		jsr dec_hl
000E62  2               ;		jsr dec_de
000E62  2               ;		jsr dec_bc
000E62  2               ;		lda z80_b
000E62  2               ;		ora z80_c
000E62  2               ;		bne lddr_loop
000E62  2               ;		rts
000E62  2               ;ei:
000E62  2               ;		rts
000E62  2               ;di:
000E62  2               ;		rts
000E62  2               
000E62  2               ;-------------------------------------------------------------
000E62  2               ; Set bits in bitmem
000E62  2               ;-------------------------------------------------------------
000E62  2               
000E62  2               .if 0
000E62  2               z80_init:
000E62  2               	ldx #$00
000E62  2               	lda #$01
000E62  2               z80_init_loop:
000E62  2               	sta _bitmem0,x
000E62  2               	inx
000E62  2               	asl a
000E62  2               	bne z80_init_loop
000E62  2               	rts
000E62  2               .endif
000E62  2               
000E62  2               push_af:
000E62  2               push_bc:
000E62  2               push_de:
000E62  2               push_hl:
000E62  2               
000E62  2               pop_af:
000E62  2               pop_bc:
000E62  2               pop_de:
000E62  2               pop_ix:
000E62  2               pop_hl:
000E62  2               
000E62  2               add_hl_hl:
000E62  2               
000E62  2               inc_bc:
000E62  2               inc_de:
000E62  2               inc_hl:
000E62  2               inc_ix:
000E62  2               inc_sp:
000E62  2               
000E62  2               cpir:
000E62  2               
000E62  2               ex_af_af:
000E62  2               ;	rts
000E62  2               
000E62  1               	.include "bbc.inc"
000E62  2               ;----------------------------------------------------------------------
000E62  2               ; BBC Platform Specific functions
000E62  2               ;----------------------------------------------------------------------
000E62  2               
000E62  2               ;--------------------------------------------------------
000E62  2               ; Keys
000E62  2               ;
000E62  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000E62  2               ;             ||||||||
000E62  2               ;             |||||||+> Right    KEY 0  - X
000E62  2               ;             ||||||+-> Left     KEY 1  - Z
000E62  2               ;             |||||+--> Down     KEY 2  - .
000E62  2               ;             ||||+---> Up       KEY 3  - ;
000E62  2               ;             |||+----> Fire1    KEY 4  - SPC
000E62  2               ;             ||+-----> Fire2    KEY 5  - Q
000E62  2               ;             |+------> Fire3    KEY 6  - P
000E62  2               ;             +-------> Not used
000E62  2               ;
000E62  2               ;                       Option1  KEY 7  - 1
000E62  2               ;                       Option2  KEY 8  - 2
000E62  2               ;                       Option3  KEY 9  - 3
000E62  2               ;                       Option4  KEY 10 - 4
000E62  2               ;--------------------------------------------------------
000E62  2               
000E62  2               ;              X   Z   .   ;  SPC  Q   P
000E62  2               ;keys:   .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E62  2               ;        .byte $30,$31,$11,$12                   ; menu options.
000E62  2               
000E62  2  42 61 68 48  jkeys:  .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E66  2  62 10 37     
000E69  2  30 31 11 12          .byte $30,$31,$11,$12                   ; menu options.
000E6D  2               
000E6D  2               ;----------------------------------------------------
000E6D  2               ; Wait for keypress.
000E6D  2               ;----------------------------------------------------
000E6D  2               
000E6D  2               prskey:
000E6D  2  8A           	txa
000E6E  2  48           	pha
000E6F  2               prsloop:
000E6F  2  20 0E 0F     	jsr vsync
000E72  2               
000E72  2  A9 79        	lda #$79
000E74  2  A2 01        	ldx #$01
000E76  2  20 F4 FF     	jsr OSBYTE
000E79  2               
000E79  2  E0 FF        	cpx #$ff
000E7B  2  F0 F2        	beq prsloop		; wait until key pressed
000E7D  2  68           	pla
000E7E  2  AA           	tax
000E7F  2  60           	rts
000E80  2               
000E80  2               bbcinit:
000E80  2  78           	sei
000E81  2  AD 20 02     	lda EVENTV
000E84  2  8D B4 0E     	sta old_eventv
000E87  2  AD 21 02     	lda EVENTV+1
000E8A  2  8D B5 0E     	sta old_eventv+1
000E8D  2               
000E8D  2  A9 B6        	lda #<event_handler
000E8F  2  8D 20 02     	sta EVENTV
000E92  2  A9 0E        	lda #>event_handler
000E94  2  8D 21 02     	sta EVENTV+1
000E97  2  58           	cli
000E98  2               
000E98  2               	; Enable VSYNC event.
000E98  2  A9 0E        	lda #14
000E9A  2  A2 04        	ldx #4
000E9C  2  4C F4 FF     	jmp OSBYTE
000E9F  2               
000E9F  2               bbckill:
000E9F  2  78           	sei
000EA0  2  AD B4 0E     	lda old_eventv
000EA3  2  8D 20 02     	sta EVENTV
000EA6  2  AD B5 0E     	lda old_eventv+1
000EA9  2  8D 21 02     	sta EVENTV+1
000EAC  2  58           	cli
000EAD  2               
000EAD  2               	; Disable VSYNC event.
000EAD  2  A9 0D        	lda #13
000EAF  2  A2 04        	ldx #4
000EB1  2  4C F4 FF     	jmp OSBYTE
000EB4  2               
000EB4  2               
000EB4  2               old_eventv:
000EB4  2  xx xx        	.res 2
000EB6  2               
000EB6  2               event_handler:
000EB6  2  08           	php
000EB7  2  C9 04        	cmp #4
000EB9  2  D0 02        	bne not_vsync
000EBB  2               
000EBB  2  E6 rr        	inc vsync_count
000EBD  2               
000EBD  2               not_vsync:
000EBD  2  28           	plp
000EBE  2  6C B4 0E     	jmp (old_eventv)
000EC1  2               
000EC1  2               bbcsync:
000EC1  2  A5 rr        	lda vsync_count
000EC3  2  C9 02        	cmp #2
000EC5  2  90 FA        	bcc bbcsync
000EC7  2  A9 00        	lda #0
000EC9  2  85 rr        	sta vsync_count
000ECB  2  60           	rts
000ECC  2               
000ECC  2               ;--------------------------------------------------------
000ECC  2               ; Keyboard test routine.
000ECC  2               ;
000ECC  2               ; Input:
000ECC  2               ;  A = key to read, high nibble=row and low nibble=col
000ECC  2               ;
000ECC  2               ; Output:
000ECC  2               ;  carry clr = key pressed
000ECC  2               ;  carry set = key not pressed
000ECC  2               ;--------------------------------------------------------
000ECC  2               
000ECC  2               ktest:
000ECC  2  85 rr        	sta z80_a		; save key
000ECE  2  98           	tya
000ECF  2  48           	pha
000ED0  2               
000ED0  2               ; _BEEB keyboard read
000ED0  2  A5 rr        	lda z80_a
000ED2  2  49 80        	eor #$80		; _BEEB just look for this key
000ED4  2  AA           	tax
000ED5  2               
000ED5  2  A9 79        	lda #$79
000ED7  2  20 F4 FF     	jsr OSBYTE
000EDA  2               
000EDA  2  8A           	txa
000EDB  2  30 04        	bmi pressed 	; _BEEB X is negative if key is pressed
000EDD  2               
000EDD  2  38           	sec			; key not pressed
000EDE  2  68           	pla
000EDF  2  A8           	tay
000EE0  2  60           	rts
000EE1  2               
000EE1  2               pressed:
000EE1  2  18           	clc			; key pressed
000EE2  2  68           	pla
000EE3  2  A8           	tay
000EE4  2  60           	rts
000EE5  2               
000EE5  2               ;---------------------------------------------------------------
000EE5  2               ; Getkey in column,row format
000EE5  2               ;
000EE5  2               ; Output:
000EE5  2               ;  A = high nibble=row and low nibble=column key in matrix
000EE5  2               ;---------------------------------------------------------------
000EE5  2               
000EE5  2               kget:
000EE5  2  86 rr        	stx xtmp
000EE7  2               
000EE7  2               kget1:
000EE7  2  A9 79        	lda #$79			; _BEEB read keyboard with OSBYTE &79
000EE9  2  A2 01        	ldx #$01
000EEB  2  20 F4 FF     	jsr OSBYTE
000EEE  2               
000EEE  2  E0 FF        	cpx #$ff
000EF0  2  F0 F5        	beq kget1
000EF2  2               
000EF2  2  8A           	txa
000EF3  2               
000EF3  2  A6 rr        	ldx xtmp
000EF5  2  60           	rts
000EF6  2               
000EF6  2               ;----------------------------------------------------
000EF6  2               ; AtoMMC joystick controls.
000EF6  2               ; _BEEB TODO
000EF6  2               ;----------------------------------------------------
000EF6  2               
000EF6  2               joyinit:
000EF6  2               joysin:
000EF6  2  60           	rts
000EF7  2               
000EF7  2               
000EF7  2               ;----------------------------------------------------
000EF7  2               ; Delay routine 1/50 sec
000EF7  2               ;
000EF7  2               ; Wait 1/60 sec = 16666 usec
000EF7  2               ; Wait 208 x 16 =  3328 usec
000EF7  2               ;                 19994 usec
000EF7  2               ; rts           =     6 usec
000EF7  2               ; Total         = 20000 usec
000EF7  2               ;----------------------------------------------------
000EF7  2               
000EF7  2               delay:
000EF7  2  85 rr        	sta xtmp
000EF9  2               del_loop:
000EF9  2  A9 13        	lda #19
000EFB  2  20 F4 FF     	jsr OSBYTE		; wait for vsync _BEEB
000EFE  2               
000EFE  2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
000F00  2               delay1:
000F00  2  61 80        	adc ($80,x)		;	 6 usec
000F02  2  61 80        	adc ($80,x)		;	 6 usec
000F04  2  88           	dey			;	 2 usec
000F05  2  D0 F9        	bne delay1		;	 2 usec
000F07  2  EA           	nop			; 2 usec
000F08  2  EA           	nop			; 2 usec
000F09  2               				; tot: 20000 usec
000F09  2  C6 rr        	dec xtmp
000F0B  2  D0 EC        	bne del_loop
000F0D  2  60           	rts
000F0E  2               
000F0E  2               ;-------------------------------------------------------------
000F0E  2               ; Screen synchronisation.
000F0E  2               ;
000F0E  2               ;  - read joystick/keyboard
000F0E  2               ;  - handle sound
000F0E  2               ;  - sync framerate with clock
000F0E  2               ;  - handle shrapnel every even frame
000F0E  2               ;-------------------------------------------------------------
000F0E  2               
000F0E  2               vsync:
000F0E  2  48           	pha
000F0F  2  98           	tya
000F10  2  48           	pha
000F11  2  8A           	txa
000F12  2  48           	pha
000F13  2  20 FA 1F     	jsr joykey		; read joystick/keyboard.
000F16  2               vsync1:
000F16  2               ; Don't sync to vsync here - we can sync to every other vsync in main loop
000F16  2               ;	lda #19
000F16  2               ;	jsr OSBYTE		; _BEEB vsync
000F16  2               
000F16  2  A5 rr        	lda clock
000F18  2  29 01        	and #1
000F1A  2  D0 03        	bne:+
000F1C  2  20 D8 16     	jsr proshr		; handle shrapnel every even frame
000F1F  2               :
000F1F  2  AD 2A 0F     	lda sndtyp
000F22  2  F0 00        	beq sndskip
000F24  2               
000F24  2               ; _BEEB TODO SOUND
000F24  2               ;sndloop:
000F24  2               ;	lda SpeakerBit		; handle sound
000F24  2               ;	ldy sndtyp
000F24  2               ;sndwait:
000F24  2               ;	dey
000F24  2               ;	bne sndwait
000F24  2               ;	eor #4
000F24  2               ;	sta SpeakerBit
000F24  2               ;	dec sndtyp
000F24  2               ;	bne sndloop
000F24  2               
000F24  2               sndskip:
000F24  2  68           	pla
000F25  2  AA           	tax
000F26  2  68           	pla
000F27  2  A8           	tay
000F28  2  68           	pla
000F29  2  60           	rts
000F2A  2               
000F2A  2  00           sndtyp:	.byte 0
000F2B  2               
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               ; BBC video hardware fns
000F2B  2               ;----------------------------------------------------------------------
000F2B  2               
000F2B  2               screeninit:
000F2B  2  A2 0D        	ldx #13
000F2D  2               crtcloop:
000F2D  2  8E 00 FE     	stx $FE00
000F30  2  BD 4D 0F     	lda crtc_regs_high,x
000F33  2  8D 01 FE     	sta $FE01
000F36  2  CA           	dex
000F37  2  10 F4        	bpl crtcloop
000F39  2               
000F39  2                   ; Set ULA
000F39  2  A9 88            lda #$88            ; MODE 4
000F3B  2  8D 48 02         sta $248            ; Tell the OS or it will mess with ULA settings at vsync
000F3E  2  8D 20 FE         sta $FE20
000F41  2               
000F41  2               ; fall through to palette
000F41  2               
000F41  2               setpal:
000F41  2  A2 0F        	ldx #15
000F43  2               palloop:
000F43  2  BD 5B 0F     	lda ula_pal,x
000F46  2  8D 21 FE     	sta $fe21
000F49  2  CA           	dex
000F4A  2  10 F7        	bpl palloop
000F4C  2  60           	rts
000F4D  2               
000F4D  2               crtc_regs_high:
000F4D  2  3F           	.byte 63				; R0  horizontal total
000F4E  2  20           	.byte 32				; R1  horizontal displayed
000F4F  2  31           	.byte 49				; R2  horizontal position
000F50  2  24           	.byte $24				; R3  sync width 40 = &28
000F51  2  26           	.byte 38				; R4  vertical total
000F52  2  00           	.byte 0					; R5  vertical total adjust
000F53  2  18           	.byte 24				; R6  vertical displayed
000F54  2  23           	.byte 35				; R7  vertical position; 35=top of screen
000F55  2  00           	.byte $00				; R8  interlace
000F56  2  07           	.byte 7					; R9  scanlines per row
000F57  2  20           	.byte 32				; R10 cursor start
000F58  2  08           	.byte 8					; R11 cursor end
000F59  2  0D           	.byte >(ScreenAddr/8)	; R12 screen start address, high
000F5A  2  00           	.byte <(ScreenAddr/8)	; R13 screen start address, low
000F5B  2               
000F5B  2               ula_pal:
000F5B  2  07           	.byte $00 + PAL_black
000F5C  2  17           	.byte $10 + PAL_black
000F5D  2  27           	.byte $20 + PAL_black
000F5E  2  37           	.byte $30 + PAL_black
000F5F  2  47           	.byte $40 + PAL_black
000F60  2  57           	.byte $50 + PAL_black
000F61  2  67           	.byte $60 + PAL_black
000F62  2  77           	.byte $70 + PAL_black
000F63  2  80           	.byte $80 + PAL_white
000F64  2  90           	.byte $90 + PAL_white
000F65  2  A0           	.byte $a0 + PAL_white
000F66  2  B0           	.byte $b0 + PAL_white
000F67  2  C0           	.byte $c0 + PAL_white
000F68  2  D0           	.byte $d0 + PAL_white
000F69  2  E0           	.byte $e0 + PAL_white
000F6A  2  F0           	.byte $f0 + PAL_white
000F6B  2               
000F6B  2               ;----------------------------------------------------
000F6B  2               ; Draw sprite
000F6B  2               ;----------------------------------------------------
000F6B  2               
000F6B  2               sprite:
000F6B  2  86 rr        	stx xtmp		; Save X-reg
000F6D  2  20 BD 0F     	jsr scadd 		; get screen address in scraddr.
000F70  2               
000F70  2  A5 rr        	lda dispx 		; x position.
000F72  2  29 07        	and #7 			; position straddling cells.
000F74  2  85 rr        	sta z80_b		; store in b register.
000F76  2               
000F76  2  A5 rr        	lda z80_l		; store sprite graphic address.
000F78  2  8D 89 0F     	sta sprit1+1
000F7B  2  8D 8F 0F     	sta sprit2+1
000F7E  2  A5 rr        	lda z80_h
000F80  2  8D 8A 0F     	sta sprit1+2
000F83  2  8D 90 0F     	sta sprit2+2
000F86  2               
000F86  2  A2 00        	ldx #0			; pixel height.
000F88  2               sprit1:
000F88  2  BD 6E 39     	lda objdta,x		; fetch first byte.
000F8B  2  85 rr        	sta spr
000F8D  2  E8           	inx
000F8E  2               sprit2:
000F8E  2  BD 6E 39     	lda objdta,x
000F91  2  85 rr        	sta spr+1
000F93  2               
000F93  2  A9 00        	lda #0
000F95  2  85 rr        	sta spr+2
000F97  2  20 94 1C     	jsr sprit7		; shift sprite
000F9A  2               
000F9A  2  A5 rr        	lda spr			; fetch graphic.
000F9C  2  A0 00        	ldy #0			; _BEEB
000F9E  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA0  2  91 rr        	sta (scraddr),y		; write to screen.
000FA2  2               
000FA2  2  A5 rr        	lda spr+1		; fetch graphic.
000FA4  2  A0 08        	ldy #8			; _BEEB
000FA6  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FA8  2  91 rr        	sta (scraddr),y		; write to screen.
000FAA  2               
000FAA  2  A5 rr        	lda spr+2		; fetch graphic.
000FAC  2  A0 10        	ldy #16			; _BEEB
000FAE  2  51 rr        	eor (scraddr),y		; merge with screen image.
000FB0  2  91 rr        	sta (scraddr),y		; write to screen.
000FB2  2               
000FB2  2  20 9F 10     	jsr nline
000FB5  2               
000FB5  2  E8           	inx			; next source byte.
000FB6  2  E0 20        	cpx #32
000FB8  2  D0 CE        	bne sprit1		; repeat
000FBA  2               
000FBA  2  A6 rr        	ldx xtmp		; retreive X-reg
000FBC  2  60           	rts
000FBD  2               
000FBD  2               ;------------------------------------------------------------------
000FBD  2               ; This routine returns a screen address for (dispx, dispy) in scraddr.
000FBD  2               ;------------------------------------------------------------------
000FBD  2               
000FBD  2               scadd:
000FBD  2  A6 rr        	ldx dispy
000FBF  2  A5 rr        	lda dispx
000FC1  2  29 F8        	and #$f8
000FC3  2  18           	clc
000FC4  2  7D 00 06     	adc SCADTB_lb,x
000FC7  2  85 rr        	sta scraddr
000FC9  2  BD 00 07     	lda SCADTB_hb,x
000FCC  2  69 00        	adc #0
000FCE  2  85 rr        	sta scraddr+1
000FD0  2  60           	rts
000FD1  2               
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               ; These are the sprite routines.
000FD1  2               ; sspria = single sprite, old (ix).
000FD1  2               ; ssprib = single sprite, new (ix+5).
000FD1  2               ; sspric = both sprites, old (ix) and new (ix+5).
000FD1  2               ;-----------------------------------------------------------------
000FD1  2               
000FD1  2               sspria:
000FD1  2  20 48 23     	jsr gsprad		; get old sprite address.
000FD4  2               sspri2:
000FD4  2               
000FD4  2  A5 rr        	lda z80_e				; 3c
000FD6  2  8D 6C 10     	sta dline_spraddr1+1	; 4c
000FD9  2  8D 83 10     	sta dline_spraddr2+1	; 4c
000FDC  2               
000FDC  2  A5 rr        	lda z80_d				; 3c
000FDE  2  8D 6D 10     	sta dline_spraddr1+2	; 4c
000FE1  2  8D 84 10     	sta dline_spraddr2+2	; 4c
000FE4  2               
000FE4  2  A6 rr        	ldx sprshft
000FE6  2  BD 63 10     	lda shift_table,x
000FE9  2  8D 6F 10     	sta dline_shift1+1
000FEC  2  8D 86 10     	sta dline_shift2+1
000FEF  2  BD 64 10     	lda shift_table+1,x
000FF2  2  8D 70 10     	sta dline_shift1+2
000FF5  2  8D 87 10     	sta dline_shift2+2
000FF8  2               
000FF8  2  A2 00        	ldx #0			; vertical lines.
000FFA  2               sspri0:
000FFA  2  20 6B 10     	jsr dline		; draw a line.
000FFD  2  E0 20        	cpx #32
000FFF  2  D0 F9        	bne sspri0		; repeat 16 times x 2 bytes
001001  2  60           	rts
001002  2               
001002  2               ;-----------------------------------------------------------------
001002  2               
001002  2               ssprib:
001002  2  20 29 23     	jsr gspran 		; get new sprite address.
001005  2  4C D4 0F     	jmp sspri2
001008  2               
001008  2               ;-----------------------------------------------------------------
001008  2               
001008  2               sspric:
001008  2  20 48 23     	jsr gsprad 		; get old sprite address.
00100B  2               
00100B  2  A5 rr        	lda z80_e				; 3c
00100D  2  8D 06 11     	sta ddline_spraddr3+1	; 4c
001010  2  8D 1D 11     	sta ddline_spraddr4+1	; 4c
001013  2               
001013  2  A5 rr        	lda z80_d				; 3c
001015  2  8D 07 11     	sta ddline_spraddr3+2	; 4c
001018  2  8D 1E 11     	sta ddline_spraddr4+2	; 4c
00101B  2               
00101B  2  A6 rr        	ldx sprshft
00101D  2  BD 63 10     	lda shift_table,x
001020  2  8D 09 11     	sta ddline_shift3+1
001023  2  8D 20 11     	sta ddline_shift4+1
001026  2  BD 64 10     	lda shift_table+1,x
001029  2  8D 0A 11     	sta ddline_shift3+2
00102C  2  8D 21 11     	sta ddline_shift4+2
00102F  2               
00102F  2  20 31 0E     	jsr exx  		; store addresses.
001032  2  20 29 23     	jsr gspran 		; get new sprite addresses.
001035  2               
001035  2  A5 rr        	lda z80_e				; 3c
001037  2  8D B9 10     	sta ddline_spraddr1+1	; 4c
00103A  2  8D D0 10     	sta ddline_spraddr2+1	; 4c
00103D  2               
00103D  2  A5 rr        	lda z80_d				; 3c
00103F  2  8D BA 10     	sta ddline_spraddr1+2	; 4c
001042  2  8D D1 10     	sta ddline_spraddr2+2	; 4c
001045  2               
001045  2  A6 rr        	ldx sprshft
001047  2  BD 63 10     	lda shift_table,x
00104A  2  8D BC 10     	sta ddline_shift1+1
00104D  2  8D D3 10     	sta ddline_shift2+1
001050  2  BD 64 10     	lda shift_table+1,x
001053  2  8D BD 10     	sta ddline_shift1+2
001056  2  8D D4 10     	sta ddline_shift2+2
001059  2               
001059  2  A2 00        	ldx #0
00105B  2               lloop:
00105B  2  20 B8 10     	jsr ddline 		; draw a line.
00105E  2  E0 20        	cpx #32
001060  2  D0 F9        	bne lloop
001062  2  60           	rts
001063  2               
001063  2               shift_table:
001063  2  00 12        .word shift0
001065  2  00 13        .word shift2
001067  2  00 14        .word shift4
001069  2  00 15        .word shift6
00106B  2               
00106B  2               ;-------------------------------------------------------------
00106B  2               ; Drop through.
00106B  2               ; Line drawn, now work out next target address.
00106B  2               ;
00106B  2               ; Input:
00106B  2               ;  B  = right mask
00106B  2               ;  C  = left mask
00106B  2               ;  DE = spriteaddress
00106B  2               ;  scraddr = screen address
00106B  2               ;-------------------------------------------------------------
00106B  2               
00106B  2               dline:
00106B  2               
00106B  2               ; first screen byte
00106B  2               
00106B  2               dline_spraddr1:
00106B  2  BC FF FF     	ldy $ffff,x 		; graphic data.
00106E  2               dline_shift1:
00106E  2  B9 FF FF     	lda $ffff,y
001071  2  85 rr        	sta sprtmp
001073  2  25 rr        	and z80_c 			; mask away what's not needed.
001075  2               
001075  2  A0 00        	ldy #0
001077  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001079  2  91 rr        	sta (scraddr),y 	; bung it in.
00107B  2               
00107B  2               ; carry to next screen byte
00107B  2               
00107B  2  A5 rr        	lda sprtmp			; fetch data.
00107D  2  25 rr        	and z80_b 			; mask away unwanted
00107F  2  85 rr        	sta sprtmp
001081  2               
001081  2               ; middle screen byte
001081  2               
001081  2  E8           	inx
001082  2               dline_spraddr2:
001082  2  BC FF FF     	ldy $ffff,x 		; second bit of data.
001085  2               dline_shift2:
001085  2  B9 FF FF     	lda $ffff,y
001088  2  85 rr        	sta sprtmp2
00108A  2  25 rr        	and z80_c 			; mask away what's not needed.
00108C  2  05 rr        	ora sprtmp
00108E  2               
00108E  2  A0 08        	ldy #8
001090  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
001092  2  91 rr        	sta (scraddr),y 	; bung it in.
001094  2               
001094  2               ; carry to last screen byte
001094  2               
001094  2  A5 rr        	lda sprtmp2
001096  2  25 rr        	and z80_b 			; mask away unwanted
001098  2               
001098  2  A0 10        	ldy #16
00109A  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
00109C  2  91 rr        	sta (scraddr),y 	; bung it in.
00109E  2               
00109E  2  E8           	inx
00109F  2               
00109F  2               ;----------------------------------------------------------------------
00109F  2               ; Line drawn, now work out next target address.
00109F  2               ;----------------------------------------------------------------------
00109F  2               
00109F  2               ; _BEEB screen arrangement
00109F  2               
00109F  2               nline:
00109F  2  A5 rr        	lda scraddr 		; get low byte of address.
0010A1  2  29 07        	and #7
0010A3  2  C9 07        	cmp #7				; is this last line of row?
0010A5  2  F0 03        	beq beeb_next_row
0010A7  2               
0010A7  2               	; within same row
0010A7  2  E6 rr        	inc scraddr			; new low byte of address.
0010A9  2               ;	bne :+
0010A9  2               ;	inc scraddr+1		; new high byte of address.
0010A9  2               :
0010A9  2  60           	rts
0010AA  2               
0010AA  2               beeb_next_row:
0010AA  2  18           	clc
0010AB  2  A5 rr        	lda scraddr
0010AD  2  69 F9        	adc #<(ScreenRowBytes-7)
0010AF  2  85 rr        	sta scraddr			; new low byte of address.
0010B1  2  A5 rr        	lda scraddr+1
0010B3  2  69 00        	adc #>(ScreenRowBytes-7)
0010B5  2  85 rr        	sta scraddr+1		; new high byte of address.
0010B7  2  60           	rts
0010B8  2               
0010B8  2               ;-------------------------------------------------------------
0010B8  2               ; Drop through.
0010B8  2               ; Line drawn, now work out next target address.
0010B8  2               ;
0010B8  2               ; Input:
0010B8  2               ;  B  = right mask
0010B8  2               ;  C  = left mask
0010B8  2               ;  DE = spriteaddress
0010B8  2               ;  scraddr = screen address
0010B8  2               ;-------------------------------------------------------------
0010B8  2               
0010B8  2               ddline:
0010B8  2               
0010B8  2               ; NEW SPRITE
0010B8  2               
0010B8  2               ; first screen byte
0010B8  2               
0010B8  2               ddline_spraddr1:
0010B8  2  BC FF FF     	ldy $ffff,x 		; graphic data.
0010BB  2               ddline_shift1:
0010BB  2  B9 FF FF     	lda $ffff,y
0010BE  2  85 rr        	sta sprtmp
0010C0  2  25 rr        	and z80_c 			; mask away what's not needed.
0010C2  2               
0010C2  2  A0 00        	ldy #0
0010C4  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
0010C6  2  91 rr        	sta (scraddr),y 	; bung it in.
0010C8  2               
0010C8  2               ; carry to next screen byte
0010C8  2               
0010C8  2  A5 rr        	lda sprtmp			; fetch data.
0010CA  2  25 rr        	and z80_b 			; mask away unwanted
0010CC  2  85 rr        	sta sprtmp
0010CE  2               
0010CE  2               ; middle screen byte
0010CE  2               
0010CE  2  E8           	inx
0010CF  2               ddline_spraddr2:
0010CF  2  BC FF FF     	ldy $ffff,x 		; second bit of data.
0010D2  2               ddline_shift2:
0010D2  2  B9 FF FF     	lda $ffff,y
0010D5  2  85 rr        	sta sprtmp2
0010D7  2  25 rr        	and z80_c 			; mask away what's not needed.
0010D9  2  05 rr        	ora sprtmp
0010DB  2               
0010DB  2  A0 08        	ldy #8
0010DD  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
0010DF  2  91 rr        	sta (scraddr),y 	; bung it in.
0010E1  2               
0010E1  2               ; carry to last screen byte
0010E1  2               
0010E1  2  A5 rr        	lda sprtmp2
0010E3  2  25 rr        	and z80_b 			; mask away unwanted
0010E5  2               
0010E5  2  A0 10        	ldy #16
0010E7  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
0010E9  2  91 rr        	sta (scraddr),y 	; bung it in.
0010EB  2               
0010EB  2               ; _BEEB next row
0010EB  2               
0010EB  2  A5 rr        	lda scraddr 		; get low byte of address.
0010ED  2  29 07        	and #7
0010EF  2  C9 07        	cmp #7				; is this last line of row?
0010F1  2  F0 04        	beq :+
0010F3  2               
0010F3  2               	; within same row can't increment page
0010F3  2  E6 rr        	inc scraddr			; new low byte of address.
0010F5  2  D0 0D        	bne ddline2
0010F7  2               
0010F7  2               :
0010F7  2  18           	clc
0010F8  2  A5 rr        	lda scraddr
0010FA  2  69 F9        	adc #<(ScreenRowBytes-7)
0010FC  2  85 rr        	sta scraddr			; new low byte of address.
0010FE  2  A5 rr        	lda scraddr+1
001100  2  69 00        	adc #>(ScreenRowBytes-7)
001102  2  85 rr        	sta scraddr+1		; new high byte of address.
001104  2               
001104  2               ; OLD SPRITE
001104  2               
001104  2               ddline2:
001104  2               
001104  2               ; still first row but different data!
001104  2               
001104  2  CA           	dex
001105  2               
001105  2               ; first screen byte
001105  2               
001105  2               ddline_spraddr3:
001105  2  BC FF FF     	ldy $ffff,x			; graphic data.
001108  2               ddline_shift3:
001108  2  B9 FF FF     	lda $ffff,y
00110B  2  85 rr        	sta sprtmp
00110D  2  25 rr        	and z80_cp 			; mask away what's not needed.
00110F  2               
00110F  2  A0 00        	ldy #0
001111  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
001113  2  91 rr        	sta (z80_hlp),y 	; bung it in.
001115  2               
001115  2               ; carry to next screen byte
001115  2               
001115  2  A5 rr        	lda sprtmp			; fetch data.
001117  2  25 rr        	and z80_bp 			; mask away unwanted
001119  2  85 rr        	sta sprtmp
00111B  2               
00111B  2               ; middle screen byte
00111B  2               
00111B  2  E8           	inx
00111C  2               ddline_spraddr4:
00111C  2  BC FF FF     	ldy $ffff,x 		; second bit of data.
00111F  2               ddline_shift4:
00111F  2  B9 FF FF     	lda $ffff,y
001122  2  85 rr        	sta sprtmp2
001124  2  25 rr        	and z80_cp 			; mask away what's not needed.
001126  2  05 rr        	ora sprtmp
001128  2               
001128  2  A0 08        	ldy #8
00112A  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
00112C  2  91 rr        	sta (z80_hlp),y 	; bung it in.
00112E  2               
00112E  2               ; last screen byte
00112E  2               
00112E  2  A5 rr        	lda sprtmp2			; fetch data.
001130  2  25 rr        	and z80_bp 			; mask away unwanted
001132  2               
001132  2  A0 10        	ldy #16
001134  2  51 rr        	eor (z80_hlp),y 	; XOR with what's there.
001136  2  91 rr        	sta (z80_hlp),y 	; bung it in.
001138  2               
001138  2               ; next row of sprite data
001138  2               
001138  2  E8           	inx
001139  2               
001139  2               ; _BEEB screen arrangement
001139  2               
001139  2  A5 rr        	lda z80_lp 			; get low byte of address.
00113B  2  29 07        	and #7
00113D  2  C9 07        	cmp #7				; is this last line of row?
00113F  2  F0 03        	beq :+
001141  2               
001141  2               	; within same row can't increment page
001141  2  E6 rr        	inc z80_lp			; new low byte of address.
001143  2  60           	rts
001144  2               
001144  2               :
001144  2  18           	clc
001145  2  A5 rr        	lda z80_lp
001147  2  69 F9        	adc #<(ScreenRowBytes-7)
001149  2  85 rr        	sta z80_lp			; new low byte of address.
00114B  2  A5 rr        	lda z80_lp+1
00114D  2  69 00        	adc #>(ScreenRowBytes-7)
00114F  2  85 rr        	sta z80_lp+1		; new high byte of address.
001151  2  60           	rts
001152  2               
001152  2               ;----------------------------------------------------
001152  2               ; Display character in A at dispx,dispy.
001152  2               ;
001152  2               ; Input:
001152  2               ;  A 	   = character to print
001152  2               ;----------------------------------------------------
001152  2               
001152  2               pchar:
001152  2  85 rr        	sta fntaddr
001154  2  A9 00        	lda #0
001156  2  85 rr        	sta fntaddr+1
001158  2  06 rr        	asl fntaddr  		; multiply char by 8.
00115A  2  26 rr        	rol fntaddr+1
00115C  2  06 rr        	asl fntaddr
00115E  2  26 rr        	rol fntaddr+1
001160  2  06 rr        	asl fntaddr
001162  2  26 rr        	rol fntaddr+1
001164  2               
001164  2  A5 rr        	lda fntaddr
001166  2  18           	clc
001167  2  65 rr        	adc FontPtr
001169  2  85 rr        	sta fntaddr		; that's the low byte.
00116B  2  A5 rr        	lda fntaddr+1
00116D  2  65 rr        	adc FontPtr+1
00116F  2  85 rr        	sta fntaddr+1		; add displacement.
001171  2               pchark:
001171  2  20 E7 1B     	jsr gprad		; get screen address.
001174  2  A0 00        	ldy #0
001176  2               
001176  2               pchar0:
001176  2  B1 rr        	lda (fntaddr),y 	; get image byte.
001178  2  49 FF        	eor #TxtInvert		; Invert
00117A  2  91 rr        	sta (scraddr),y 	; copy to screen.
00117C  2  C8           	iny					; next screen row down.
00117D  2  C0 08        	cpy #8				; number lines
00117F  2  90 F5        	bcc pchar0			; repeat.
001181  2  60           	rts
001182  2               
001182  2               ;----------------------------------------------------
001182  2               ; Shift tables
001182  2               ;----------------------------------------------------
001182  2               
001182  2               .if 1
001182  2  xx xx xx xx  .align 256
001186  2  xx xx xx xx  
00118A  2  xx xx xx xx  
001200  2               shift0:
001200  2  00 01 02 03  .repeat 256, i
001204  2  04 05 06 07  
001208  2  08 09 0A 0B  
001300  2               	.byte i
001300  2               .endrep
001300  2               
001300  2               shift2:
001300  2  00 40 80 C0  .repeat 256, i
001304  2  01 41 81 C1  
001308  2  02 42 82 C2  
001400  2               	.byte (i >> 2) | (i << 6) & $c0
001400  2               .endrep
001400  2               
001400  2               shift4:
001400  2  00 10 20 30  .repeat 256, i
001404  2  40 50 60 70  
001408  2  80 90 A0 B0  
001500  2               	.byte (i >> 4) | ((i << 4) & $f0)
001500  2               .endrep
001500  2               
001500  2               shift6:
001500  2  00 04 08 0C  .repeat 256, i
001504  2  10 14 18 1C  
001508  2  20 24 28 2C  
001600  2               	.byte (i >> 6) | ((i << 2) & $fc)
001600  2               .endrep
001600  2               .align 1
001600  2               .endif
001600  2               
001600  1               
001600  1               ;----------------------------------------------------------------------
001600  1               ; AGD 6502 ENGINE CODE + COMPILED GAME SCRIPT
001600  1               ;----------------------------------------------------------------------
001600  1               
001600  1               start_game:
001600  1               
001600  1               	.include "game.inc"
001600  2               .include "doodlebug.inc"
001600  3               ; Game engine code --------------------------------------------------------------
001600  3               
001600  3               ; Arcade Game Designer.
001600  3               ; (C) 2008 Jonathan Cauldwell.
001600  3               ; ZX Spectrum Next Engine v0.1.
001600  3               
001600  3               ; Global definitions ------------------------------------------------------------
001600  3               
001600  3               	FONT = font			; Font address
001600  3               
001600  3               ; Block characteristics.
001600  3               
001600  3               	PLATFM = 1			; platform.
001600  3               	WALL = PLATFM + 1	; solid wall.
001600  3               	LADDER = WALL + 1	; ladder.
001600  3               	FODDER = LADDER + 1	; fodder block.
001600  3               	DEADLY = FODDER + 1	; deadly block.
001600  3               	CUSTOM = DEADLY + 1	; custom block.
001600  3               	WATER  = CUSTOM + 1	; water block.
001600  3                   COLECT = WATER + 1      ; collectable block.
001600  3                   NUMTYP = COLECT + 1     ; number of types.
001600  3               
001600  3               ; Sprites.
001600  3               
001600  3               	NUMSPR = 12			; number of sprites.
001600  3               	TABSIZ = 17			; size of each entry.
001600  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
001600  3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
001600  3               
001600  3               ; Sprite table variable offsets.
001600  3               
001600  3               	var_Type = 0		; sprite type
001600  3               	var_Image = 1		; sprite time number
001600  3               	var_Frame = 2		; sprite frame
001600  3               	var_Y = 3			; sprite y coordinate
001600  3               	var_X = 4			; sprite X coordinate
001600  3               
001600  3               	var_newType = 5		; sprite new type
001600  3               	var_newImage = 6	; sprite new image number
001600  3               	var_newFrame = 7	; sprite new frame
001600  3               	var_newY = 8		; sprite new y coordinate
001600  3               	var_newX = 9		; sprite new x coordinate
001600  3               
001600  3               	var_Direction = 10	; sprite direction
001600  3               	var_Param1 = 11		; sprite parameter 1
001600  3               	var_Param2 = 12		; sprite parameter 2
001600  3               
001600  3               	var_jumpLo = 13		; sprite jump ptr low
001600  3               	var_jumpHi = 14		; sprite jump ptr high
001600  3               	var_dataLo = 15		; sprite data ptr low
001600  3               	var_dataHi = 16		; sprite data ptr high
001600  3               
001600  3               ; Particle engine.
001600  3               
001600  3               	NUMSHR = 55			; pieces of shrapnel.
001600  3               	SHRSIZ = 6			; bytes per particle.
001600  3               
001600  3               ; Conditional compilation flags
001600  3               ; Flags are set in commandline assembly
001600  3               
001600  3               ;	mflag = 0 		; MENU + INV
001600  3               ;	pflag = 0		; Particle engine
001600  3               ;	sflag = 0		; scrollytext
001600  3               ;	fflag = 1		; Fontflag
001600  3               
001600  3               .if iflag
001600  3               	TxtInvert   = $ff	; Invert byte for character printing
001600  3               	ScrFillByte = $ff	; Screen fill byte for CLS
001600  3               .else
001600  3               	TxtInvert   = $00	; Invert byte for character printing
001600  3               	ScrFillByte = $00	; Screen fill byte for CLS
001600  3               .endif
001600  3               
001600  3               	ASCII_NEWLINE = 13
001600  3               
001600  3               ;===============================================================
001600  3               ; Game starts here
001600  3               ;===============================================================
001600  3               
001600  3               ;--------------------------------------------------------------
001600  3               ; If a font is required...
001600  3               ;--------------------------------------------------------------
001600  3               
001600  3  A9 94        	lda #<(FONT-256)	; address of font.
001602  3  85 rr        	sta FontPtr
001604  3  A9 38        	lda #>(FONT-256)
001606  3  85 rr        	sta FontPtr+1
001608  3               
001608  3  20 D9 16     	jsr game	 		; start the game.
00160B  3  60           	rts
00160C  3               
00160C  3               ; Don't change the order of these four.
00160C  3               ; Menu routine relies on winlft following wintop.
00160C  3               
00160C  3  00           wintop:	.byte WINDOWTOP		; top of window.
00160D  3  00           winlft:	.byte WINDOWLFT		; left edge.
00160E  3  17           winhgt:	.byte WINDOWHGT		; window height.
00160F  3  20           winwid:	.byte WINDOWWID		; window width.
001610  3  01           numob:	.byte NUMOBJ		; number of objects in game.
001611  3               
001611  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
001611  3               
001611  3  00           wntopx:	.byte (8 * WINDOWTOP)
001612  3  00           wnlftx:	.byte (8 * WINDOWLFT)
001613  3  A8           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
001614  3  EE           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
001615  3               
001615  3               ; Make sure pointers are arranged in the same order as the data itself.
001615  3               
001615  3  91 30        frmptr:	.word frmlst         ; sprite frames.
001617  3               
001617  3               ; Assorted game routines which can go in contended memory.
001617  3               
001617  3               ;--------------------------------------------------------------
001617  3               ; Modify for inventory.
001617  3               ; called by the INV command
001617  3               ;
001617  3               ; Input:
001617  3               ;  X   = message nr with objects seperated with ,
001617  3               ;
001617  3               ; Output:
001617  3               ;  OPT = selected line nr of INV menu
001617  3               ;--------------------------------------------------------------
001617  3               
001617  3               .if mflag
001617  3               minve:
001617  3               	lda #<(invdis)		; routine address.
001617  3               	sta mod0+1		; set up menu routine.
001617  3               	sta mod2+1		; set up count routine.
001617  3               	lda #>(invdis)
001617  3               	sta mod0+2
001617  3               	sta mod2+2
001617  3               	lda #<(fopt)		; find option from available objects.
001617  3               	sta mod1+1		; set up routine.
001617  3               	lda #>(fopt)
001617  3               	sta mod1+1+1
001617  3               	jmp dbox		; do menu routine.
001617  3               
001617  3               ;--------------------------------------------------------------
001617  3               ; Modify for menu.
001617  3               ; called by the MENU command
001617  3               ;
001617  3               ; Input:
001617  3               ;  X   = message nr with menu items seperated with ,
001617  3               ;
001617  3               ; Output:
001617  3               ;  OPT = selected line nr of MENU menu
001617  3               ;--------------------------------------------------------------
001617  3               
001617  3               mmenu:
001617  3               	lda #<(always)		; routine address.
001617  3               	sta mod0+1		; set up routine.
001617  3               	sta mod2+1		; set up count routine.
001617  3               	lda #>(always)
001617  3               	sta mod0+2
001617  3               	sta mod2+2
001617  3               
001617  3               	lda #<(fstd)		; standard option selection.
001617  3               	sta mod1+1		; set up routine.
001617  3               	lda #>(fstd)
001617  3               	sta mod1+2
001617  3               
001617  3               ; Drop through into box routine.
001617  3               
001617  3               ;--------------------------------------------------------------
001617  3               ; Work out size of box for message or menu.
001617  3               ;--------------------------------------------------------------
001617  3               
001617  3               dbox:
001617  3               	lda #<(msgdat)		; pointer to messages.
001617  3               	sta z80_l
001617  3               	lda #>(msgdat)
001617  3               	sta z80_h
001617  3               
001617  3               	jsr getwrd		; get message number.
001617  3               
001617  3               	lda z80_h		; store pointer to message.
001617  3               	sta TmpAddr
001617  3               	lda z80_l
001617  3               	sta TmpAddr+1
001617  3               
001617  3               	lda #1			; height.
001617  3               	sta z80_d
001617  3               	lda #0			; start at object zero.
001617  3               	sta combyt		; store number of object in combyt.
001617  3               	sta z80_e		; maximum width.
001617  3               dbox5:
001617  3               	lda #0			; this line"s width.
001617  3               	sta z80_b
001617  3               mod2:
001617  3               	jsr always		; item in player"s possession?
001617  3               	cmp #255
001617  3               	bne dbox6		; not in inventory, skip this line.
001617  3               	inc z80_d		; add to tally.
001617  3               dbox6:
001617  3               	ldy #0			; get character.
001617  3               	lda (z80_hl),y
001617  3               	sta z80_a
001617  3               	inc z80_l		; next character.
001617  3               	bne :+
001617  3               	inc z80_h
001617  3               :
001617  3               	lda z80_a		; reached end of line?
001617  3               	cmp #','
001617  3               	beq dbox3		; yes.
001617  3               	cmp #ASCII_NEWLINE
001617  3               	beq dbox3		; yes.
001617  3               	inc z80_b		; add to this line"s width.
001617  3               	lda z80_a
001617  3               	bmi dbox4		; end of message? yes, end count.
001617  3               	jmp dbox6		; repeat until we find the end.
001617  3               dbox3:
001617  3               	lda z80_e		; maximum line width.
001617  3               	cmp z80_b		; have we exceeded longest so far?
001617  3               	bpl dbox5		; no, carry on looking.
001617  3               	lda z80_b		; make this the widest so far.
001617  3               	sta z80_e
001617  3               	jmp dbox5		; keep looking.
001617  3               dbox4:
001617  3               	lda z80_e		; maximum line width.
001617  3               	cmp z80_b		; have we exceeded longest so far?
001617  3               	bpl dbox8		; no, carry on looking.
001617  3               	lda z80_b		; final line is the longest so far.
001617  3               	sta z80_e
001617  3               dbox8:
001617  3               	dec z80_d		; decrement items found.
001617  3               	bne :+			; total was zero.
001617  3               	jmp dbox15
001617  3               :
001617  3               	lda z80_e		; longest line.
001617  3               	bne :+			; was it zero?
001617  3               	jmp dbox15		; total was zero.
001617  3               :
001617  3               	sta bwid		; set up size.
001617  3               	lda z80_d
001617  3               	sta blen
001617  3               
001617  3               ;--------------------------------------------------------------
001617  3               ; That's set up our box size.
001617  3               ;--------------------------------------------------------------
001617  3               
001617  3               	lda winhgt		; window height in characters.
001617  3               	sec
001617  3               	sbc z80_d		; subtract height of box.
001617  3               	lsr a			; divide by 2.
001617  3               	clc
001617  3               	adc wintop		; add top edge of window.
001617  3               	sta btop		; set up box top.
001617  3               
001617  3               	lda winwid		; window width in characters.
001617  3               	sec
001617  3               	sbc z80_e		; subtract box width.
001617  3               	lsr a			; divide by 2.
001617  3               	clc
001617  3               	adc winlft		; add left edge of window.
001617  3               	sta blft		; box left.
001617  3               
001617  3               	lda FontPtr		; font.
001617  3               	sta grbase		; set up for text display.
001617  3               	lda FontPtr+1
001617  3               	sta grbase+1
001617  3               
001617  3               	lda TmpAddr+1		; restore message pointer.
001617  3               	sta z80_l
001617  3               	lda TmpAddr
001617  3               	sta z80_h
001617  3               
001617  3               	lda btop		; box top.
001617  3               	sta dispy		; set display coordinate.
001617  3               	lda #0			; start at object zero.
001617  3               	sta combyt		; store number of object in combyt.
001617  3               dbox2:
001617  3               	lda combyt		; get object number.
001617  3               	sta z80_a
001617  3               mod0:
001617  3               	jsr always		; check inventory for display.
001617  3               	cmp #255
001617  3               	beq :+
001617  3               	jmp dbox13		; not in inventory, skip this line.
001617  3               :
001617  3               	lda blft		; box left.
001617  3               	sta dispx		; set left display position.
001617  3               	lda bwid		; box width.
001617  3               	sta z80_b		; store width.
001617  3               dbox0:
001617  3               	ldy #0			; get character.
001617  3               	lda (z80_hl),y
001617  3               	cmp #','		; end of line?
001617  3               	beq dbox1		; yes, next one.
001617  3               	cmp #ASCII_NEWLINE			; end of line?
001617  3               	beq dbox1		; yes, next one.
001617  3               
001617  3               	dec z80_b		; one less to display.
001617  3               	and #127		; remove terminator.
001617  3               
001617  3               	jsr pchr		; display on screen.
001617  3               
001617  3               	ldy #0
001617  3               	lda (z80_hl),y		; get character.
001617  3               	sta z80_a
001617  3               	inc z80_l		; next character.
001617  3               	bne :+
001617  3               	inc z80_h
001617  3               :
001617  3               	lda z80_a
001617  3               	cmp #128		; end of message?
001617  3               	bmi :+
001617  3               	jmp dbox7		; yes, job done.
001617  3               :
001617  3               	lda z80_b		; chars remaining.
001617  3               	beq :+			; are any left?
001617  3               	jmp dbox0		; yes, continue.
001617  3               :
001617  3               ;---------------------------------------------------
001617  3               ; Reached limit of characters per line.
001617  3               ;---------------------------------------------------
001617  3               
001617  3               dbox9:
001617  3               	ldy #0
001617  3               	lda (z80_hl),y		; get character.
001617  3               	inc z80_l		; next one.
001617  3               	bne :+
001617  3               	inc z80_h
001617  3               :
001617  3               	cmp #','		; another line?
001617  3               	beq dbox10		; yes, do next line.
001617  3               	cmp #ASCII_NEWLINE			; another line?
001617  3               	beq dbox10		; yes, do next line.
001617  3               	cmp #128		; end of message?
001617  3               	bcs :+
001617  3               	jmp dbox11		; yes, finish message.
001617  3               :
001617  3               	jmp dbox9
001617  3               
001617  3               ;---------------------------------------------------
001617  3               ; Fill box to end of line.
001617  3               ;---------------------------------------------------
001617  3               
001617  3               dboxf:
001617  3               	lda #32			; space character.
001617  3               	jsr pchr		; display character.
001617  3               	dec z80_b
001617  3               	beq :+
001617  3               	jmp dboxf		; repeat for remaining chars on line.
001617  3               :
001617  3               	rts
001617  3               dbox1:
001617  3               	inc z80_l		; skip character.
001617  3               	bne :+
001617  3               	inc z80_h
001617  3               :
001617  3               	jsr dboxf		; fill box out to right side.
001617  3               dbox10:
001617  3               	inc dispy		; y coordinate down a line next position.
001617  3               	jmp dbox2		; next line.
001617  3               dbox7:
001617  3               	lda z80_b		; chars remaining.
001617  3               	bne :+			; are any left?
001617  3               	jmp dbox11		; no, nothing to draw.
001617  3               :
001617  3               	jsr dboxf		; fill message to line.
001617  3               
001617  3               ;------------------------------------------------------
001617  3               ; Drawn the box menu, now select option.
001617  3               ;------------------------------------------------------
001617  3               
001617  3               dbox11:
001617  3               	lda btop		; box top.
001617  3               	sta dispy		; set bar position.
001617  3               dbox14:
001617  3               	jsr joykey		; get controls.
001617  3               	cmp #$7f		; anything pressed?
001617  3               	bne dbox14		; yes, debounce it.
001617  3               	jsr dbar		; draw bar.
001617  3               dbox12:
001617  3               	jsr joykey		; get controls.
001617  3               	cmp #$7f		; anything pressed?
001617  3               	beq dbox12		; no, nothing.
001617  3               	and #16			; fire button pressed?
001617  3               	bne :+
001617  3               mod1:
001617  3               	jmp fstd		; yes, job done.
001617  3               :
001617  3               	jsr dbar		; delete bar.
001617  3               
001617  3               	lda joyval		; joystick reading.
001617  3               	and #8			; going up?
001617  3               	beq dboxu		; yes, go up.
001617  3               
001617  3               	ldx dispy		; vertical position of bar.
001617  3               	inx			; look down.
001617  3               	txa
001617  3               	sec
001617  3               	sbc btop		; find distance from top.
001617  3               	cmp blen		; top of box.
001617  3               	bne :+
001617  3               	jmp dbox14		; yes, go no further.
001617  3               :
001617  3               	inc dispy		; move bar.
001617  3               	jmp dbox14		; continue.
001617  3               dboxu:
001617  3               	lda dispy		; vertical position of bar.
001617  3               	cmp btop		; are we at the top?
001617  3               	bne :+
001617  3               	jmp dbox14		; yes, go no further.
001617  3               :
001617  3               	dec dispy		; move bar.
001617  3               	jmp dbox14		; continue.
001617  3               fstd:
001617  3               	lda dispy		; bar position.
001617  3               	sec
001617  3               	sbc btop		; find selected option.
001617  3               	sta varopt		; store the option.
001617  3               	jmp redraw		; redraw the screen.
001617  3               
001617  3               ;------------------------------------------------------
001617  3               ; Option not available.  Skip this line.
001617  3               ;------------------------------------------------------
001617  3               
001617  3               dbox13:
001617  3               	ldy #0
001617  3               	lda (z80_hl),y		; get character.
001617  3               	inc z80_l		; next one.
001617  3               	bne :+
001617  3               	inc z80_h
001617  3               :
001617  3               	cmp #','		; another line?
001617  3               	bne :+
001617  3               	jmp dbox2		; yes, do next line.
001617  3               :
001617  3               	cmp #ASCII_NEWLINE			; another line?
001617  3               	bne :+
001617  3               	jmp dbox2		; yes, do next line.
001617  3               :
001617  3               
001617  3               	bpl :+			; end of message?
001617  3               	jmp dbox11		; yes, finish message.
001617  3               :
001617  3               	jmp dbox13
001617  3               dbox15:
001617  3               	lda TmpAddr		; pop message pointer from the stack.
001617  3               	sta z80_h
001617  3               	lda TmpAddr+1
001617  3               	sta z80_l
001617  3               	rts
001617  3               
001617  3               ;------------------------------------------------------
001617  3               ; Invert bar
001617  3               ;------------------------------------------------------
001617  3               
001617  3               dbar:
001617  3               	lda blft		; box left.
001617  3               	sta dispx		; set display coordinate.
001617  3               	jsr gprad		; get printing address.
001617  3               
001617  3               	lda bwid		; box width.
001617  3               	sta z80_c		; loop counter in c.
001617  3               	lda z80_h
001617  3               	sta z80_d		; store screen address high byte.
001617  3               dbar1:
001617  3               	ldy #7			; pixel height in b.
001617  3               dbar0:
001617  3               	lda (scraddr),y		; get screen byte.
001617  3               	eor #255		; reverse all bits.
001617  3               	sta (scraddr),y		; write back to screen.
001617  3               	dey			; next line down.
001617  3               	bpl dbar0		; draw rest of character.
001617  3               
001617  3               	clc
001617  3               	lda scraddr		; one char right.
001617  3               	adc #8
001617  3               	sta scraddr
001617  3               	bcc :+
001617  3               	inc scraddr+1
001617  3               :
001617  3               
001617  3               	dec z80_c		; decrement character counter.
001617  3               	beq :+
001617  3               	jmp dbar1		; repeat for whole line.
001617  3               :
001617  3               	rts
001617  3               
001617  3               ;------------------------------------------------------
001617  3               ; Point to object
001617  3               ;
001617  3               ; Input:
001617  3               ;  -
001617  3               ;
001617  3               ; Output:
001617  3               ;  A = object number, A=255 if already in possession
001617  3               ;------------------------------------------------------
001617  3               
001617  3               invdis:
001617  3               	lda z80_l		; store message text pointer.
001617  3               	pha
001617  3               	lda z80_h
001617  3               	pha
001617  3               	lda combyt		; object number.
001617  3               	inc combyt		; ready for next one.
001617  3               	jsr gotob		; check if we have object.
001617  3               	tay
001617  3               	pla
001617  3               	sta z80_h
001617  3               	pla
001617  3               	sta z80_l
001617  3               	tya
001617  3               	rts
001617  3               
001617  3               ;------------------------------------------------------
001617  3               ; Find option selected.
001617  3               ;
001617  3               ; Input:
001617  3               ;  -
001617  3               ;
001617  3               ; Output:
001617  3               ;  OPT = selected object
001617  3               ;------------------------------------------------------
001617  3               
001617  3               fopt:
001617  3               	lda dispy
001617  3               	sec
001617  3               	sbc btop		; find selected option.
001617  3               	sta tmp+2		; option selected in b register.
001617  3               	inc tmp+2
001617  3               
001617  3               	lda #0			; set to first item.
001617  3               	sta combyt		; object number.
001617  3               fopt0:
001617  3               	jsr fobj		; find next object in inventory.
001617  3               	dec tmp+2
001617  3               	bne fopt0		; repeat for relevant steps down the list.
001617  3               
001617  3               	lda combyt		; get option.
001617  3               	sta varopt		; store the option.
001617  3               	dec varopt		; one less, due to where we increment combyt.
001617  3               	jmp redraw		; redraw the screen.
001617  3               fobj:
001617  3               	ldy combyt		; object number.
001617  3               	inc combyt		; ready for next item.
001617  3               	tya
001617  3               	jsr gotob		; do we have this item?
001617  3               	cmp #255
001617  3               	bne :+
001617  3               	rts
001617  3               :
001617  3               	jmp fobj		; yes, it's on the list.
001617  3               .endif
001617  3               
001617  3               ;----------------------------------------------------
001617  3               ; Clear sprite table.
001617  3               ;
001617  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
001617  3               ;----------------------------------------------------
001617  3               
001617  3               xspr:
001617  3  A9 FF        	lda #255		; clear byte.
001619  3  A2 00        	ldx #0			; length of table.
00161B  3               xspr0:
00161B  3  9D 00 0B     	sta sprtab,x		; sprite table.
00161E  3  E8           	inx			; move to next byte.
00161F  3  E0 CC        	cpx #SPRBUF
001621  3  D0 F8        	bne xspr0		; repeat for rest of table.
001623  3  60           	rts
001624  3               
001624  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001624  3               ; Sound, NOT IMPLEMENTED!!!
001624  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001624  3               ;
001624  3               ;silenc:
001624  3               ;	jsr silen1 		; silence channel 1.
001624  3               ;	jsr silen2 		; silence channel 2.
001624  3               ;	jsr silen3 		; silence channel 3.
001624  3               ;	jmp plsnd 		; play all channels to switch them off.
001624  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001624  3               
001624  3               ;-------------------------------------------------------------
001624  3               ; Initialise all objects.
001624  3               ;
001624  3               ; Reset current room,y,x to start room,y,x for all objects
001624  3               ;-------------------------------------------------------------
001624  3               
001624  3               iniob:
001624  3  A9 6E        	lda #<objdta 		; objects table.
001626  3  85 rr        	sta z80_x
001628  3  A9 39        	lda #>objdta
00162A  3  85 rr        	sta z80_i
00162C  3               
00162C  3  AE 10 16     	ldx numob 		; number of objects in the game.
00162F  3               iniob0:
00162F  3  A0 23        	ldy #35
001631  3  B1 rr        	lda (z80_ix),y 		; start screen.
001633  3  A0 20        	ldy #32
001635  3  91 rr        	sta (z80_ix),y 		; set start screen.
001637  3               
001637  3  A0 24        	ldy #36
001639  3  B1 rr        	lda (z80_ix),y 		; find start y.
00163B  3  A0 21        	ldy #33
00163D  3  91 rr        	sta (z80_ix),y 		; set start y.
00163F  3               
00163F  3  A0 25        	ldy #37
001641  3  B1 rr        	lda (z80_ix),y 		; get initial x.
001643  3  A0 22        	ldy #34
001645  3  91 rr        	sta (z80_ix),y 		; set x coord.
001647  3               
001647  3  18           	clc 			; point to next object.
001648  3  A5 rr        	lda z80_x
00164A  3  69 26        	adc #38			; distance between objects.
00164C  3  85 rr        	sta z80_x
00164E  3  90 02        	bcc :+
001650  3  E6 rr        	inc z80_i
001652  3               :
001652  3  CA           	dex 			; repeat.
001653  3  D0 DA        	bne iniob0
001655  3               
001655  3  60           	rts
001656  3               
001656  3               ;-----------------------------------------------
001656  3               ; Redraw the screen.
001656  3               ;
001656  3               ; Remove old copy of all sprites for redraw.
001656  3               ;-----------------------------------------------
001656  3               
001656  3               redraw:
001656  3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
001658  3  48           	pha
001659  3  A5 rr        	lda z80_x
00165B  3  48           	pha
00165C  3               
00165C  3  20 D8 1C     	jsr droom		; show screen layout.
00165F  3  20 CB 18     	jsr shwob		; draw objects.
001662  3               numsp0:
001662  3  A9 0C        	lda #NUMSPR		; sprites to draw.
001664  3  85 rr        	sta tmp
001666  3               
001666  3  A9 00        	lda #<sprtab		; sprite table.
001668  3  85 rr        	sta z80_x
00166A  3  A9 0B        	lda #>sprtab
00166C  3  85 rr        	sta z80_i
00166E  3               redrw0:
00166E  3  A0 00        	ldy #0
001670  3  B1 rr        	lda (z80_ix),y		; old sprite type.
001672  3  C9 FF        	cmp #255		; is it enabled?
001674  3  F0 0B        	beq redrw1 		; no, find next one.
001676  3               
001676  3  A0 03        	ldy #var_Y
001678  3  B1 rr        	lda (z80_ix),y 		; sprite y.
00167A  3  C9 B1        	cmp #177		; beyond maximum?
00167C  3  B0 03        	bcs redrw1		; yes, nothing to draw.
00167E  3               
00167E  3  20 D1 0F     	jsr sspria		; show single sprite.
001681  3               
001681  3               redrw1:
001681  3  18           	clc			; next sprite.
001682  3  A5 rr        	lda z80_x
001684  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
001686  3  85 rr        	sta z80_x
001688  3  90 02        	bcc :+
00168A  3  E6 rr        	inc z80_i
00168C  3               :
00168C  3  C6 rr        	dec tmp			; repeat for remaining sprites.
00168E  3  D0 DE        	bne redrw0
001690  3               
001690  3               rpblc1:
001690  3               ;	jsr dshrp		; redraw shrapnel.
001690  3               
001690  3  68           	pla			; retrieve sprite pointer.
001691  3  85 rr        	sta z80_x
001693  3  68           	pla
001694  3  85 rr        	sta z80_i
001696  3               
001696  3  60           	rts
001697  3               
001697  3               ;----------------------------------------------------------------------
001697  3               ; Clear screen routine.
001697  3               ;
001697  3               ; Fill screenmem $8000-$97ff with ScrFillByte
001697  3               ;----------------------------------------------------------------------
001697  3               
001697  3               cls:
001697  3  A9 68        	lda #>ScreenAddr		; screen address.
001699  3  8D A2 16     	sta clsloop+2
00169C  3  A9 FF        	lda #ScrFillByte
00169E  3  A0 00        	ldy #0
0016A0  3               clsloop:
0016A0  3  99 00 68     	sta ScreenAddr,y
0016A3  3  C8           	iny
0016A4  3  D0 FA        	bne clsloop
0016A6  3  EE A2 16     	inc clsloop+2
0016A9  3  AE A2 16     	ldx clsloop+2
0016AC  3  E0 80        	cpx #>(ScreenAddr+ScreenSize)		; _BEEB
0016AE  3  D0 F0        	bne clsloop
0016B0  3  60           	rts
0016B1  3               
0016B1  3               ;----------------------------------------------------------------------
0016B1  3               ; FODDER check
0016B1  3               ;----------------------------------------------------------------------
0016B1  3               
0016B1  3               fdchk:
0016B1  3  C9 04        	cmp #FODDER 		; is it fodder?
0016B3  3  F0 01        	beq :+
0016B5  3  60           	rts 			; no.
0016B6  3               :
0016B6  3  A9 00        	lda #0			; wipe fodder in MAP
0016B8  3  A0 00        	ldy #0
0016BA  3  91 rr        	sta (bufaddr),y 	; rewrite block type.
0016BC  3               
0016BC  3  A5 rr        	lda dispx		; x=x/8
0016BE  3  48           	pha
0016BF  3  4A           	lsr a
0016C0  3  4A           	lsr a
0016C1  3  4A           	lsr a
0016C2  3  85 rr        	sta dispx
0016C4  3               
0016C4  3  A5 rr        	lda dispy		; y=y/8
0016C6  3  48           	pha
0016C7  3  4A           	lsr a
0016C8  3  4A           	lsr a
0016C9  3  4A           	lsr a
0016CA  3  85 rr        	sta dispy
0016CC  3               
0016CC  3  A9 00        	lda #0 			; block to write.
0016CE  3  20 41 1C     	jsr pattr 		; write block.
0016D1  3               
0016D1  3  68           	pla
0016D2  3  85 rr        	sta dispy
0016D4  3  68           	pla
0016D5  3  85 rr        	sta dispx
0016D7  3  60           	rts
0016D8  3               
0016D8  3               ;----------------------------------------------------
0016D8  3               ; Scrolly text and puzzle variables.
0016D8  3               ;----------------------------------------------------
0016D8  3               
0016D8  3               .if sflag
0016D8  3               txtbit:	.byte 128		; bit to write.
0016D8  3               txtwid:	.byte 16		; width of ticker message.
0016D8  3               txtpos:	.word msgdat
0016D8  3               txtini:	.word msgdat
0016D8  3               txtscr:	.word ScreenAddr
0016D8  3               .endif
0016D8  3               
0016D8  3               ;----------------------------------------------------
0016D8  3               ; Specialist routines.
0016D8  3               ; Process shrapnel.
0016D8  3               ;----------------------------------------------------
0016D8  3               proshr:
0016D8  3               .if pflag
0016D8  3               	lda #<SHRAPN		; table.
0016D8  3               	sta z80_x
0016D8  3               	lda #>SHRAPN
0016D8  3               	sta z80_i
0016D8  3               
0016D8  3               	lda #NUMSHR		; shrapnel pieces to process.
0016D8  3               	sta shrctr
0016D8  3               prosh0:
0016D8  3               	ldy #0
0016D8  3               	lda (z80_ix),y		; on/off marker.
0016D8  3               	asl a
0016D8  3               proshx:
0016D8  3               	bcs :+
0016D8  3               	jsr prosh1 		; on, so process it.
0016D8  3               :
0016D8  3               	clc
0016D8  3               	lda z80_x
0016D8  3               	adc #SHRSIZ
0016D8  3               	sta z80_x
0016D8  3               	bcc :+
0016D8  3               	inc z80_i
0016D8  3               :
0016D8  3               	dec shrctr		; round again.
0016D8  3               	bne prosh0
0016D8  3               .endif
0016D8  3               .if sflag
0016D8  3               	jsr scrly
0016D8  3               .endif
0016D8  3  60           	rts
0016D9  3               
0016D9  3               .if pflag
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Proces shrapnel piece
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               prosh1:
0016D9  3               	jsr plot 		; delete the pixel.
0016D9  3               
0016D9  3               	lda #<shrptr		; shrapnel routine pointers.
0016D9  3               	sta z80_l
0016D9  3               	lda #>shrptr
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	ldy #0
0016D9  3               	lda (z80_ix),y		; restore shrapnel type.
0016D9  3               	jsr prosh2 		; run the routine.
0016D9  3               	jsr chkxy		; check x and y are good before we redisplay.
0016D9  3               
0016D9  3               	lda #<SHRSIZ 		; distance to next.
0016D9  3               	sta z80_e
0016D9  3               	lda #>SHRSIZ
0016D9  3               	sta z80_d
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Run the routine
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               prosh2:
0016D9  3               	asl a 			; 2 bytes per address.
0016D9  3               	tay
0016D9  3               	lda shrptr,y
0016D9  3               	sta z80_l
0016D9  3               	lda shrptr+1,y 		; fetch high byte from table.
0016D9  3               	sta z80_h
0016D9  3               	jmp (z80_hl) 		; jump to routine.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Paricle routine table
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               shrptr:	.word laser		; laser.
0016D9  3               	.word trail		; vapour trail.
0016D9  3               	.word shrap		; shrapnel from explosion.
0016D9  3               	.word dotl		; horizontal starfield left.
0016D9  3               	.word dotr		; horizontal starfield right.
0016D9  3               	.word dotu		; vertical starfield up.
0016D9  3               	.word dotd		; vertical starfield down.
0016D9  3               	.word ptcusr		; user particle.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Explosion shrapnel.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               shrap:
0016D9  3               	ldy #1
0016D9  3               	lda (z80_ix),y 		; get the angle.
0016D9  3               	clc
0016D9  3               	adc #<shrsin		; shrapnel sine table.
0016D9  3               	sta z80_l
0016D9  3               	lda #>shrsin
0016D9  3               	adc #0
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	ldy #0
0016D9  3               	lda (z80_hl),y 		; fetch value from table.
0016D9  3               	sta z80_e
0016D9  3               	inc z80_l 		; next byte of table.
0016D9  3               	bne :+
0016D9  3               	inc z80_h
0016D9  3               :
0016D9  3               	ldy #0
0016D9  3               	lda (z80_hl),y		; fetch value from table.
0016D9  3               	sta z80_d
0016D9  3               	inc z80_l		; next byte of table.
0016D9  3               	bne :+
0016D9  3               	inc z80_h
0016D9  3               :
0016D9  3               	ldy #0
0016D9  3               	lda (z80_hl),y 		; fetch value from table.
0016D9  3               	sta z80_c
0016D9  3               	inc z80_l 		; next byte of table.
0016D9  3               	bne :+
0016D9  3               	inc z80_h
0016D9  3               :
0016D9  3               	ldy #0
0016D9  3               	lda (z80_hl),y 		; fetch value from table.
0016D9  3               	sta z80_b
0016D9  3               
0016D9  3               	ldy #2
0016D9  3               	lda (z80_ix),y 		; x coordinate in hl.
0016D9  3               	clc
0016D9  3               	adc z80_e		; add sine lb
0016D9  3               	sta (z80_ix),y		; store new coordinate lb.
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y
0016D9  3               	adc z80_d		; add sine hb
0016D9  3               	sta (z80_ix),y		; store new coordinate hb.
0016D9  3               
0016D9  3               	ldy #4
0016D9  3               	lda (z80_ix),y	 	; y coordinate in hl.
0016D9  3               	clc
0016D9  3               	adc z80_c		; add cosine lb
0016D9  3               	sta (z80_ix),y		; store new coordinate lb.
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y
0016D9  3               	adc z80_b		; add cosine lb
0016D9  3               	sta (z80_ix),y		; store new coordinate hb.
0016D9  3               
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Move dots
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               dotl:
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y
0016D9  3               	sec
0016D9  3               	sbc #1		 	; move left.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               dotr:
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y
0016D9  3               	clc
0016D9  3               	adc #1		 	; move left.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               dotu:
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y
0016D9  3               	sec
0016D9  3               	sbc #1		 	; move up.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               dotd:
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y
0016D9  3               	clc
0016D9  3               	adc #1			; move down.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Check if coordinates are ok before redrawing at new position.
0016D9  3               ;
0016D9  3               ; left:   X>L		X=L	Ok
0016D9  3               ; right:  R+15>X	X=R	Ok
0016D9  3               ; top:    Y>T		Y=T	Ok
0016D9  3               ; bottom: B+15>Y	Y=B	Ok
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               chkxy:
0016D9  3               
0016D9  3               ; top:    Y>T		Y=T	Ok
0016D9  3               
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0016D9  3               	cmp wntopx		; window top.
0016D9  3               	bcs :+			; compare with top window limit.
0016D9  3               	jmp kilshr		; out of window, kill shrapnel.
0016D9  3               :
0016D9  3               ; left:   X>L		X=L	Ok
0016D9  3               
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
0016D9  3               	cmp wnlftx		; left edge.
0016D9  3               	bcs :+			; compare with left window limit.
0016D9  3               	jmp kilshr		; out of window, kill shrapnel.
0016D9  3               :
0016D9  3               ; bottom: B+15>Y	Y=B	Ok
0016D9  3               
0016D9  3               	lda wnbotx		; point to bottom.
0016D9  3               	clc
0016D9  3               	adc #15
0016D9  3               	ldy #3
0016D9  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0016D9  3               	bcs :+			; compare with shrapnel x coordinate.
0016D9  3               	jmp kilshr		; off screen, kill shrapnel..
0016D9  3               :
0016D9  3               ; right:  R+15>X	X=R	Ok
0016D9  3               
0016D9  3               	lda wnrgtx		; point to right edge.
0016D9  3               	clc
0016D9  3               	adc #15
0016D9  3               	ldy #5
0016D9  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
0016D9  3               	bcs :+			; compare with window limit.
0016D9  3               	jmp kilshr		; off screen, kill shrapnel.
0016D9  3               :
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Drop through.
0016D9  3               ; Display shrapnel.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               plot:
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y		; y integer.
0016D9  3               	sta dispy	 	; workspace coordinates.
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y	 	; x integer.
0016D9  3               	sta dispx 		; workspace coordinates.
0016D9  3               
0016D9  3               	ldy #0
0016D9  3               	lda (z80_ix),y 		; type.
0016D9  3               	bne :+			; is it a laser?
0016D9  3               	jmp plot1 		; yes, draw laser instead.
0016D9  3               :
0016D9  3               plot0:
0016D9  3               	lda dispx		; which pixel within byte do we
0016D9  3               	and #7			; want to set first?
0016D9  3               	tay
0016D9  3               	lda dots,y 		; table of small pixel positions.
0016D9  3               	sta z80_e 		; get value.
0016D9  3               
0016D9  3               	jsr scadd 		; screen address.
0016D9  3               	ldy #0
0016D9  3               	lda (scraddr),y		; see what's already there.
0016D9  3               	eor z80_e
0016D9  3               	sta (scraddr),y 	; put back on screen.
0016D9  3               	rts
0016D9  3               
0016D9  3               plot1:
0016D9  3               	jsr scadd 		; screen address.
0016D9  3               	ldy #0
0016D9  3               	lda (scraddr),y 	; fetch byte there.
0016D9  3               	eor #255 		; toggle all bits.
0016D9  3               	sta (scraddr),y 	; new byte.
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Switch off shrapnel
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               kilshr:
0016D9  3               	lda #128
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y	; switch off shrapnel.
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Sine/cosine table
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               shrsin:	.word 0,1024,391,946,724,724,946,391
0016D9  3               	.word 1024,0,946,65144,724,64811,391,64589
0016D9  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
0016D9  3               	.word 64512,0,64589,391,64811,724,65144,946
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create trail
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               trail:
0016D9  3               	ldy #1
0016D9  3               	lda (z80_ix),y 	; time remaining.
0016D9  3               	sec
0016D9  3               	sbc #1
0016D9  3               	sta (z80_ix),y
0016D9  3               	bne :+
0016D9  3               	jmp trailk		; time to switch it off.
0016D9  3               :
0016D9  3               	jsr qrand		; get a random number.
0016D9  3               	lsr a 			; x or y axis?
0016D9  3               	bcc :+
0016D9  3               	jmp trailv		; use y.
0016D9  3               :
0016D9  3               ; Trail horizontal
0016D9  3               
0016D9  3               	lsr a 			; which direction?
0016D9  3               	bcc :+
0016D9  3               	jmp traill		; go left.
0016D9  3               :
0016D9  3               ; Trail right
0016D9  3               
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y
0016D9  3               	clc
0016D9  3               	adc #1	 		; go right.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ; Trail left
0016D9  3               
0016D9  3               traill:
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y
0016D9  3               	sec
0016D9  3               	sbc #1 			; go left.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ; Trail vertical
0016D9  3               
0016D9  3               trailv:
0016D9  3               	lsr a		 	; which direction?
0016D9  3               	bcc :+
0016D9  3               	jmp trailu		; go up.
0016D9  3               :
0016D9  3               ; Trail down
0016D9  3               
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y
0016D9  3               	clc
0016D9  3               	adc #1 			; go down.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ; Trail up
0016D9  3               
0016D9  3               trailu:
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y
0016D9  3               	sec
0016D9  3               	sbc #1 			; go up.
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ; Kill trail
0016D9  3               
0016D9  3               trailk:
0016D9  3               	lda #200		; set off-screen to kill vapour trail.
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create laser beam
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               laser:
0016D9  3               	ldy #1
0016D9  3               	lda (z80_ix),y 		; direction.
0016D9  3               	ror a 			; left or right?
0016D9  3               	bcs :+
0016D9  3               	jmp laserl		; move left.
0016D9  3               :
0016D9  3               ; Laser right
0016D9  3               
0016D9  3               	lda #8			; distance to travel.
0016D9  3               	sta z80_b
0016D9  3               	jmp laserm		; move laser.
0016D9  3               
0016D9  3               ; Laser left
0016D9  3               
0016D9  3               laserl:
0016D9  3               	lda #248		; distance to travel.
0016D9  3               	sta z80_b
0016D9  3               laserm:
0016D9  3               	ldy #5
0016D9  3               	lda (z80_ix),y		; x position.
0016D9  3               	clc
0016D9  3               	adc z80_b		; add distance.
0016D9  3               	sta (z80_ix),y		; set new x coordinate.
0016D9  3               
0016D9  3               ; Test new block.
0016D9  3               
0016D9  3               	sta dispx 		; set x for block collision detection purposes.
0016D9  3               	ldy #3
0016D9  3               	lda (z80_ix),y 		; get y.
0016D9  3               	sta dispy		; set coordinate for collision test.
0016D9  3               	jsr tstbl 		; get block type there.
0016D9  3               	cmp #WALL		; is it solid?
0016D9  3               	bne :+
0016D9  3               	jmp trailk		; yes, it cannot pass.
0016D9  3               :
0016D9  3                       cmp #FODDER             ; is it fodder?
0016D9  3                       bne :+
0016D9  3                       jsr fdchk               ; remove fodder block.
0016D9  3                       jmp trailk              ; destroy laser.
0016D9  3               :
0016D9  3                       rts                     ; no, ignore it.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Dots mask
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               dots:	.byte 128,64,32,16,8,4,2,1
0016D9  3               
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Plot, preserving de.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               plotde:
0016D9  3               	lda z80_d 		; put de on stack.
0016D9  3               	pha
0016D9  3               	lda z80_e
0016D9  3               	pha
0016D9  3               
0016D9  3               	jsr plot 		; plot pixel.
0016D9  3               
0016D9  3               	pla			; restore de from stack.
0016D9  3               	sta z80_e
0016D9  3               	pla
0016D9  3               	sta z80_d
0016D9  3               
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Shoot a laser.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               shoot:
0016D9  3               	sta z80_c		; store direction in c register.
0016D9  3               	ldy #8
0016D9  3               	lda (z80_ix),y 		; y coordinate.
0016D9  3               shoot1:
0016D9  3               	clc
0016D9  3               	adc #7 			; down 7 pixels.
0016D9  3               	sta z80_l 		; puty y coordinate in l.
0016D9  3               
0016D9  3               	ldy #9
0016D9  3               	lda (z80_ix),y 		; x coordinate in h.
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	lda z80_i		; store pointer to sprite.
0016D9  3               	pha
0016D9  3               	lda z80_x
0016D9  3               	pha
0016D9  3               
0016D9  3               	jsr fpslot 		; find particle slot.
0016D9  3               	bcs :+
0016D9  3               	jmp vapou2		; failed, restore ix.
0016D9  3               :
0016D9  3               	lda #0
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y 		; set up a laser.
0016D9  3               
0016D9  3               	lda z80_c
0016D9  3               	ldy #1
0016D9  3               	sta (z80_ix),y 		; set the direction.
0016D9  3               
0016D9  3               	lda z80_l
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y		; set y coordinate.
0016D9  3               
0016D9  3               	ror z80_c		; check direction we want.
0016D9  3               	bcc :+
0016D9  3               	jmp shootr		; shoot right.
0016D9  3               :
0016D9  3               	lda z80_h		; X position.
0016D9  3               shoot0:
0016D9  3               	and #248		; align on character boundary.
0016D9  3               	ldy #5
0016D9  3               	sta (z80_ix),y		; set x coordinate.
0016D9  3               	jmp vapou0 		; draw first image.
0016D9  3               shootr:
0016D9  3               	lda z80_h		; x position.
0016D9  3               	clc
0016D9  3               	adc #15			; look right.
0016D9  3               	jmp shoot0		; align and continue.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create a bit of vapour trail.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               vapour:
0016D9  3               	lda z80_i		; store pointer to sprite.
0016D9  3               	pha
0016D9  3               	lda z80_x
0016D9  3               	pha
0016D9  3               
0016D9  3               	ldy #8
0016D9  3               	lda (z80_ix),y 		; y coordinate.
0016D9  3               	clc
0016D9  3               	adc #7			; mid-point of sprite.
0016D9  3               	sta z80_l
0016D9  3               
0016D9  3               	ldy #9
0016D9  3               	lda (z80_ix),y 		; x coordinate.
0016D9  3               	adc #7
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	jsr fpslot 		; find particle slot.
0016D9  3               	bcc :+
0016D9  3               	jmp vapou1		; no, we can use it.
0016D9  3               :
0016D9  3               vapou2:
0016D9  3               	pla
0016D9  3               	sta z80_x
0016D9  3               	pla
0016D9  3               	sta z80_i
0016D9  3               	rts
0016D9  3               vapou1:
0016D9  3               	lda z80_l
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y		; set up y.
0016D9  3               
0016D9  3               	lda z80_h
0016D9  3               	ldy #5
0016D9  3               	sta (z80_ix),y 		; set up x coordinate.
0016D9  3               
0016D9  3               	jsr qrand		; get quick random number.
0016D9  3               	and #15			; random time.
0016D9  3               	clc
0016D9  3               	adc #15			; minimum time on screen.
0016D9  3               	ldy #1
0016D9  3               	sta (z80_ix),y		; set time on screen.
0016D9  3               
0016D9  3               	lda #1
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y		; define particle as vapour trail.
0016D9  3               vapou0:
0016D9  3               	jsr chkxy		; plot first position.
0016D9  3               	jmp vapou2
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create a user particle.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               ptusr:
0016D9  3               	sta z80_f		; store timer.
0016D9  3               
0016D9  3               	ldy #8
0016D9  3               	lda (z80_ix),y 		; y coordinate.
0016D9  3               	clc
0016D9  3               	adc #7			; mid-point of sprite.
0016D9  3               	sta z80_l
0016D9  3               
0016D9  3               	ldy #9
0016D9  3               	lda (z80_ix),y 		; x coordinate.
0016D9  3               	clc
0016D9  3               	adc #7			; mid-point of sprite.
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	jsr fpslot 		; find particle slot.
0016D9  3               	bcs ptusr1
0016D9  3               	rts 			; out of slots, can't generate anything.
0016D9  3               ptusr1:
0016D9  3               	lda z80_l
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y 		; set up y.
0016D9  3               
0016D9  3               	lda z80_h
0016D9  3               	ldy #5
0016D9  3               	sta (z80_ix),y		; set up x coordinate.
0016D9  3               
0016D9  3               	lda z80_f 		; restore timer.
0016D9  3               	ldy #1
0016D9  3               	sta (z80_ix),y		; set time on screen.
0016D9  3               
0016D9  3               	lda #7
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y		; define particle as user particle.
0016D9  3               
0016D9  3               	jmp chkxy		; plot first position.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create a vertical or horizontal star.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               star:
0016D9  3               	lda z80_i		; store pointer to sprite.
0016D9  3               	pha
0016D9  3               	lda z80_x
0016D9  3               	pha
0016D9  3               
0016D9  3               	jsr fpslot 		; find particle slot.
0016D9  3               	bcs star7		; found one we can use.
0016D9  3               star0:
0016D9  3               	pla 			; restore sprite pointer.
0016D9  3               	sta z80_x
0016D9  3               	pla
0016D9  3               	sta z80_i
0016D9  3               	rts 			; out of slots, can't generate anything.
0016D9  3               star7:
0016D9  3               	lda z80_c		; direction.
0016D9  3               	and #3 			; is it left?
0016D9  3               	bne :+
0016D9  3               	jmp star1 		; yes, it's left.
0016D9  3               :
0016D9  3               	cmp #1 			; is it right?
0016D9  3               	bne :+
0016D9  3               	jmp star2 		; yes, it's right.
0016D9  3               :
0016D9  3               	cmp #2 			; is it up?
0016D9  3               	bne :+
0016D9  3               	jmp star3 		; yes, it's up.
0016D9  3               :
0016D9  3               	ldy wntopx 		; get edge of screen.
0016D9  3               	iny			; down one pixel.
0016D9  3               	tya
0016D9  3               star8:
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y 		; set y coord.
0016D9  3               	jsr qrand 		; get quick random number.
0016D9  3               star9:
0016D9  3               	ldy #5
0016D9  3               	sta (z80_ix),y		; set x position.
0016D9  3               
0016D9  3               	lda z80_c		; direction.
0016D9  3               	and #3			; zero to three.
0016D9  3               	clc
0016D9  3               	adc #3			; 3 to 6 for starfield.
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y		; define particle as star.
0016D9  3               	jsr chkxy		; plot first position.
0016D9  3               	jmp star0
0016D9  3               star1:
0016D9  3               	jsr qrand		; get quick random number.
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y 		; set y coord.
0016D9  3               
0016D9  3               	lda wnrgtx 		; get edge of screen.
0016D9  3               	clc
0016D9  3               	adc #15			; add width of sprite minus 1.
0016D9  3               	jmp star9
0016D9  3               star2:
0016D9  3               	jsr qrand 		; get quick random number.
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y		; set y coord.
0016D9  3               
0016D9  3               	lda wnlftx		; get edge of screen.
0016D9  3               	jmp star9
0016D9  3               star3:
0016D9  3               	lda wnbotx 		; get edge of screen.
0016D9  3               	clc
0016D9  3               	adc #15 		; height of sprite minus one pixel.
0016D9  3               	jmp star8
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Find particle slot for lasers or vapour trail.
0016D9  3               ; can't use alternate accumulator.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               fpslot:
0016D9  3               	lda #<SHRAPN 		; shrapnel table.
0016D9  3               	sta z80_x
0016D9  3               	lda #>SHRAPN
0016D9  3               	sta z80_i
0016D9  3               
0016D9  3               	lda #NUMSHR		; number of pieces in table.
0016D9  3               	sta z80_b
0016D9  3               fpslt0:
0016D9  3               	ldy #0
0016D9  3               	lda (z80_ix),y		; get type.
0016D9  3               	asl a  			; is this slot in use?
0016D9  3               	bcc :+
0016D9  3               	rts			; no, we can use it.
0016D9  3               :
0016D9  3               	clc			; point to more shrapnel.
0016D9  3               	lda z80_x
0016D9  3               	adc #SHRSIZ
0016D9  3               	sta z80_x
0016D9  3               	bcc :+
0016D9  3               	inc z80_i
0016D9  3               :
0016D9  3               	dec z80_b		; repeat for all shrapnel.
0016D9  3               	bne fpslt0
0016D9  3               
0016D9  3               	clc
0016D9  3               	rts 			; out of slots, can't generate anything.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Create an explosion at sprite position.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               explod:
0016D9  3               	sta z80_c 		; particles to create.
0016D9  3               
0016D9  3               	lda z80_i 		; store pointer to sprite.
0016D9  3               	pha
0016D9  3               	lda z80_x
0016D9  3               	pha
0016D9  3               
0016D9  3               	ldy #8
0016D9  3               	lda (z80_ix),y 		; y coordinate.
0016D9  3               	sta z80_l
0016D9  3               	ldy #9
0016D9  3               	lda (z80_ix),y		; x coordinate.
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	lda #<SHRAPN		; shrapnel table.
0016D9  3               	sta z80_x
0016D9  3               	lda #>SHRAPN
0016D9  3               	sta z80_i
0016D9  3               
0016D9  3               	lda #NUMSHR		; number of pieces in table.
0016D9  3               	sta explcnt
0016D9  3               expld0:
0016D9  3               	ldy #0
0016D9  3               	lda (z80_ix),y		; get type.
0016D9  3               	asl a 			; is this slot in use?
0016D9  3               	bcs expld1		; no, we can use it.
0016D9  3               expld2:
0016D9  3               	clc
0016D9  3               	lda z80_x
0016D9  3               	adc #SHRSIZ
0016D9  3               	sta z80_x
0016D9  3               	bcc :+
0016D9  3               	inc z80_i
0016D9  3               :
0016D9  3               	dec explcnt		; repeat for all shrapnel.
0016D9  3               	bne expld0
0016D9  3               expld3:
0016D9  3               	pla			; restore sprite pointer.
0016D9  3               	sta z80_x
0016D9  3               	pla
0016D9  3               	sta z80_i
0016D9  3               	rts 			; out of slots, can't generate any more.
0016D9  3               
0016D9  3               expld1:
0016D9  3               	lda z80_c		; shrapnel counter.
0016D9  3               	and #15			; 0 to 15.
0016D9  3               	clc			; add to x.
0016D9  3               	adc z80_l
0016D9  3               	ldy #3
0016D9  3               	sta (z80_ix),y		; y coord.
0016D9  3               
0016D9  3               	lda seed3 		; crap random number.
0016D9  3               	and #15			; 0 to 15.
0016D9  3               	clc 			; add to y.
0016D9  3               	adc z80_h
0016D9  3               	ldy #5
0016D9  3               	sta (z80_ix),y		; x coord.
0016D9  3               
0016D9  3               	lda #2
0016D9  3               	ldy #0
0016D9  3               	sta (z80_ix),y		; switch it on.
0016D9  3               
0016D9  3               	jsr chkxy		; plot first position.
0016D9  3               	jsr qrand		; quick random angle.
0016D9  3               	and #60 		; keep within range.
0016D9  3               	ldy #1
0016D9  3               	sta (z80_ix),y		; angle.
0016D9  3               
0016D9  3               	dec z80_c		; one less piece of shrapnel to generate.
0016D9  3               	bne expld2 		; back to main explosion loop.
0016D9  3               	jmp expld3 		; restore sprite pointer and exit.
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Quick random
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               qrand:
0016D9  3               	jsr random		; r register.
0016D9  3               	eor seed3		; combine with seed.
0016D9  3               	sta seed3 		; new seed.
0016D9  3               	rts
0016D9  3               
0016D9  3               ;----------------------------------------------------
0016D9  3               ; Display all shrapnel.
0016D9  3               ;----------------------------------------------------
0016D9  3               
0016D9  3               dshrp:
0016D9  3               	lda #<plotde		; display routine.
0016D9  3               	sta proshx+1
0016D9  3               	lda #>plotde
0016D9  3               	sta proshx+2
0016D9  3               	jsr proshr		; process shrapnel.
0016D9  3               
0016D9  3               	lda #<prosh1		; processing routine.
0016D9  3               	sta proshx+1
0016D9  3               	lda #>prosh1
0016D9  3               	sta proshx+2
0016D9  3               	rts
0016D9  3               
0016D9  3               ;------------------------------------------------------
0016D9  3               ; Particle engine.
0016D9  3               ;
0016D9  3               ; Init particle data for 55 particles in SHRAPN table.
0016D9  3               ; Every particle has 6 bytes.
0016D9  3               ;
0016D9  3               ; global:	-
0016D9  3               ; local:	x,y,hl
0016D9  3               ; calls:	-
0016D9  3               ;------------------------------------------------------
0016D9  3               
0016D9  3               inishr:
0016D9  3               	lda #<SHRAPN 		; table.
0016D9  3               	sta z80_l
0016D9  3               	lda #>SHRAPN
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	ldy #0
0016D9  3               	ldx #NUMSHR		; shrapnel pieces to process.
0016D9  3               inish0:
0016D9  3               	lda #255 		; kill the shrapnel.
0016D9  3               	sta (z80_hl),y
0016D9  3               
0016D9  3               	clc 			; point there.
0016D9  3               	lda z80_l
0016D9  3               	adc #SHRSIZ		; distance to next.
0016D9  3               	sta z80_l
0016D9  3               	bcc :+
0016D9  3               	inc z80_h
0016D9  3               :
0016D9  3               	dex
0016D9  3               	bne inish0 		; round again.
0016D9  3               	rts
0016D9  3               
0016D9  3               ;------------------------------------------------------
0016D9  3               ; Check for collision between laser and sprite.
0016D9  3               ;------------------------------------------------------
0016D9  3               
0016D9  3               lcol:
0016D9  3               	lda #<SHRAPN		; shrapnel table.
0016D9  3               	sta z80_l
0016D9  3               	lda #>SHRAPN
0016D9  3               	sta z80_h
0016D9  3               
0016D9  3               	lda #NUMSHR		; number of pieces in table.
0016D9  3               	sta z80_b
0016D9  3               lcol0:
0016D9  3               	ldy #0
0016D9  3               	lda (z80_hl),y 		; get type.
0016D9  3               	beq lcol1		; yes, check collision.
0016D9  3               lcol3:
0016D9  3               	clc			; point to more shrapnel.
0016D9  3               	lda z80_l
0016D9  3               	adc #SHRSIZ
0016D9  3               	sta z80_l
0016D9  3               	bcc :+
0016D9  3               	inc z80_h
0016D9  3               :
0016D9  3               	dec z80_b		; repeat for all shrapnel.
0016D9  3               	bne lcol0
0016D9  3               	rts 			; no collision, carry not set.
0016D9  3               lcol1:
0016D9  3               	ldy #3
0016D9  3               	lda (z80_hl),y		; get y.
0016D9  3               	sec
0016D9  3               	ldy #8
0016D9  3               	sbc (z80_ix),y		; subtract sprite y.
0016D9  3               lcolh:
0016D9  3               	cmp #16 		; within range?
0016D9  3               	bcc :+
0016D9  3               	jmp lcol2		; no, missed.
0016D9  3               :
0016D9  3               	ldy #5
0016D9  3               	lda (z80_hl),y 		; get x.
0016D9  3               	sec
0016D9  3               	ldy #9
0016D9  3               	sbc (z80_ix),y 		; subtract sprite y.
0016D9  3               	cmp #16			; within range?
0016D9  3               	bcs :+
0016D9  3               	jmp lcol4 		; yes, collision occurred.
0016D9  3               :
0016D9  3               lcol2:
0016D9  3               	jmp lcol3
0016D9  3               lcol4:
0016D9  3               	sec
0016D9  3               	rts 			; return with carry set for collision.
0016D9  3               .endif
0016D9  3               
0016D9  3               ;------------------------------------------------------
0016D9  3               ; Main game engine code starts here.
0016D9  3               ; After initialisation, mloop is the main loop
0016D9  3               ;------------------------------------------------------
0016D9  3               
0016D9  3               game:
0016D9  3               
0016D9  3               ; Set up screen address table.
0016D9  3               
0016D9  3               setsat:
0016D9  3  A9 00        	lda #<ScreenAddr		; start of screen.
0016DB  3  85 rr        	sta scraddr
0016DD  3  A9 68        	lda #>ScreenAddr
0016DF  3  85 rr        	sta scraddr+1
0016E1  3               
0016E1  3  A0 00        	ldy #0			; vertical lines on screen.
0016E3  3               setsa0:
0016E3  3  A5 rr        	lda scraddr
0016E5  3  99 00 06     	sta SCADTB_lb,y		; write low byte.
0016E8  3  A5 rr        	lda scraddr+1
0016EA  3  99 00 07     	sta SCADTB_hb,y		; write high byte.
0016ED  3  20 9F 10     	jsr nline		; next line down.
0016F0  3  C8           	iny			; next position in table.
0016F1  3  D0 F0        	bne setsa0
0016F3  3               
0016F3  3               ; Init graphics mode
0016F3  3               
0016F3  3  20 2B 0F     	jsr screeninit
0016F6  3               
0016F6  3               ; Init AtoMMC joystick
0016F6  3  20 F6 0E     	jsr joyinit		; AtoMMC joystick on PORT B
0016F9  3               
0016F9  3               rpblc2:
0016F9  3               .if pflag
0016F9  3               	jsr inishr 		; initialise particle engine.
0016F9  3               .endif
0016F9  3               evintr:
0016F9  3  20 4E 2D     	jsr evnt12 		; call intro/menu event.
0016FC  3               
0016FC  3  A9 02        	lda #WALL 		; write default property.
0016FE  3  A2 00        	ldx #0
001700  3               clrmap:
001700  3  9D 00 03     	sta MAP,x 		; block properties.
001703  3  9D 00 04     	sta MAP+256,x
001706  3  9D 00 05     	sta MAP+512,x
001709  3  E8           	inx			; next byte.
00170A  3  D0 F4        	bne clrmap
00170C  3               
00170C  3  20 24 16     	jsr iniob 		; initialise objects.
00170F  3               
00170F  3  A9 00        	lda #0			; put zero in accumulator.
001711  3  85 rr        	sta gamwon		; reset game won flag.
001713  3               
001713  3  20 7B 18     	jsr inisc 		; init the score.
001716  3               mapst:
001716  3  AD 02 28     	lda stmap 		; start position on map.
001719  3  8D F7 27     	sta roomtb		; set up position in table, if there is one.
00171C  3               
00171C  3               inipbl:
00171C  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00171C  3               .if aflag
00171C  3               	lda #<eop		; reset blockpointer
00171C  3               	sta pbptr
00171C  3               	lda #>eop
00171C  3               	sta pbptr+1
00171C  3               .endif
00171C  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
00171C  3  20 AE 24     	jsr initsc 		; set up first screen.
00171F  3               
00171F  3  A9 E6        	lda #<ssprit 		; default to spare sprite in table.
001721  3  85 rr        	sta z80_x
001723  3  A9 27        	lda #>ssprit
001725  3  85 rr        	sta z80_i
001727  3               evini:
001727  3  20 4F 2D     	jsr evnt13 		; initialisation.
00172A  3               
00172A  3               ; Two restarts.
00172A  3               ; First restart - clear all sprites and initialise everything.
00172A  3               
00172A  3               rstrt:
00172A  3  20 1B 18     	jsr rsevt 		; restart events.
00172D  3  20 17 16     	jsr xspr 		; clear sprite table.
001730  3  20 1A 26     	jsr sprlst 		; fetch pointer to screen sprites.
001733  3  20 A3 26     	jsr ispr 		; initialise sprite table.
001736  3               
001736  3  4C 45 17     	jmp rstrt0
001739  3               
001739  3               ; Second restart - clear all but player, and don't initialise him.
001739  3               
001739  3               rstrtn:
001739  3  20 1B 18     	jsr rsevt		; restart events.
00173C  3  20 47 26     	jsr nspr 		; clear all non-player sprites.
00173F  3  20 1A 26     	jsr sprlst 		; fetch pointer to screen sprites.
001742  3  20 E0 26     	jsr kspr 		; initialise sprite table, no more players.
001745  3               
001745  3               ; Set up the player and/or enemy sprites.
001745  3               
001745  3               rstrt0:
001745  3  A9 00        	lda #0 			; zero in accumulator.
001747  3  85 rr        	sta nexlev 		; reset next level flag.
001749  3  85 rr        	sta restfl 		; reset restart flag.
00174B  3  85 rr        	sta deadf 		; reset dead flag.
00174D  3  20 D8 1C     	jsr droom 		; show screen layout.
001750  3               rpblc0:
001750  3               .if pflag
001750  3               	jsr inishr 		; initialise particle engine.
001750  3               .endif
001750  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001750  3               .if aflag
001750  3               	jsr rbloc		; draw blocks for this screen
001750  3               .endif
001750  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001750  3  20 CB 18     	jsr shwob		; draw objects.
001753  3               
001753  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
001755  3  85 rr        	sta z80_x
001757  3  A9 0B        	lda #>sprtab
001759  3  85 rr        	sta z80_i
00175B  3               
00175B  3  20 78 22     	jsr dspr 		; display sprites.
00175E  3               
00175E  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
001760  3  85 rr        	sta z80_x
001762  3  A9 0B        	lda #>(sprtab+TABSIZ)
001764  3  85 rr        	sta z80_i
001766  3  20 78 22     	jsr dspr 		; display sprites.
001769  3               
001769  3               mloop:
001769  3  20 C1 0E     	jsr bbcsync
00176C  3               
00176C  3  20 0E 0F     	jsr vsync 		; synchronise with display.
00176F  3               
00176F  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
001771  3  85 rr        	sta z80_x
001773  3  A9 0B        	lda #>sprtab
001775  3  85 rr        	sta z80_i
001777  3               
001777  3               DEBUG_PAL PAL_red
001777  3  20 78 22     	jsr dspr 		; display even sprites.
00177A  3               DEBUG_PAL PAL_black
00177A  3               
00177A  3  20 CA 18     	jsr plsnd 		; play sounds.
00177D  3  20 0E 0F     	jsr vsync 		; synchronise with display.
001780  3               
001780  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
001782  3  85 rr        	sta z80_x
001784  3  A9 0B        	lda #>(sprtab+TABSIZ)
001786  3  85 rr        	sta z80_i
001788  3               
001788  3               DEBUG_PAL PAL_red
001788  3  20 78 22     	jsr dspr 		; display odd sprites.
00178B  3               DEBUG_PAL PAL_black
00178B  3               
00178B  3  A9 E6        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
00178D  3  85 rr        	sta z80_x
00178F  3  A9 27        	lda #>(ssprit)
001791  3  85 rr        	sta z80_i
001793  3               evlp1:
001793  3               DEBUG_PAL PAL_green
001793  3  20 D2 2C     	jsr evnt10 		; called once per main loop.
001796  3  20 F6 21     	jsr pspr 		; process sprites.
001799  3               DEBUG_PAL PAL_black
001799  3               
001799  3               ; Main loop events.
001799  3               
001799  3  A9 E6        	lda #<ssprit 		; point to spare sprite for spawning purposes.
00179B  3  85 rr        	sta z80_x
00179D  3  A9 27        	lda #>ssprit
00179F  3  85 rr        	sta z80_i
0017A1  3               DEBUG_PAL PAL_green
0017A1  3               evlp2:
0017A1  3  20 E7 2C     	jsr evnt11 		; called once per main loop.
0017A4  3               bsortx:
0017A4  3  20 6C 21     	jsr bsort 		; sort sprites.
0017A7  3               DEBUG_PAL PAL_black
0017A7  3               
0017A7  3  A5 rr        	lda nexlev		; finished level flag.
0017A9  3  D0 1F        	bne newlev		; is set, go to next level.
0017AB  3  A5 rr        	lda gamwon		; finished game flag.
0017AD  3  D0 2A        	bne evwon		; is set, finish the game.
0017AF  3  A5 rr        	lda restfl 		; finished level flag.
0017B1  3  C9 01        	cmp #1			; has it been set?
0017B3  3  D0 03        	bne :+
0017B5  3  4C 2A 17     	jmp rstrt		; yes, go to next level.
0017B8  3               :
0017B8  3  C9 02        	cmp #2			; has it been set?
0017BA  3  D0 03        	bne :+
0017BC  3  4C 39 17     	jmp rstrtn		; yes, go to next level.
0017BF  3               :
0017BF  3  A5 rr        	lda deadf 		; dead flag.
0017C1  3  D0 1C        	bne pdead		; yes, player dead.
0017C3  3               
0017C3  3               ; back to start of main loop.
0017C3  3               
0017C3  3  E6 rr        	inc frmno
0017C5  3  E6 rr        	inc clock
0017C7  3  4C 69 17     	jmp mloop		; switched to a jmp mloop during test mode.
0017CA  3               
0017CA  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0017CA  3               
0017CA  3               ;----------------------------------------------------------
0017CA  3               ; Read blocks from list and update screen accordingly.
0017CA  3               ;----------------------------------------------------------
0017CA  3               
0017CA  3               .if aflag
0017CA  3               rbloc:
0017CA  3               	lda #<eop		; reset temp blockpointer
0017CA  3               	sta tmp
0017CA  3               	lda #>eop
0017CA  3               	sta tmp+1
0017CA  3               
0017CA  3               rbloc2:
0017CA  3               	lda tmp			; check for last block
0017CA  3               	cmp pbptr
0017CA  3               	bne rbloc1
0017CA  3               	lda tmp+1
0017CA  3               	cmp pbptr+1
0017CA  3               	bne rbloc1
0017CA  3               	rts
0017CA  3               rbloc1:
0017CA  3               	ldy #0
0017CA  3               	lda (tmp),y		; check if block for this scno
0017CA  3               	cmp scno
0017CA  3               	bne rbloc0		; if not, skip
0017CA  3               	iny
0017CA  3               	lda (tmp),y		; get y
0017CA  3               	sta dispy
0017CA  3               	iny
0017CA  3               	lda (tmp),y		; get x
0017CA  3               	sta dispx
0017CA  3               	iny
0017CA  3               	lda (tmp),y		; get blocknr
0017CA  3               	jsr pattr2		; draw block
0017CA  3               rbloc0:
0017CA  3               	clc			; point to next block
0017CA  3               	lda tmp
0017CA  3               	adc #4
0017CA  3               	sta tmp
0017CA  3               	bcc rbloc2
0017CA  3               	inc tmp+1
0017CA  3               	jmp rbloc2
0017CA  3               .endif
0017CA  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0017CA  3               
0017CA  3               ;----------------------------------------------------------
0017CA  3               ; New level
0017CA  3               ;----------------------------------------------------------
0017CA  3               
0017CA  3               newlev:
0017CA  3  A5 rr        	lda scno 			; current screen.
0017CC  3  18           	clc
0017CD  3  69 01        	adc #1				; next screen.
0017CF  3  CD C9 38     	cmp numsc			; total number of screens.
0017D2  3  B0 05        	bcs evwon			; yes, game finished.
0017D4  3  85 rr        	sta scno			; set new level number.
0017D6  3  4C 2A 17     	jmp rstrt			; restart, clearing all aliens.
0017D9  3               
0017D9  3               evwon:
0017D9  3  20 76 2D     	jsr evnt18		 	; game completed.
0017DC  3  4C F0 17     	jmp tidyup			; tidy up and return to BASIC/calling routine.
0017DF  3               
0017DF  3               ;----------------------------------------------------------
0017DF  3               ; Player dead.
0017DF  3               ;----------------------------------------------------------
0017DF  3               
0017DF  3               pdead:
0017DF  3  A9 00        	lda #0				; zeroise accumulator.
0017E1  3  85 rr        	sta deadf			; reset dead flag.
0017E3  3               evdie:
0017E3  3  20 69 2D     	jsr evnt16 			; death subroutine.
0017E6  3  A5 rr        	lda numlif			; number of lives.
0017E8  3  F0 03        	beq :+
0017EA  3  4C 2A 17     	jmp rstrt 			; restart game.
0017ED  3               :
0017ED  3               evfail:
0017ED  3  20 70 2D     	jsr evnt17 			; failure event.
0017F0  3               
0017F0  3               ;----------------------------------------------------------
0017F0  3               ; Tidy things up
0017F0  3               ;----------------------------------------------------------
0017F0  3               
0017F0  3               tidyup:
0017F0  3  A0 00        	ldy #0				; digits to check.
0017F2  3               tidyu2:
0017F2  3  B9 95 1A     	lda score,y 			; get score digit.
0017F5  3  CD 9B 1A     	cmp hiscor 			; are we larger than high score digit?
0017F8  3  90 07        	bcc tidyu0			; high score is bigger.
0017FA  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
0017FC  3  C8           	iny				; next digit of high score.
0017FD  3  C0 06        	cpy #6
0017FF  3  D0 F1        	bne tidyu2			; repeat for all digits
001801  3               tidyu0:
001801  3  A9 95        	lda #<score			; return pointing to score.
001803  3  85 rr        	sta z80_c
001805  3  A9 1A        	lda #>score
001807  3  85 rr        	sta z80_b
001809  3  60           	rts
00180A  3               tidyu1:
00180A  3  A0 05        	ldy #5
00180C  3               tidyu3:
00180C  3  B9 95 1A     	lda score,y			; score.
00180F  3  99 9B 1A     	sta hiscor,y			; high score.
001812  3  88           	dey
001813  3  10 F7        	bpl tidyu3 			; copy score to high score.
001815  3               evnewh:
001815  3  20 7C 2D     	jsr evnt19			; new high score event.
001818  3  4C 01 18     	jmp tidyu0			; tidy up.
00181B  3               
00181B  3               ;--------------------------------------------------
00181B  3               ; Restart event.
00181B  3               ;--------------------------------------------------
00181B  3               
00181B  3               rsevt:
00181B  3  A9 E6        	lda #<ssprit 			; default to spare element in table.
00181D  3  85 rr        	sta z80_x
00181F  3  A9 27        	lda #>ssprit
001821  3  85 rr        	sta z80_i
001823  3               evrs:
001823  3  4C 5B 2D     	jmp evnt14	 		; call restart event.
001826  3               
001826  3               ;------------------------------------------------------------------
001826  3               ; Copy number passed in a to string position bc, right-justified.
001826  3               ;
001826  3               ; Input:
001826  3               ;  A  = number
001826  3               ;  BC = string address
001826  3               ;
001826  3               ; Output:
001826  3               ;  BC = string with number
001826  3               ;-----------------------------------------------------------------
001826  3               
001826  3               num2ch:
001826  3  85 rr        	sta z80_d		; Save number
001828  3               
001828  3  A9 00        	lda #0
00182A  3  85 rr        	sta flag
00182C  3               numdg3:
00182C  3  A2 64        	ldx #100		; hundreds column.
00182E  3  86 rr        	stx z80_e
001830  3  20 40 18     	jsr numdg		; show digit.
001833  3               numdg2:
001833  3  A2 0A        	ldx #10			; tens column.
001835  3  86 rr        	stx z80_e
001837  3  20 40 18     	jsr numdg		; show digit.
00183A  3               
00183A  3  E6 rr        	inc flag
00183C  3  A2 01        	ldx #1			; units column.
00183E  3  86 rr        	stx z80_e
001840  3               numdg:
001840  3  A9 30        	lda #48			; clear digit.
001842  3  85 rr        	sta z80_a
001844  3               numdg1:
001844  3  A5 rr        	lda z80_d
001846  3  C5 rr        	cmp z80_e
001848  3  90 0E        	bcc numdg0		; nothing to show.
00184A  3  38           	sec
00184B  3  A5 rr        	lda z80_d
00184D  3  E5 rr        	sbc z80_e		; subtract from column.
00184F  3  85 rr        	sta z80_d
001851  3  E6 rr        	inc z80_a		; increment digit.
001853  3  E6 rr        	inc flag
001855  3  4C 44 18     	jmp numdg1		; repeat until column is zero.
001858  3               numdg0:
001858  3  A0 00        	ldy #0
00185A  3  A5 rr        	lda z80_a
00185C  3  91 rr        	sta (z80_bc),y		; write digit to buffer.
00185E  3  A5 rr        	lda flag
001860  3  F0 06        	beq :+
001862  3  E6 rr        	inc z80_c		; next buffer position.
001864  3  D0 02        	bne :+
001866  3  E6 rr        	inc z80_b
001868  3               :
001868  3  60           	rts
001869  3               num2dd:
001869  3  85 rr        	sta z80_d		; Save number
00186B  3               
00186B  3  A9 01        	lda #1
00186D  3  85 rr        	sta flag
00186F  3               
00186F  3  4C 33 18     	jmp numdg2
001872  3               num2td:
001872  3  85 rr        	sta z80_d		; Save number
001874  3               
001874  3  A9 01        	lda #1
001876  3  85 rr        	sta flag
001878  3  4C 2C 18     	jmp numdg3
00187B  3               
00187B  3               ;---------------------------------------------------------
00187B  3               ; Reset score to "000000"
00187B  3               ;---------------------------------------------------------
00187B  3               
00187B  3               inisc:
00187B  3  A9 30        	lda #'0'
00187D  3  A2 05        	ldx #5			; digits to initialise.
00187F  3               inisc0:
00187F  3  9D 95 1A     	sta score,x 		; write zero digit.
001882  3  CA           	dex			; next column.
001883  3  10 FA        	bpl inisc0		; repeat for all digits.
001885  3               
001885  3  60           	rts
001886  3               
001886  3               ;-----------------------------------------------------
001886  3               ; Multiply h by d and return in hl.
001886  3               ;
001886  3               ; Input:
001886  3               ;  H = first number
001886  3               ;  D = second number
001886  3               ;
001886  3               ; Output:
001886  3               ;  HL = result H x D
001886  3               ;-----------------------------------------------------
001886  3               
001886  3               imul:
001886  3  A5 rr        	lda z80_d		; HL = H * D
001888  3  85 rr        	sta z80_e
00188A  3  A5 rr        	lda z80_h
00188C  3  85 rr        	sta z80_c		; make c first multiplier.
00188E  3               imul0:
00188E  3  A9 00        	lda #0			; zeroise total.
001890  3  85 rr        	sta z80_l
001892  3  85 rr        	sta z80_h
001894  3               
001894  3  A5 rr        	lda z80_h
001896  3  85 rr        	sta z80_d		; zeroise high byte.
001898  3               
001898  3  A9 08        	lda #8			; repeat 8 times.
00189A  3  85 rr        	sta z80_b
00189C  3               imul1:
00189C  3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
00189E  3  90 0E        	bcc imul2		; wasn't set.
0018A0  3  18           	clc			; bit was set, so add de.
0018A1  3  A5 rr        	lda z80_l
0018A3  3  65 rr        	adc z80_e
0018A5  3  85 rr        	sta z80_l
0018A7  3  A5 rr        	lda z80_h
0018A9  3  65 rr        	adc z80_d
0018AB  3  85 rr        	sta z80_h
0018AD  3  18           	clc 			; reset carry.
0018AE  3               imul2:
0018AE  3  06 rr        	asl z80_e 		; shift de 1 bit left.
0018B0  3  26 rr        	rol z80_d
0018B2  3  C6 rr        	dec z80_b
0018B4  3  D0 E6        	bne imul1		; repeat 8 times.
0018B6  3               
0018B6  3  60           	rts
0018B7  3               
0018B7  3               ;-----------------------------------------------
0018B7  3               ; Divide d by e and return in d, remainder in a.
0018B7  3               ;
0018B7  3               ; Input:
0018B7  3               ;  D = first number
0018B7  3               ;  E = second number
0018B7  3               ;
0018B7  3               ; Output:
0018B7  3               ;  D = result D/E
0018B7  3               ;  A = remainder
0018B7  3               ;-----------------------------------------------
0018B7  3               
0018B7  3               idiv:
0018B7  3  A9 00        	lda #0
0018B9  3  A0 08        	ldy #8		 	; bits to shift.
0018BB  3  06 rr        	asl z80_d
0018BD  3               idiv0:
0018BD  3  2A           	rol a 			; multiply d by 2.
0018BE  3  C5 rr        	cmp z80_e 		; test if e is smaller.
0018C0  3  90 02        	bcc idiv1		; e is greater, no division this time.
0018C2  3  E5 rr        	sbc z80_e		; subtract it.
0018C4  3               idiv1:
0018C4  3  26 rr        	rol z80_d		; rotate into d.
0018C6  3  88           	dey
0018C7  3  D0 F4        	bne idiv0		; repeat
0018C9  3  60           	rts
0018CA  3               
0018CA  3               ;---------------------------------------------------
0018CA  3               ; Play AY sound effect
0018CA  3               ;---------------------------------------------------
0018CA  3               
0018CA  3               plsnd:
0018CA  3  60           	rts
0018CB  3               
0018CB  3               ;---------------------------------------------------
0018CB  3               ; Objects handling.
0018CB  3               ; 32 bytes for image
0018CB  3               ; 3 for room, y and x
0018CB  3               ; 3 for starting room, y and x.
0018CB  3               ; 254 = disabled.
0018CB  3               ; 255 = object in player"s pockets.
0018CB  3               ;---------------------------------------------------
0018CB  3               
0018CB  3               ;---------------------------------------------------
0018CB  3               ; Show items present.
0018CB  3               ;---------------------------------------------------
0018CB  3               
0018CB  3               shwob:
0018CB  3  A9 6E        	lda #<objdta 			; objects table.
0018CD  3  85 rr        	sta z80_l
0018CF  3  A9 39        	lda #>objdta
0018D1  3  85 rr        	sta z80_h
0018D3  3               
0018D3  3  AD 10 16     	lda numob 			; number of objects in the game.
0018D6  3  85 rr        	sta sprcnt
0018D8  3               shwob0:
0018D8  3  A0 20        	ldy #32 			; distance to room number.
0018DA  3  B1 rr        	lda (z80_hl),y 			; same as an item?
0018DC  3  C5 rr        	cmp scno 			; current location.
0018DE  3  D0 03        	bne :+
0018E0  3  20 F5 18     	jsr dobj 			; yes, display object.
0018E3  3               :
0018E3  3  18           	clc
0018E4  3  A5 rr        	lda z80_l
0018E6  3  69 26        	adc #38 			; distance to next item.
0018E8  3  85 rr        	sta z80_l
0018EA  3  A5 rr        	lda z80_h
0018EC  3  69 00        	adc #0
0018EE  3  85 rr        	sta z80_h	 		; point to it.
0018F0  3  C6 rr        	dec sprcnt
0018F2  3  D0 E4        	bne shwob0 			; repeat for others.
0018F4  3  60           	rts
0018F5  3               
0018F5  3               ;---------------------------------------------------
0018F5  3               ; Display object.
0018F5  3               ; hl must point to object's start address.
0018F5  3               ;
0018F5  3               ; Input:
0018F5  3               ;  HL = object address
0018F5  3               ;---------------------------------------------------
0018F5  3               
0018F5  3               dobj:
0018F5  3  A0 21        	ldy #33
0018F7  3  B1 rr        	lda (z80_hl),y 			; point to y.
0018F9  3  85 rr        	sta dispy
0018FB  3  C8           	iny
0018FC  3  B1 rr        	lda (z80_hl),y 			; point to x.
0018FE  3  85 rr        	sta dispx
001900  3               dobj1:
001900  3  4C 6B 0F     	jmp sprite 			; draw this sprite.
001903  3               
001903  3               ;--------------------------------------
001903  3               ; Remove an object.
001903  3               ;
001903  3               ; Input:
001903  3               ;  A = object number
001903  3               ;--------------------------------------
001903  3               
001903  3               remob:
001903  3  CD 10 16     	cmp numob			; number of objects in game.
001906  3  90 01        	bcc :+				; are we checking past the end?
001908  3  60           	rts				; yes, can't get non-existent item.
001909  3               :
001909  3  48           	pha				; remember object.
00190A  3  20 18 19     	jsr getob			; pick it up if we haven't already got it.
00190D  3  68           	pla				; retrieve object number.
00190E  3  20 47 19     	jsr gotob			; get its address.
001911  3  A9 FE        	lda #254
001913  3  A0 20        	ldy #32
001915  3  91 rr        	sta (z80_hl),y			; remove it.
001917  3  60           	rts
001918  3               
001918  3               ;---------------------------------------------------
001918  3               ; Pick up object number held in the accumulator.
001918  3               ;
001918  3               ; Input:
001918  3               ;  A = object number
001918  3               ;---------------------------------------------------
001918  3               
001918  3               getob:
001918  3  CD 10 16     	cmp numob 		; number of objects in game.
00191B  3  90 01        	bcc :+			; are we checking past the end?
00191D  3  60           	rts			; yes, can't get non-existent item.
00191E  3               :
00191E  3  20 47 19     	jsr gotob 		; check if we already have it.
001921  3  C9 FF        	cmp #255
001923  3  D0 01        	bne :+
001925  3  60           	rts			; we already do.
001926  3               :
001926  3  A0 20        	ldy #32
001928  3  B1 rr        	lda (z80_hl),y		; is it on this screen?
00192A  3  C5 rr        	cmp scno 		; current screen.
00192C  3  D0 14        	bne getob0		; not on screen, so nothing to delete.
00192E  3               
00192E  3  A9 FF        	lda #255
001930  3  91 rr        	sta (z80_hl),y		; pick it up.
001932  3  C8           	iny 			; point to y coord.
001933  3               getob1:
001933  3  A0 21        	ldy #33
001935  3  B1 rr        	lda (z80_hl),y		; y coord.
001937  3  85 rr        	sta dispy
001939  3  A0 22        	ldy #34
00193B  3  B1 rr        	lda (z80_hl),y 		; x coord.
00193D  3  85 rr        	sta dispx
00193F  3  4C 00 19     	jmp dobj1 		; delete object sprite.
001942  3               getob0:
001942  3  A9 FF        	lda #255
001944  3  91 rr        	sta (z80_hl),y 		; pick it up.
001946  3  60           	rts
001947  3               
001947  3               ;-----------------------------------------------------------------
001947  3               ; Got object check.
001947  3               ; Call with object in accumulator, returns zero set if in pockets.
001947  3               ;
001947  3               ; Input:
001947  3               ;  A = object number
001947  3               ;-----------------------------------------------------------------
001947  3               
001947  3               gotob:
001947  3  CD 10 16     	cmp numob 		; number of objects in game.
00194A  3  90 03        	bcc :+ 			; are we checking past the end?
00194C  3  4C 53 19     	jmp gotob0 		; yes, we can't have a non-existent object.
00194F  3               :
00194F  3  20 58 19     	jsr findob		; find the object.
001952  3               gotob1:
001952  3  60           	rts
001953  3               
001953  3               gotob0:
001953  3  A9 FE        	lda #254 		; missing.
001955  3  4C 52 19     	jmp gotob1
001958  3               
001958  3               findob:
001958  3  48           	pha			; save object number
001959  3  A9 6E        	lda #<objdta 		; objects.
00195B  3  85 rr        	sta z80_l
00195D  3  A9 39        	lda #>objdta
00195F  3  85 rr        	sta z80_h
001961  3  68           	pla			; retreive object number
001962  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
001964  3  AA           	tax 			; loop counter
001965  3               fndob2:
001965  3  18           	clc
001966  3  A5 rr        	lda z80_l
001968  3  69 26        	adc #38 		; size of each object.
00196A  3  85 rr        	sta z80_l
00196C  3  90 02        	bcc :+
00196E  3  E6 rr        	inc z80_h
001970  3               :
001970  3  CA           	dex 			; repeat until we find address.
001971  3  D0 F2        	bne fndob2
001973  3               fndob1:
001973  3  A0 20        	ldy #32			; distance to room it's in.
001975  3  B1 rr        	lda (z80_hl),y		; fetch status.
001977  3  60           	rts
001978  3               
001978  3               ;---------------------------------------------
001978  3               ; Drop object number at (dispx, dispy).
001978  3               ;
001978  3               ; Input:
001978  3               ;  A = object number
001978  3               ;---------------------------------------------
001978  3               
001978  3               drpob:
001978  3  CD 10 16     	cmp numob 		; are we checking past the end?
00197B  3  90 01        	bcc :+
00197D  3  60           	rts			; yes, can't drop non-existent item.
00197E  3               :
00197E  3  20 47 19     	jsr gotob		; make sure object is in inventory.
001981  3  C5 rr        	cmp scno		; already on this screen?
001983  3  D0 01        	bne :+
001985  3  60           	rts			; yes, nothing to do.
001986  3               :
001986  3  A0 20        	ldy #32
001988  3  A5 rr        	lda scno
00198A  3  91 rr        	sta (z80_hl),y		; bring onto screen.
00198C  3  A5 rr        	lda dispy		; sprite y coordinate.
00198E  3  C8           	iny
00198F  3  91 rr        	sta (z80_hl),y		; point to object y.
001991  3  A5 rr        	lda dispx 		; sprite x coordinate.
001993  3  C8           	iny
001994  3  91 rr        	sta (z80_hl),y 		; point to object x
001996  3  4C F5 18     	jmp dobj		; draw the object sprite.
001999  3               
001999  3               ;-----------------------------------------------
001999  3               ; Seek objects at sprite position.
001999  3               ;
001999  3               ; Output:
001999  3               ;  A = object number, if not found A=255
001999  3               ;-----------------------------------------------
001999  3               
001999  3               skobj:
001999  3  A9 6E        	lda #<objdta 		; pointer to objects.
00199B  3  85 rr        	sta z80_l
00199D  3  A9 39        	lda #>objdta
00199F  3  85 rr        	sta z80_h
0019A1  3               
0019A1  3  AD 10 16     	lda numob 		; number of objects in game.
0019A4  3  85 rr        	sta z80_b 		; set up the loop counter.
0019A6  3               skobj0:
0019A6  3  A5 rr        	lda scno		; current room number.
0019A8  3  A0 20        	ldy #32
0019AA  3  D1 rr        	cmp (z80_hl),y		; is object in here?
0019AC  3  D0 03        	bne :+
0019AE  3  20 C3 19     	jsr skobj1		; yes, check coordinates.
0019B1  3               :
0019B1  3  18           	clc			; point to next object in table.
0019B2  3  A5 rr        	lda z80_l
0019B4  3  69 26        	adc #38			; size of each object.
0019B6  3  85 rr        	sta z80_l
0019B8  3  90 02        	bcc :+
0019BA  3  E6 rr        	inc z80_h
0019BC  3               :
0019BC  3  C6 rr        	dec z80_b
0019BE  3  D0 E6        	bne skobj0		; repeat for all objects.
0019C0  3               
0019C0  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
0019C2  3  60           	rts
0019C3  3               
0019C3  3               skobj1:
0019C3  3  A0 21        	ldy #33			; point to y coordinate.
0019C5  3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
0019C7  3  38           	sec
0019C8  3  A0 08        	ldy #var_newY
0019CA  3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
0019CC  3  18           	clc
0019CD  3  69 0F        	adc #15			; add sprite height minus one.
0019CF  3  C9 1F        	cmp #31			; within range?
0019D1  3  90 03        	bcc :+
0019D3  3  4C F1 19     	jmp skobj2		; no, ignore object.
0019D6  3               :
0019D6  3  A0 22        	ldy #34			; point to x coordinate now.
0019D8  3  B1 rr        	lda (z80_hl),y 		; get coordinate.
0019DA  3  38           	sec
0019DB  3  A0 09        	ldy #var_newX
0019DD  3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
0019DF  3  18           	clc			; add sprite width minus one.
0019E0  3  69 0F        	adc #15
0019E2  3  C9 1F        	cmp #31			; within range?
0019E4  3  90 03        	bcc :+
0019E6  3  4C F1 19     	jmp skobj2		; no, ignore object.
0019E9  3               :
0019E9  3  68           	pla			; remove return address from stack.
0019EA  3  68           	pla
0019EB  3               
0019EB  3  AD 10 16     	lda numob 		; objects in game.
0019EE  3  38           	sec
0019EF  3  E5 rr        	sbc z80_b		; subtract loop counter.
0019F1  3               skobj2:
0019F1  3  60           	rts			; accumulator now points to object.
0019F2  3               
0019F2  3               
0019F2  3               ;---------------------------------------------------------------------
0019F2  3               ; Spawn a new sprite.
0019F2  3               ;---------------------------------------------------------------------
0019F2  3               
0019F2  3               spawn:
0019F2  3  A9 00        	lda #<sprtab		; sprite table.
0019F4  3  85 rr        	sta z80_l
0019F6  3  A9 0B        	lda #>sprtab
0019F8  3  85 rr        	sta z80_h
0019FA  3               numsp1:
0019FA  3  A9 0C        	lda #NUMSPR		; number of sprites.
0019FC  3  85 rr        	sta spcnt
0019FE  3               spaw0:
0019FE  3  A0 00        	ldy #var_Type
001A00  3  B1 rr        	lda (z80_hl),y		; get sprite type.
001A02  3  C9 FF        	cmp #255		; is it an unused slot?
001A04  3  F0 0F        	beq spaw1 		; yes, we can use this one.
001A06  3               
001A06  3  18           	clc 			; point to next sprite in table.
001A07  3  A5 rr        	lda z80_l
001A09  3  69 11        	adc #TABSIZ		; size of each entry.
001A0B  3  85 rr        	sta z80_l
001A0D  3  90 02        	bcc :+
001A0F  3  E6 rr        	inc z80_h
001A11  3               :
001A11  3  C6 rr        	dec spcnt		; one less iteration.
001A13  3  D0 E9        	bne spaw0		; keep going until we find a slot.
001A15  3               
001A15  3               ; Didn't find one but drop through and set up a dummy sprite instead.
001A15  3               
001A15  3               spaw1:
001A15  3  A5 rr        	lda z80_i		; address of original sprite.
001A17  3  48           	pha
001A18  3  A5 rr        	lda z80_x
001A1A  3  48           	pha
001A1B  3               
001A1B  3  A5 rr        	lda z80_l		; store spawned sprite address.
001A1D  3  85 rr        	sta spptr
001A1F  3  A5 rr        	lda z80_h
001A21  3  85 rr        	sta spptr+1
001A23  3               
001A23  3  A5 rr        	lda z80_c
001A25  3  A0 00        	ldy #var_Type
001A27  3  91 rr        	sta (z80_hl),y 		; set the type.
001A29  3  A0 05        	ldy #var_newType
001A2B  3  91 rr        	sta (z80_hl),y		; copy
001A2D  3               
001A2D  3  A5 rr        	lda z80_b
001A2F  3  A0 01        	ldy #var_Image
001A31  3  91 rr        	sta (z80_hl),y		; set the image.
001A33  3  A0 06        	ldy #var_newImage
001A35  3  91 rr        	sta (z80_hl),y		; copy
001A37  3               
001A37  3  A9 00        	lda #0 				; frame zero.
001A39  3  A0 02        	ldy #var_Frame
001A3B  3  91 rr        	sta (z80_hl),y		; set frame.
001A3D  3  A0 07        	ldy #var_newFrame
001A3F  3  91 rr        	sta (z80_hl),y		; copy
001A41  3               
001A41  3  A0 09        	ldy #9
001A43  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001A45  3  A0 04        	ldy #var_X
001A47  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001A49  3  A0 09        	ldy #var_newX
001A4B  3  91 rr        	sta (z80_hl),y		; copy
001A4D  3               
001A4D  3  A0 08        	ldy #8
001A4F  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001A51  3  A0 03        	ldy #var_Y
001A53  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
001A55  3  A0 08        	ldy #var_newY
001A57  3  91 rr        	sta (z80_hl),y		; copy
001A59  3               
001A59  3  A0 0A        	ldy #10				; direction of original.
001A5B  3  B1 rr        	lda (z80_ix),y
001A5D  3  A0 0A        	ldy #var_Direction
001A5F  3  91 rr        	sta (z80_hl),y		; direction
001A61  3               
001A61  3  A9 00        	lda #0
001A63  3  A0 0D        	ldy #var_jumpLo
001A65  3  91 rr        	sta (z80_hl),y		; reset parameter.
001A67  3  C8           	iny
001A68  3  91 rr        	sta (z80_hl),y		; reset parameter.
001A6A  3  C8           	iny
001A6B  3  91 rr        	sta (z80_hl),y		; reset parameter.
001A6D  3  C8           	iny
001A6E  3  91 rr        	sta (z80_hl),y		; reset parameter.
001A70  3               rtssp:
001A70  3  A5 rr        	lda spptr			; address of new sprite.
001A72  3  85 rr        	sta z80_x
001A74  3  A5 rr        	lda spptr+1
001A76  3  85 rr        	sta z80_i
001A78  3               evis1:
001A78  3  20 BA 2C     	jsr evnt09 			; call sprite initialisation event.
001A7B  3               
001A7B  3  A5 rr        	lda spptr 			; address of new sprite.
001A7D  3  85 rr        	sta z80_x
001A7F  3  A5 rr        	lda spptr+1
001A81  3  85 rr        	sta z80_i
001A83  3               
001A83  3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
001A83  3  A0 03        	ldy #var_Y
001A85  3  B1 rr        	lda (z80_hl), y		; old x coord
001A87  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001A89  3  B0 03        	bcs :+				; yes, don't draw it.
001A8B  3               
001A8B  3  20 D1 0F     	jsr sspria 			; display the new sprite.
001A8E  3               :
001A8E  3  68           	pla					; address of original sprite.
001A8F  3  85 rr        	sta z80_x
001A91  3  68           	pla
001A92  3  85 rr        	sta z80_i
001A94  3               
001A94  3  60           	rts
001A95  3               
001A95  3  30 30 30 30  score:	.byte "000000"		; player"s score.
001A99  3  30 30        
001A9B  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
001A9F  3  30 30        
001AA1  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
001AA5  3  30 30        
001AA7  3  00 68        grbase:	.word ScreenAddr	; graphics base address.
001AA9  3               
001AA9  3               ;----------------------------------------------------
001AA9  3               ; Check y-pos
001AA9  3               ;----------------------------------------------------
001AA9  3               
001AA9  3               checkx:
001AA9  3  A5 rr        	lda dispy		; y position.
001AAB  3  C9 18        	cmp #24			; off screen?
001AAD  3  B0 01        	bcs :+
001AAF  3  60           	rts			; no, it's okay.
001AB0  3               :
001AB0  3  68           	pla			; remove return address from stack.
001AB1  3  85 rr        	sta z80_l
001AB3  3  68           	pla
001AB4  3  85 rr        	sta z80_h
001AB6  3  60           	rts
001AB7  3               
001AB7  3               ;-----------------------------------------------
001AB7  3               ; Displays the current high score.
001AB7  3               ;-----------------------------------------------
001AB7  3               
001AB7  3               dhisc:
001AB7  3  A9 9B        	lda #<hiscor 		; high score text.
001AB9  3  85 rr        	sta z80_l
001ABB  3  A9 1A        	lda #>hiscor
001ABD  3  85 rr        	sta z80_h
001ABF  3  4C CA 1A     	jmp dscor1		; check in printable range then show 6 digits.
001AC2  3               
001AC2  3               ;------------------------------------------------------
001AC2  3               ; Displays the current score.
001AC2  3               ;------------------------------------------------------
001AC2  3               
001AC2  3               dscor:
001AC2  3  A9 95        	lda #<score		; score text.
001AC4  3  85 rr        	sta z80_l
001AC6  3  A9 1A        	lda #>score
001AC8  3  85 rr        	sta z80_h
001ACA  3               dscor1:
001ACA  3  20 40 21     	jsr preprt		; set up font and print position.
001ACD  3  20 A9 1A     	jsr checkx		; make sure we're in a printable range.
001AD0  3               
001AD0  3  A9 06        	lda #6			; digits to display.
001AD2  3  85 rr        	sta z80_b
001AD4  3  A5 rr        	lda prtmod		; get print mode.
001AD6  3  F0 03        	beq :+			; standard size text?
001AD8  3  4C F7 1A     	jmp bscor0		; no, show double-height.
001ADB  3               :
001ADB  3               dscor0:
001ADB  3  A0 00        	ldy #0
001ADD  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001ADF  3  20 52 11     	jsr pchar 		; display character.
001AE2  3  E6 rr        	inc dispx		; move along x coordinate
001AE4  3               
001AE4  3  E6 rr        	inc z80_l		; next score column.
001AE6  3  D0 02        	bne :+
001AE8  3  E6 rr        	inc z80_h
001AEA  3               :
001AEA  3  C6 rr        	dec z80_b
001AEC  3  D0 ED        	bne dscor0 		; repeat for all digits.
001AEE  3               dscor2:
001AEE  3  A5 rr        	lda dispx 		; set up display coordinates.
001AF0  3  85 rr        	sta charx
001AF2  3  A5 rr        	lda dispy
001AF4  3  85 rr        	sta chary
001AF6  3  60           	rts
001AF7  3               
001AF7  3               ;------------------------------------------------------
001AF7  3               ; Displays the current score in double-height characters.
001AF7  3               ;
001AF7  3               ; Input:
001AF7  3               ;  B  = digit number
001AF7  3               ;  HL = score string
001AF7  3               ;------------------------------------------------------
001AF7  3               
001AF7  3               bscor0:
001AF7  3  A0 00        	ldy #0
001AF9  3               
001AF9  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001AFB  3  20 C3 20     	jsr bchar 		; display big char.
001AFE  3               
001AFE  3  E6 rr        	inc z80_l 		; next score column.
001B00  3  D0 02        	bne :+
001B02  3  E6 rr        	inc z80_h
001B04  3               :
001B04  3  C6 rr        	dec z80_b
001B06  3  F0 03        	beq :+
001B08  3  4C F7 1A     	jmp bscor0 		; repeat for all digits.
001B0B  3               :
001B0B  3  4C EE 1A     	jmp dscor2 		; tidy up line and column variables.
001B0E  3               
001B0E  3               ;-----------------------------------------------------
001B0E  3               ; Adds number in the hl pair to the score.
001B0E  3               ;-----------------------------------------------------
001B0E  3               
001B0E  3               addsc:
001B0E  3  A9 96        	lda #<(score+1) 	; ten thousands column.
001B10  3  85 rr        	sta z80_e
001B12  3  A9 1A        	lda #>(score+1)
001B14  3  85 rr        	sta z80_d
001B16  3  A9 10        	lda #<10000		; amount to add each time.
001B18  3  85 rr        	sta z80_c
001B1A  3  A9 27        	lda #>10000
001B1C  3  85 rr        	sta z80_b
001B1E  3  20 62 1B     	jsr incsc		; add to score.
001B21  3               
001B21  3  E6 rr        	inc z80_e		; thousands column.
001B23  3  D0 02        	bne :+
001B25  3  E6 rr        	inc z80_d
001B27  3               :
001B27  3  A9 E8        	lda #<1000		; amount to add each time.
001B29  3  85 rr        	sta z80_c
001B2B  3  A9 03        	lda #>1000
001B2D  3  85 rr        	sta z80_b
001B2F  3  20 62 1B     	jsr incsc 		; add to score.
001B32  3               
001B32  3  E6 rr        	inc z80_e		; hundreds column.
001B34  3  D0 02        	bne :+
001B36  3  E6 rr        	inc z80_d
001B38  3               :
001B38  3  A9 64        	lda #<100		; amount to add each time.
001B3A  3  85 rr        	sta z80_c
001B3C  3  A9 00        	lda #>100
001B3E  3  85 rr        	sta z80_b
001B40  3  20 62 1B     	jsr incsc		; add to score.
001B43  3               
001B43  3  E6 rr        	inc z80_e 		; tens column.
001B45  3  D0 02        	bne :+
001B47  3  E6 rr        	inc z80_d
001B49  3               :
001B49  3  A9 0A        	lda #<10		; amount to add each time.
001B4B  3  85 rr        	sta z80_c
001B4D  3  A9 00        	lda #>10
001B4F  3  85 rr        	sta z80_b
001B51  3  20 62 1B     	jsr incsc 		; add to score.
001B54  3               
001B54  3  E6 rr        	inc z80_e		; units column.
001B56  3  D0 02        	bne :+
001B58  3  E6 rr        	inc z80_d
001B5A  3               :
001B5A  3  A9 01        	lda #<1			; units.
001B5C  3  85 rr        	sta z80_c
001B5E  3  A9 00        	lda #>1
001B60  3  85 rr        	sta z80_b
001B62  3               incsc:
001B62  3  A5 rr        	lda z80_h		; store amount to add.
001B64  3  48           	pha
001B65  3  A5 rr        	lda z80_l
001B67  3  48           	pha
001B68  3               
001B68  3  38           	sec			; subtract from amount to add.
001B69  3  A5 rr        	lda z80_l
001B6B  3  E5 rr        	sbc z80_c
001B6D  3  85 rr        	sta z80_l
001B6F  3  A5 rr        	lda z80_h
001B71  3  E5 rr        	sbc z80_b
001B73  3  85 rr        	sta z80_h
001B75  3  90 14        	bcc incsc0		; too much, restore value.
001B77  3               
001B77  3  68           	pla			; delete the previous amount from the stack.
001B78  3  68           	pla
001B79  3               
001B79  3  A5 rr        	lda z80_d 		; store column position.
001B7B  3  48           	pha
001B7C  3  A5 rr        	lda z80_e
001B7E  3  48           	pha
001B7F  3  20 92 1B     	jsr incsc2		; do the increment.
001B82  3               
001B82  3  68           	pla			; restore column.
001B83  3  85 rr        	sta z80_e
001B85  3  68           	pla
001B86  3  85 rr        	sta z80_d
001B88  3  4C 62 1B     	jmp incsc		; repeat until all added.
001B8B  3               
001B8B  3               incsc0:
001B8B  3  68           	pla			; restore previous value.
001B8C  3  85 rr        	sta z80_l
001B8E  3  68           	pla
001B8F  3  85 rr        	sta z80_h
001B91  3  60           	rts
001B92  3               incsc2:
001B92  3  A0 00        	ldy #0
001B94  3  B1 rr        	lda (z80_de),y 		; get amount.
001B96  3  18           	clc
001B97  3  69 01        	adc #1			; add one to column.
001B99  3  91 rr        	sta (z80_de),y		; write new column total.
001B9B  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
001B9D  3  B0 01        	bcs :+
001B9F  3  60           	rts			; no, carry on.
001BA0  3               :
001BA0  3  A9 30        	lda #'0'		; make it zero.
001BA2  3  91 rr        	sta (z80_de),y		; write new column total.
001BA4  3  C6 rr        	dec z80_e		; back one column.
001BA6  3  D0 02        	bne :+
001BA8  3  C6 rr        	dec z80_d
001BAA  3               :
001BAA  3  4C 92 1B     	jmp incsc2
001BAD  3               
001BAD  3               ;------------------------------------
001BAD  3               ; Add bonus to score and reset bonus
001BAD  3               ;------------------------------------
001BAD  3               
001BAD  3               addbo:
001BAD  3  A2 05        	ldx #5			; last digit.
001BAF  3  18           	clc			; clear carry.
001BB0  3               addbo0:
001BB0  3  BD 95 1A     	lda score,x		; get score.
001BB3  3  7D A1 1A     	adc bonus,x		; add bonus.
001BB6  3  38           	sec			; 0 to 18.
001BB7  3  E9 30        	sbc #48
001BB9  3  48           	pha
001BBA  3  A9 30        	lda #'0'
001BBC  3  9D A1 1A     	sta bonus,x		; zeroise bonus.
001BBF  3  68           	pla
001BC0  3  C9 3A        	cmp #58			; carried?
001BC2  3  B0 07        	bcs addbo2		; no, do next one.
001BC4  3  38           	sec
001BC5  3  E9 0A        	sbc #10			; subtract 10.
001BC7  3  38           	sec
001BC8  3  4C CC 1B     	jmp addbo1
001BCB  3               addbo2:
001BCB  3  18           	clc
001BCC  3               addbo1:
001BCC  3  9D 95 1A     	sta score,x		; write new score.
001BCF  3  CA           	dex			; next digit.
001BD0  3  10 DE        	bpl addbo0		; repeat for all 6 digits.
001BD2  3  60           	rts
001BD3  3               
001BD3  3               ;------------------------------------
001BD3  3               ; Swap score and bonus.
001BD3  3               ;------------------------------------
001BD3  3               
001BD3  3               swpsb:
001BD3  3  A2 05        	ldx #5			; digits to add.
001BD5  3               swpsb0:
001BD5  3  BD 95 1A     	lda score,x 		; get score digits.
001BD8  3  48           	pha			; save digit
001BD9  3  BD A1 1A     	lda bonus,x 		; get bonus digits.
001BDC  3  9D 95 1A     	sta score,x		; switch score-bonus
001BDF  3  68           	pla
001BE0  3  9D A1 1A     	sta bonus,x
001BE3  3  CA           	dex 			; repeat for all 6 digits.
001BE4  3  10 EF        	bpl swpsb0
001BE6  3  60           	rts
001BE7  3               
001BE7  3               ;----------------------------------------------------
001BE7  3               ; Get print address.
001BE7  3               ;----------------------------------------------------
001BE7  3               
001BE7  3               gprad:
001BE7  3  98           	tya
001BE8  3  48           	pha
001BE9  3               
001BE9  3  A5 rr        	lda dispx 		; x coordinate.
001BEB  3  85 rr        	sta scraddr
001BED  3  A9 00        	lda #0
001BEF  3  85 rr        	sta scraddr+1
001BF1  3  06 rr        	asl scraddr  	; multiply char by 8
001BF3  3  26 rr        	rol scraddr+1
001BF5  3  06 rr        	asl scraddr
001BF7  3  26 rr        	rol scraddr+1
001BF9  3  06 rr        	asl scraddr
001BFB  3  26 rr        	rol scraddr+1
001BFD  3               
001BFD  3  A5 rr        	lda dispy		; y coordinate.
001BFF  3  0A           	asl a
001C00  3  0A           	asl a
001C01  3  0A           	asl a			; multiply char by 8
001C02  3  A8           	tay
001C03  3               
001C03  3  18           	clc
001C04  3  A5 rr        	lda scraddr
001C06  3  79 00 06     	adc SCADTB_lb,y
001C09  3  85 rr        	sta scraddr
001C0B  3  A5 rr        	lda scraddr+1
001C0D  3  79 00 07     	adc SCADTB_hb,y
001C10  3  85 rr        	sta scraddr+1
001C12  3               
001C12  3  68           	pla
001C13  3  A8           	tay
001C14  3  60           	rts
001C15  3               
001C15  3               ;--------------------------------------------------------------
001C15  3               ; Get property buffer address of char at (dispx, dispy) in hl.
001C15  3               ;
001C15  3               ; Output:
001C15  3               ;  bufaddr = MAP + dispy*32 + dispx
001C15  3               ;--------------------------------------------------------------
001C15  3               
001C15  3               pradd:
001C15  3  A5 rr        	lda dispy 		; y coordinate.
001C17  3  85 rr        	sta bufaddr
001C19  3  A9 00        	lda #0
001C1B  3  85 rr        	sta bufaddr+1
001C1D  3  06 rr        	asl bufaddr  		; multiply char by 32
001C1F  3  26 rr        	rol bufaddr+1
001C21  3  06 rr        	asl bufaddr
001C23  3  26 rr        	rol bufaddr+1
001C25  3  06 rr        	asl bufaddr
001C27  3  26 rr        	rol bufaddr+1
001C29  3  06 rr        	asl bufaddr
001C2B  3  26 rr        	rol bufaddr+1
001C2D  3  06 rr        	asl bufaddr
001C2F  3  26 rr        	rol bufaddr+1
001C31  3  18           	clc			; add address of MAP graphics.
001C32  3  A5 rr        	lda bufaddr
001C34  3  65 rr        	adc dispx
001C36  3  69 00        	adc #<MAP
001C38  3  85 rr        	sta bufaddr
001C3A  3  A5 rr        	lda bufaddr+1
001C3C  3  69 03        	adc #>MAP
001C3E  3  85 rr        	sta bufaddr+1
001C40  3  60           	rts
001C41  3               
001C41  3               ;----------------------------------------------
001C41  3               ; Print attributes, properties and pixels.
001C41  3               ;
001C41  3               ; Input:
001C41  3               ;  A	= tile number
001C41  3               ;----------------------------------------------
001C41  3               
001C41  3               pattr:
001C41  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001C41  3               .if aflag
001C41  3               	pha
001C41  3               	jsr wbloc		; save blockinfo
001C41  3               	pla
001C41  3               .endif
001C41  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001C41  3               
001C41  3               pattr2:
001C41  3  85 rr        	sta z80_b		; store cell in b register for now.
001C43  3  AA           	tax
001C44  3  BD 61 2E     	lda bprop,x 		; block properties.
001C47  3  85 rr        	sta z80_c
001C49  3  C9 08        	cmp #COLECT
001C4B  3  D0 04        	bne :+
001C4D  3  A5 rr        	lda z80_b
001C4F  3  85 rr        	sta colpatt
001C51  3               :
001C51  3  20 15 1C     	jsr pradd 		; get property buffer address.
001C54  3  A5 rr        	lda z80_c
001C56  3  A0 00        	ldy #0
001C58  3  91 rr        	sta (bufaddr),y 	; write property.
001C5A  3  A5 rr        	lda z80_b 		; restore cell.
001C5C  3               
001C5C  3               ; Print attributes, no properties.
001C5C  3               
001C5C  3               panp:
001C5C  3  85 rr        	sta z80_e		; displacement in e.
001C5E  3  A9 00        	lda #0
001C60  3  85 rr        	sta z80_d		; no high byte.
001C62  3  06 rr        	asl z80_e  		; multiply char by 8.
001C64  3  26 rr        	rol z80_d
001C66  3  06 rr        	asl z80_e
001C68  3  26 rr        	rol z80_d
001C6A  3  06 rr        	asl z80_e
001C6C  3  26 rr        	rol z80_d
001C6E  3  18           	clc
001C6F  3  A5 rr        	lda z80_e
001C71  3  69 D1        	adc #<chgfx 		; address of graphics.
001C73  3  85 rr        	sta tileaddr
001C75  3  A5 rr        	lda z80_d
001C77  3  69 2D        	adc #>chgfx
001C79  3  85 rr        	sta tileaddr+1
001C7B  3  20 E7 1B     	jsr gprad 		; get screen address.
001C7E  3  A0 07        	ldy #7			; number of pixel rows to write.
001C80  3               panp0:
001C80  3  B1 rr        	lda (tileaddr),y 	; get image byte.
001C82  3  49 FF        	eor #TxtInvert		; Invert
001C84  3  91 rr        	sta (scraddr),y 	; copy to screen.
001C86  3  88           	dey	 		; repeat for 8 pixel rows.
001C87  3  10 F7        	bpl panp0
001C89  3  E6 rr        	inc dispx 		; move along one.
001C8B  3  E6 rr        	inc charx
001C8D  3  60           	rts
001C8E  3               
001C8E  3               ;----------------------------------------------
001C8E  3               ; Write block
001C8E  3               ;----------------------------------------------
001C8E  3               
001C8E  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001C8E  3               .if aflag
001C8E  3               wbloc:
001C8E  3               	ldy #3
001C8E  3               	sta (pbptr),y		; store block number
001C8E  3               	dey
001C8E  3               	lda dispx
001C8E  3               	sta (pbptr),y		; write x position of block.
001C8E  3               	dey
001C8E  3               	lda dispy
001C8E  3               	sta (pbptr),y		; write y position of block.
001C8E  3               	dey
001C8E  3               	lda scno
001C8E  3               	sta (pbptr),y		; write screen.
001C8E  3               	clc			; point to next free location
001C8E  3               	lda pbptr
001C8E  3               	adc #4
001C8E  3               	sta pbptr
001C8E  3               	bcc :+
001C8E  3               	inc pbptr+1
001C8E  3               :
001C8E  3               	rts
001C8E  3               .endif
001C8E  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001C8E  3               
001C8E  3               ;----------------------------------------------
001C8E  3               ; Print character pixels, no more.
001C8E  3               ;
001C8E  3               ; Input:
001C8E  3               ;  A	= character to print
001C8E  3               ;----------------------------------------------
001C8E  3               
001C8E  3               pchr:
001C8E  3  20 52 11     	jsr pchar 		; show character in accumulator.
001C91  3  E6 rr        	inc dispx		; move along one.
001C93  3  60           	rts
001C94  3               
001C94  3               ;----------------------------------------------------
001C94  3               ; Shifter sprite routine for objects.
001C94  3               ;----------------------------------------------------
001C94  3               
001C94  3               sprit7:
001C94  3  A5 rr        	lda z80_b
001C96  3  F0 0A        	beq sprit0
001C98  3  A8           	tay
001C99  3               sprit3:
001C99  3  46 rr        	lsr spr			; shift into position.
001C9B  3  66 rr        	ror spr+1
001C9D  3  66 rr        	ror spr+2
001C9F  3  88           	dey				; one less iteration.
001CA0  3  D0 F7        	bne sprit3
001CA2  3               sprit0:
001CA2  3  60           	rts 			; now apply to screen.
001CA3  3               
001CA3  3               ;-----------------------------------------------------------
001CA3  3               ; Get room address.
001CA3  3               ;-----------------------------------------------------------
001CA3  3               
001CA3  3               groom:
001CA3  3  A6 rr        	ldx scno 		; screen number.
001CA5  3  A0 00        	ldy #0
001CA7  3               groomx:
001CA7  3  A9 9F        	lda #<scdat 		; pointer to screens.
001CA9  3  85 rr        	sta z80_l
001CAB  3  A9 30        	lda #>scdat
001CAD  3  85 rr        	sta z80_h
001CAF  3               groom1:
001CAF  3  E0 00        	cpx #0			; is it the first one?
001CB1  3  F0 15        	beq groom0 		; no more screens to skip.
001CB3  3               
001CB3  3  18           	clc
001CB4  3  A5 rr        	lda z80_l
001CB6  3  79 9F 30     	adc scdat,y 		; low byte of screen size.
001CB9  3  85 rr        	sta z80_l
001CBB  3  C8           	iny			; point to high byte.
001CBC  3  A5 rr        	lda z80_h
001CBE  3  79 9F 30     	adc scdat,y 		; high byte of screen size.
001CC1  3  85 rr        	sta z80_h
001CC3  3  C8           	iny			; next address.
001CC4  3               
001CC4  3  CA           	dex 			; one less iteration.
001CC5  3  4C AF 1C     	jmp groom1 		; loop until we reach the end.
001CC8  3               groom0:
001CC8  3  AD C9 38     	lda numsc 		; add displacement.
001CCB  3  0A           	asl a
001CCC  3  18           	clc			; add double displacement to address.
001CCD  3  65 rr        	adc z80_l
001CCF  3  85 rr        	sta z80_l
001CD1  3  A5 rr        	lda z80_h
001CD3  3  69 00        	adc #0
001CD5  3  85 rr        	sta z80_h
001CD7  3  60           	rts
001CD8  3               
001CD8  3               ;-----------------------------------------------------------
001CD8  3               ; Draw present room.
001CD8  3               ;-----------------------------------------------------------
001CD8  3               
001CD8  3               droom:
001CD8  3  AD 0C 16     	lda wintop 		; window top.
001CDB  3  85 rr        	sta dispy		; set cursor y position.
001CDD  3               droom2:
001CDD  3  20 A3 1C     	jsr groom 		; get address of current room.
001CE0  3  A9 00        	lda #0	 		; zero in accumulator.
001CE2  3  85 rr        	sta comcnt 		; reset compression counter.
001CE4  3  AD 0E 16     	lda winhgt 		; height of window.
001CE7  3  85 rr        	sta rrow		; set row counter
001CE9  3               droom0:
001CE9  3  AD 0D 16     	lda winlft 		; window left edge.
001CEC  3  85 rr        	sta dispx 		; set cursor x position.
001CEE  3  AD 0F 16     	lda winwid 		; width of window.
001CF1  3  85 rr        	sta rcol		; set column counter
001CF3  3               droom1:
001CF3  3  20 04 1D     	jsr flbyt 		; decompress next byte on the fly.
001CF6  3  20 41 1C     	jsr pattr2 		; show attributes and block.
001CF9  3  C6 rr        	dec rcol		; one less column.
001CFB  3  D0 F6        	bne droom1 		; repeat for entire line.
001CFD  3  E6 rr        	inc dispy		; move down one line.
001CFF  3  C6 rr        	dec rrow 		; one less row.
001D01  3  D0 E6        	bne droom0 		; repeat for all rows.
001D03  3  60           	rts
001D04  3               
001D04  3               ;----------------------------------------------
001D04  3               ; Decompress bytes on-the-fly.
001D04  3               ;----------------------------------------------
001D04  3               
001D04  3               flbyt:
001D04  3  A5 rr        	lda comcnt 		; compression counter.
001D06  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
001D08  3               
001D08  3  A0 00        	ldy #0
001D0A  3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
001D0C  3  E6 rr        	inc z80_l 		; point to next cell.
001D0E  3  D0 02        	bne :+
001D10  3  E6 rr        	inc z80_h
001D12  3               :
001D12  3  C9 FF        	cmp #255 		; is this byte a control code?
001D14  3  F0 01        	beq :+
001D16  3  60           	rts 			; no, this byte is uncompressed.
001D17  3               :
001D17  3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
001D19  3  85 rr        	sta combyt 		; set up the type.
001D1B  3  E6 rr        	inc z80_l 		; point to quantity.
001D1D  3  D0 02        	bne :+
001D1F  3  E6 rr        	inc z80_h
001D21  3               :
001D21  3  B1 rr        	lda (z80_hl),y 		; get quantity.
001D23  3  E6 rr        	inc z80_l 		; point to next byte.
001D25  3  D0 02        	bne :+
001D27  3  E6 rr        	inc z80_h
001D29  3               :
001D29  3               flbyt1:
001D29  3  85 rr        	sta comcnt 		; store new quantity.
001D2B  3  C6 rr        	dec comcnt		; one less.
001D2D  3  A5 rr        	lda combyt 		; byte to expand.
001D2F  3  60           	rts
001D30  3               
001D30  3               ;------------------------------------------
001D30  3               ; Ladder down check.
001D30  3               ;
001D30  3               ; Input:
001D30  3               ;  IX = sprite pointer
001D30  3               ;------------------------------------------
001D30  3               
001D30  3               laddd:
001D30  3  A0 09        	ldy #var_newX
001D32  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001D34  3  85 rr        	sta dispx
001D36  3               
001D36  3  A0 08        	ldy #var_newY
001D38  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001D3A  3  29 FE        	and #254		; make it even.
001D3C  3  91 rr        	sta (z80_ix),y 		; reset it.
001D3E  3               numsp5:
001D3E  3  18           	clc 			; look down 16 pixels.
001D3F  3  69 10        	adc #16
001D41  3  85 rr        	sta dispy		; coords in dispx,dispy.
001D43  3  4C 59 1D     	jmp laddv
001D46  3               
001D46  3               ;------------------------------------------
001D46  3               ; Ladder up check.
001D46  3               ;
001D46  3               ; Input:
001D46  3               ;  IX = sprite pointer
001D46  3               ;
001D46  3               ; Output:
001D46  3               ;  A  = 0 is ok, A <>0 is not ok
001D46  3               ;------------------------------------------
001D46  3               
001D46  3               laddu:
001D46  3  A0 09        	ldy #var_newX
001D48  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001D4A  3  85 rr        	sta dispx
001D4C  3               
001D4C  3  A0 08        	ldy #var_newY
001D4E  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001D50  3  29 FE        	and #254 		; make it even.
001D52  3  91 rr        	sta (z80_ix),y		; reset it.
001D54  3               numsp6:
001D54  3  18           	clc 			; look 2 pixels above feet.
001D55  3  69 0E        	adc #14
001D57  3  85 rr        	sta dispy		; coords in dispx,dispy.
001D59  3               laddv:
001D59  3  20 9B 1F     	jsr tstbl 		; get map address.
001D5C  3  20 66 1E     	jsr ldchk 		; standard ladder check.
001D5F  3  F0 01        	beq :+
001D61  3  60           	rts 			; no way through.
001D62  3               :
001D62  3  E6 rr        	inc bufaddr 		; look right one cell.
001D64  3  D0 02        	bne :+
001D66  3  E6 rr        	inc bufaddr+1
001D68  3               :
001D68  3  20 66 1E     	jsr ldchk 		; do the check.
001D6B  3  F0 01        	beq :+
001D6D  3  60           	rts 			; impassable.
001D6E  3               :
001D6E  3  A5 rr        	lda dispx 		; y coordinate.
001D70  3  29 07        	and #7 			; position straddling block cells.
001D72  3  D0 01        	bne :+
001D74  3  60           	rts 			; no more checks needed.
001D75  3               :
001D75  3  E6 rr        	inc bufaddr 		; look to third cell.
001D77  3  D0 02        	bne :+
001D79  3  E6 rr        	inc bufaddr+1
001D7B  3               :
001D7B  3  20 66 1E     	jsr ldchk 		; do the check.
001D7E  3  60           	rts  			; return with zero flag set accordingly.
001D7F  3               
001D7F  3               ;---------------------------------------------------------
001D7F  3               ; Can go up check.
001D7F  3               ;
001D7F  3               ; Input:
001D7F  3               ;  IX = sprite pointer
001D7F  3               ;
001D7F  3               ; Output:
001D7F  3               ;  A  = 0 is ok, A <>0 is not ok
001D7F  3               ;---------------------------------------------------------
001D7F  3               
001D7F  3               cangu:
001D7F  3  A0 09        	ldy #var_newX
001D81  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001D83  3  85 rr        	sta dispx
001D85  3  A0 08        	ldy #var_newY
001D87  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001D89  3  38           	sec
001D8A  3  E9 02        	sbc #2
001D8C  3  85 rr        	sta dispy		; coords in dispx,dispy.
001D8E  3  20 9B 1F     	jsr tstbl 		; get map address.
001D91  3  20 31 1E     	jsr lrchk 		; standard left/right check.
001D94  3  F0 01        	beq :+
001D96  3  60           	rts			; no way through.
001D97  3               :
001D97  3  E6 rr        	inc bufaddr		; look right one cell.
001D99  3  D0 02        	bne :+
001D9B  3  E6 rr        	inc bufaddr+1
001D9D  3               :
001D9D  3  20 31 1E     	jsr lrchk 		; do the check.
001DA0  3  F0 01        	beq :+
001DA2  3  60           	rts			; impassable.
001DA3  3               :
001DA3  3  A5 rr        	lda dispx		; x coordinate.
001DA5  3  29 07        	and #7			; position straddling block cells.
001DA7  3  D0 01        	bne :+
001DA9  3  60           	rts			; no more checks needed.
001DAA  3               :
001DAA  3  E6 rr        	inc bufaddr		; look to third cell.
001DAC  3  D0 02        	bne :+
001DAE  3  E6 rr        	inc bufaddr+1
001DB0  3               :
001DB0  3  20 31 1E     	jsr lrchk		; do the check.
001DB3  3  60           	rts 			; return with zero flag set accordingly.
001DB4  3               
001DB4  3               ;---------------------------------------------------------
001DB4  3               ; Can go down check.
001DB4  3               ;
001DB4  3               ; Input:
001DB4  3               ;  IX = sprite pointer
001DB4  3               ;
001DB4  3               ; Output:
001DB4  3               ;  A  = 0 is ok, A <>0 is not ok
001DB4  3               ;---------------------------------------------------------
001DB4  3               
001DB4  3               cangd:
001DB4  3  A0 09        	ldy #var_newX
001DB6  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001DB8  3  85 rr        	sta dispx
001DBA  3  A0 08        	ldy #var_newY
001DBC  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001DBE  3               numsp3:
001DBE  3  18           	clc
001DBF  3  69 10        	adc #16 		; look down 16 pixels.
001DC1  3  85 rr        	sta dispy		; coords in dispx,dispy.
001DC3  3  20 9B 1F     	jsr tstbl 		; get map address.
001DC6  3  20 46 1E     	jsr plchk 		; block, platform check.
001DC9  3  F0 01        	beq :+
001DCB  3  60           	rts			; no way through.
001DCC  3               :
001DCC  3  E6 rr        	inc bufaddr		; look right one cell.
001DCE  3  D0 02        	bne :+
001DD0  3  E6 rr        	inc bufaddr+1
001DD2  3               :
001DD2  3  20 46 1E     	jsr plchk		; block, platform check.
001DD5  3  F0 01        	beq :+
001DD7  3  60           	rts			; impassable.
001DD8  3               :
001DD8  3  A5 rr        	lda dispx		; x coordinate.
001DDA  3  29 07        	and #7			; position straddling block cells.
001DDC  3  D0 01        	bne :+
001DDE  3  60           	rts			; no more checks needed.
001DDF  3               :
001DDF  3  E6 rr        	inc bufaddr		; look to third cell.
001DE1  3  D0 02        	bne :+
001DE3  3  E6 rr        	inc bufaddr+1
001DE5  3               :
001DE5  3  20 46 1E     	jsr plchk		; block, platform check.
001DE8  3  60           	rts			; return with zero flag set accordingly.
001DE9  3               
001DE9  3               ;---------------------------------------------------------
001DE9  3               ; Can go left check.
001DE9  3               ;
001DE9  3               ; Input:
001DE9  3               ;  IX = sprite pointer
001DE9  3               ;
001DE9  3               ; Output:
001DE9  3               ;  A  = 0 is ok, A <>0 is not ok
001DE9  3               ;---------------------------------------------------------
001DE9  3               
001DE9  3               cangl:
001DE9  3  A0 08        	ldy #var_newY
001DEB  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001DED  3  85 rr        	sta dispy
001DEF  3  A0 09        	ldy #var_newX
001DF1  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001DF3  3  38           	sec
001DF4  3  E9 02        	sbc #2			; look left 2 pixels.
001DF6  3  85 rr        	sta dispx		; coords in dispx,dispy.
001DF8  3  4C 0A 1E     	jmp cangh		; test if we can go there.
001DFB  3               
001DFB  3               ;---------------------------------------------------------
001DFB  3               ; Can go right check.
001DFB  3               ;
001DFB  3               ; Input:
001DFB  3               ;  IX = sprite pointer
001DFB  3               ;
001DFB  3               ; Output:
001DFB  3               ;  A  = 0 is ok, A <>0 is not ok
001DFB  3               ;---------------------------------------------------------
001DFB  3               
001DFB  3               cangr:
001DFB  3  A0 08        	ldy #var_newY
001DFD  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001DFF  3  85 rr        	sta dispy
001E01  3  A0 09        	ldy #var_newX
001E03  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001E05  3  18           	clc
001E06  3  69 10        	adc #16			; look right 16 pixels.
001E08  3  85 rr        	sta dispx		; coords in dispx,dispy.
001E0A  3               cangh:
001E0A  3               cangh2:
001E0A  3  A9 03        	lda #3			; default rows to write.
001E0C  3  85 rr        	sta z80_b
001E0E  3  A5 rr        	lda dispy		; y position.
001E10  3  29 07        	and #7			; does x straddle cells?
001E12  3  D0 02        	bne cangh0		; yes, loop counter is good.
001E14  3  C6 rr        	dec z80_b		; one less row to write.
001E16  3               cangh0:
001E16  3  20 9B 1F     	jsr tstbl		; get map address.
001E19  3               cangh1:
001E19  3  20 31 1E     	jsr lrchk		; standard left/right check.
001E1C  3  F0 01        	beq :+
001E1E  3  60           	rts			; no way through.
001E1F  3               :
001E1F  3  48           	pha
001E20  3  18           	clc
001E21  3  A5 rr        	lda bufaddr
001E23  3  69 20        	adc #32			; look down.
001E25  3  85 rr        	sta bufaddr
001E27  3  90 02        	bcc :+
001E29  3  E6 rr        	inc bufaddr+1
001E2B  3               :
001E2B  3  68           	pla
001E2C  3               
001E2C  3  C6 rr        	dec z80_b
001E2E  3  D0 E9        	bne cangh1
001E30  3  60           	rts
001E31  3               
001E31  3               ;-------------------------------------
001E31  3               ; Check left/right movement is okay.
001E31  3               ;
001E31  3               ; Input:
001E31  3               ;  bufaddr = MAP + x/8 + y/8*32
001E31  3               ;
001E31  3               ; Output:
001E31  3               ;  A  = 0 is ok, A <>0 is not ok
001E31  3               ;-------------------------------------
001E31  3               
001E31  3               lrchk:
001E31  3  A0 00        	ldy #0
001E33  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
001E35  3  C9 02        	cmp #WALL 		; is it passable?
001E37  3  F0 0A        	beq lrchkx		; no.
001E39  3               
001E39  3  C9 04        	cmp #FODDER		; fodder has to be dug.
001E3B  3  F0 06        	beq lrchkx		; not passable.
001E3D  3  A9 00        	lda #0
001E3F  3  60           	rts
001E40  3               
001E40  3               ;--------------------------------------------------------------
001E40  3               ; Called by mmenu
001E40  3               ;--------------------------------------------------------------
001E40  3               
001E40  3               always:
001E40  3  A9 FF        	lda #255		; report it as okay.
001E42  3  60           	rts
001E43  3               
001E43  3               lrchkx:
001E43  3  A9 01        	lda #1 			; reset all bits.
001E45  3  60           	rts
001E46  3               
001E46  3               
001E46  3               ;--------------------------------------------------------------
001E46  3               ; Check platform or solid item is not in way.
001E46  3               ;
001E46  3               ; Input:
001E46  3               ;  bufaddr = MAP + x/8 + y/8*32
001E46  3               ;
001E46  3               ; Output:
001E46  3               ;  A  = 0 is ok, A <>0 is not ok
001E46  3               ;--------------------------------------------------------------
001E46  3               
001E46  3               plchk:
001E46  3  A0 00        	ldy #0
001E48  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
001E4A  3  C9 02        	cmp #WALL 		; is it passable?
001E4C  3  F0 F5        	beq lrchkx		; no.
001E4E  3               
001E4E  3  C9 04        	cmp #FODDER		; fodder has to be dug.
001E50  3  F0 F1        	beq lrchkx		; not passable.
001E52  3               
001E52  3  C9 01        	cmp #PLATFM		; platform is solid.
001E54  3  F0 07        	beq plchkx		; not passable.
001E56  3               
001E56  3  C9 03        	cmp #LADDER		; is it a ladder?
001E58  3  F0 E9        	beq lrchkx		; on ladder, deny movement.
001E5A  3               plchk0:
001E5A  3  A9 00        	lda #0			; report as ok
001E5C  3  60           	rts
001E5D  3               plchkx:
001E5D  3  A5 rr        	lda dispy		; x coordinate.
001E5F  3  29 07        	and #7			; position straddling blocks.
001E61  3  F0 E0        	beq lrchkx		; on platform, deny movement.
001E63  3  4C 5A 1E     	jmp plchk0
001E66  3               
001E66  3               ;--------------------------------------------------------------
001E66  3               ; Check ladder is available.
001E66  3               ;
001E66  3               ; Input:
001E66  3               ;  bufaddr = MAP + x/8 + y/8*32
001E66  3               ;
001E66  3               ; Output:
001E66  3               ;  A  = 0 is ok, A <>0 is not ok
001E66  3               ;--------------------------------------------------------------
001E66  3               
001E66  3               ldchk:
001E66  3  A0 00        	ldy #0
001E68  3  B1 rr        	lda (bufaddr),y 	; fetch cell.
001E6A  3  C9 03        	cmp #LADDER 		; is it a ladder?
001E6C  3  F0 03        	beq :+
001E6E  3  A9 01        	lda #1
001E70  3  60           	rts  			; return with zero flag set accordingly.
001E71  3               :
001E71  3  A9 00        	lda #0
001E73  3  60           	rts
001E74  3               
001E74  3               ;--------------------------------------------------------------
001E74  3               ; Get collectables.
001E74  3               ;--------------------------------------------------------------
001E74  3               
001E74  3               getcol:
001E74  3  A9 08            lda #COLECT             ; collectable blocks.
001E76  3  85 rr            sta z80_b
001E78  3  20 E0 1E         jsr tded                ; test for collectable blocks.
001E7B  3  C5 rr            cmp z80_b               ; did we find one?
001E7D  3  F0 01            beq :+
001E7F  3  60               rts                     ; none were found, job done.
001E80  3               :
001E80  3  20 89 1E         jsr gtblk               ; get block.
001E83  3               
001E83  3  20 7D 2D         jsr evnt20              ; collected block event.
001E86  3  4C 74 1E         jmp getcol              ; repeat until none left.
001E89  3               
001E89  3               ; Get collectable block.
001E89  3               
001E89  3               gtblk:
001E89  3  A0 00        	ldy #0
001E8B  3  B1 rr        	lda (bufaddr),y
001E8D  3  85 rr        	sta z80_a
001E8F  3  A9 00                lda #0
001E91  3  91 rr                sta (bufaddr),y		; make it empty now.
001E93  3               
001E93  3  A5 rr        	lda bufaddr		; set dispx
001E95  3  29 1F        	and #31
001E97  3  85 rr        	sta dispx
001E99  3               
001E99  3  A5 rr        	lda bufaddr+1		; Set dispy
001E9B  3  38           	sec
001E9C  3  E9 03        	sbc #>MAP
001E9E  3  85 rr        	sta bufaddr+1
001EA0  3  06 rr        	asl bufaddr
001EA2  3  26 rr        	rol bufaddr+1
001EA4  3  06 rr        	asl bufaddr
001EA6  3  26 rr        	rol bufaddr+1
001EA8  3  06 rr        	asl bufaddr
001EAA  3  26 rr        	rol bufaddr+1
001EAC  3  A5 rr        	lda bufaddr+1
001EAE  3  85 rr        	sta dispy
001EB0  3               
001EB0  3  A5 rr        	lda colpatt		; get blocknr
001EB2  3  85 rr        	sta z80_e		; displacement in e.
001EB4  3  A9 00        	lda #0
001EB6  3  85 rr        	sta z80_d		; no high byte.
001EB8  3  06 rr        	asl z80_e  		; multiply char by 8.
001EBA  3  26 rr        	rol z80_d
001EBC  3  06 rr        	asl z80_e
001EBE  3  26 rr        	rol z80_d
001EC0  3  06 rr        	asl z80_e
001EC2  3  26 rr        	rol z80_d
001EC4  3  18           	clc
001EC5  3  A5 rr        	lda z80_e
001EC7  3  69 D1        	adc #<chgfx 		; address of graphics.
001EC9  3  85 rr        	sta tileaddr
001ECB  3  A5 rr        	lda z80_d
001ECD  3  69 2D        	adc #>chgfx
001ECF  3  85 rr        	sta tileaddr+1
001ED1  3  20 E7 1B     	jsr gprad 		; get screen address.
001ED4  3  A0 07        	ldy #7			; number of pixel rows to write.
001ED6  3               gtblk0:
001ED6  3  B1 rr        	lda (tileaddr),y 	; get image byte.
001ED8  3  51 rr        	eor (scraddr),y 	; XOR tile on screen
001EDA  3  91 rr        	sta (scraddr),y 	; copy to screen.
001EDC  3  88           	dey	 		; repeat for 8 pixel rows.
001EDD  3  10 F7        	bpl gtblk0
001EDF  3  60           	rts
001EE0  3               
001EE0  3               ;--------------------------------------------------------------
001EE0  3               ; Touched deadly block check.
001EE0  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
001EE0  3               ;
001EE0  3               ; Input:
001EE0  3               ;  IX = sprite address
001EE0  3               ;
001EE0  3               ; Output:
001EE0  3               ;  A  = 0 is ok, A=5 is not ok
001EE0  3               ;--------------------------------------------------------------
001EE0  3               
001EE0  3               tded:
001EE0  3  A0 08        	ldy #var_newY
001EE2  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001EE4  3  85 rr        	sta dispy
001EE6  3  C8           	iny
001EE7  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001EE9  3  85 rr        	sta dispx		; coords in dispx,dispy.
001EEB  3  20 9B 1F     	jsr tstbl		; get map address.
001EEE  3  48           	pha
001EEF  3  A9 1F        	lda #31			; default distance to next line down.
001EF1  3  85 rr        	sta z80_e
001EF3  3  68           	pla
001EF4  3  C5 rr        	cmp z80_b		; is this the required block?
001EF6  3  D0 01        	bne :+
001EF8  3  60           	rts			; yes.
001EF9  3               :
001EF9  3  E6 rr        	inc bufaddr 		; next cell.
001EFB  3  D0 02        	bne :+
001EFD  3  E6 rr        	inc bufaddr+1
001EFF  3               :
001EFF  3  A0 00        	ldy #0
001F01  3  B1 rr        	lda (bufaddr),y		; fetch type.
001F03  3  C5 rr        	cmp z80_b 		; is this deadly/custom?
001F05  3  D0 01        	bne :+
001F07  3  60           	rts			; yes.
001F08  3               :
001F08  3  A5 rr        	lda dispx		; horizontal position.
001F0A  3  85 rr        	sta z80_c 		; store column in c register.
001F0C  3  29 07        	and #7			; is it straddling cells?
001F0E  3  D0 03        	bne :+
001F10  3  4C 24 1F     	jmp tded0		; no.
001F13  3               :
001F13  3  E6 rr        	inc bufaddr 		; last cell.
001F15  3  D0 02        	bne :+
001F17  3  E6 rr        	inc bufaddr+1
001F19  3               :
001F19  3  A0 00        	ldy #0
001F1B  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001F1D  3  C5 rr        	cmp z80_b		; is this the block?
001F1F  3  D0 01        	bne :+
001F21  3  60           	rts			; yes.
001F22  3               :
001F22  3  C6 rr        	dec z80_e		; one less cell to next row down.
001F24  3               tded0:
001F24  3  18           	clc 			; point to next row.
001F25  3  A5 rr        	lda bufaddr
001F27  3  65 rr        	adc z80_e
001F29  3  85 rr        	sta bufaddr
001F2B  3  90 02        	bcc :+
001F2D  3  E6 rr        	inc bufaddr+1
001F2F  3               :
001F2F  3  A0 00        	ldy #0
001F31  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
001F33  3  C5 rr        	cmp z80_b		; is this fatal?
001F35  3  D0 01        	bne :+
001F37  3  60           	rts			; yes.
001F38  3               :
001F38  3  E6 rr        	inc bufaddr 		; next cell.
001F3A  3  D0 02        	bne :+
001F3C  3  E6 rr        	inc bufaddr+1
001F3E  3               :
001F3E  3  A0 00        	ldy #0
001F40  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001F42  3  C5 rr        	cmp z80_b		; is this fatal?
001F44  3  D0 01        	bne :+
001F46  3  60           	rts			; yes.
001F47  3               :
001F47  3  A5 rr        	lda z80_c		; horizontal position.
001F49  3  29 07        	and #7			; is it straddling cells?
001F4B  3  D0 03        	bne :+
001F4D  3  4C 5F 1F     	jmp tded1 		; no.
001F50  3               :
001F50  3  E6 rr        	inc bufaddr		; last cell.
001F52  3  D0 02        	bne :+
001F54  3  E6 rr        	inc bufaddr+1
001F56  3               :
001F56  3  A0 00        	ldy #0
001F58  3  B1 rr        	lda (bufaddr),y		; fetch type.
001F5A  3  C5 rr        	cmp z80_b		; is this fatal?
001F5C  3  D0 01        	bne :+
001F5E  3  60           	rts			; yes.
001F5F  3               :
001F5F  3               tded1:
001F5F  3  A5 rr        	lda dispy		; vertical position.
001F61  3  29 07        	and #7 			; is it straddling cells?
001F63  3  D0 01        	bne :+
001F65  3  60           	rts			; no, job done.
001F66  3               :
001F66  3  18           	clc			; point to next row.
001F67  3  A5 rr        	lda bufaddr
001F69  3  65 rr        	adc z80_e
001F6B  3  85 rr        	sta bufaddr
001F6D  3  90 02        	bcc :+
001F6F  3  E6 rr        	inc bufaddr+1
001F71  3               :
001F71  3  A0 00        	ldy #0
001F73  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
001F75  3  C5 rr        	cmp z80_b		; is this fatal?
001F77  3  D0 01        	bne :+
001F79  3  60           	rts			; yes.
001F7A  3               :
001F7A  3  E6 rr        	inc bufaddr		; next cell.
001F7C  3  D0 02        	bne :+
001F7E  3  E6 rr        	inc bufaddr+1
001F80  3               :
001F80  3  A0 00        	ldy #0
001F82  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001F84  3  C5 rr        	cmp z80_b		; is this fatal?
001F86  3  D0 01        	bne :+
001F88  3  60           	rts			; yes.
001F89  3               :
001F89  3  A5 rr        	lda z80_c		; horizontal position.
001F8B  3  29 07        	and #7			; is it straddling cells?
001F8D  3  D0 01        	bne :+
001F8F  3  60           	rts			; no.
001F90  3               :
001F90  3  E6 rr        	inc bufaddr		; last cell.
001F92  3  D0 02        	bne :+
001F94  3  E6 rr        	inc bufaddr+1
001F96  3               :
001F96  3  A0 00        	ldy #0
001F98  3  B1 rr        	lda (bufaddr),y		; fetch final type.
001F9A  3  60           	rts 			; return with final type in accumulator.
001F9B  3               
001F9B  3               ;---------------------------------------------------
001F9B  3               ; Fetch block type at (dispx, dispy).
001F9B  3               ;
001F9B  3               ; Output:
001F9B  3               ;  A = block type
001F9B  3               ;---------------------------------------------------
001F9B  3               
001F9B  3               tstbl:
001F9B  3  A5 rr        	lda dispy 			; fetch y coord.
001F9D  3  4A           	lsr a				; bufaddr = y/8
001F9E  3  4A           	lsr a
001F9F  3  4A           	lsr a
001FA0  3  85 rr        	sta chary
001FA2  3               
001FA2  3  85 rr        	sta bufaddr
001FA4  3  A9 00        	lda #0
001FA6  3  85 rr        	sta bufaddr+1
001FA8  3               
001FA8  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
001FAA  3  26 rr        	rol bufaddr+1
001FAC  3  06 rr        	asl bufaddr
001FAE  3  26 rr        	rol bufaddr+1
001FB0  3  06 rr        	asl bufaddr
001FB2  3  26 rr        	rol bufaddr+1
001FB4  3  06 rr        	asl bufaddr
001FB6  3  26 rr        	rol bufaddr+1
001FB8  3  06 rr        	asl bufaddr
001FBA  3  26 rr        	rol bufaddr+1
001FBC  3               
001FBC  3  A5 rr        	lda dispx			; x/8
001FBE  3  4A           	lsr a
001FBF  3  4A           	lsr a
001FC0  3  4A           	lsr a
001FC1  3  85 rr        	sta charx
001FC3  3               
001FC3  3  18           	clc					; bufaddr = MAP + x/8 + y/8*32
001FC4  3  65 rr        	adc bufaddr
001FC6  3               ;	adc #<MAP			; only works because <MAP == $0
001FC6  3  85 rr        	sta bufaddr
001FC8  3  A5 rr        	lda bufaddr+1
001FCA  3  69 03        	adc #>MAP
001FCC  3  85 rr        	sta bufaddr+1
001FCE  3               
001FCE  3  A0 00        	ldy #0
001FD0  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
001FD2  3  60           	rts
001FD3  3               
001FD3  3               ;-------------------------------------------------------------------
001FD3  3               ; Jump - if we can.
001FD3  3               ; Requires initial speed to be set up in accumulator prior to call.
001FD3  3               ;
001FD3  3               ; Input:
001FD3  3               ;  IX = sprite address
001FD3  3               ;-------------------------------------------------------------------
001FD3  3               
001FD3  3               jump:
001FD3  3  A0 0D        	ldy #var_jumpLo
001FD5  3  B1 rr        	lda (z80_ix),y		; jump table low.
001FD7  3  A0 0E        	ldy #var_jumpHi
001FD9  3  11 rr        	ora (z80_ix),y		; jump table high.
001FDB  3  F0 01        	beq :+
001FDD  3  60           	rts			; already in the air.
001FDE  3               :
001FDE  3  A9 3C        	lda #>jtab
001FE0  3  A0 0E        	ldy #var_jumpHi
001FE2  3  91 rr        	sta (z80_ix),y		; set jump high.
001FE4  3  A9 94        	lda #<jtab		; jump table start.
001FE6  3  A0 0D        	ldy #var_jumpLo
001FE8  3  91 rr        	sta (z80_ix),y		; set jump low.
001FEA  3  60           	rts
001FEB  3               
001FEB  3               ; Jump table.
001FEB  3               
001FEB  3               ;jtab:
001FEB  3               ;	.byte 248,250,252
001FEB  3               ;	.byte 254,254,255
001FEB  3               ;	.byte 255,255,0,0
001FEB  3               ;	.byte 0,1,1,1,2,2
001FEB  3               ;	.byte 4,6,8,8,8,99
001FEB  3               
001FEB  3               ;------------------------------------------------
001FEB  3               ; Random numbers code.
001FEB  3               ; Pseudo-random number generator, 8-bit.
001FEB  3               ;
001FEB  3               ; Output:
001FEB  3               ;  RND = random number
001FEB  3               ;------------------------------------------------
001FEB  3               
001FEB  3               random:
001FEB  3  A5 rr        	lda seed		; get last random number.
001FED  3  0A           	asl a
001FEE  3  0A           	asl a
001FEF  3  18           	clc
001FF0  3  65 rr        	adc seed
001FF2  3  18           	clc
001FF3  3  69 45        	adc #$45
001FF5  3  85 rr        	sta seed		; store new seed.
001FF7  3  85 rr        	sta varrnd		; return number in variable.
001FF9  3  60           	rts
001FFA  3               
001FFA  3               ;-------------------------------------------------------
001FFA  3               ; Joystick and keyboard reading routines.
001FFA  3               ;
001FFA  3               ; contrl = 0, Keyboard
001FFA  3               ;          1, JoyKeyb
001FFA  3               ;          2, JoyMMC
001FFA  3               ;-------------------------------------------------------
001FFA  3               
001FFA  3               joykey:
001FFA  3  A5 rr        	lda contrl 		; control flag.
001FFC  3  C9 01        	cmp #1
001FFE  3  D0 03        	bne :+
002000  3  4C 1E 20     	jmp joyjoy 		; read keyboard joystick
002003  3               :
002003  3  C9 02        	cmp #2
002005  3  D0 03        	bne :+
002007  3  4C F6 0E     	jmp joysin 		; read MMC joystick.
00200A  3               :
00200A  3               ; Keyboard controls.
00200A  3               
00200A  3  A9 00        	lda #0		 	; zero reading.
00200C  3  85 rr        	sta z80_e
00200E  3               
00200E  3  A0 06        	ldy #6	 		; address of last key.
002010  3               joyke0:
002010  3  B9 AA 3C     	lda keys,y 		; get key from table.
002013  3  20 CC 0E     	jsr ktest		; being pressed?
002016  3  26 rr        	rol z80_e 		; rotate into reading.
002018  3               
002018  3  88           	dey		 	; next key.
002019  3  10 F5        	bpl joyke0 		; repeat for all keys.
00201B  3  4C 2F 20     	jmp joyjo1 		; store the value.
00201E  3               
00201E  3               ; Keyboard joystick controls.
00201E  3               
00201E  3               joyjoy:
00201E  3  A9 00        	lda #0		 	; zero reading.
002020  3  85 rr        	sta z80_e
002022  3               
002022  3  A0 06        	ldy #6	 		; address of last key.
002024  3               joyjo3:
002024  3  B9 62 0E     	lda jkeys,y 		; get key from table.
002027  3  20 CC 0E     	jsr ktest		; being pressed?
00202A  3  26 rr        	rol z80_e 		; rotate into reading.
00202C  3               
00202C  3  88           	dey		 	; next key.
00202D  3  10 F5        	bpl joyjo3 		; repeat for all keys.
00202F  3               joyjo1:
00202F  3  A5 rr        	lda z80_e 		; copy e register to accumulator.
002031  3               joyjo2:
002031  3  85 rr        	sta joyval		; remember value.
002033  3  60           	rts
002034  3               
002034  3               ;---------------------------------------------------------------
002034  3               ; Display message.
002034  3               ;
002034  3               ; Input:
002034  3               ;  A = message number
002034  3               ;---------------------------------------------------------------
002034  3               
002034  3               dmsg:
002034  3  AA           	tax
002035  3  A9 7F        	lda #<msgdat		; pointer to messages.
002037  3  85 rr        	sta z80_l
002039  3  A9 2D        	lda #>msgdat
00203B  3  85 rr        	sta z80_h
00203D  3  20 53 21     	jsr getwrd		; get message number.
002040  3               dmsg3:
002040  3  20 40 21     	jsr preprt		; pre-printing stuff.
002043  3  20 A9 1A     	jsr checkx		; make sure we"re in a printable range.
002046  3  A5 rr        	lda prtmod		; print mode.
002048  3  D0 47        	bne bmsg1		; no, double-height text.
00204A  3               dmsg0:
00204A  3  A5 rr        	lda z80_h		; store string pointer.
00204C  3  48           	pha
00204D  3  A5 rr        	lda z80_l
00204F  3  48           	pha
002050  3               
002050  3  A0 00        	ldy #0
002052  3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
002054  3  29 7F        	and #127		; remove any end marker.
002056  3  C9 0D        	cmp #ASCII_NEWLINE
002058  3  F0 24        	beq dmsg1
00205A  3  20 52 11     	jsr pchar		; display character.
00205D  3  20 2B 21     	jsr nexpos 		; display position.
002060  3  D0 03        	bne dmsg2		; not on a new line.
002062  3  20 32 21     	jsr nexlin		; next line down.
002065  3               dmsg2:
002065  3  68           	pla			; retrieve string pointer
002066  3  85 rr        	sta z80_l
002068  3  68           	pla
002069  3  85 rr        	sta z80_h
00206B  3               
00206B  3  A0 00        	ldy #0
00206D  3  B1 rr        	lda (z80_hl),y		; fetch last character.
00206F  3  0A           	asl a  			; was it the end?
002070  3  90 03        	bcc :+
002072  3  4C EE 1A     	jmp dscor2		; yes, job done.
002075  3               :
002075  3  E6 rr        	inc z80_l		; next character to display.
002077  3  D0 02        	bne :+
002079  3  E6 rr        	inc z80_h
00207B  3               :
00207B  3  4C 4A 20     	jmp dmsg0
00207E  3               dmsg1:
00207E  3  E6 rr        	inc dispy
002080  3  A5 rr        	lda dispy
002082  3  C9 18        	cmp #24
002084  3  90 04        	bcc dmsg4
002086  3  A9 00        	lda #0
002088  3  85 rr        	sta dispy
00208A  3               dmsg4:
00208A  3  A9 00        	lda #0
00208C  3  85 rr        	sta dispx
00208E  3  4C 65 20     	jmp dmsg2
002091  3               
002091  3               ;----------------------------------------------------------
002091  3               ; Display message in big text.
002091  3               ;
002091  3               ; Input:
002091  3               ;  HL = string pointer
002091  3               ;----------------------------------------------------------
002091  3               
002091  3               bmsg1:
002091  3  A0 00        	ldy #0
002093  3  B1 rr        	lda (z80_hl),y 		; get character to display.
002095  3  29 7F        	and #127		; only want 7 bits.
002097  3  C9 0D        	cmp #ASCII_NEWLINE
002099  3  F0 13        	beq bmsg2
00209B  3  20 C3 20     	jsr bchar 		; display big char.
00209E  3               bmsg3:
00209E  3  A0 00        	ldy #0
0020A0  3  B1 rr        	lda (z80_hl),y 		; look at last character.
0020A2  3  48           	pha
0020A3  3  E6 rr        	inc z80_l 		; next character in list.
0020A5  3  D0 02        	bne :+
0020A7  3  E6 rr        	inc z80_h
0020A9  3               :
0020A9  3  68           	pla
0020AA  3  0A           	asl a  			; was terminator flag set?
0020AB  3  90 E4        	bcc bmsg1		; no, keep going.
0020AD  3               :
0020AD  3  60           	rts
0020AE  3               bmsg2:
0020AE  3  A9 00        	lda #0
0020B0  3  85 rr        	sta dispx
0020B2  3  E6 rr        	inc dispy
0020B4  3  E6 rr        	inc dispy
0020B6  3  A5 rr        	lda dispy
0020B8  3  C9 17        	cmp #23
0020BA  3  90 E2        	bcc bmsg3
0020BC  3  A9 00        	lda #0
0020BE  3  85 rr        	sta dispy
0020C0  3  4C 9E 20     	jmp bmsg3
0020C3  3               
0020C3  3               ;----------------------------------------------------------
0020C3  3               ; Big character display.
0020C3  3               ;
0020C3  3               ; Input:
0020C3  3               ;  A = character
0020C3  3               ;----------------------------------------------------------
0020C3  3               
0020C3  3               bchar:
0020C3  3  85 rr        	sta z80_e		; save char in lb
0020C5  3  A9 00        	lda #0
0020C7  3  85 rr        	sta z80_d		; reset hb
0020C9  3               
0020C9  3  06 rr        	asl z80_e 		; multiply char by 8.
0020CB  3  26 rr        	rol z80_d
0020CD  3  06 rr        	asl z80_e
0020CF  3  26 rr        	rol z80_d
0020D1  3  06 rr        	asl z80_e
0020D3  3  26 rr        	rol z80_d		; de = a*8
0020D5  3               
0020D5  3  18           	clc			; de = FontPtr + a*8
0020D6  3  A5 rr        	lda z80_e
0020D8  3  65 rr        	adc FontPtr 		; address of font.
0020DA  3  85 rr        	sta z80_e
0020DC  3  A5 rr        	lda z80_d
0020DE  3  65 rr        	adc FontPtr+1
0020E0  3  85 rr        	sta z80_d
0020E2  3               
0020E2  3  20 E7 1B     	jsr gprad 		; get screen address.
0020E5  3               
0020E5  3  A2 00        	ldx #0			; height of character in font.
0020E7  3               bchar0:
0020E7  3  A0 00        	ldy #0
0020E9  3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
0020EB  3               
0020EB  3  49 FF        	eor #TxtInvert		; Invert
0020ED  3               
0020ED  3  91 rr        	sta (scraddr),y
0020EF  3  48           	pha
0020F0  3  20 9F 10     	jsr nline 		; next line down.
0020F3  3  68           	pla
0020F4  3  91 rr        	sta (scraddr),y
0020F6  3  20 9F 10     	jsr nline 		; next line down.
0020F9  3               
0020F9  3  18           	clc
0020FA  3  E6 rr        	inc z80_e 		; next line of font.
0020FC  3  D0 02        	bne :+
0020FE  3  E6 rr        	inc z80_d
002100  3               :
002100  3  E8           	inx
002101  3  E0 08        	cpx #8
002103  3  D0 E2        	bne bchar0
002105  3               
002105  3  20 2B 21     	jsr nexpos		; display position.
002108  3  D0 05        	bne bchar2 		; not on a new line.
00210A  3               bchar3:
00210A  3  E6 rr        	inc dispy
00210C  3  20 32 21     	jsr nexlin 		; next line check.
00210F  3               bchar2:
00210F  3  4C EE 1A     	jmp dscor2		; tidy up line and column variables.
002112  3               
002112  3               
002112  3               ;-------------------------------------------------
002112  3               ; Display a character.
002112  3               ;
002112  3               ; Input:
002112  3               ;  A = character
002112  3               ;-------------------------------------------------
002112  3               
002112  3               achar:
002112  3  85 rr        	sta z80_b 		; copy to b.
002114  3  20 40 21     	jsr preprt 		; get ready to print.
002117  3  A5 rr        	lda z80_b		; character in accumulator.
002119  3  A6 rr        	ldx prtmod 		; print mode.
00211B  3  F0 03        	beq :+
00211D  3  4C C3 20     	jmp bchar 		; no, double-height text.
002120  3               :
002120  3  20 52 11     	jsr pchar 		; display character.
002123  3  20 2B 21     	jsr nexpos 		; display position.
002126  3  F0 E2        	beq bchar3		; next line down.
002128  3  4C 0F 21     	jmp bchar2 		; tidy up.
00212B  3               
00212B  3               
00212B  3               ;-------------------------------------------------
00212B  3               ; Get next print column position.
00212B  3               ;-------------------------------------------------
00212B  3               
00212B  3               nexpos:
00212B  3  E6 rr        	inc dispx		; move along one position.
00212D  3  A5 rr        	lda dispx 		; get coordinate.
00212F  3  29 1F        	and #31
002131  3  60           	rts 			; return with status in zero flag.
002132  3               
002132  3               ;-------------------------------------------------
002132  3               ; Get next print line position.
002132  3               ;-------------------------------------------------
002132  3               
002132  3               nexlin:
002132  3  E6 rr        	inc dispy 		; newline.
002134  3  A5 rr        	lda dispy		; vertical position.
002136  3  C9 18        	cmp #24			; past screen edge?
002138  3  B0 01        	bcs :+
00213A  3  60           	rts			; no, still okay.
00213B  3               :
00213B  3  A9 00        	lda #0			; restart at top.
00213D  3  85 rr        	sta dispy
00213F  3  60           	rts
002140  3               
002140  3               ;--------------------------------------------------------
002140  3               ; Pre-print preliminaries.
002140  3               ;--------------------------------------------------------
002140  3               
002140  3               preprt:
002140  3  A5 rr        	lda FontPtr		; font pointer.
002142  3  8D A7 1A     	sta grbase		; set up graphics base.
002145  3  A5 rr        	lda FontPtr+1
002147  3  8D A8 1A     	sta grbase+1
00214A  3               prescr:
00214A  3  A5 rr        	lda charx 		; display coordinates.
00214C  3  85 rr        	sta dispx		; set up general coordinates.
00214E  3  A5 rr        	lda chary
002150  3  85 rr        	sta dispy
002152  3  60           	rts
002153  3               
002153  3               ;--------------------------------------------------------------
002153  3               ; Get messagenr x in hl
002153  3               ;
002153  3               ; Input:
002153  3               ;  HL = pointer to message list
002153  3               ;  X  = message number.
002153  3               ;--------------------------------------------------------------
002153  3               
002153  3               getwrd:
002153  3  E0 00        	cpx #0
002155  3  D0 01        	bne:+ 			; first word in list?
002157  3  60           	rts 			; yep, don't search.
002158  3               :
002158  3  A0 00        	ldy #0
00215A  3               getwd0:
00215A  3  B1 rr        	lda (z80_hl),y
00215C  3  48           	pha
00215D  3  E6 rr        	inc z80_l
00215F  3  D0 02        	bne :+
002161  3  E6 rr        	inc z80_h
002163  3               :
002163  3  68           	pla
002164  3  C9 80        	cmp #128		; found end?
002166  3  30 F2        	bmi getwd0		; no, carry on.
002168  3  CA           	dex			; until we have right number.
002169  3  D0 EF        	bne getwd0
00216B  3  60           	rts
00216C  3               
00216C  3               ;-----------------------------------------------------------
00216C  3               ; Bubble sort.
00216C  3               ;-----------------------------------------------------------
00216C  3               
00216C  3               bsort:
00216C  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
00216E  3  85 rr        	sta qscnt
002170  3               
002170  3  A9 00        	lda #<sprtab 		; sprite table.
002172  3  85 rr        	sta z80_x
002174  3  A9 0B        	lda #>sprtab
002176  3  85 rr        	sta z80_i
002178  3               bsort0:
002178  3  A0 00        	ldy #0
00217A  3  B1 rr        	lda (z80_ix),y 		; first sprite type.
00217C  3  C9 FF        	cmp #255 		; is it switched off?
00217E  3  F0 30        	beq swemp		; yes, may need to switch another in here.
002180  3               
002180  3  A0 11        	ldy #TABSIZ
002182  3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
002184  3  C9 FF        	cmp #255 		; is it enabled?
002186  3  F0 0A        	beq bsort2 		; no, nothing to swap.
002188  3               
002188  3  A0 14        	ldy #TABSIZ+3
00218A  3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
00218C  3  A0 03        	ldy #3
00218E  3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
002190  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
002192  3               bsort2:
002192  3  18           	clc
002193  3  A5 rr        	lda z80_x
002195  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002197  3  85 rr        	sta z80_x
002199  3  90 02        	bcc :+
00219B  3  E6 rr        	inc z80_i
00219D  3               :
00219D  3  C6 rr        	dec qscnt
00219F  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
0021A1  3  60           	rts
0021A2  3               
0021A2  3               bsort1:
0021A2  3  A0 11        	ldy #TABSIZ
0021A4  3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
0021A6  3  C9 FF        	cmp #255		; is it enabled?
0021A8  3  F0 E8        	beq bsort2		; no, nothing to swap.
0021AA  3  20 BE 21     	jsr swspr		; swap positions.
0021AD  3  4C 92 21     	jmp bsort2
0021B0  3               swemp:
0021B0  3  A0 11        	ldy #TABSIZ
0021B2  3  B1 rr        	lda (z80_ix),y		; next table entry.
0021B4  3  C9 FF        	cmp #255		; is that one on?
0021B6  3  F0 DA        	beq bsort2		; no, nothing to swap.
0021B8  3  20 BE 21     	jsr swspr		; swap positions.
0021BB  3  4C 92 21     	jmp bsort2
0021BE  3               
0021BE  3               ; Swap sprites.
0021BE  3               
0021BE  3               swspr:
0021BE  3  A5 rr        	lda z80_x		; table address
0021C0  3  85 rr        	sta z80_e		; copy to de pair.
0021C2  3  85 rr        	sta z80_l		; copy to hl pair.
0021C4  3  A5 rr        	lda z80_i
0021C6  3  85 rr        	sta z80_h
0021C8  3  85 rr        	sta z80_d
0021CA  3               
0021CA  3  18           	clc
0021CB  3  A5 rr        	lda z80_l
0021CD  3  69 11        	adc #TABSIZ		; distance to second entry.
0021CF  3  85 rr        	sta z80_l
0021D1  3  90 02        	bcc :+
0021D3  3  E6 rr        	inc z80_h
0021D5  3               :
0021D5  3  A9 11        	lda #TABSIZ		; bytes to swap.
0021D7  3  85 rr        	sta z80_b
0021D9  3  A0 00        	ldy #0
0021DB  3               swspr0:
0021DB  3  B1 rr        	lda (z80_hl),y		; fetch second byte.
0021DD  3  48           	pha
0021DE  3  B1 rr        	lda (z80_de),y 		; fetch first byte.
0021E0  3  91 rr        	sta (z80_hl),y 		; copy to second.
0021E2  3  68           	pla
0021E3  3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
0021E5  3               
0021E5  3  E6 rr        	inc z80_e 		; next byte.
0021E7  3  D0 02        	bne :+
0021E9  3  E6 rr        	inc z80_d
0021EB  3               :
0021EB  3  E6 rr        	inc z80_l 		; next byte.
0021ED  3  D0 02        	bne :+
0021EF  3  E6 rr        	inc z80_h
0021F1  3               :
0021F1  3  C6 rr        	dec z80_b
0021F3  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
0021F5  3  60           	rts
0021F6  3               
0021F6  3               ;----------------------------------------------------
0021F6  3               ; Process sprites.
0021F6  3               ;----------------------------------------------------
0021F6  3               
0021F6  3               pspr:
0021F6  3  A9 0C        	lda #NUMSPR		; sprites to process.
0021F8  3  85 rr        	sta sprptr
0021FA  3               
0021FA  3  A9 00        	lda #<sprtab 		; sprite table.
0021FC  3  85 rr        	sta z80_x
0021FE  3  A9 0B        	lda #>sprtab
002200  3  85 rr        	sta z80_i
002202  3               pspr1:
002202  3  A0 00        	ldy #0
002204  3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
002206  3  C9 09        	cmp #9 			; within range of sprite types?
002208  3  B0 03        	bcs :+
00220A  3  20 1D 22     	jsr pspr2 		; yes, process this one.
00220D  3               :
00220D  3  18           	clc
00220E  3  A5 rr        	lda z80_x
002210  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
002212  3  85 rr        	sta z80_x
002214  3  90 02        	bcc :+
002216  3  E6 rr        	inc z80_i		; next sprite.
002218  3               :
002218  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
00221A  3  D0 E6        	bne pspr1
00221C  3  60           	rts
00221D  3               
00221D  3               pspr2:
00221D  3  A5 rr        	lda z80_x 		; store original sprite pointer.
00221F  3  85 rr        	sta ogptr
002221  3  A5 rr        	lda z80_i
002223  3  85 rr        	sta ogptr+1
002225  3  20 31 22     	jsr pspr3		; do the routine.
002228  3               rtorg:
002228  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
00222A  3  85 rr        	sta z80_x
00222C  3  A5 rr        	lda ogptr+1
00222E  3  85 rr        	sta z80_i
002230  3               rtorg0:
002230  3  60           	rts
002231  3               
002231  3               pspr3:
002231  3  A9 66        	lda #<evtyp0		; sprite type events list.
002233  3  85 rr        	sta z80_l
002235  3  A9 22        	lda #>evtyp0
002237  3  85 rr        	sta z80_h
002239  3               pspr4:
002239  3  B1 rr        	lda (z80_ix),y
00223B  3  0A           	asl a			; double accumulator.
00223C  3  18           	clc
00223D  3  65 rr        	adc z80_l
00223F  3  85 rr        	sta z80_l
002241  3  90 02        	bcc :+
002243  3  E6 rr        	inc z80_h
002245  3               :
002245  3  B1 rr        	lda (z80_hl),y
002247  3  85 rr        	sta z80_e 		; copy to de.
002249  3  48           	pha
00224A  3               
00224A  3  E6 rr        	inc z80_l 		; next byte of address.
00224C  3  D0 02        	bne :+
00224E  3  E6 rr        	inc z80_h
002250  3               :
002250  3  B1 rr        	lda (z80_hl),y 		; address high.
002252  3  85 rr        	sta z80_d
002254  3               
002254  3  48           	pha	 		; swap address into hl.
002255  3  A5 rr        	lda z80_h
002257  3  85 rr        	sta z80_d
002259  3  68           	pla
00225A  3  85 rr        	sta z80_h
00225C  3  68           	pla
00225D  3  85 rr        	sta z80_l
00225F  3  A5 rr        	lda z80_l
002261  3  85 rr        	sta z80_e
002263  3               
002263  3  6C rr rr     	jmp (z80_hl) 		; go there.
002266  3               
002266  3               ; Address of each sprite type's routine.
002266  3               
002266  3  03 28        evtyp0:	.word evnt00
002268  3  BB 28        evtyp1:	.word evnt01
00226A  3  4B 29        evtyp2:	.word evnt02
00226C  3  33 2A        evtyp3:	.word evnt03
00226E  3  1C 2B        evtyp4:	.word evnt04
002270  3  AC 2B        evtyp5:	.word evnt05
002272  3  46 2C        evtyp6:	.word evnt06
002274  3  91 2C        evtyp7:	.word evnt07
002276  3  92 2C        evtyp8:	.word evnt08
002278  3               
002278  3               ;--------------------------------------------------------------
002278  3               ; Display sprites.
002278  3               ;
002278  3               ; Input:
002278  3               ;  IX = sprite table
002278  3               ;--------------------------------------------------------------
002278  3               
002278  3               dspr:
002278  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
00227A  3  85 rr        	sta sprcnt
00227C  3               
00227C  3               dspr0:
00227C  3  A0 00        	ldy #var_Type
00227E  3  B1 rr        	lda (z80_ix),y 		; get sprite type.
002280  3  C9 FF        	cmp #255 			; is it enabled?
002282  3  D0 45        	bne dspr1 			; yes, it needs deleting.
002284  3               
002284  3               dspr5:
002284  3  A0 05        	ldy #var_newType
002286  3  B1 rr        	lda (z80_ix),y 		; new type.
002288  3  C9 FF        	cmp #255			; is it enabled?
00228A  3  F0 03        	beq dspr2			; no, skip
00228C  3  4C 18 23     	jmp dspr3 			; yes, it needs drawing.
00228F  3               
00228F  3               dspr2:
00228F  3  A0 05        	ldy #var_newType
002291  3  B1 rr        	lda (z80_ix),y 		; copy new type.
002293  3  A0 00        	ldy #var_Type
002295  3  91 rr        	sta (z80_ix),y
002297  3  A0 06        	ldy #var_newImage
002299  3  B1 rr        	lda (z80_ix),y 		; copy new image number.
00229B  3  A0 01        	ldy #var_Image
00229D  3  91 rr        	sta (z80_ix),y
00229F  3  A0 07        	ldy #var_newFrame
0022A1  3  B1 rr        	lda (z80_ix),y 		; copy new frame.
0022A3  3  A0 02        	ldy #var_Frame
0022A5  3  91 rr        	sta (z80_ix),y
0022A7  3  A0 08        	ldy #var_newY
0022A9  3  B1 rr        	lda (z80_ix),y 		; copy new y.
0022AB  3  A0 03        	ldy #var_Y
0022AD  3  91 rr        	sta (z80_ix),y
0022AF  3  A0 09        	ldy #var_newX
0022B1  3  B1 rr        	lda (z80_ix),y 		; copy new x.
0022B3  3  A0 04        	ldy #var_X
0022B5  3  91 rr        	sta (z80_ix),y
0022B7  3               
0022B7  3  18           	clc
0022B8  3  A5 rr        	lda z80_x
0022BA  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
0022BC  3  85 rr        	sta z80_x
0022BE  3  A5 rr        	lda z80_i
0022C0  3  69 00        	adc #0
0022C2  3  85 rr        	sta z80_i 			; next sprite.
0022C4  3  C6 rr        	dec sprcnt
0022C6  3  D0 B4        	bne dspr0			; repeat for remaining sprites.
0022C8  3  60           	rts
0022C9  3               
0022C9  3               dspr1:
0022C9  3               	; _BEEB clipping code copied from CPC Engine
0022C9  3  A0 03        	ldy #var_Y
0022CB  3  B1 rr        	lda (z80_ix), y		; old x coord
0022CD  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
0022CF  3  B0 B3        	bcs dspr5			; yes, don't delete it.
0022D1  3               
0022D1  3  A0 05        	ldy #var_newType
0022D3  3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
0022D5  3  C9 FF        	cmp #255			; is this enabled?
0022D7  3  D0 06        	bne dspr4 			; yes, display both.
0022D9  3               
0022D9  3               dspr6:
0022D9  3  20 D1 0F     	jsr sspria 			; show single sprite.
0022DC  3  4C 8F 22     	jmp dspr2
0022DF  3               
0022DF  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
0022DF  3               
0022DF  3               dspr4:
0022DF  3               	; _BEEB clipping code copied from CPC Engine
0022DF  3  A0 08        	ldy #var_newY
0022E1  3  B1 rr        	lda (z80_ix), y		; old x coord
0022E3  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
0022E5  3  B0 F2        	bcs dspr6			; yes, don't display it.
0022E7  3               
0022E7  3  A0 04        	ldy #var_X
0022E9  3  B1 rr        	lda (z80_ix),y		; old x.
0022EB  3  A0 09        	ldy #var_newX
0022ED  3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
0022EF  3  D0 21        	bne dspr7 			; they differ, need to redraw.
0022F1  3               
0022F1  3  A0 03        	ldy #var_Y
0022F3  3  B1 rr        	lda (z80_ix),y		; old y.
0022F5  3  A0 08        	ldy #var_newY
0022F7  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
0022F9  3  D0 17        	bne dspr7			; they differ, need to redraw.
0022FB  3               
0022FB  3  A0 02        	ldy #var_Frame
0022FD  3  B1 rr        	lda (z80_ix),y 		; old frame.
0022FF  3  A0 07        	ldy #var_newFrame
002301  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
002303  3  D0 0D        	bne dspr7 			; they differ, need to redraw.
002305  3               
002305  3  A0 01        	ldy #var_Image
002307  3  B1 rr        	lda (z80_ix),y 		; old image.
002309  3  A0 06        	ldy #var_newImage
00230B  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
00230D  3  D0 03        	bne dspr7 			; they differ, need to redraw.
00230F  3  4C 8F 22     	jmp dspr2			; everything is the same, don't redraw.
002312  3               
002312  3               dspr7:
002312  3  20 08 10     	jsr sspric 			; delete old sprite, draw new one simultaneously.
002315  3  4C 8F 22     	jmp dspr2
002318  3               
002318  3               dspr3:
002318  3               	; _BEEB clipping code copied from CPC Engine
002318  3  A0 08        	ldy #var_newY
00231A  3  B1 rr        	lda (z80_ix), y		; old x coord
00231C  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
00231E  3  90 03        	bcc :+				; no, continue
002320  3  4C 8F 22     	jmp dspr2			; yes, don't display it.
002323  3               :
002323  3  20 02 10     	jsr ssprib 			; show single sprite.
002326  3  4C 8F 22     	jmp dspr2
002329  3               
002329  3               ;-----------------------------------------
002329  3               ; Get sprite address calculations.
002329  3               ; gspran = new sprite, gsprad = old sprite.
002329  3               ;
002329  3               ; Input:
002329  3               ;  IX = sprite address
002329  3               ;-----------------------------------------
002329  3               
002329  3               gspran:
002329  3  A0 08        	ldy #var_newY
00232B  3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
00232D  3  85 rr        	sta dispy
00232F  3  A0 09        	ldy #var_newX
002331  3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
002333  3  85 rr        	sta dispx
002335  3  A0 06        	ldy #var_newImage
002337  3  B1 rr        	lda (z80_ix),y 		; new sprite image.
002339  3  20 0B 26     	jsr gfrm		; fetch start frame for this sprite.
00233C  3               
00233C  3  A0 00        	ldy #0
00233E  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
002340  3  A0 07        	ldy #var_newFrame
002342  3  18           	clc
002343  3  71 rr        	adc (z80_ix),y 		; new add frame number.
002345  3  4C 64 23     	jmp gspra0
002348  3               
002348  3               ;-----------------------------------------
002348  3               ; Calculate old sprite address
002348  3               ;
002348  3               ; Input:
002348  3               ;  IX = sprite address
002348  3               ;
002348  3               ; Output:
002348  3               ;  B  = right byte mask
002348  3               ;  C  = left byte mask
002348  3               ;  DE = spriteframe address
002348  3               ;  scraddr = screenaddress(dispx,dispy)
002348  3               ;-----------------------------------------
002348  3               
002348  3               gsprad:
002348  3  A0 03        	ldy #var_Y
00234A  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00234C  3  85 rr        	sta dispy
00234E  3  A0 04        	ldy #var_X
002350  3  B1 rr        	lda (z80_ix),y		; x coordinate.
002352  3  85 rr        	sta dispx
002354  3  A0 01        	ldy #var_Image
002356  3  B1 rr        	lda (z80_ix),y 		; sprite image.
002358  3  20 0B 26     	jsr gfrm 		; fetch start frame for this sprite.
00235B  3               
00235B  3  A0 00        	ldy #0
00235D  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
00235F  3  A0 02        	ldy #var_Frame
002361  3  18           	clc
002362  3  71 rr        	adc (z80_ix),y 		; add frame number.
002364  3               
002364  3               gspra0:
002364  3               .if 0
002364  3               	lsr a	  		; multiply by 128.
002364  3               	sta z80_d 		; store in d.
002364  3               	lda #0
002364  3               	ror a
002364  3               	sta z80_e 		; got low byte.
002364  3               .else
002364  3  85 rr        	sta z80_e
002366  3  A9 00        	lda #0
002368  3  85 rr        	sta z80_d
00236A  3               
00236A  3  06 rr        	asl z80_e
00236C  3  26 rr        	rol z80_d
00236E  3  06 rr        	asl z80_e
002370  3  26 rr        	rol z80_d
002372  3  06 rr        	asl z80_e
002374  3  26 rr        	rol z80_d
002376  3  06 rr        	asl z80_e
002378  3  26 rr        	rol z80_d
00237A  3  06 rr        	asl z80_e
00237C  3  26 rr        	rol z80_d
00237E  3               
00237E  3               .endif
00237E  3               
00237E  3  18           	clc 			; address of play sprites.
00237F  3  A5 rr        	lda z80_e
002381  3  69 71        	adc #<sprgfx
002383  3  85 rr        	sta z80_e
002385  3  A5 rr        	lda z80_d
002387  3  69 2E        	adc #>sprgfx
002389  3  85 rr        	sta z80_d
00238B  3               
00238B  3  A5 rr        	lda dispx 		; y coordinate.
00238D  3  29 06        	and #6 			; position within byte boundary.
00238F  3  AA           	tax	 		; low byte of table displacement.
002390  3  86 rr        	stx sprshft
002392  3               
002392  3               .if 0
002392  3               	asl a	  		; multiply by 32.
002392  3               	asl a  			; already a multiple
002392  3               	asl a  			; of 2, so just 4
002392  3               	asl a  			; shifts needed.
002392  3               
002392  3               	clc 			; add to sprite address.
002392  3               	adc z80_e
002392  3               	sta z80_e
002392  3               	bcc :+
002392  3               	inc z80_d
002392  3               :
002392  3               .endif
002392  3               
002392  3  BD 9F 23     	lda spmask,x		 ; pointer to mask table.
002395  3  85 rr        	sta z80_c 		; left mask.
002397  3  BD A0 23     	lda spmask+1,x
00239A  3  85 rr        	sta z80_b 		; right mask.
00239C  3               ; Drop into screen address routine.
00239C  3  4C BD 0F     	jmp scadd
00239F  3               
00239F  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
0023A3  3  0F F0 03 FC  
0023A7  3               
0023A7  3               
0023A7  3               ;-----------------------------------------------------------
0023A7  3               ; Animates a sprite.
0023A7  3               ;
0023A7  3               ; Input:
0023A7  3               ;  IX = sprite address
0023A7  3               ;  HL = last sprite address
0023A7  3               ;-----------------------------------------------------------
0023A7  3               
0023A7  3               animsp:
0023A7  3  25 rr        	and frmno
0023A9  3  F0 01        	beq :+
0023AB  3  60           	rts
0023AC  3               :
0023AC  3  A0 06        	ldy #var_newImage
0023AE  3  B1 rr        	lda (z80_ix),y		; sprite image
0023B0  3  20 0B 26     	jsr gfrm		; get frame data.
0023B3  3               
0023B3  3  E6 rr        	inc z80_l		; point to frames.
0023B5  3  D0 02        	bne :+
0023B7  3  E6 rr        	inc z80_h
0023B9  3               :
0023B9  3  A0 07        	ldy #var_newFrame
0023BB  3  B1 rr        	lda (z80_ix),y		; sprite frame.
0023BD  3  18           	clc
0023BE  3  69 01        	adc #1			; next one along.
0023C0  3  A0 00        	ldy #0
0023C2  3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
0023C4  3  90 02        	bcc anims0		; no, not yet.
0023C6  3  A9 00        	lda #0			; start at first frame.
0023C8  3               anims0:
0023C8  3  A0 07        	ldy #var_newFrame
0023CA  3  91 rr        	sta (z80_ix),y		; new frame.
0023CC  3  60           	rts
0023CD  3               
0023CD  3               ;--------------------------------------------------------------
0023CD  3               ; Animate back
0023CD  3               ;
0023CD  3               ; Input:
0023CD  3               ;  IX = sprite address
0023CD  3               ;  HL = last sprite address
0023CD  3               ;--------------------------------------------------------------
0023CD  3               
0023CD  3               animbk:
0023CD  3  25 rr        	and frmno
0023CF  3  F0 01        	beq :+
0023D1  3  60           	rts
0023D2  3               :
0023D2  3  A0 06        	ldy #var_newImage
0023D4  3  B1 rr        	lda (z80_ix),y		; sprite image.
0023D6  3  20 0B 26     	jsr gfrm		; get frame data.
0023D9  3               
0023D9  3  E6 rr        	inc z80_l 		; point to frames.
0023DB  3  D0 02        	bne :+
0023DD  3  E6 rr        	inc z80_h
0023DF  3               :
0023DF  3  A0 07        	ldy #var_newFrame
0023E1  3  B1 rr        	lda (z80_ix),y 		; sprite frame.
0023E3  3  F0 03        	beq :+
0023E5  3  4C EC 23     	jmp rtanb0 		; yes, start at end.
0023E8  3               :
0023E8  3  A0 00        	ldy #0
0023EA  3  B1 rr        	lda (z80_hl),y 		; last sprite.
0023EC  3               rtanb0:
0023EC  3  38           	sec
0023ED  3  E9 01        	sbc #1			; next one along.
0023EF  3  4C C8 23     	jmp anims0		; set new frame.
0023F2  3               
0023F2  3               ;--------------------------------------------------------------
0023F2  3               ; Check for collision with other sprite, strict enforcement.
0023F2  3               ;
0023F2  3               ; Input:
0023F2  3               ;  b		= sprite to test for
0023F2  3               ;  ix		= current sprite pointer
0023F2  3               ;
0023F2  3               ; global:	b
0023F2  3               ; local:	x,y,hl,de,skptr
0023F2  3               ; calls:	-
0023F2  3               ;--------------------------------------------------------------
0023F2  3               
0023F2  3               sktyp:
0023F2  3  A9 00        	lda #<sprtab				; sprite table.
0023F4  3  85 rr        	sta z80_l
0023F6  3  A9 0B        	lda #>sprtab
0023F8  3  85 rr        	sta z80_h
0023FA  3               numsp2:
0023FA  3  A9 0C        	lda #NUMSPR				; number of sprites.
0023FC  3  85 rr        	sta sktptr
0023FE  3               sktyp0:
0023FE  3  A5 rr        	lda z80_l 				; store pointer to sprite.
002400  3  85 rr        	sta skptr
002402  3  A5 rr        	lda z80_h
002404  3  85 rr        	sta skptr+1
002406  3               
002406  3  A0 00        	ldy #0
002408  3  B1 rr        	lda (z80_hl),y 				; get sprite type.
00240A  3  C5 rr        	cmp z80_b				; is it the type we seek?
00240C  3  F0 1D        	beq coltyp				; yes, we can use this one.
00240E  3               :
00240E  3               sktyp1:
00240E  3  18           	clc
00240F  3  A5 rr        	lda skptr				; retrieve sprite pointer.
002411  3  69 11        	adc #TABSIZ				; size of each entry.
002413  3  85 rr        	sta z80_l
002415  3  A5 rr        	lda skptr+1
002417  3  69 00        	adc #0
002419  3  85 rr        	sta z80_h
00241B  3  C6 rr        	dec sktptr					; one less iteration.
00241D  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
00241F  3               :
00241F  3  A9 00        	lda #0					; default to ROM address - no sprite.
002421  3  85 rr        	sta z80_l
002423  3  85 rr        	sta z80_h
002425  3  85 rr        	sta skptr				; store pointer to sprite.
002427  3  85 rr        	sta skptr+1
002429  3               
002429  3  18           	clc					; don't return with zero flag set.
00242A  3  60           	rts 					; didn't find one.
00242B  3               
00242B  3               coltyp:
00242B  3  A0 00        	ldy #0
00242D  3  B1 rr        	lda (z80_ix),y				; current sprite type.
00242F  3  C5 rr        	cmp z80_b				; seeking sprite of same type?
002431  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
002433  3               colty0:
002433  3  A0 09        	ldy #9					; distance to x position in table.
002435  3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
002437  3  85 rr        	sta z80_e
002439  3  88           	dey
00243A  3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
00243C  3  85 rr        	sta z80_d
00243E  3               
00243E  3               ; Drop into collision detection.
00243E  3               
00243E  3               colc16:
00243E  3  A0 09        	ldy #9
002440  3  B1 rr        	lda (z80_ix),y			 	; x coord.
002442  3  38           	sec					; subtract x.
002443  3  E5 rr        	sbc z80_e
002445  3  B0 05        	bcs  colc1a 				; result is positive.
002447  3  49 FF        	eor #$ff				; make negative positive.
002449  3  18           	clc
00244A  3  69 01        	adc #1
00244C  3               colc1a:
00244C  3  C9 10        	cmp #16 				; within x range?
00244E  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
002450  3  85 rr        	sta z80_c				; store difference.
002452  3               
002452  3  A0 08        	ldy #8
002454  3  B1 rr        	lda (z80_ix),y				; y coord.
002456  3  38           	sec
002457  3  E5 rr        	sbc z80_d				; subtract y.
002459  3  B0 05        	bcs colc1b				; result is positive.
00245B  3  49 FF        	eor #$ff				; make negative positive.
00245D  3  18           	clc
00245E  3  69 01        	adc #1
002460  3               colc1b:
002460  3  C9 10        	cmp #16					; within y range?
002462  3  B0 AA        	bcs sktyp1 				; no - they've missed.
002464  3  18           	clc					; add x difference.
002465  3  65 rr        	adc z80_c
002467  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
002469  3  B0 02        	bcs :+
00246B  3  38           	sec
00246C  3  60           	rts 					; carry set if there's a collision.
00246D  3               :
00246D  3  4C 0E 24     	jmp sktyp1				; try next sprite in table.
002470  3               colty1:
002470  3  A5 rr        	lda z80_x  				; compare the two.
002472  3  C5 rr        	cmp z80_l
002474  3  D0 09        	bne end_col
002476  3  A5 rr        	lda z80_i
002478  3  C5 rr        	cmp z80_h
00247A  3  D0 03        	bne end_col
00247C  3  4C 0E 24     	jmp sktyp1 				; addresses are identical.
00247F  3               end_col:
00247F  3  4C 33 24     	jmp colty0
002482  3               
002482  3               ;-----------------------------------------------------------
002482  3               ; Display number, left aligned
002482  3               ;
002482  3               ; Input:
002482  3               ;  a		= number
002482  3               ;
002482  3               ; global:	-
002482  3               ; local:	a,y,bc,hl,displ0
002482  3               ; calls:	num2ch,dmsg3
002482  3               ;-----------------------------------------------------------
002482  3               
002482  3               disply:
002482  3  85 rr        	sta z80_a
002484  3  A9 AA        	lda #<displ0				; display workspace.
002486  3  85 rr        	sta z80_c
002488  3  A9 24        	lda #>displ0
00248A  3  85 rr        	sta z80_b
00248C  3  A5 rr        	lda z80_a
00248E  3  20 26 18     	jsr num2ch				; convert accumulator to string.
002491  3               displ1:
002491  3  C6 rr        	dec z80_c				; back one character.
002493  3  D0 02        	bne :+
002495  3  C6 rr        	dec z80_b
002497  3               :
002497  3  A0 00        	ldy #0
002499  3  B1 rr        	lda (z80_bc),y				; fetch digit.
00249B  3  09 80        	ora #128				; insert end marker.
00249D  3  91 rr        	sta (z80_bc),y				; new value.
00249F  3               
00249F  3  A9 AA        	lda #<displ0				; display space.
0024A1  3  85 rr        	sta z80_l
0024A3  3  A9 24        	lda #>displ0
0024A5  3  85 rr        	sta z80_h
0024A7  3  4C 40 20     	jmp dmsg3				; display the string.
0024AA  3               
0024AA  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
0024AE  3               
0024AE  3               ;----------------------------------------------------------------
0024AE  3               ; Initialise screen.
0024AE  3               ;
0024AE  3               ; global:	roomtb,scno
0024AE  3               ; local:	-
0024AE  3               ; calls:	tstcs
0024AE  3               ;----------------------------------------------------------------
0024AE  3               
0024AE  3               initsc:
0024AE  3  AD F7 27     	lda roomtb 			; whereabouts in the map are we?
0024B1  3  20 BB 24     	jsr tstsc 			; find displacement.
0024B4  3  C9 FF        	cmp #255 			; is it valid?
0024B6  3  F0 02        	beq init_end 			; no, it's rubbish.
0024B8  3  85 rr        	sta scno			; store new room number.
0024BA  3               init_end:
0024BA  3  60           	rts
0024BB  3               
0024BB  3               ;----------------------------------------------------------------
0024BB  3               ; Test screen.
0024BB  3               ;
0024BB  3               ; global:	-
0024BB  3               ; local:	x
0024BB  3               ; calls:	-
0024BB  3               ;----------------------------------------------------------------
0024BB  3               
0024BB  3               tstsc:
0024BB  3  85 rr        	sta tmproom
0024BD  3  18           	clc
0024BE  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
0024C0  3  AA           	tax 				; add displacement to map data.
0024C1  3  BD F9 27     	lda mapdat-MAPWID,x 		; find room number there.
0024C4  3  60           	rts
0024C5  3               
0024C5  3               ;--------------------------
0024C5  3               ; Screen left.
0024C5  3               ;--------------------------
0024C5  3               
0024C5  3               scrl:
0024C5  3  AD F7 27     	lda roomtb 			; present room table pointer.
0024C8  3  38           	sec
0024C9  3  E9 01        	sbc #1				; room left.
0024CB  3               scrl0:
0024CB  3  20 BB 24     	jsr tstsc			; test screen.
0024CE  3  C9 FF        	cmp #255			; is there a screen this way?
0024D0  3  D0 01        	bne :+
0024D2  3  60           	rts				; no, return to loop.
0024D3  3               :
0024D3  3  A5 rr        	lda tmproom			; restore room displacement.
0024D5  3  8D F7 27     	sta roomtb			; new room table position.
0024D8  3               scrl1:
0024D8  3  20 AE 24     	jsr initsc 			; set new screen.
0024DB  3  A9 02        	lda #2
0024DD  3  85 rr        	sta restfl 			; set it.
0024DF  3  60           	rts
0024E0  3               scrr:
0024E0  3  AD F7 27     	lda roomtb 			; room table pointer.
0024E3  3  18           	clc
0024E4  3  69 01        	adc #1				; room right.
0024E6  3  4C CB 24     	jmp scrl0
0024E9  3               scru:
0024E9  3  AD F7 27     	lda roomtb 			; room table pointer.
0024EC  3  38           	sec
0024ED  3  E9 03        	sbc #MAPWID 			; room up.
0024EF  3  4C CB 24     	jmp scrl0
0024F2  3               scrd:
0024F2  3  AD F7 27     	lda roomtb 			; room table pointer.
0024F5  3  18           	clc
0024F6  3  69 03        	adc #MAPWID 			; room down.
0024F8  3  4C CB 24     	jmp scrl0
0024FB  3               
0024FB  3               ;-----------------------------------------
0024FB  3               ; Jump to new screen.
0024FB  3               ;-----------------------------------------
0024FB  3               
0024FB  3               nwscr:
0024FB  3  A2 00        	ldx #0				; start of map data.
0024FD  3               nwscr0:
0024FD  3  DD FC 27     	cmp mapdat,x
002500  3  F0 06        	beq nwscr1			; have we found a match for screen?
002502  3  E8           	inx 				; next room.
002503  3  E0 50        	cpx #80				; zero room count, 80 to search.
002505  3  D0 F6        	bne nwscr0			; keep looking.
002507  3  60           	rts
002508  3               nwscr1:
002508  3  8E F7 27     	stx roomtb			; set the map position.
00250B  3  4C D8 24     	jmp scrl1			; draw new room.
00250E  3               
00250E  3               
00250E  3               ;----------------------------------------------------------
00250E  3               ; Gravity processing.
00250E  3               ;----------------------------------------------------------
00250E  3               
00250E  3               grav:
00250E  3  A0 0D        	ldy #var_jumpLo
002510  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002512  3  85 rr        	sta z80_l
002514  3  A0 0E        	ldy #var_jumpHi
002516  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
002518  3  85 rr        	sta z80_h
00251A  3  05 rr        	ora z80_l			; merge in low byte.
00251C  3  D0 01        	bne :+
00251E  3  60           	rts				; if neither is set, we're not in the air.
00251F  3               :
00251F  3  A0 00        	ldy #0
002521  3  B1 rr        	lda (z80_hl),y			; pixels to move.
002523  3  85 rr        	sta z80_a
002525  3  C9 63        	cmp #99				; reached the end?
002527  3  D0 0C        	bne grav0			; no, continue.
002529  3               grav2:
002529  3  C6 rr        	dec z80_l			; go back to previous value.
00252B  3  C9 FF        	cmp #$ff
00252D  3  D0 02        	bne :+
00252F  3  C6 rr        	dec z80_h
002531  3               :
002531  3  B1 rr        	lda (z80_hl),y			; fetch that from table.
002533  3  85 rr        	sta z80_a
002535  3               grav0:
002535  3  E6 rr        	inc z80_l			; point to next table entry.
002537  3  D0 02        	bne :+
002539  3  E6 rr        	inc z80_h
00253B  3               :
00253B  3  A5 rr        	lda z80_l
00253D  3  A0 0D        	ldy #var_jumpLo
00253F  3  91 rr        	sta (z80_ix),y			; store new pointer low.
002541  3  A5 rr        	lda z80_h
002543  3  A0 0E        	ldy #var_jumpHi
002545  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002547  3               grav1:
002547  3  A5 rr        	lda z80_a
002549  3  D0 01        	bne :+				; any movement required?
00254B  3  60           	rts				; no, not this time.
00254C  3               :
00254C  3  A5 rr        	lda z80_a
00254E  3  C9 80        	cmp #128			; is it up or down?
002550  3  B0 15        	bcs gravu			; it's up.
002552  3               gravd:
002552  3  85 rr        	sta z80_b			; set pixels to move.
002554  3               gravd0:
002554  3  20 B4 1D     	jsr cangd			; can we go down?
002557  3  D0 28        	bne gravst			; can't move down, so stop.
002559  3  A0 08        	ldy #var_newY
00255B  3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
00255D  3  18           	clc
00255E  3  69 01        	adc #1
002560  3  91 rr        	sta (z80_ix),y
002562  3  C6 rr        	dec z80_b
002564  3  D0 EE        	bne gravd0
002566  3  60           	rts
002567  3               gravu:
002567  3  49 FF        	eor #$ff			; flip the sign so it's positive.
002569  3  18           	clc
00256A  3  69 01        	adc #1
00256C  3  85 rr        	sta z80_b			; set pixels to move.
00256E  3               gravu0:
00256E  3  20 7F 1D     	jsr cangu			; can we go up?
002571  3  D0 6E        	bne ifalls			; can't move up, go down next.
002573  3  A0 08        	ldy #var_newY
002575  3  B1 rr        	lda (z80_ix),y
002577  3  38           	sec
002578  3  E9 01        	sbc #1
00257A  3  91 rr        	sta (z80_ix),y			; adjust new x coord.
00257C  3  C6 rr        	dec z80_b
00257E  3  D0 EE        	bne gravu0
002580  3  60           	rts
002581  3               gravst:
002581  3  A0 0D        	ldy #var_jumpLo
002583  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002585  3  85 rr        	sta z80_l
002587  3  A0 0E        	ldy #var_jumpHi
002589  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
00258B  3  85 rr        	sta z80_h
00258D  3               
00258D  3  A9 00        	lda #0				; null value in pointer.
00258F  3  A0 0D        	ldy #var_jumpLo
002591  3  91 rr        	sta (z80_ix),y			; store new pointer low.
002593  3  C8           	iny
002594  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002596  3               
002596  3  A0 00        	ldy #0
002598  3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
00259A  3  C9 63        	cmp #99				; is it the end marker?
00259C  3               evftf:
00259C  3  F0 01        	beq :+				; yes, fallen too far.
00259E  3  60           	rts
00259F  3               :
00259F  3  4C 68 2D     	jmp evnt15			; EVENT FELLTOOFAR
0025A2  3               
0025A2  3               ;------------------------------------------------
0025A2  3               ; Initiate fall check.
0025A2  3               ;------------------------------------------------
0025A2  3               
0025A2  3               ifall:
0025A2  3  A0 0D        	ldy #var_jumpLo
0025A4  3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
0025A6  3  85 rr        	sta z80_l
0025A8  3  A0 0E        	ldy #var_jumpHi
0025AA  3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
0025AC  3  85 rr        	sta z80_h			; high byte in accumulator.
0025AE  3  05 rr        	ora z80_l			; merge in low byte.
0025B0  3  F0 01        	beq :+
0025B2  3  60           	rts				; if either is set, we're already in the air.
0025B3  3               :
0025B3  3  A0 09        	ldy #var_newX
0025B5  3  B1 rr        	lda (z80_ix),y			; y coordinate.
0025B7  3  85 rr        	sta dispx
0025B9  3               numsp7:
0025B9  3  A0 08        	ldy #var_newY
0025BB  3  B1 rr        	lda (z80_ix),y			; look x coordinate.
0025BD  3  18           	clc
0025BE  3  69 10        	adc #16				; add 16 pixels.
0025C0  3  85 rr        	sta dispy			; set up test coordinates.
0025C2  3  20 9B 1F     	jsr tstbl			; get map address.
0025C5  3  20 46 1E     	jsr plchk			; block, platform check.
0025C8  3  F0 01        	beq :+
0025CA  3  60           	rts				; it's solid, don't fall.
0025CB  3               :
0025CB  3  E6 rr        	inc bufaddr			; look right one cell.
0025CD  3  20 46 1E     	jsr plchk			; block, platform check.
0025D0  3  F0 01        	beq :+
0025D2  3  60           	rts				; it's solid, don't fall.
0025D3  3               :
0025D3  3  A5 rr        	lda dispx			; y coordinate.
0025D5  3  29 07        	and #7				; position straddling block cells.
0025D7  3  F0 08        	beq ifalls			; no more checks needed.
0025D9  3  E6 rr        	inc bufaddr			; look to third cell.
0025DB  3  20 46 1E     	jsr plchk			; block, platform check.
0025DE  3  F0 01        	beq :+
0025E0  3  60           	rts				; it's solid, don't fall.
0025E1  3               :
0025E1  3               ifalls:
0025E1  3  A9 94        	lda #<jtab			; jump table start.
0025E3  3  85 rr        	sta z80_l
0025E5  3  A9 3C        	lda #>jtab
0025E7  3  85 rr        	sta z80_h
0025E9  3               ifal0:
0025E9  3  E6 rr        	inc z80_l			; point to next value.
0025EB  3  D0 02        	bne :+
0025ED  3  E6 rr        	inc z80_h
0025EF  3               :
0025EF  3  A0 00        	ldy #0
0025F1  3  B1 rr        	lda (z80_hl),y			; fetch value.
0025F3  3  F0 F4        	beq ifal0			; no, get next value.
0025F5  3  C9 63        	cmp #99				; reached end of table?
0025F7  3  D0 01        	bne :+
0025F9  3  60           	rts				; yes, don't fall.
0025FA  3               :
0025FA  3  C9 80        	cmp #128			; is it going up?
0025FC  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
0025FE  3               
0025FE  3  A0 0D        	ldy #var_jumpLo
002600  3  A5 rr        	lda z80_l
002602  3  91 rr        	sta (z80_ix),y 			; set jump low.
002604  3  A0 0E        	ldy #var_jumpHi
002606  3  A5 rr        	lda z80_h
002608  3  91 rr        	sta (z80_ix),y 			; set jump high.
00260A  3  60           	rts
00260B  3               
00260B  3               
00260B  3               ;----------------------------------------------------
00260B  3               ; Get frame data for a particular sprite.
00260B  3               ; Input:
00260B  3               ;  a		= framenumer
00260B  3               ; Output:
00260B  3               ;  hl		= frame address
00260B  3               ;
00260B  3               ; global:	hl,frmptr
00260B  3               ; local:	-
00260B  3               ; calls:	-
00260B  3               ;----------------------------------------------------
00260B  3               
00260B  3               gfrm:
00260B  3  0A           	asl a	 		 	; multiple of 2.
00260C  3  18           	clc
00260D  3  6D 15 16     	adc frmptr 			; frames used by game.
002610  3  85 rr        	sta z80_l
002612  3  AD 16 16     	lda frmptr+1
002615  3  69 00        	adc #0
002617  3  85 rr        	sta z80_h 			; point to frame start.
002619  3  60           	rts
00261A  3               
00261A  3               ;----------------------------------------------------
00261A  3               ; Find sprite list for current room.
00261A  3               ;
00261A  3               ; global:	hl
00261A  3               ; local:	x,y
00261A  3               ; calls:	-
00261A  3               ;----------------------------------------------------
00261A  3               
00261A  3               sprlst:
00261A  3  A9 CA        	lda #<nmedat 			; list of enemy sprites.
00261C  3  85 rr        	sta z80_l
00261E  3  A9 38        	lda #>nmedat
002620  3  85 rr        	sta z80_h
002622  3  A6 rr        	ldx scno 			; screen number.
002624  3  D0 01        	bne sprls2 			; is it the first screen?
002626  3  60           	rts 				; yes, don't need to search data.
002627  3               sprls2:
002627  3  A0 00        	ldy #0
002629  3               sprls1:
002629  3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
00262B  3  C9 FF        	cmp #255			; is it an end marker?
00262D  3  F0 0E        	beq sprls0 			; yes, end of this room.
00262F  3               
00262F  3  18           	clc 				; point to next sprite in list.
002630  3  A5 rr        	lda z80_l
002632  3  69 04        	adc #NMESIZ
002634  3  85 rr        	sta z80_l
002636  3  90 02        	bcc :+
002638  3  E6 rr        	inc z80_h
00263A  3               :
00263A  3  4C 29 26     	jmp sprls1 			; continue until end of room.
00263D  3               sprls0:
00263D  3  E6 rr        	inc z80_l 			; point to start of next screen.s
00263F  3  D0 02        	bne :+
002641  3  E6 rr        	inc z80_h
002643  3               :
002643  3  CA           	dex
002644  3  D0 E3        	bne sprls1 			; continue until room found.
002646  3  60           	rts
002647  3               
002647  3               
002647  3               ;----------------------------------------------------
002647  3               ; Clear all but a single player sprite.
002647  3               ;
002647  3               ; global:	-
002647  3               ; local:	x,y,ix
002647  3               ; calls:	-
002647  3               ;----------------------------------------------------
002647  3               
002647  3               nspr:
002647  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002649  3  85 rr        	sta sprcnt
00264B  3  A9 00        	lda #<sprtab 			; sprite table.
00264D  3  85 rr        	sta z80_x
00264F  3  A9 0B        	lda #>sprtab
002651  3  85 rr        	sta z80_i
002653  3               nspr0:
002653  3  A0 00        	ldy #0 				; fetch sprite type.
002655  3  B1 rr        	lda (z80_ix),y 			; is it a player?
002657  3  F0 1A        	beq nspr1 			; yes, keep this one.
002659  3               
002659  3  A9 FF        	lda #255
00265B  3  A0 00        	ldy #0 				; fetch sprite type.
00265D  3  91 rr        	sta (z80_ix),y 			; delete sprite.
00265F  3  A0 05        	ldy #5
002661  3  91 rr        	sta (z80_ix),y 			; remove next type.
002663  3               
002663  3  18           	clc	 			; next sprite.
002664  3  A5 rr        	lda z80_x
002666  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002668  3  85 rr        	sta z80_x
00266A  3  90 02        	bcc :+
00266C  3  E6 rr        	inc z80_i
00266E  3               :
00266E  3  C6 rr        	dec sprcnt	 			; one less space in the table.
002670  3  D0 E1        	bne nspr0
002672  3  60           	rts
002673  3               nspr1:
002673  3  A9 FF        	lda #255
002675  3  A0 00        	ldy #0
002677  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002679  3               
002679  3  18           	clc	 			; point to next sprite.
00267A  3  A5 rr        	lda z80_x
00267C  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
00267E  3  85 rr        	sta z80_x
002680  3  90 02        	bcc :+
002682  3  E6 rr        	inc z80_i
002684  3               :
002684  3  C6 rr        	dec sprcnt	 			; one less to do.
002686  3  D0 01        	bne nspr2
002688  3  60           	rts
002689  3               nspr2:
002689  3  A9 FF        	lda #255
00268B  3  A0 00        	ldy #0
00268D  3  91 rr        	sta (z80_ix),y 			; delete sprite.
00268F  3  A0 05        	ldy #5
002691  3  91 rr        	sta (z80_ix),y 			; remove next type.
002693  3               
002693  3  18           	clc	 			; next sprite.
002694  3  A5 rr        	lda z80_x
002696  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002698  3  85 rr        	sta z80_x
00269A  3  90 02        	bcc :+
00269C  3  E6 rr        	inc z80_i
00269E  3               :
00269E  3  C6 rr        	dec sprcnt	 			; one less space in table.
0026A0  3  D0 E7        	bne nspr2
0026A2  3  60           	rts
0026A3  3               
0026A3  3               ;----------------------------------------------------------
0026A3  3               ; Two initialisation routines.
0026A3  3               ; Initialise sprites - copy everything from list to table.
0026A3  3               ;
0026A3  3               ; global:	-
0026A3  3               ; local:	x,y,ix
0026A3  3               ; calls:	cpsp
0026A3  3               ;----------------------------------------------------------
0026A3  3               
0026A3  3               ispr:
0026A3  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0026A5  3  85 rr        	sta sprcnt
0026A7  3  A9 00        	lda #<sprtab			; sprite table.
0026A9  3  85 rr        	sta z80_x
0026AB  3  A9 0B        	lda #>sprtab
0026AD  3  85 rr        	sta z80_i
0026AF  3               ispr2:
0026AF  3  A0 00        	ldy #0
0026B1  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0026B3  3  C9 FF        	cmp #255 			; is it an end marker?
0026B5  3  D0 01        	bne :+
0026B7  3  60           	rts 				; yes, no more to do.
0026B8  3               :
0026B8  3               ispr1:
0026B8  3  A0 00        	ldy #0
0026BA  3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
0026BC  3  C9 FF        	cmp #255 			; is it enabled yet?
0026BE  3  D0 08        	bne ispr4			; yes, try another slot.
0026C0  3               
0026C0  3  A0 05        	ldy #5
0026C2  3  B1 rr        	lda (z80_ix),y		 	; next type.
0026C4  3  C9 FF        	cmp #255 			; is it enabled yet?
0026C6  3  F0 10        	beq ispr3 			; no, process this one.
0026C8  3               ispr4:
0026C8  3  18           	clc 				; next sprite.
0026C9  3  A5 rr        	lda z80_x
0026CB  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
0026CD  3  85 rr        	sta z80_x
0026CF  3  90 02        	bcc :+
0026D1  3  E6 rr        	inc z80_i
0026D3  3               :
0026D3  3  C6 rr        	dec sprcnt
0026D5  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
0026D7  3  60           	rts  				; no more room in table.
0026D8  3               ispr3:
0026D8  3  20 2B 27     	jsr cpsp			; initialise a sprite.
0026DB  3  C6 rr        	dec sprcnt			; one less space in the table.
0026DD  3  D0 D0        	bne ispr2
0026DF  3  60           	rts
0026E0  3               
0026E0  3               
0026E0  3               ;-----------------------------------------------------------------------
0026E0  3               ; Initialise sprites - but not player, we're keeping the old one.
0026E0  3               ;
0026E0  3               ; global:	-
0026E0  3               ; local:	x,y,ix
0026E0  3               ; calls:	cpsp
0026E0  3               ;-----------------------------------------------------------------------
0026E0  3               
0026E0  3               kspr:
0026E0  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
0026E2  3  A9 00        	lda #<sprtab 			; sprite table.
0026E4  3  85 rr        	sta z80_x
0026E6  3  A9 0B        	lda #>sprtab
0026E8  3  85 rr        	sta z80_i
0026EA  3               kspr2:
0026EA  3  A0 00        	ldy #0
0026EC  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
0026EE  3  C9 FF        	cmp #255 			; is it an end marker?
0026F0  3  D0 01        	bne :+
0026F2  3  60           	rts 				; yes, no more to do.
0026F3  3               :
0026F3  3  C9 00        	cmp #0
0026F5  3  D0 0E        	bne kspr1 			; no, add to table as normal.
0026F7  3               
0026F7  3  18           	clc 				; next sprite.
0026F8  3  A5 rr        	lda z80_l
0026FA  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
0026FC  3  85 rr        	sta z80_l
0026FE  3  90 02        	bcc :+
002700  3  E6 rr        	inc z80_h
002702  3               :
002702  3  4C EA 26     	jmp kspr2
002705  3               kspr1:
002705  3  A0 00        	ldy #0 				; fetch sprite type.
002707  3  B1 rr        	lda (z80_ix),y
002709  3  C9 FF        	cmp #255 			; is it enabled yet?
00270B  3  D0 08        	bne kspr4 			; yes, try another slot.
00270D  3               
00270D  3  A0 05        	ldy #5 				; next type.
00270F  3  B1 rr        	lda (z80_ix),y
002711  3  C9 FF        	cmp #255 			; is it enabled yet?
002713  3  F0 0F        	beq kspr3 			; no, process this one.
002715  3               kspr4:
002715  3  18           	clc 				; next sprite.
002716  3  A5 rr        	lda z80_x
002718  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00271A  3  85 rr        	sta z80_x
00271C  3  90 02        	bcc :+
00271E  3  E6 rr        	inc z80_i
002720  3               :
002720  3  CA           	dex	 			; repeat for remaining sprites.
002721  3  D0 E2        	bne kspr1
002723  3  60           	rts  				; no more room in table.
002724  3               kspr3:
002724  3  20 2B 27     	jsr cpsp 			; copy sprite to table.
002727  3  CA           	dex	 			; one less space in the table.
002728  3  D0 C0        	bne kspr2
00272A  3  60           	rts
00272B  3               
00272B  3               ;----------------------------------------------
00272B  3               ; Copy sprite from list to table.
00272B  3               ;
00272B  3               ; global:	hl,ix
00272B  3               ; local:	y
00272B  3               ; calls:	evnt09
00272B  3               ;----------------------------------------------
00272B  3               
00272B  3               cpsp:
00272B  3  A0 00        	ldy #0					; fetch byte from table.
00272D  3  B1 rr        	lda (z80_hl),y
00272F  3               	; y=var_Type
00272F  3  91 rr        	sta (z80_ix),y			; set up type.
002731  3  A0 05        	ldy #var_newType
002733  3  91 rr        	sta (z80_ix),y 			; set up type.
002735  3               
002735  3  E6 rr        	inc z80_l 				; move to next byte.
002737  3  D0 02        	bne :+
002739  3  E6 rr        	inc z80_h
00273B  3               :
00273B  3  A0 00        	ldy #0 					; fetch byte from table.
00273D  3  B1 rr        	lda (z80_hl),y
00273F  3  A0 06        	ldy #var_newImage
002741  3  91 rr        	sta (z80_ix),y			; set up image.
002743  3               
002743  3  E6 rr        	inc z80_l 				; move to next byte.
002745  3  D0 02        	bne :+
002747  3  E6 rr        	inc z80_h
002749  3               :
002749  3  A0 00        	ldy #0
00274B  3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
00274D  3  A0 08        	ldy #var_newY
00274F  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
002751  3               
002751  3  A9 C8        	lda #200 				; set initial coordinate off screen.
002753  3  A0 03        	ldy #var_Y
002755  3  91 rr        	sta (z80_ix),y
002757  3               
002757  3  E6 rr        	inc z80_l 				; move to next byte.
002759  3  D0 02        	bne :+
00275B  3  E6 rr        	inc z80_h
00275D  3               :
00275D  3  A0 00        	ldy #0 					; fetch byte from table.
00275F  3  B1 rr        	lda (z80_hl),y
002761  3  A0 09        	ldy #var_newX
002763  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
002765  3               
002765  3  E6 rr        	inc z80_l 				; move to next byte.
002767  3  D0 02        	bne :+
002769  3  E6 rr        	inc z80_h
00276B  3               :
00276B  3  A9 00        	lda #0					; zeroes in accumulator.
00276D  3  A0 07        	ldy #var_newFrame 		; reset frame number.
00276F  3  91 rr        	sta (z80_ix),y
002771  3  A0 0A        	ldy #var_Direction 		; reset direction.
002773  3  91 rr        	sta (z80_ix),y
002775  3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
002777  3  91 rr        	sta (z80_ix),y
002779  3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
00277B  3  91 rr        	sta (z80_ix),y
00277D  3               
00277D  3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
00277F  3  A0 10        	ldy #var_dataHi
002781  3  91 rr        	sta (z80_ix),y
002783  3               evis0:
002783  3  A5 rr        	lda z80_i
002785  3  48           	pha
002786  3  A5 rr        	lda z80_x
002788  3  48           	pha
002789  3  A5 rr        	lda z80_h
00278B  3  48           	pha
00278C  3  A5 rr        	lda z80_l
00278E  3  48           	pha
00278F  3               
00278F  3  20 BA 2C     	jsr evnt09 				; perform event.
002792  3               
002792  3  68           	pla
002793  3  85 rr        	sta z80_l
002795  3  68           	pla
002796  3  85 rr        	sta z80_h
002798  3  68           	pla
002799  3  85 rr        	sta z80_x
00279B  3  68           	pla
00279C  3  85 rr        	sta z80_i
00279E  3               
00279E  3  18           	clc
00279F  3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
0027A1  3  69 11        	adc #TABSIZ		 	; next sprite.
0027A3  3  85 rr        	sta z80_x
0027A5  3  90 02        	bcc :+
0027A7  3  E6 rr        	inc z80_i
0027A9  3               :
0027A9  3  60           	rts
0027AA  3               
0027AA  3               
0027AA  3               ;-------------------------------------
0027AA  3               ; Clear the play area window.
0027AA  3               ;-------------------------------------
0027AA  3               
0027AA  3               clw:
0027AA  3  AD 0C 16     	lda wintop			; get coordinates of window.
0027AD  3  85 rr        	sta dispy			; put into dispx for calculation.
0027AF  3  AD 0D 16     	lda winlft
0027B2  3  85 rr        	sta dispx
0027B4  3               
0027B4  3  AD 0E 16     	lda winhgt			; height of window.
0027B7  3  85 rr        	sta rrow			; copy to b register.
0027B9  3               clw3:
0027B9  3  AD 0F 16     	lda winwid 			; width of window.
0027BC  3  85 rr        	sta rcol
0027BE  3               clw2:
0027BE  3  20 E7 1B     	jsr gprad 			; get print address.
0027C1  3  A9 00        	lda #0				; zero byte to write.
0027C3  3  A0 07        	ldy #7				; pixel height of each cell.
0027C5  3               clw1:
0027C5  3  91 rr        	sta (scraddr),y 	; copy to screen.
0027C7  3  88           	dey					; next screen row down.
0027C8  3  10 FB        	bpl clw1
0027CA  3               
0027CA  3  E6 rr        	inc dispx			; next column.
0027CC  3  C6 rr        	dec rcol			; one less to do.
0027CE  3  D0 EE        	bne clw2			; repeat for remaining columns.
0027D0  3               
0027D0  3  AD 0D 16     	lda winlft			; get left edge.
0027D3  3  85 rr        	sta dispx 			; reset x.
0027D5  3  E6 rr        	inc dispy 			; next line down.
0027D7  3               
0027D7  3  C6 rr        	dec rrow
0027D9  3  D0 DE        	bne clw3			; repeat down the screen.
0027DB  3               
0027DB  3  AD 0C 16     	lda wintop			; get coordinates of window.
0027DE  3  85 rr        	sta chary			; put into display position.
0027E0  3  AD 0D 16     	lda winlft
0027E3  3  85 rr        	sta charx
0027E5  3  60           	rts
0027E6  3               
0027E6  3               
0027E6  3               ;----------------------------------------------------------
0027E6  3               ; Effects code.
0027E6  3               ; Ticker routine is called 25 times per second.
0027E6  3               ;
0027E6  3               ; HL = txtscr = left text screen address
0027E6  3               ; DE = txtscr+txtwid-1 = right text screen address
0027E6  3               ; BC = txtpos = text scroller position
0027E6  3               ;
0027E6  3               ;----------------------------------------------------------
0027E6  3               
0027E6  3               .if sflag
0027E6  3               scrly:
0027E6  3               	rts
0027E6  3               	.word txtscr         	; get left screen address.
0027E6  3               	sta scr_l
0027E6  3               	lda txtscr+1
0027E6  3               	sta scr_l+1
0027E6  3               	sta scr_r+1
0027E6  3               
0027E6  3               	stx xtmp
0027E6  3               
0027E6  3               	clc         		; get right screen address.
0027E6  3               	lda scr_l
0027E6  3               	adc txtwid
0027E6  3               	sta scr_r
0027E6  3               	dec scr_r
0027E6  3               scrly1:
0027E6  3               	ldy txtwid		; set txtwide
0027E6  3               	dey
0027E6  3               	clc
0027E6  3               scrly0:
0027E6  3               	lda (scr_l),y		; scroll 1 line
0027E6  3               	rol a
0027E6  3               	sta (scr_l),y
0027E6  3               	dey
0027E6  3               	bpl scrly0
0027E6  3               
0027E6  3               	clc			; point to next line
0027E6  3               	lda scr_l
0027E6  3               	adc #32
0027E6  3               	sta scr_l
0027E6  3               	bcc scrly1		; repeat 8 times
0027E6  3               
0027E6  3               	lda txtpos 		; get text pointer.
0027E6  3               	sta scr_txt
0027E6  3               	lda txtpos+1
0027E6  3               	sta scr_txt+1
0027E6  3               
0027E6  3               	ldy #0
0027E6  3               	lda (scr_txt),y 		; find character we're displaying.
0027E6  3               	and #127 		; remove end marker bit if applicable.
0027E6  3               	cmp #ASCII_NEWLINE			; is it newline?
0027E6  3               	bne scrly5 		; no, it's okay.
0027E6  3               	lda #32			; convert to a space instead.
0027E6  3               scrly5:
0027E6  3               	sta fntaddr		; calculate char address
0027E6  3               	lda #0
0027E6  3               	sta fntaddr+1
0027E6  3               	asl fntaddr  		; multiply char by 8.
0027E6  3               	rol fntaddr+1
0027E6  3               	asl fntaddr
0027E6  3               	rol fntaddr+1
0027E6  3               	asl fntaddr
0027E6  3               	rol fntaddr+1
0027E6  3               	lda fntaddr
0027E6  3               	clc
0027E6  3               	adc FontPtr
0027E6  3               	sta scrly3+1		; that's the low byte.
0027E6  3               	lda fntaddr+1
0027E6  3               	adc FontPtr+1
0027E6  3               	sta scrly3+2		; add displacement.
0027E6  3               
0027E6  3               	ldx #0
0027E6  3               scrly3:
0027E6  3               	lda $3333,x		; get image of char line.
0027E6  3               	and txtbit
0027E6  3               	beq scrly2		; don't plot pixel
0027E6  3               	ldy scrline,x
0027E6  3               	lda (scr_r),y
0027E6  3               	clc
0027E6  3               	ora #1
0027E6  3               	sta (scr_r),y		; plot pixel
0027E6  3               scrly2:
0027E6  3               	inx			; next line of char.
0027E6  3               	cpx #8
0027E6  3               	bne scrly3
0027E6  3               
0027E6  3               	lsr txtbit		; bit of text to display.
0027E6  3               	bcs :+
0027E6  3               	rts
0027E6  3               :
0027E6  3               	ldy #0
0027E6  3               	lda (scr_txt),y 	; what was the character?
0027E6  3               	asl a	  		; end of message?
0027E6  3               	bcs scrly4
0027E6  3               	inc txtpos
0027E6  3               	bne :+
0027E6  3               	inc txtpos+1
0027E6  3               :
0027E6  3               	jmp scrly6 		; not yet - continue.
0027E6  3               scrly4:
0027E6  3               	lda txtini 		; start of scrolling message.
0027E6  3               	sta txtpos
0027E6  3               	lda txtini+1
0027E6  3               	sta txtpos+1
0027E6  3               scrly6:
0027E6  3               	lda #128
0027E6  3               	sta txtbit
0027E6  3               	ldx xtmp
0027E6  3               	rts
0027E6  3               
0027E6  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
0027E6  3               
0027E6  3               ;-------------------------------------------------------
0027E6  3               ; Entry TICKER command
0027E6  3               ;
0027E6  3               ; Entry:
0027E6  3               ;  z80_b = message nr
0027E6  3               ;  z80_c = width
0027E6  3               ;-------------------------------------------------------
0027E6  3               
0027E6  3               iscrly:
0027E6  3               	jsr prescr 		; set up display position.
0027E6  3               
0027E6  3               	lda #<msgdat 		; text messages.
0027E6  3               	sta z80_l
0027E6  3               	lda #>msgdat
0027E6  3               	sta z80_h
0027E6  3               
0027E6  3               	lda z80_c 		; width.
0027E6  3               	sec
0027E6  3               	sbc #1			; subtract one.
0027E6  3               	cmp #32 		; is it between 1 and 32?
0027E6  3               	bcc :+
0027E6  3               	lda #$60
0027E6  3               	jmp iscrl0		; no, disable messages.
0027E6  3               :
0027E6  3               	ldx z80_b		; message number.
0027E6  3               	jsr getwrd 		; find message start.
0027E6  3               
0027E6  3               	lda z80_l		; set initial text position.
0027E6  3               	sta txtini
0027E6  3               	lda z80_h
0027E6  3               	sta txtini+1
0027E6  3               
0027E6  3               	lda #$ad		; code for lda adrr
0027E6  3               iscrl0:
0027E6  3               	sta scrly		; enable/disable scrolling routine.
0027E6  3               
0027E6  3               	jsr prescr 		; set up display position.
0027E6  3               	jsr gprad 		; get print address.
0027E6  3               
0027E6  3               	lda scraddr 		; set text screen address.
0027E6  3               	sta txtscr
0027E6  3               	lda scraddr+1
0027E6  3               	sta txtscr+1
0027E6  3               
0027E6  3               	lda z80_c		; width.
0027E6  3               	sta txtwid		; set width in working storage.
0027E6  3               
0027E6  3               	lda #128 		; start with leftmost bit.
0027E6  3               	sta txtbit
0027E6  3               
0027E6  3               	jmp scrly4
0027E6  3               .endif
0027E6  3               
0027E6  3               ;------------------------------------------------------------------
0027E6  3               ; Dig routine, conditional assembly depending on dflag
0027E6  3               ;------------------------------------------------------------------
0027E6  3               .if dflag
0027E6  3               dig:
0027E6  3               	and #3
0027E6  3               	beq digr		; dig right
0027E6  3               	cmp #1
0027E6  3               	beq digl		; dig left
0027E6  3               	cmp #2
0027E6  3               	beq digd		; dig down
0027E6  3               
0027E6  3               ; Dig up.
0027E6  3               
0027E6  3               digu:				; dig up
0027E6  3               	ldy #var_newY
0027E6  3               	lda (z80_ix),y
0027E6  3               	sec
0027E6  3               	sbc #2
0027E6  3               	sta dispy		; set y
0027E6  3               
0027E6  3               	iny
0027E6  3               	lda (z80_ix),y
0027E6  3               	sta dispx		; set x
0027E6  3               	jmp digv
0027E6  3               
0027E6  3               ; Dig down.
0027E6  3               
0027E6  3               digd:
0027E6  3               	ldy #var_newX
0027E6  3               	lda (z80_ix),y
0027E6  3               	sta dispx		; set x
0027E6  3               
0027E6  3               	dey
0027E6  3               	clc
0027E6  3               	lda (z80_ix),y
0027E6  3               	adc #16
0027E6  3               	sta dispy		; set y
0027E6  3               	jmp digv
0027E6  3               
0027E6  3               ; Dig left.
0027E6  3               
0027E6  3               digl:
0027E6  3               	ldy #var_newY
0027E6  3               	lda (z80_ix),y
0027E6  3               	sta dispy		; set y
0027E6  3               
0027E6  3               	iny
0027E6  3               	lda (z80_ix),y
0027E6  3               	sec
0027E6  3               	sbc #2			; x=x-2
0027E6  3               	sta dispx		; set x
0027E6  3               	jmp digh
0027E6  3               
0027E6  3               ; Dig right.
0027E6  3               
0027E6  3               digr:
0027E6  3               	ldy #var_newY
0027E6  3               	lda (z80_ix),y
0027E6  3               	sta dispy		; set y
0027E6  3               
0027E6  3               	iny
0027E6  3               	lda (z80_ix),y
0027E6  3               	clc
0027E6  3               	adc #16
0027E6  3               	sta dispx		; set x+16
0027E6  3               	jmp digh
0027E6  3               
0027E6  3               ; Vertical digging
0027E6  3               
0027E6  3               digv:
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jsr fdchk		; test if FODDER
0027E6  3               
0027E6  3               	clc
0027E6  3               	lda dispx		; look 1 cell down
0027E6  3               	adc #8
0027E6  3               	sta dispx
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jsr fdchk
0027E6  3               	lda dispx
0027E6  3               	and #7
0027E6  3               	bne :+
0027E6  3               	rts
0027E6  3               :
0027E6  3               	clc
0027E6  3               	lda dispx		; look 1 cell down
0027E6  3               	adc #8
0027E6  3               	sta dispx
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jmp fdchk
0027E6  3               
0027E6  3               ; Horizontal digging
0027E6  3               
0027E6  3               digh:
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jsr fdchk		; test if FODDER
0027E6  3               
0027E6  3               	clc
0027E6  3               	lda dispy		; look 1 cell down
0027E6  3               	adc #8
0027E6  3               	sta dispy
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jsr fdchk
0027E6  3               	lda dispy
0027E6  3               	and #7
0027E6  3               	bne :+
0027E6  3               	rts
0027E6  3               :
0027E6  3               	clc
0027E6  3               	lda dispy		; look 1 cell down
0027E6  3               	adc #8
0027E6  3               	sta dispy
0027E6  3               	jsr tstbl		; check blocktype in MAP
0027E6  3               	jmp fdchk
0027E6  3               
0027E6  3               digcnt:	.byte 0
0027E6  3               
0027E6  3               .endif
0027E6  3               
0027E6  3               ;------------------------------------------------------------------
0027E6  3               ; Sprite table
0027E6  3               ;------------------------------------------------------------------
0027E6  3               
0027E6  3               
0027E6  3               ; ix+0  = type.
0027E6  3               ; ix+1  = sprite image number.
0027E6  3               ; ix+2  = frame.
0027E6  3               ; ix+3  = y coord.
0027E6  3               ; ix+4  = x coord.
0027E6  3               
0027E6  3               ; ix+5  = new type.
0027E6  3               ; ix+6  = new image number.
0027E6  3               ; ix+7  = new frame.
0027E6  3               ; ix+8  = new y coord.
0027E6  3               ; ix+9  = new x coord.
0027E6  3               
0027E6  3               ; ix+10 = direction.
0027E6  3               ; ix+11 = parameter 1.
0027E6  3               ; ix+12 = parameter 2.
0027E6  3               ; ix+13 = jump pointer low.
0027E6  3               ; ix+14 = jump pointer high.
0027E6  3               ; ix+15 = data pointer low.
0027E6  3               ; ix+16 = data pointer high.
0027E6  3               
0027E6  3               ; block NUMSPR * TABSIZ,255
0027E6  3               ; sprtab NUMSPR*TABSIZ,255
0027E6  3               
0027E6  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
0027EA  3  FF FF FF 00  
0027EE  3  C0 78 00 00  
0027F7  3  07           roomtb:	.byte 7                      ; start room map offset.
0027F8  3               
0027F8  3               ; User routine.  Put your own code in here to be called with USER instruction.
0027F8  3               ; if USER has an argument it will be passed in the accumulator.
0027F8  3               
0027F8  3               user:
0027F8  3  60           	rts
0027F9  3               
0027F9  3               ; Everything below here will be generated by the editors.
0027F9  3               
0027F9  3               script_start:
0027F9  3               
0027F9  3               WINDOWTOP = 0
0027F9  3               WINDOWLFT = 0
0027F9  3               WINDOWHGT = 23
0027F9  3               WINDOWWID = 32 ;
0027F9  3               MAPWID = 3
0027F9  3  FF FF FF             .byte 255,255,255
0027FC  3               mapdat:
0027FC  3  FF 00 FF             .byte 255,0,255
0027FF  3  FF FF FF             .byte 255,255,255
002802  3  02           stmap:  .byte 2
002803  3               
002803  3               evnt00:
002803  3  20 A2 25             jsr ifall
002806  3  A5 rr                lda joyval
002808  3  29 04                and #4
00280A  3  F0 03                beq :+
00280C  3  4C 12 28             jmp a00028
00280F  3               :
00280F  3  20 6D 0E             jsr prskey
002812  3  A5 rr        a00028: lda joyval
002814  3  29 01                and #1
002816  3  F0 03                beq :+
002818  3  4C 2C 28             jmp a00081
00281B  3               :
00281B  3  20 FB 1D             jsr cangr
00281E  3  F0 03                beq :+
002820  3  4C 2C 28             jmp a00081
002823  3               :
002823  3  A0 09                ldy #9
002825  3  B1 rr                lda (z80_ix),y
002827  3  18                   clc
002828  3  69 02                adc #2
00282A  3  91 rr                sta (z80_ix),y
00282C  3  A5 rr        a00081: lda joyval
00282E  3  29 02                and #2
002830  3  F0 03                beq :+
002832  3  4C 46 28             jmp a00134
002835  3               :
002835  3  20 E9 1D             jsr cangl
002838  3  F0 03                beq :+
00283A  3  4C 46 28             jmp a00134
00283D  3               :
00283D  3  A0 09                ldy #9
00283F  3  B1 rr                lda (z80_ix),y
002841  3  38                   sec
002842  3  E9 02                sbc #2
002844  3  91 rr                sta (z80_ix),y
002846  3  20 B4 1D     a00134: jsr cangd
002849  3  F0 03                beq :+
00284B  3  4C 51 28             jmp a00153
00284E  3               :
00284E  3  4C 57 28             jmp a00166
002851  3  A9 03        a00153: lda #3
002853  3  A0 0B                ldy #11
002855  3  91 rr                sta (z80_ix),y
002857  3  A0 0B        a00166: ldy #11
002859  3  B1 rr                lda (z80_ix),y
00285B  3  A0 07                ldy #7
00285D  3  91 rr                sta (z80_ix),y
00285F  3  A9 00                lda #0
002861  3  A0 0B                ldy #11
002863  3  D1 rr                cmp (z80_ix),y
002865  3  90 03                bcc *+5
002867  3  4C 7E 28             jmp a00251
00286A  3  A9 00                lda #0
00286C  3  C5 rr                cmp vart
00286E  3  F0 03                beq *+5
002870  3  4C 7E 28             jmp a00251
002873  3  A0 0B                ldy #11
002875  3  B1 rr                lda (z80_ix),y
002877  3  38                   sec
002878  3  E9 01                sbc #1
00287A  3  A0 0B                ldy #11
00287C  3  91 rr                sta (z80_ix),y
00287E  3  20 D3 1F     a00251: jsr jump
002881  3  A9 05                lda #DEADLY
002883  3  85 rr                sta z80_b
002885  3  20 E0 1E             jsr tded
002888  3  C5 rr                cmp z80_b
00288A  3  F0 03                beq :+
00288C  3  4C 93 28             jmp a00290
00288F  3               :
00288F  3  A9 01                lda #1
002891  3  85 rr                sta deadf
002893  3  A9 06        a00290: lda #CUSTOM
002895  3  85 rr                sta z80_b
002897  3  20 E0 1E             jsr tded
00289A  3  C5 rr                cmp z80_b
00289C  3  F0 03                beq :+
00289E  3  4C B8 28             jmp a00363
0028A1  3               :
0028A1  3  A9 01                lda #1
0028A3  3  85 rr                sta vare
0028A5  3  A9 00                lda #0
0028A7  3  C5 rr                cmp vars
0028A9  3  F0 03                beq *+5
0028AB  3  4C B4 28             jmp a00355
0028AE  3  A9 64                lda #100
0028B0  3  0A                   asl a
0028B1  3  8D 2A 0F             sta sndtyp
0028B4  3  A9 01        a00355: lda #1
0028B6  3  85 rr                sta vars
0028B8  3  4C 0E 25     a00363: jmp grav
0028BB  3               .out .sprintf("EVENT 0 SIZE = %d", (* - evnt00))
0028BB  3               
0028BB  3               evnt01:
0028BB  3  A9 00                lda #0
0028BD  3  A0 0B                ldy #11
0028BF  3  D1 rr                cmp (z80_ix),y
0028C1  3  F0 03                beq *+5
0028C3  3  4C E3 28             jmp b00082
0028C6  3  20 7F 1D             jsr cangu
0028C9  3  F0 03                beq :+
0028CB  3  4C DA 28             jmp b00064
0028CE  3               :
0028CE  3  A0 08                ldy #8
0028D0  3  B1 rr                lda (z80_ix),y
0028D2  3  38                   sec
0028D3  3  E9 02                sbc #2
0028D5  3  91 rr                sta (z80_ix),y
0028D7  3  4C E0 28             jmp b00078
0028DA  3  A9 01        b00064: lda #1
0028DC  3  A0 0B                ldy #11
0028DE  3  91 rr                sta (z80_ix),y
0028E0  3  4C FD 28     b00078: jmp b00136
0028E3  3  20 B4 1D     b00082: jsr cangd
0028E6  3  F0 03                beq :+
0028E8  3  4C F7 28             jmp b00123
0028EB  3               :
0028EB  3  A0 08                ldy #8
0028ED  3  B1 rr                lda (z80_ix),y
0028EF  3  18                   clc
0028F0  3  69 02                adc #2
0028F2  3  91 rr                sta (z80_ix),y
0028F4  3  4C FD 28             jmp b00136
0028F7  3  A9 00        b00123: lda #0
0028F9  3  A0 0B                ldy #11
0028FB  3  91 rr                sta (z80_ix),y
0028FD  3  A9 01        b00136: lda #1
0028FF  3  C5 rr                cmp vart
002901  3  F0 03                beq *+5
002903  3  4C 3A 29             jmp b00259
002906  3  A0 0C                ldy #12
002908  3  B1 rr                lda (z80_ix),y
00290A  3  18                   clc
00290B  3  69 01                adc #1
00290D  3  A0 0C                ldy #12
00290F  3  91 rr                sta (z80_ix),y
002911  3  A9 05                lda #5
002913  3  A0 0C                ldy #12
002915  3  D1 rr                cmp (z80_ix),y
002917  3  90 03                bcc *+5
002919  3  4C 22 29             jmp b00215
00291C  3  A9 00                lda #0
00291E  3  A0 0C                ldy #12
002920  3  91 rr                sta (z80_ix),y
002922  3  A0 0C        b00215: ldy #12
002924  3  B1 rr                lda (z80_ix),y
002926  3  C9 03                cmp #3
002928  3  90 03                bcc *+5
00292A  3  4C 35 29             jmp b00250
00292D  3  A9 00                lda #0
00292F  3  20 A7 23             jsr animsp
002932  3  4C 3A 29             jmp b00259
002935  3  A9 00        b00250: lda #0
002937  3  20 CD 23             jsr animbk
00293A  3  A9 00        b00259: lda #0
00293C  3  85 rr                sta z80_b
00293E  3  20 F2 23             jsr sktyp
002941  3  B0 03                bcs :+
002943  3  4C 4A 29             jmp b00289
002946  3               :
002946  3  A9 01                lda #1
002948  3  85 rr                sta deadf
00294A  3  60           b00289: rts
00294B  3               .out .sprintf("EVENT 1 SIZE = %d", (* - evnt01))
00294B  3               
00294B  3               evnt02:
00294B  3  A9 00                lda #0
00294D  3  A0 0B                ldy #11
00294F  3  D1 rr                cmp (z80_ix),y
002951  3  F0 03                beq *+5
002953  3  4C 9F 29             jmp c00179
002956  3  20 E9 1D             jsr cangl
002959  3  F0 03                beq :+
00295B  3  4C 96 29             jmp c00161
00295E  3               :
00295E  3  A0 09                ldy #9
002960  3  B1 rr                lda (z80_ix),y
002962  3  38                   sec
002963  3  E9 02                sbc #2
002965  3  91 rr                sta (z80_ix),y
002967  3  A9 10                lda #16
002969  3  85 rr                sta z80_c
00296B  3  A0 09                ldy #9
00296D  3  B1 rr                lda (z80_ix),y
00296F  3  38                   sec
002970  3  E5 rr                sbc z80_c
002972  3  A0 09                ldy #9
002974  3  91 rr                sta (z80_ix),y
002976  3  20 B4 1D             jsr cangd
002979  3  F0 03                beq :+
00297B  3  4C 84 29             jmp c00121
00297E  3               :
00297E  3  A9 01                lda #1
002980  3  A0 0B                ldy #11
002982  3  91 rr                sta (z80_ix),y
002984  3  A9 10        c00121: lda #16
002986  3  85 rr                sta z80_c
002988  3  A0 09                ldy #9
00298A  3  B1 rr                lda (z80_ix),y
00298C  3  18                   clc
00298D  3  65 rr                adc z80_c
00298F  3  A0 09                ldy #9
002991  3  91 rr                sta (z80_ix),y
002993  3  4C 9C 29             jmp c00175
002996  3  A9 01        c00161: lda #1
002998  3  A0 0B                ldy #11
00299A  3  91 rr                sta (z80_ix),y
00299C  3  4C E5 29     c00175: jmp c00330
00299F  3  20 FB 1D     c00179: jsr cangr
0029A2  3  F0 03                beq :+
0029A4  3  4C DF 29             jmp c00317
0029A7  3               :
0029A7  3  A0 09                ldy #9
0029A9  3  B1 rr                lda (z80_ix),y
0029AB  3  18                   clc
0029AC  3  69 02                adc #2
0029AE  3  91 rr                sta (z80_ix),y
0029B0  3  A9 10                lda #16
0029B2  3  85 rr                sta z80_c
0029B4  3  A0 09                ldy #9
0029B6  3  B1 rr                lda (z80_ix),y
0029B8  3  18                   clc
0029B9  3  65 rr                adc z80_c
0029BB  3  A0 09                ldy #9
0029BD  3  91 rr                sta (z80_ix),y
0029BF  3  20 B4 1D             jsr cangd
0029C2  3  F0 03                beq :+
0029C4  3  4C CD 29             jmp c00277
0029C7  3               :
0029C7  3  A9 00                lda #0
0029C9  3  A0 0B                ldy #11
0029CB  3  91 rr                sta (z80_ix),y
0029CD  3  A9 10        c00277: lda #16
0029CF  3  85 rr                sta z80_c
0029D1  3  A0 09                ldy #9
0029D3  3  B1 rr                lda (z80_ix),y
0029D5  3  38                   sec
0029D6  3  E5 rr                sbc z80_c
0029D8  3  A0 09                ldy #9
0029DA  3  91 rr                sta (z80_ix),y
0029DC  3  4C E5 29             jmp c00330
0029DF  3  A9 00        c00317: lda #0
0029E1  3  A0 0B                ldy #11
0029E3  3  91 rr                sta (z80_ix),y
0029E5  3  A9 00        c00330: lda #0
0029E7  3  C5 rr                cmp vart
0029E9  3  F0 03                beq *+5
0029EB  3  4C 22 2A             jmp c00453
0029EE  3  A0 0C                ldy #12
0029F0  3  B1 rr                lda (z80_ix),y
0029F2  3  18                   clc
0029F3  3  69 01                adc #1
0029F5  3  A0 0C                ldy #12
0029F7  3  91 rr                sta (z80_ix),y
0029F9  3  A9 05                lda #5
0029FB  3  A0 0C                ldy #12
0029FD  3  D1 rr                cmp (z80_ix),y
0029FF  3  90 03                bcc *+5
002A01  3  4C 0A 2A             jmp c00409
002A04  3  A9 00                lda #0
002A06  3  A0 0C                ldy #12
002A08  3  91 rr                sta (z80_ix),y
002A0A  3  A0 0C        c00409: ldy #12
002A0C  3  B1 rr                lda (z80_ix),y
002A0E  3  C9 03                cmp #3
002A10  3  90 03                bcc *+5
002A12  3  4C 1D 2A             jmp c00444
002A15  3  A9 00                lda #0
002A17  3  20 A7 23             jsr animsp
002A1A  3  4C 22 2A             jmp c00453
002A1D  3  A9 00        c00444: lda #0
002A1F  3  20 CD 23             jsr animbk
002A22  3  A9 00        c00453: lda #0
002A24  3  85 rr                sta z80_b
002A26  3  20 F2 23             jsr sktyp
002A29  3  B0 03                bcs :+
002A2B  3  4C 32 2A             jmp c00483
002A2E  3               :
002A2E  3  A9 01                lda #1
002A30  3  85 rr                sta deadf
002A32  3  60           c00483: rts
002A33  3               .out .sprintf("EVENT 2 SIZE = %d", (* - evnt02))
002A33  3               
002A33  3               evnt03:
002A33  3  A9 00                lda #0
002A35  3  85 rr                sta z80_b
002A37  3  20 F2 23             jsr sktyp
002A3A  3  B0 03                bcs :+
002A3C  3  4C 43 2A             jmp d00032
002A3F  3               :
002A3F  3  A9 01                lda #1
002A41  3  85 rr                sta deadf
002A43  3  A9 01        d00032: lda #1
002A45  3  C5 rr                cmp vart
002A47  3  F0 03                beq *+5
002A49  3  4C 4D 2A             jmp d00051
002A4C  3  60                   rts
002A4D  3  A9 00        d00051: lda #0
002A4F  3  A0 0B                ldy #11
002A51  3  D1 rr                cmp (z80_ix),y
002A53  3  F0 03                beq *+5
002A55  3  4C A1 2A             jmp d00229
002A58  3  20 E9 1D             jsr cangl
002A5B  3  F0 03                beq :+
002A5D  3  4C 98 2A             jmp d00211
002A60  3               :
002A60  3  A0 09                ldy #9
002A62  3  B1 rr                lda (z80_ix),y
002A64  3  38                   sec
002A65  3  E9 02                sbc #2
002A67  3  91 rr                sta (z80_ix),y
002A69  3  A9 10                lda #16
002A6B  3  85 rr                sta z80_c
002A6D  3  A0 09                ldy #9
002A6F  3  B1 rr                lda (z80_ix),y
002A71  3  38                   sec
002A72  3  E5 rr                sbc z80_c
002A74  3  A0 09                ldy #9
002A76  3  91 rr                sta (z80_ix),y
002A78  3  20 B4 1D             jsr cangd
002A7B  3  F0 03                beq :+
002A7D  3  4C 86 2A             jmp d00171
002A80  3               :
002A80  3  A9 01                lda #1
002A82  3  A0 0B                ldy #11
002A84  3  91 rr                sta (z80_ix),y
002A86  3  A9 10        d00171: lda #16
002A88  3  85 rr                sta z80_c
002A8A  3  A0 09                ldy #9
002A8C  3  B1 rr                lda (z80_ix),y
002A8E  3  18                   clc
002A8F  3  65 rr                adc z80_c
002A91  3  A0 09                ldy #9
002A93  3  91 rr                sta (z80_ix),y
002A95  3  4C 9E 2A             jmp d00224
002A98  3  A9 01        d00211: lda #1
002A9A  3  A0 0B                ldy #11
002A9C  3  91 rr                sta (z80_ix),y
002A9E  3  4C E7 2A     d00224: jmp d00380
002AA1  3  20 FB 1D     d00229: jsr cangr
002AA4  3  F0 03                beq :+
002AA6  3  4C E1 2A             jmp d00366
002AA9  3               :
002AA9  3  A0 09                ldy #9
002AAB  3  B1 rr                lda (z80_ix),y
002AAD  3  18                   clc
002AAE  3  69 02                adc #2
002AB0  3  91 rr                sta (z80_ix),y
002AB2  3  A9 10                lda #16
002AB4  3  85 rr                sta z80_c
002AB6  3  A0 09                ldy #9
002AB8  3  B1 rr                lda (z80_ix),y
002ABA  3  18                   clc
002ABB  3  65 rr                adc z80_c
002ABD  3  A0 09                ldy #9
002ABF  3  91 rr                sta (z80_ix),y
002AC1  3  20 B4 1D             jsr cangd
002AC4  3  F0 03                beq :+
002AC6  3  4C CF 2A             jmp d00327
002AC9  3               :
002AC9  3  A9 00                lda #0
002ACB  3  A0 0B                ldy #11
002ACD  3  91 rr                sta (z80_ix),y
002ACF  3  A9 10        d00327: lda #16
002AD1  3  85 rr                sta z80_c
002AD3  3  A0 09                ldy #9
002AD5  3  B1 rr                lda (z80_ix),y
002AD7  3  38                   sec
002AD8  3  E5 rr                sbc z80_c
002ADA  3  A0 09                ldy #9
002ADC  3  91 rr                sta (z80_ix),y
002ADE  3  4C E7 2A             jmp d00380
002AE1  3  A9 00        d00366: lda #0
002AE3  3  A0 0B                ldy #11
002AE5  3  91 rr                sta (z80_ix),y
002AE7  3  A0 0C        d00380: ldy #12
002AE9  3  B1 rr                lda (z80_ix),y
002AEB  3  18                   clc
002AEC  3  69 01                adc #1
002AEE  3  A0 0C                ldy #12
002AF0  3  91 rr                sta (z80_ix),y
002AF2  3  A9 05                lda #5
002AF4  3  A0 0C                ldy #12
002AF6  3  D1 rr                cmp (z80_ix),y
002AF8  3  90 03                bcc *+5
002AFA  3  4C 03 2B             jmp d00442
002AFD  3  A9 00                lda #0
002AFF  3  A0 0C                ldy #12
002B01  3  91 rr                sta (z80_ix),y
002B03  3  A0 0C        d00442: ldy #12
002B05  3  B1 rr                lda (z80_ix),y
002B07  3  C9 03                cmp #3
002B09  3  90 03                bcc *+5
002B0B  3  4C 16 2B             jmp d00477
002B0E  3  A9 00                lda #0
002B10  3  20 A7 23             jsr animsp
002B13  3  4C 1B 2B             jmp d00486
002B16  3  A9 00        d00477: lda #0
002B18  3  20 CD 23             jsr animbk
002B1B  3  60           d00486: rts
002B1C  3               .out .sprintf("EVENT 3 SIZE = %d", (* - evnt03))
002B1C  3               
002B1C  3               evnt04:
002B1C  3  A9 00                lda #0
002B1E  3  85 rr                sta z80_b
002B20  3  20 F2 23             jsr sktyp
002B23  3  B0 03                bcs :+
002B25  3  4C 2C 2B             jmp e00032
002B28  3               :
002B28  3  A9 01                lda #1
002B2A  3  85 rr                sta deadf
002B2C  3  A9 00        e00032: lda #0
002B2E  3  A0 0B                ldy #11
002B30  3  D1 rr                cmp (z80_ix),y
002B32  3  F0 03                beq *+5
002B34  3  4C 54 2B             jmp e00112
002B37  3  20 E9 1D             jsr cangl
002B3A  3  F0 03                beq :+
002B3C  3  4C 4B 2B             jmp e00094
002B3F  3               :
002B3F  3  A0 09                ldy #9
002B41  3  B1 rr                lda (z80_ix),y
002B43  3  38                   sec
002B44  3  E9 02                sbc #2
002B46  3  91 rr                sta (z80_ix),y
002B48  3  4C 51 2B             jmp e00108
002B4B  3  A9 01        e00094: lda #1
002B4D  3  A0 0B                ldy #11
002B4F  3  91 rr                sta (z80_ix),y
002B51  3  4C 6E 2B     e00108: jmp e00166
002B54  3  20 FB 1D     e00112: jsr cangr
002B57  3  F0 03                beq :+
002B59  3  4C 68 2B             jmp e00153
002B5C  3               :
002B5C  3  A0 09                ldy #9
002B5E  3  B1 rr                lda (z80_ix),y
002B60  3  18                   clc
002B61  3  69 02                adc #2
002B63  3  91 rr                sta (z80_ix),y
002B65  3  4C 6E 2B             jmp e00166
002B68  3  A9 00        e00153: lda #0
002B6A  3  A0 0B                ldy #11
002B6C  3  91 rr                sta (z80_ix),y
002B6E  3  A9 00        e00166: lda #0
002B70  3  C5 rr                cmp vart
002B72  3  F0 03                beq *+5
002B74  3  4C AB 2B             jmp e00289
002B77  3  A0 0C                ldy #12
002B79  3  B1 rr                lda (z80_ix),y
002B7B  3  18                   clc
002B7C  3  69 01                adc #1
002B7E  3  A0 0C                ldy #12
002B80  3  91 rr                sta (z80_ix),y
002B82  3  A9 05                lda #5
002B84  3  A0 0C                ldy #12
002B86  3  D1 rr                cmp (z80_ix),y
002B88  3  90 03                bcc *+5
002B8A  3  4C 93 2B             jmp e00245
002B8D  3  A9 00                lda #0
002B8F  3  A0 0C                ldy #12
002B91  3  91 rr                sta (z80_ix),y
002B93  3  A0 0C        e00245: ldy #12
002B95  3  B1 rr                lda (z80_ix),y
002B97  3  C9 03                cmp #3
002B99  3  90 03                bcc *+5
002B9B  3  4C A6 2B             jmp e00280
002B9E  3  A9 00                lda #0
002BA0  3  20 A7 23             jsr animsp
002BA3  3  4C AB 2B             jmp e00289
002BA6  3  A9 00        e00280: lda #0
002BA8  3  20 CD 23             jsr animbk
002BAB  3  60           e00289: rts
002BAC  3               .out .sprintf("EVENT 4 SIZE = %d", (* - evnt04))
002BAC  3               
002BAC  3               evnt05:
002BAC  3  A9 00                lda #0
002BAE  3  85 rr                sta z80_b
002BB0  3  20 F2 23             jsr sktyp
002BB3  3  B0 03                bcs :+
002BB5  3  4C BC 2B             jmp f00032
002BB8  3               :
002BB8  3  A9 01                lda #1
002BBA  3  85 rr                sta deadf
002BBC  3  A9 00        f00032: lda #0
002BBE  3  C5 rr                cmp vart
002BC0  3  F0 03                beq *+5
002BC2  3  4C C6 2B             jmp f00051
002BC5  3  60                   rts
002BC6  3  A9 00        f00051: lda #0
002BC8  3  A0 0B                ldy #11
002BCA  3  D1 rr                cmp (z80_ix),y
002BCC  3  F0 03                beq *+5
002BCE  3  4C EE 2B             jmp f00132
002BD1  3  20 B4 1D             jsr cangd
002BD4  3  F0 03                beq :+
002BD6  3  4C E5 2B             jmp f00114
002BD9  3               :
002BD9  3  A0 08                ldy #8
002BDB  3  B1 rr                lda (z80_ix),y
002BDD  3  18                   clc
002BDE  3  69 02                adc #2
002BE0  3  91 rr                sta (z80_ix),y
002BE2  3  4C EB 2B             jmp f00127
002BE5  3  A9 01        f00114: lda #1
002BE7  3  A0 0B                ldy #11
002BE9  3  91 rr                sta (z80_ix),y
002BEB  3  4C 08 2C     f00127: jmp f00186
002BEE  3  20 7F 1D     f00132: jsr cangu
002BF1  3  F0 03                beq :+
002BF3  3  4C 02 2C             jmp f00172
002BF6  3               :
002BF6  3  A0 08                ldy #8
002BF8  3  B1 rr                lda (z80_ix),y
002BFA  3  38                   sec
002BFB  3  E9 02                sbc #2
002BFD  3  91 rr                sta (z80_ix),y
002BFF  3  4C 08 2C             jmp f00186
002C02  3  A9 00        f00172: lda #0
002C04  3  A0 0B                ldy #11
002C06  3  91 rr                sta (z80_ix),y
002C08  3  A9 01        f00186: lda #1
002C0A  3  C5 rr                cmp vart
002C0C  3  F0 03                beq *+5
002C0E  3  4C 45 2C             jmp f00309
002C11  3  A0 0C                ldy #12
002C13  3  B1 rr                lda (z80_ix),y
002C15  3  18                   clc
002C16  3  69 01                adc #1
002C18  3  A0 0C                ldy #12
002C1A  3  91 rr                sta (z80_ix),y
002C1C  3  A9 05                lda #5
002C1E  3  A0 0C                ldy #12
002C20  3  D1 rr                cmp (z80_ix),y
002C22  3  90 03                bcc *+5
002C24  3  4C 2D 2C             jmp f00265
002C27  3  A9 00                lda #0
002C29  3  A0 0C                ldy #12
002C2B  3  91 rr                sta (z80_ix),y
002C2D  3  A0 0C        f00265: ldy #12
002C2F  3  B1 rr                lda (z80_ix),y
002C31  3  C9 03                cmp #3
002C33  3  90 03                bcc *+5
002C35  3  4C 40 2C             jmp f00300
002C38  3  A9 00                lda #0
002C3A  3  20 A7 23             jsr animsp
002C3D  3  4C 45 2C             jmp f00309
002C40  3  A9 00        f00300: lda #0
002C42  3  20 CD 23             jsr animbk
002C45  3  60           f00309: rts
002C46  3               .out .sprintf("EVENT 5 SIZE = %d", (* - evnt05))
002C46  3               
002C46  3               evnt06:
002C46  3  20 A2 25             jsr ifall
002C49  3  20 D3 1F             jsr jump
002C4C  3  A9 00                lda #0
002C4E  3  A0 0B                ldy #11
002C50  3  D1 rr                cmp (z80_ix),y
002C52  3  F0 03                beq *+5
002C54  3  4C 74 2C             jmp g00091
002C57  3  20 FB 1D             jsr cangr
002C5A  3  F0 03                beq :+
002C5C  3  4C 6B 2C             jmp g00073
002C5F  3               :
002C5F  3  A0 09                ldy #9
002C61  3  B1 rr                lda (z80_ix),y
002C63  3  18                   clc
002C64  3  69 02                adc #2
002C66  3  91 rr                sta (z80_ix),y
002C68  3  4C 71 2C             jmp g00086
002C6B  3  A9 01        g00073: lda #1
002C6D  3  A0 0B                ldy #11
002C6F  3  91 rr                sta (z80_ix),y
002C71  3  4C 8E 2C     g00086: jmp g00145
002C74  3  20 E9 1D     g00091: jsr cangl
002C77  3  F0 03                beq :+
002C79  3  4C 88 2C             jmp g00131
002C7C  3               :
002C7C  3  A0 09                ldy #9
002C7E  3  B1 rr                lda (z80_ix),y
002C80  3  38                   sec
002C81  3  E9 02                sbc #2
002C83  3  91 rr                sta (z80_ix),y
002C85  3  4C 8E 2C             jmp g00145
002C88  3  A9 00        g00131: lda #0
002C8A  3  A0 0B                ldy #11
002C8C  3  91 rr                sta (z80_ix),y
002C8E  3  4C 0E 25     g00145: jmp grav
002C91  3               .out .sprintf("EVENT 6 SIZE = %d", (* - evnt06))
002C91  3               
002C91  3               evnt07:
002C91  3  60                   rts
002C92  3               .out .sprintf("EVENT 7 SIZE = %d", (* - evnt07))
002C92  3               
002C92  3               evnt08:
002C92  3  A9 00                lda #0
002C94  3  C5 rr                cmp vare
002C96  3  F0 03                beq *+5
002C98  3  4C 9F 2C             jmp i00026
002C9B  3  60                   rts
002C9C  3  4C B9 2C             jmp i00078
002C9F  3  A9 01        i00026: lda #1
002CA1  3  A0 07                ldy #7
002CA3  3  91 rr                sta (z80_ix),y
002CA5  3  A9 00                lda #0
002CA7  3  85 rr                sta z80_b
002CA9  3  20 F2 23             jsr sktyp
002CAC  3  B0 03                bcs :+
002CAE  3  4C B9 2C             jmp i00078
002CB1  3               :
002CB1  3  A9 01                lda #1
002CB3  3  85 rr                sta vara
002CB5  3  A9 01                lda #1
002CB7  3  85 rr                sta nexlev
002CB9  3  60           i00078: rts
002CBA  3               .out .sprintf("EVENT 8 SIZE = %d", (* - evnt08))
002CBA  3               
002CBA  3               evnt09:
002CBA  3  A9 00                lda #0
002CBC  3  A0 05                ldy #5
002CBE  3  D1 rr                cmp (z80_ix),y
002CC0  3  F0 03                beq *+5
002CC2  3  4C D1 2C             jmp j00051
002CC5  3  A9 00                lda #0
002CC7  3  A0 0B                ldy #11
002CC9  3  91 rr                sta (z80_ix),y
002CCB  3  A9 00                lda #0
002CCD  3  A0 0C                ldy #12
002CCF  3  91 rr                sta (z80_ix),y
002CD1  3  60           j00051: rts
002CD2  3               .out .sprintf("EVENT 9 SIZE = %d", (* - evnt09))
002CD2  3               
002CD2  3               evnt10:
002CD2  3  A5 rr                lda vart
002CD4  3  18                   clc
002CD5  3  69 01                adc #1
002CD7  3  85 rr                sta vart
002CD9  3  A9 01                lda #1
002CDB  3  C5 rr                cmp vart
002CDD  3  90 03                bcc *+5
002CDF  3  4C E6 2C             jmp k00042
002CE2  3  A9 00                lda #0
002CE4  3  85 rr                sta vart
002CE6  3  60           k00042: rts
002CE7  3               .out .sprintf("EVENT 10 SIZE = %d", (* - evnt10))
002CE7  3               
002CE7  3               evnt11:
002CE7  3  A9 00                lda #0
002CE9  3  C5 rr                cmp scno
002CEB  3  F0 03                beq *+5
002CED  3  4C 3A 2D             jmp l00158
002CF0  3  A9 01                lda #1
002CF2  3  C5 rr                cmp varm
002CF4  3  F0 03                beq *+5
002CF6  3  4C 3A 2D             jmp l00158
002CF9  3  A9 02                lda #2
002CFB  3  85 rr                sta chary
002CFD  3  A9 0C                lda #12
002CFF  3  85 rr                sta charx
002D01  3  A9 01                lda #1
002D03  3  85 rr                sta prtmod
002D05  3  A9 00                lda #0
002D07  3  20 34 20             jsr dmsg
002D0A  3  A9 00                lda #0
002D0C  3  85 rr                sta prtmod
002D0E  3  A9 06                lda #6
002D10  3  85 rr                sta chary
002D12  3  A9 06                lda #6
002D14  3  85 rr                sta charx
002D16  3  A9 01                lda #1
002D18  3  20 34 20             jsr dmsg
002D1B  3  A9 06                lda #6
002D1D  3  85 rr                sta charx
002D1F  3  A9 02                lda #2
002D21  3  20 34 20             jsr dmsg
002D24  3  A9 0C                lda #12
002D26  3  85 rr                sta charx
002D28  3  A9 03                lda #3
002D2A  3  20 34 20             jsr dmsg
002D2D  3  A9 06                lda #6
002D2F  3  85 rr                sta charx
002D31  3  A9 04                lda #4
002D33  3  20 34 20             jsr dmsg
002D36  3  A9 00                lda #0
002D38  3  85 rr                sta varm
002D3A  3  A9 07        l00158: lda #7
002D3C  3  C5 rr                cmp scno
002D3E  3  F0 03                beq *+5
002D40  3  4C 4D 2D             jmp l00197
002D43  3  A5 rr                lda clock
002D45  3  85 rr                sta vara
002D47  3  A5 rr                lda clock
002D49  3  0A                   asl a
002D4A  3  8D 2A 0F             sta sndtyp
002D4D  3  60           l00197: rts
002D4E  3               .out .sprintf("EVENT 11 SIZE = %d", (* - evnt11))
002D4E  3               
002D4E  3               evnt12:
002D4E  3  60                   rts
002D4F  3               .out .sprintf("EVENT 12 SIZE = %d", (* - evnt12))
002D4F  3               
002D4F  3               evnt13:
002D4F  3  A9 01                lda #1
002D51  3  85 rr                sta varm
002D53  3  A9 63                lda #99
002D55  3  85 rr                sta numlif
002D57  3  20 97 16             jsr cls
002D5A  3  60                   rts
002D5B  3               .out .sprintf("EVENT 13 SIZE = %d", (* - evnt13))
002D5B  3               
002D5B  3               evnt14:
002D5B  3  A9 00                lda #0
002D5D  3  85 rr                sta vara
002D5F  3  A9 00                lda #0
002D61  3  85 rr                sta vare
002D63  3  A9 00                lda #0
002D65  3  85 rr                sta vars
002D67  3  60                   rts
002D68  3               .out .sprintf("EVENT 14 SIZE = %d", (* - evnt14))
002D68  3               
002D68  3               evnt15:
002D68  3  60                   rts
002D69  3               .out .sprintf("EVENT 15 SIZE = %d", (* - evnt15))
002D69  3               
002D69  3               evnt16:
002D69  3  A9 C8                lda #200
002D6B  3  0A                   asl a
002D6C  3  8D 2A 0F             sta sndtyp
002D6F  3  60                   rts
002D70  3               .out .sprintf("EVENT 16 SIZE = %d", (* - evnt16))
002D70  3               
002D70  3               evnt17:
002D70  3  A9 32                lda #50
002D72  3  20 F7 0E             jsr delay
002D75  3  60                   rts
002D76  3               .out .sprintf("EVENT 17 SIZE = %d", (* - evnt17))
002D76  3               
002D76  3               evnt18:
002D76  3  A9 32                lda #50
002D78  3  20 F7 0E             jsr delay
002D7B  3  60                   rts
002D7C  3               .out .sprintf("EVENT 18 SIZE = %d", (* - evnt18))
002D7C  3               
002D7C  3               evnt19:
002D7C  3  60                   rts
002D7D  3               .out .sprintf("EVENT 19 SIZE = %d", (* - evnt19))
002D7D  3               
002D7D  3               evnt20:
002D7D  3  60                   rts
002D7E  3               .out .sprintf("EVENT 20 SIZE = %d", (* - evnt20))
002D7E  3               
002D7E  3  60           ptcusr: rts
002D7F  3               script_end:
002D7F  3               
002D7F  3               .out .sprintf("TOTAL SCRIPT SIZE = %d", (* - script_start))
002D7F  3               
002D7F  3               data_start:
002D7F  3               msgdat:
002D7F  3  44 4F 4F 44          .byte "DOODLEBUG!",141
002D83  3  4C 45 42 55  
002D87  3  47 21 8D     
002D8A  3  47 4F 20 54          .byte "GO TO THE GREEN TICK",141
002D8E  3  4F 20 54 48  
002D92  3  45 20 47 52  
002D9F  3  54 48 45 4E          .byte "THEN GO TO THE EXIT.",141
002DA3  3  20 47 4F 20  
002DA7  3  54 4F 20 54  
002DB4  3  53 49 4D 50          .byte "SIMPLES!",141
002DB8  3  4C 45 53 21  
002DBC  3  8D           
002DBD  3  4B 45 59 53          .byte "KEYS: OP (Z-Pause)",141
002DC1  3  3A 20 4F 50  
002DC5  3  20 28 5A 2D  
002DD0  3               nummsg:
002DD0  3  05                   .byte 5
002DD1  3               .out .sprintf("MESSAGE SIZE = %d", (* - msgdat))
002DD1  3               
002DD1  3               chgfx:
002DD1  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002DD5  3  00 00 00 00  
002DD9  3  FF 00 FF 00          .byte 255,0,255,0,255,0,255,0
002DDD  3  FF 00 FF 00  
002DE1  3  AA AA AA AA          .byte 170,170,170,170,170,170,170,170
002DE5  3  AA AA AA AA  
002DE9  3  AA 2A EA 0A          .byte 170,42,234,10,250,2,254,0
002DED  3  FA 02 FE 00  
002DF1  3  FF 80 FF E0          .byte 255,128,255,224,255,240,255,252
002DF5  3  FF F0 FF FC  
002DF9  3  FF BF BF AF          .byte 255,191,191,175,175,171,171,170
002DFD  3  AF AB AB AA  
002E01  3  00 00 18 FC          .byte 0,0,24,252,252,24,0,0
002E05  3  FC 18 00 00  
002E09  3  02 02 00 00          .byte 2,2,0,0,2,2,0,0
002E0D  3  02 02 00 00  
002E11  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002E15  3  00 00 00 00  
002E19  3  FE 82 AA 96          .byte 254,130,170,150,254,0,0,0
002E1D  3  FE 00 00 00  
002E21  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002E25  3  00 00 00 00  
002E29  3  FE 82 FE 00          .byte 254,130,254,0,239,40,239,0
002E2D  3  EF 28 EF 00  
002E31  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
002E35  3  00 00 00 00  
002E39  3  00 00 01 02          .byte 0,0,1,2,4,136,80,32
002E3D  3  04 88 50 20  
002E41  3  82 64 14 18          .byte 130,100,20,24,36,66,194,0
002E45  3  24 42 C2 00  
002E49  3  AA 55 AA 55          .byte 170,85,170,85,170,85,170,85
002E4D  3  AA 55 AA 55  
002E51  3               bcol:
002E51  3  78                   .byte 120
002E52  3  78                   .byte 120
002E53  3  78                   .byte 120
002E54  3  78                   .byte 120
002E55  3  78                   .byte 120
002E56  3  78                   .byte 120
002E57  3  78                   .byte 120
002E58  3  7D                   .byte 125
002E59  3  7D                   .byte 125
002E5A  3  78                   .byte 120
002E5B  3  78                   .byte 120
002E5C  3  78                   .byte 120
002E5D  3  78                   .byte 120
002E5E  3  7C                   .byte 124
002E5F  3  7A                   .byte 122
002E60  3  47                   .byte 71
002E61  3               bprop:
002E61  3  00                   .byte 0
002E62  3  02                   .byte 2
002E63  3  02                   .byte 2
002E64  3  02                   .byte 2
002E65  3  02                   .byte 2
002E66  3  02                   .byte 2
002E67  3  02                   .byte 2
002E68  3  02                   .byte 2
002E69  3  00                   .byte 0
002E6A  3  01                   .byte 1
002E6B  3  01                   .byte 1
002E6C  3  02                   .byte 2
002E6D  3  02                   .byte 2
002E6E  3  06                   .byte 6
002E6F  3  05                   .byte 5
002E70  3  00                   .byte 0
002E71  3               .out .sprintf("BLOCKS SIZE = %d", (* - chgfx))
002E71  3               
002E71  3               sprgfx:
002E71  3  01 80 06 60          .byte 1,128,6,96,24,24,32,4,38,4,79,2,79,2,134,1,128,1,64,2,64,2,32,4,32,4,24,24,6,96,1,128
002E75  3  18 18 20 04  
002E79  3  26 04 4F 02  
002E91  3  00 00 07 E0          .byte 0,0,7,224,24,24,32,4,32,4,70,2,79,2,143,1,134,1,128,1,64,2,64,2,64,2,48,12,12,48,3,192
002E95  3  18 18 20 04  
002E99  3  20 04 46 02  
002EB1  3  00 00 00 00          .byte 0,0,0,0,7,224,24,24,32,4,64,2,70,2,143,1,143,1,134,1,128,1,64,2,64,2,32,4,24,24,7,224
002EB5  3  07 E0 18 18  
002EB9  3  20 04 40 02  
002ED1  3  00 00 00 00          .byte 0,0,0,0,0,0,7,240,24,12,32,2,64,2,134,1,143,1,143,1,134,1,128,1,64,2,64,2,48,12,15,240
002ED5  3  00 00 07 F0  
002ED9  3  18 0C 20 02  
002EF1  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,199,227,224,7,232,23,48,12
002EF5  3  20 04 40 02  
002EF9  3  8C 31 9E 79  
002F11  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,71,226,224,7,116,46,56,28
002F15  3  20 04 40 02  
002F19  3  8C 31 9E 79  
002F31  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,71,226,112,14,58,92,28,56
002F35  3  20 04 40 02  
002F39  3  8C 31 9E 79  
002F51  3  07 E0 18 18          .byte 7,224,24,24,32,4,64,2,140,49,158,121,190,125,186,93,154,89,76,50,32,4,88,26,103,230,56,28,29,184,14,112
002F55  3  20 04 40 02  
002F59  3  8C 31 9E 79  
002F71  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,64,2,128,1,129,129,66,194,67,194,129,129,128,1,64,2,64,2,32,4,25,152,6,96
002F75  3  20 04 40 02  
002F79  3  40 02 80 01  
002F91  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,64,2,129,129,130,193,69,226,71,226,131,193,129,129,64,2,64,2,32,4,25,152,6,96
002F95  3  20 04 40 02  
002F99  3  40 02 81 81  
002FB1  3  06 60 19 98          .byte 6,96,25,152,32,4,64,2,65,130,135,225,132,225,76,242,79,242,135,225,135,225,65,130,64,2,32,4,25,152,6,96
002FB5  3  20 04 40 02  
002FB9  3  41 82 87 E1  
002FD1  3  06 60 19 98          .byte 6,96,25,152,32,4,67,194,79,242,140,241,152,121,88,122,92,250,159,249,143,241,79,242,67,194,32,4,25,152,6,96
002FD5  3  20 04 43 C2  
002FD9  3  4F F2 8C F1  
002FF1  3  18 00 7C 00          .byte 24,0,124,0,98,0,209,0,232,128,84,64,42,32,21,16,10,152,5,108,2,194,1,130,0,134,0,78,0,63,0,3
002FF5  3  62 00 D1 00  
002FF9  3  E8 80 54 40  
003011  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003015  3  00 00 00 00  
003019  3  00 00 00 00  
003031  3  FE C3 F0 E7          .byte 254,195,240,231,252,102,240,60,240,60,240,102,254,231,254,195,0,0,254,255,56,60,56,60,56,60,56,60,56,60,254,60
003035  3  FC 66 F0 3C  
003039  3  F0 3C F0 66  
003051  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003055  3  00 00 00 00  
003059  3  00 00 00 00  
003071  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
003075  3  00 00 00 00  
003079  3  00 00 00 00  
003091  3               frmlst:
003091  3  00 04                .byte 0,4
003093  3  04 04                .byte 4,4
003095  3  08 04                .byte 8,4
003097  3  0C 01                .byte 12,1
003099  3  0D 02                .byte 13,2
00309B  3  0F 02 11 00          .byte 15,2,17,0
00309F  3               .out .sprintf("SPRITES SIZE = %d", (* - sprgfx))
00309F  3               
00309F  3               scdat:
00309F  3  13 01 B5 00          .word 275,181,221,221,297,270,248,361
0030A3  3  DD 00 DD 00  
0030A7  3  29 01 0E 01  
0030AF  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,6,255,12,17,255,0,6,2,6,7,255,0,6
0030B3  3  1D 05 00 07  
0030B7  3  FF 00 1D 02  
0030D2  3  0C FF 00 0F          .byte 12,255,0,15,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12
0030D6  3  0C FF 00 06  
0030DA  3  02 00 07 FF  
0030F3  3  FF 00 06 02          .byte 255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0
0030F7  3  00 07 FF 00  
0030FB  3  06 0C FF 00  
003114  3  07 FF 00 06          .byte 7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0,7,255,0,6,12
003118  3  0C FF 00 0F  
00311C  3  0C FF 00 06  
003135  3  FF 00 0F 0C          .byte 255,0,15,12,255,0,6,2,6,7,255,0,6,12,255,0,15,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6
003139  3  FF 00 06 02  
00313D  3  06 07 FF 00  
003158  3  02 06 07 FF          .byte 2,6,7,255,0,6,12,255,0,13,13,0,12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7
00315C  3  00 06 0C FF  
003160  3  00 0D 0D 00  
003179  3  FF 00 06 0C          .byte 255,0,6,12,255,11,15,12,255,0,6,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,0
00317D  3  FF 0B 0F 0C  
003181  3  FF 00 06 02  
00319A  3  0E 00 0E 00          .byte 14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,14,0,2,0,7,255,0,29
00319E  3  0E 00 0E 00  
0031A2  3  0E 00 0E 00  
0031BC  3  02 04 FF 01          .byte 2,4,255,1,30,3
0031C0  3  1E 03        
0031C2  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,13,13,255,0,15,2,0,7,255,0,29,2,6,7,255,0,29
0031C6  3  1D 05 00 07  
0031CA  3  FF 00 1D 02  
0031E3  3  02 00 07 FF          .byte 2,0,7,255,0,11,255,9,9,255,0,9,2,6,7,255,0,22,9,9,255,0,5,2,0,7,255,0,29,2,6,7,255,0,29
0031E7  3  00 0B FF 09  
0031EB  3  09 FF 00 09  
003206  3  02 00 07 00          .byte 2,0,7,0,9,9,0,0,0,255,11,18,255,0,5,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,0,9,9
00320A  3  09 09 00 00  
00320E  3  00 FF 0B 12  
003227  3  FF 00 1A 02          .byte 255,0,26,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,11,19,0,0,0,9,9,255,0,5,2
00322B  3  00 07 FF 00  
00322F  3  1A 09 09 00  
003248  3  06 07 FF 00          .byte 6,7,255,0,26,9,9,0,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29
00324C  3  1A 09 09 00  
003250  3  02 00 07 FF  
00326B  3  02 00 07 FF          .byte 2,0,7,255,0,29,2,4,255,1,30,3
00326F  3  00 1D 02 04  
003273  3  FF 01 1E 03  
003277  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29
00327B  3  1D 05 00 07  
00327F  3  FF 00 1D 02  
00329A  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,5,14,0,0,0,14,255,0,4,14,255,0,14,2,6,7,255,9,19,11,0,0
00329E  3  00 1D 02 00  
0032A2  3  07 FF 00 05  
0032BB  3  0B 09 09 09          .byte 11,9,9,9,0,0,0,2,0,7,255,0,19,11,0,0,11,255,0,6,2,6,7,9,9,255,0,15,13,0,11,0,0
0032BF  3  00 00 00 02  
0032C3  3  00 07 FF 00  
0032DC  3  0B FF 00 06          .byte 11,255,0,6,2,0,7,255,0,19,11,0,0,11,255,0,6,2,6,7,255,0,19,255,11,4,255,0,6,2,0,7,9,9
0032E0  3  02 00 07 FF  
0032E4  3  00 13 0B 00  
0032FE  3  00 00 00 FF          .byte 0,0,0,255,9,18,255,0,6,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,9,9,255,0,27,2,0,7,255,0,29
003302  3  09 12 FF 00  
003306  3  06 02 06 07  
003321  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,9,9,255,0,27,2,6,7,255,0,29,2,0,7,255,0,5,14,255,0,4,14,255,0,4
003325  3  00 1D 02 00  
003329  3  07 09 09 FF  
003343  3  0E FF 00 04          .byte 14,255,0,4,14,255,0,5,14,14,14,2,4,255,1,30,3
003347  3  0E FF 00 05  
00334B  3  0E 0E 0E 02  
003354  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,0,13,255,0,27,2,0,7,255,0,29,2,6,7,255,0,29,2,0
003358  3  1D 05 00 07  
00335C  3  FF 00 1D 02  
003375  3  07 09 09 09          .byte 7,9,9,9,255,0,26,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,9,6,0,0,9,9,255,0,4,9,9
003379  3  FF 00 1A 02  
00337D  3  06 07 FF 00  
003397  3  00 00 09 09          .byte 0,0,9,9,0,0,0,9,9,255,0,4,2,0,7,255,0,29,2,6,7,255,0,26,9,9,0,2,0,7,255,0,29
00339B  3  00 00 00 09  
00339F  3  09 FF 00 04  
0033B8  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,6
0033BC  3  00 1D 02 00  
0033C0  3  07 FF 00 1A  
0033D9  3  0B 0B FF 00          .byte 11,11,255,0,8,11,11,255,0,8,11,11,0,2,0,7,255,0,6,11,11,255,0,8,11,11,255,0,8,11,11,0,2
0033DD  3  08 0B 0B FF  
0033E1  3  00 08 0B 0B  
0033FA  3  06 07 00 0B          .byte 6,7,0,11,11,255,0,8,11,11,255,0,8,11,11,255,0,6,2,0,7,0,11,11,255,0,8,11,11,255,0,8,11,11
0033FE  3  0B FF 00 08  
003402  3  0B 0B FF 00  
00341C  3  FF 00 06 02          .byte 255,0,6,2,6,7,255,0,29,2,0,7,255,14,29,2,4,255,1,30,3
003420  3  06 07 FF 00  
003424  3  1D 02 00 07  
003431  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,17,11,255,0,11,2,6,7,255,0,17,11,255,0,11,2,0,7,255,0,17,11,255,0,11
003435  3  1D 05 00 07  
003439  3  FF 00 11 0B  
003454  3  02 06 07 FF          .byte 2,6,7,255,0,14,255,11,4,255,0,11,2,0,7,255,0,12,11,11,11,255,0,7,9,9,0,0,0,9,9,2,6
003458  3  00 0E FF 0B  
00345C  3  04 FF 00 0B  
003475  3  07 FF 00 06          .byte 7,255,0,6,255,11,7,255,0,16,2,0,7,255,0,29,2,6,7,255,0,27,9,9,2,0,7,255,0,29,2,6,7
003479  3  FF 0B 07 FF  
00347D  3  00 10 02 00  
003496  3  FF 00 0A FF          .byte 255,0,10,255,9,5,0,0,0,9,9,11,0,0,0,11,11,0,0,0,2,0,7,255,0,12,11,255,0,7,11,255,0,6
00349A  3  09 05 00 00  
00349E  3  00 09 09 0B  
0034B8  3  09 09 02 06          .byte 9,9,2,6,7,255,0,12,11,255,0,7,11,255,0,8,2,0,7,255,0,10,9,9,11,9,9,0,0,0,9,9,11
0034BC  3  07 FF 00 0C  
0034C0  3  0B FF 00 07  
0034D9  3  FF 00 08 02          .byte 255,0,8,2,6,7,255,0,12,11,255,0,7,11,255,0,6,9,9,2,0,7,255,0,12,11,255,0,7,11,255,0,8
0034DD  3  06 07 FF 00  
0034E1  3  0C 0B FF 00  
0034FA  3  02 06 07 FF          .byte 2,6,7,255,0,10,9,9,11,9,9,0,0,0,9,9,11,255,0,8,2,0,7,14,255,0,7,14,0,0,0,11,255,0,7
0034FE  3  00 0A 09 09  
003502  3  0B 09 09 00  
00351D  3  0B 09 09 FF          .byte 11,9,9,255,0,4,9,9,2,6,7,255,11,13,255,0,7,11,255,0,8,2,0,7,255,0,18,9,9,11,255,0,8
003521  3  00 04 09 09  
003525  3  02 06 07 FF  
00353E  3  02 06 07 00          .byte 2,6,7,0,13,255,0,18,14,255,0,8,2,0,7,255,0,20,14,255,0,8,2,4,255,1,30,3
003542  3  0D FF 00 12  
003546  3  0E FF 00 08  
00355A  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,9,0,0,0,255,11,21
00355E  3  1D 05 00 07  
003562  3  FF 00 1D 02  
00357B  3  09 09 09 00          .byte 9,9,9,0,2,0,7,14,0,0,0,14,11,255,0,18,11,255,0,4,2,6,7,14,0,0,0,14,11,255,0,18,11
00357F  3  02 00 07 0E  
003583  3  00 00 00 0E  
00359C  3  FF 00 04 02          .byte 255,0,4,2,0,7,14,0,0,0,14,11,255,0,18,11,0,9,9,0,2,6,7,14,255,0,4,11,0,13,255,0,16
0035A0  3  00 07 0E 00  
0035A4  3  00 00 0E 0B  
0035BD  3  0B FF 00 04          .byte 11,255,0,4,2,0,7,14,255,0,4,11,255,0,18,11,255,0,4,2,6,7,14,255,0,4,11,255,0,18,11,0,9,9
0035C1  3  02 00 07 0E  
0035C5  3  FF 00 04 0B  
0035DF  3  00 02 00 07          .byte 0,2,0,7,14,255,0,4,11,255,9,4,255,0,4,255,9,5,255,0,5,11,255,0,4,2,6,7,14,255,0,21,9,9
0035E3  3  0E FF 00 04  
0035E7  3  0B FF 09 04  
003601  3  0B FF 00 04          .byte 11,255,0,4,2,0,7,14,255,0,23,11,0,9,9,0,2,6,7,14,255,0,23,11,255,0,4,2,0,7,255,0,4
003605  3  02 00 07 0E  
003609  3  FF 00 17 0B  
003622  3  FF 0B 15 FF          .byte 255,11,21,255,0,4,2,6,7,255,0,9,14,255,0,9,14,255,0,6,9,9,0,2,0,7,255,0,29,2,6,7,255,0,29
003626  3  00 04 02 06  
00362A  3  07 FF 00 09  
003645  3  02 00 07 FF          .byte 2,0,7,255,0,26,9,9,0,2,6,7,255,0,29,2,0,7,255,0,4,14,255,0,9,14,255,0,14,2,4,255,1,30
003649  3  00 1A 09 09  
00364D  3  00 02 06 07  
003667  3  03                   .byte 3
003668  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,255,0,29,2,0,7,11,11,255,0,14,13,255,0,12,2,6,7,255,0,29
00366C  3  1D 05 00 07  
003670  3  FF 00 1D 02  
00368B  3  02 00 07 FF          .byte 2,0,7,255,0,29,2,6,7,255,0,7,14,0,0,0,14,0,0,0,14,255,0,13,2,0,7,9,9,9,255,11,21
00368F  3  00 1D 02 06  
003693  3  07 FF 00 07  
0036AC  3  FF 00 05 02          .byte 255,0,5,2,6,7,9,9,9,255,0,20,11,255,0,5,2,0,7,255,0,23,11,255,0,5,2,6,7,9,9,255,0,21
0036B0  3  06 07 09 09  
0036B4  3  09 FF 00 14  
0036CE  3  0B FF 00 05          .byte 11,255,0,5,2,0,7,255,0,23,11,255,0,5,2,6,7,9,9,255,0,21,11,255,0,5,2,0,7,255,0,23,11
0036D2  3  02 00 07 FF  
0036D6  3  00 17 0B FF  
0036EF  3  FF 00 05 02          .byte 255,0,5,2,6,7,0,0,0,9,9,255,0,4,9,9,255,0,4,9,9,255,0,4,9,9,11,255,0,5,2,0,7
0036F3  3  06 07 00 00  
0036F7  3  00 09 09 FF  
003710  3  FF 00 17 0B          .byte 255,0,23,11,255,0,5,2,6,7,255,0,23,11,255,0,5,2,0,7,255,0,21,9,9,11,255,0,5,2,6,7,0,0,0
003714  3  FF 00 05 02  
003718  3  06 07 FF 00  
003733  3  09 09 FF 00          .byte 9,9,255,0,4,9,9,255,0,4,9,9,255,0,12,2,0,7,9,9,255,0,27,2,6,7,255,0,29,2,0,7,255,0,10
003737  3  04 09 09 FF  
00373B  3  00 04 09 09  
003756  3  0E FF 00 12          .byte 14,255,0,18,2,4,255,1,30,3
00375A  3  02 04 FF 01  
00375E  3  1E 03        
003760  3  00 07 FF 0C          .byte 0,7,255,12,29,5,0,7,255,0,29,2,6,7,0,0,15,0,0,0,15,0,15,15,15,0,15,0,0,0,15,255,0,12
003764  3  1D 05 00 07  
003768  3  FF 00 1D 02  
003782  3  02 00 07 00          .byte 2,0,7,0,0,15,0,0,0,15,12,15,12,12,12,15,12,12,12,15,255,12,6,255,0,6,2,6,7,0,0,15,0
003786  3  00 0F 00 00  
00378A  3  00 0F 0C 0F  
0037A3  3  0F 00 0F 00          .byte 15,0,15,0,15,15,0,0,15,0,0,0,15,255,0,5,12,255,0,6,2,0,7,0,0,15,0,15,0,15,0,15,0,0,0
0037A7  3  0F 0F 00 00  
0037AB  3  0F 00 00 00  
0037C6  3  0F 00 00 00          .byte 15,0,0,0,15,255,0,5,12,255,0,6,2,6,7,0,0,255,15,5,0,15,15,15,0,15,15,15,0,15,15,15,0,0,0
0037CA  3  0F FF 00 05  
0037CE  3  0C FF 00 06  
0037E9  3  0C FF 00 06          .byte 12,255,0,6,2,0,7,255,0,6,12,255,0,15,12,255,0,6,2,6,7,255,0,4,15,15,15,0,0,255,15,4,0
0037ED  3  02 00 07 FF  
0037F1  3  00 06 0C FF  
00380A  3  0F 0F 0F 00          .byte 15,15,15,0,0,15,15,15,12,15,15,255,0,4,2,0,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0
00380E  3  00 0F 0F 0F  
003812  3  0C 0F 0F FF  
00382B  3  0F 00 0F 00          .byte 15,0,15,0,0,12,15,15,255,0,4,2,6,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0,15,0,15,15
00382F  3  00 0C 0F 0F  
003833  3  FF 00 04 02  
00384D  3  00 0C 0F 0F          .byte 0,12,15,15,255,0,4,2,0,7,255,0,4,15,0,12,15,0,15,0,0,15,0,15,0,0,15,0,15,0,0,12,255,0,6
003851  3  FF 00 04 02  
003855  3  00 07 FF 00  
003870  3  02 06 07 FF          .byte 2,6,7,255,0,4,15,15,15,0,0,255,15,4,0,15,0,0,15,0,15,15,15,12,15,15,255,0,4,2,0,7,255,0,29
003874  3  00 04 0F 0F  
003878  3  0F 00 00 FF  
003893  3  02 06 07 FF          .byte 2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7,255,0,29,2,6,7,255,0,29,2,0,7
003897  3  00 1D 02 00  
00389B  3  07 FF 00 1D  
0038B4  3  FF 00 1D 02          .byte 255,0,29,2,6,7,255,11,29,2,0,7,255,0,29,2,4,255,1,30,3
0038B8  3  06 07 FF 0B  
0038BC  3  1D 02 00 07  
0038C9  3               numsc:
0038C9  3  08                   .byte 8
0038CA  3               .out .sprintf("SCREENS SIZE = %d", (* - scdat))
0038CA  3               
0038CA  3               nmedat:
0038CA  3  00 00 68 50          .byte 0,0,104,80,8,4,104,80,255
0038CE  3  08 04 68 50  
0038D2  3  FF           
0038D3  3  00 00 88 20          .byte 0,0,136,32,1,1,48,224,2,2,160,176,8,4,144,24,2,2,104,88,2,1,56,136,255
0038D7  3  01 01 30 E0  
0038DB  3  02 02 A0 B0  
0038EC  3  00 00 10 18          .byte 0,0,16,24,1,3,72,176,2,2,160,32,8,4,144,224,255
0038F0  3  01 03 48 B0  
0038F4  3  02 02 A0 20  
0038FD  3  00 00 50 18          .byte 0,0,80,24,1,2,8,104,1,2,104,144,4,1,80,64,8,4,120,24,1,2,104,64,255
003901  3  01 02 08 68  
003905  3  01 02 68 90  
003916  3  00 00 08 88          .byte 0,0,8,136,3,2,160,80,4,1,56,136,8,4,16,168,1,2,32,40,1,3,104,208,255
00391A  3  03 02 A0 50  
00391E  3  04 01 38 88  
00392F  3  00 00 80 10          .byte 0,0,128,16,2,1,104,112,5,3,56,104,8,4,48,24,255
003933  3  02 01 68 70  
003937  3  05 03 38 68  
003940  3  00 00 30 E0          .byte 0,0,48,224,4,1,8,176,1,3,80,64,1,3,104,112,1,3,136,160,8,4,40,16,255
003944  3  04 01 08 B0  
003948  3  01 03 50 40  
003959  3  00 00 08 30          .byte 0,0,8,48,6,0,24,176,6,0,80,56,6,0,24,120,6,0,80,136,255
00395D  3  06 00 18 B0  
003961  3  06 00 50 38  
00396E  3               .out .sprintf("POSITIONS SIZE = %d", (* - nmedat))
00396E  3               
00396E  3               NUMOBJ = 1
00396E  3               objdta:
00396E  3  54 48 45 4E          .byte 84,72,69,78,32,71,79,32,84,79,32,84,72,69,32,69,88,73,84,46,13,83,73,77,80,76,69,83,0,0,0,0,254,56,120,254,56,120
003972  3  20 47 4F 20  
003976  3  54 4F 20 54  
003994  3               .out .sprintf("OBJECTS SIZE = %d", (* - objdta))
003994  3               
003994  3               font:
003994  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
003998  3  00 00 00 00  
00399C  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
0039A0  3  30 00 30 00  
0039A4  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
0039A8  3  00 00 00 00  
0039AC  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
0039B0  3  6C FE 6C 00  
0039B4  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0039B8  3  7E 1E 7E 18  
0039BC  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0039C0  3  30 6E CE 00  
0039C4  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0039C8  3  7E CC 7E 00  
0039CC  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0039D0  3  00 00 00 00  
0039D4  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0039D8  3  18 18 0C 00  
0039DC  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0039E0  3  30 30 60 00  
0039E4  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
0039E8  3  7E 18 3C 00  
0039EC  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
0039F0  3  7E 18 18 00  
0039F4  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
0039F8  3  00 18 18 30  
0039FC  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
003A00  3  7E 00 00 00  
003A04  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
003A08  3  00 38 38 00  
003A0C  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
003A10  3  18 30 60 00  
003A14  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
003A18  3  F6 E6 7C 00  
003A1C  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
003A20  3  18 18 7E 00  
003A24  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
003A28  3  7C C0 FE 00  
003A2C  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
003A30  3  06 C6 7C 00  
003A34  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
003A38  3  D8 FE 18 00  
003A3C  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
003A40  3  06 C6 7C 00  
003A44  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
003A48  3  C6 C6 7C 00  
003A4C  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
003A50  3  18 30 30 00  
003A54  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
003A58  3  C6 C6 7C 00  
003A5C  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
003A60  3  7E 06 7C 00  
003A64  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
003A68  3  00 00 30 00  
003A6C  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
003A70  3  00 30 30 60  
003A74  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
003A78  3  30 18 0C 00  
003A7C  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
003A80  3  00 7E 00 00  
003A84  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
003A88  3  0C 18 30 00  
003A8C  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
003A90  3  18 00 18 00  
003A94  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
003A98  3  FE C0 7C 00  
003A9C  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
003AA0  3  FE C6 C6 00  
003AA4  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
003AA8  3  C6 C6 FC 00  
003AAC  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
003AB0  3  C0 C6 7C 00  
003AB4  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
003AB8  3  C6 CC F8 00  
003ABC  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
003AC0  3  C0 C0 FE 00  
003AC4  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
003AC8  3  C0 C0 C0 00  
003ACC  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
003AD0  3  DE C6 7C 00  
003AD4  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
003AD8  3  C6 C6 C6 00  
003ADC  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
003AE0  3  18 18 7E 00  
003AE4  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
003AE8  3  C6 C6 7C 00  
003AEC  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
003AF0  3  D8 CC C6 00  
003AF4  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
003AF8  3  C0 C0 FE 00  
003AFC  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
003B00  3  C6 C6 C6 00  
003B04  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
003B08  3  DE CE C6 00  
003B0C  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
003B10  3  C6 C6 7C 00  
003B14  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
003B18  3  FC C0 C0 00  
003B1C  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
003B20  3  F6 DE 7C 00  
003B24  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
003B28  3  FC CC C6 00  
003B2C  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
003B30  3  06 C6 7C 00  
003B34  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
003B38  3  30 30 30 00  
003B3C  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
003B40  3  C6 C6 7C 00  
003B44  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
003B48  3  C6 6C 38 00  
003B4C  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
003B50  3  C6 FE 6C 00  
003B54  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
003B58  3  38 6C C6 00  
003B5C  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
003B60  3  30 30 30 00  
003B64  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
003B68  3  30 60 FE 00  
003B6C  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
003B70  3  18 18 1E 00  
003B74  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
003B78  3  30 18 0C 00  
003B7C  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
003B80  3  30 30 F0 00  
003B84  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
003B88  3  30 30 30 00  
003B8C  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
003B90  3  00 00 00 FF  
003B94  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
003B98  3  60 60 FE 00  
003B9C  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
003BA0  3  7C CC 7C 00  
003BA4  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
003BA8  3  66 66 7C 00  
003BAC  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
003BB0  3  60 60 3C 00  
003BB4  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
003BB8  3  CC CC 7C 00  
003BBC  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
003BC0  3  F8 C0 7C 00  
003BC4  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
003BC8  3  30 30 30 00  
003BCC  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
003BD0  3  CC 7C 0C 78  
003BD4  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
003BD8  3  CC CC CC 00  
003BDC  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
003BE0  3  30 30 78 00  
003BE4  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
003BE8  3  0C 0C 6C 38  
003BEC  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
003BF0  3  70 78 6C 00  
003BF4  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
003BF8  3  30 30 1C 00  
003BFC  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
003C00  3  FC FC FC 00  
003C04  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
003C08  3  CC CC CC 00  
003C0C  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
003C10  3  CC CC 78 00  
003C14  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
003C18  3  CC F8 C0 C0  
003C1C  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
003C20  3  CC 7C 0C 0E  
003C24  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
003C28  3  60 60 60 00  
003C2C  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
003C30  3  78 0C F8 00  
003C34  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
003C38  3  30 30 1C 00  
003C3C  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
003C40  3  CC CC 78 00  
003C44  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
003C48  3  78 78 30 00  
003C4C  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
003C50  3  FC FC 78 00  
003C54  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
003C58  3  30 78 CC 00  
003C5C  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
003C60  3  CC 7C 0C 78  
003C64  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
003C68  3  30 60 FC 00  
003C6C  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
003C70  3  18 18 1E 00  
003C74  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
003C78  3  18 18 18 00  
003C7C  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
003C80  3  30 30 F0 00  
003C84  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
003C88  3  00 00 00 00  
003C8C  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
003C90  3  E3 BB C6 7C  
003C94  3               .out .sprintf("FONT SIZE = %d", (* - font))
003C94  3               
003C94  3               jtab:
003C94  3  F8 FA FC FE          .byte 248,250,252,254,254,255,255,255,0,0,0,1,1,1,2,2,4,6,8,8,8,99
003C98  3  FE FF FF FF  
003C9C  3  00 00 00 01  
003CAA  3  42 61 68 48  keys:   .byte 66,97,104,72,98,16,55,48,49,17,18
003CAE  3  62 10 37 30  
003CB2  3  31 11 12     
003CB5  3               .out .sprintf("KEYS SIZE = %d", (* - keys))
003CB5  3               
003CB5  3               data_end:
003CB5  3               .out .sprintf("TOTAL DATA SIZE = %d", (* - data_start))
003CB5  3               
003CB5  2               
003CB5  1               
003CB5  1               end_asm:
003CB5  1               
003CB5  1               ;----------------------------------------------------------------------
003CB5  1               ; RELOCATION OF BEEB CODE FROM LOAD ADDRESS
003CB5  1               ;----------------------------------------------------------------------
003CB5  1               
003CB5  1               relocate:
003CB5  1               ; Issue *TAPE otherwise DFS goes mental that we've overwritten workspace from &E00 - &1100
003CB5  1               
003CB5  1  A9 8C            lda #$8C
003CB7  1  A2 0C            ldx #$0C
003CB9  1  A0 00            ldy #$00
003CBB  1  20 F4 FF         jsr OSBYTE					; *FX &8C,0,0 - *TAPE 1200
003CBE  1               
003CBE  1  78           	sei
003CBF  1  A9 7F        	lda #$7f
003CC1  1  8D 4E FE     	sta $fe4e					; disable all interupts
003CC4  1  A9 82        	lda #$82
003CC6  1  8D 4E FE     	sta $fe4e					; enable vsync interupt only
003CC9  1  58           	cli
003CCA  1               
003CCA  1               ; Other one off initialisation could happen here...
003CCA  1               
003CCA  1               ; Relocate all code down to &E00
003CCA  1  A2 2F        	ldx #>(end_asm - start_asm) + 1
003CCC  1  A0 00        	ldy #0
003CCE  1               reloop:
003CCE  1  B9 00 12     	lda load_address, y
003CD1  1  99 00 0E     	sta asm_code, y
003CD4  1  C8           	iny
003CD5  1  D0 F7        	bne reloop
003CD7  1  EE D0 40     	inc reloop + 2 + load_address - asm_code
003CDA  1  EE D3 40     	inc reloop + 5 + load_address - asm_code
003CDD  1  CA           	dex
003CDE  1  D0 EE        	bne reloop
003CE0  1  4C 03 0E     	jmp boot_game
003CE0  1               
