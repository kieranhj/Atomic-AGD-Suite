ca65 V2.9.2 - (C) Copyright 1998-2000 Ullrich von Bassewitz
Main file   : game.asm
Current file: game.asm

000000r 1               ;----------------------------------------------
000000r 1               ; BBC AGD Engine
000000r 1               ; Z80 conversion by Kees van Oss 2017
000000r 1               ; BBC Micro version by Kieran Connell 2018
000000r 1               ;----------------------------------------------
000000r 1               
000000r 1               .DEFINE asm_code $0e00		; assembly address _BEEB
000000r 1               .DEFINE load_address $1200	; load address _BEEB
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; BBC MICRO PLATFORM DEFINES
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               ; _BEEB MOS calls
000000r 1               
000000r 1               	OSBYTE	 = $fff4
000000r 1               	OSFILE	 = $ffdd
000000r 1               	OSWRCH	 = $ffee
000000r 1               	OSASCI	 = $ffe3
000000r 1               	OSWORD	 = $fff1
000000r 1               	OSFIND	 = $ffce
000000r 1               	OSGBPB	 = $ffd1
000000r 1               	OSARGS	 = $ffda
000000r 1               
000000r 1               	PAL_black = 0 ^ 7
000000r 1               	PAL_white = 7 ^ 7
000000r 1               
000000r 1               ; System constants
000000r 1               
000000r 1               	ScreenSize  = $1800	; Startaddress video RAM _BEEB
000000r 1               	ScreenAddr 	= $8000 - ScreenSize	; Screen size bytes _BEEB
000000r 1               	ScreenRowBytes = 256				; 40 columns
000000r 1               
000000r 1               	SpriteMaxY	= 177	; used for clipping bottom of screen
000000r 1               
000000r 1               ; AGD Engine Workspace
000000r 1               
000000r 1               	MAP 		= $300				; properties map buffer (3x256 bytes)
000000r 1               	SCADTB_lb	= MAP + $300
000000r 1               	SCADTB_hb	= SCADTB_lb + $100
000000r 1               
000000r 1               .if pflag
000000r 1                   SHRAPN 		= $B00 - (NUMSHR * SHRSIZ)	; shrapnel table (55x6 bytes)
000000r 1               .endif
000000r 1               
000000r 1               	sprtab		= $B00				; NUMSPR*TABSIZ
000000r 1               
000000r 1               ;----------------------------------------------------------------------
000000r 1               ; ZERO PAGE SEGMENT
000000r 1               ;----------------------------------------------------------------------
000000r 1               
000000r 1               .segment "ZEROPAGE"
000000r 1               
000000r 1               .include "z80-zp.inc"
000000r 1               .include "engine-zp.inc"
000000r 2               ;ws	 = $60
000000r 2               
000000r 2  xx           z80_f: .res 1;	 = ws+$00
000001r 2  xx           z80_a: .res 1;	 = ws+$01
000002r 2               z80_af	 = z80_f
000002r 2               
000002r 2  xx           z80_c: .res 1;	 = ws+$02
000003r 2  xx           z80_b: .res 1;	 = ws+$03
000004r 2               z80_bc	 = z80_c
000004r 2               
000004r 2  xx           z80_e: .res 1;	 = ws+$04
000005r 2  xx           z80_d: .res 1;	 = ws+$05
000006r 2               z80_de	 = z80_e
000006r 2               
000006r 2  xx           z80_l: .res 1;	 = ws+$06
000007r 2  xx           z80_h: .res 1;	 = ws+$07
000008r 2               z80_hl	 = z80_l
000008r 2               
000008r 2  xx           z80_x: .res 1;    = ws+$08
000009r 2  xx           z80_i: .res 1;    = ws+$09
00000Ar 2               z80_ix	 = z80_x
00000Ar 2               
00000Ar 2  xx xx        z80_iy: .res 2;	 = ws+$0a
00000Cr 2               
00000Cr 2  xx           z80_fp: .res 1;	 = ws+$0c
00000Dr 2  xx           z80_ap: .res 1;	 = ws+$0d
00000Er 2               
00000Er 2  xx           z80_cp: .res 1;	 = ws+$0e
00000Fr 2  xx           z80_bp: .res 1;	 = ws+$0f
000010r 2               z80_bcp	 = z80_cp
000010r 2               
000010r 2  xx           z80_ep: .res 1;	 = ws+$10
000011r 2  xx           z80_dp: .res 1;	 = ws+$11
000012r 2               z80_dep	 = z80_ep
000012r 2               
000012r 2  xx           z80_lp: .res 1;	 = ws+$12
000013r 2  xx           z80_hp: .res 1;	 = ws+$13
000014r 2               z80_hlp	 = z80_lp
000014r 2               
000014r 2  xx xx        z80_sp: .res 2;   = ws+$14
000016r 2               
000016r 2  xx           z80_reg0: .res 1; = ws+$16
000017r 2  xx           z80_reg1: .res 1; = ws+$17
000018r 2  xx           z80_reg2: .res 1; = ws+$18
000019r 2  xx           z80_reg3: .res 1; = ws+$19
00001Ar 2               
00001Ar 2               ;z80_r: .res 1;	 = ws+$1a
00001Ar 2               
00001Ar 1               
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               ; AGD 6502 Engine Zero Page Variables
00001Ar 2               ;----------------------------------------------------------------------
00001Ar 2               
00001Ar 2               ; Variables start here.
00001Ar 2               
00001Ar 2  xx           scno:	.res 1			; present screen number.
00001Br 2  xx           numlif:	.res 1			; number of lives.
00001Cr 2               
00001Cr 2  xx           vara:	.res 1			; general-purpose variable.
00001Dr 2  xx           varb:	.res 1			; general-purpose variable.
00001Er 2  xx           varc:	.res 1			; general-purpose variable.
00001Fr 2  xx           vard:	.res 1			; general-purpose variable.
000020r 2  xx           vare:	.res 1			; general-purpose variable.
000021r 2  xx           varf:	.res 1			; general-purpose variable.
000022r 2  xx           varg:	.res 1			; general-purpose variable.
000023r 2  xx           varh:	.res 1			; general-purpose variable.
000024r 2  xx           vari:	.res 1			; general-purpose variable.
000025r 2  xx           varj:	.res 1			; general-purpose variable.
000026r 2  xx           vark:	.res 1			; general-purpose variable.
000027r 2  xx           varl:	.res 1			; general-purpose variable.
000028r 2  xx           varm:	.res 1			; general-purpose variable.
000029r 2  xx           varn:	.res 1			; general-purpose variable.
00002Ar 2  xx           varo:	.res 1			; general-purpose variable.
00002Br 2  xx           varp:	.res 1			; general-purpose variable.
00002Cr 2  xx           varq:	.res 1			; general-purpose variable.
00002Dr 2  xx           varr:	.res 1			; general-purpose variable.
00002Er 2  xx           vars:	.res 1			; general-purpose variable.
00002Fr 2  xx           vart:	.res 1			; general-purpose variable.
000030r 2  xx           varu:	.res 1			; general-purpose variable.
000031r 2  xx           varv:	.res 1			; general-purpose variable.
000032r 2  xx           varw:	.res 1			; general-purpose variable.
000033r 2  xx           varz:	.res 1			; general-purpose variable.
000034r 2               
000034r 2  xx           charx:	.res 1			; cursor x position.
000035r 2  xx           chary:	.res 1			; cursor y position.
000036r 2               
000036r 2  xx           clock:	.res 1			; last clock reading.
000037r 2  xx           varrnd:	.res 1	        ; last random number.
000038r 2  xx           varobj:	.res 1  	    ; last object number.
000039r 2  xx           varopt:	.res 1     		; last option chosen from menu.
00003Ar 2  xx           varblk:	.res 1  		; block type.
00003Br 2  xx           nexlev:	.res 1			; next level flag.
00003Cr 2  xx           restfl:	.res 1			; restart screen flag.
00003Dr 2  xx           deadf:	.res 1			; dead flag.
00003Er 2  xx           gamwon:	.res 1			; game won flag.
00003Fr 2  xx           dispx:	.res 1			; cursor x position.
000040r 2  xx           dispy:	.res 1			; cursor y position.
000041r 2               
000041r 2  xx           contrl:	.res 1			; control = keyboard, 1 = Kempston, 2 = Sinclair, 3 = Mouse.
000042r 2  xx           joyval:	.res 1			; joystick reading.
000043r 2  xx           frmno:	.res 1			; selected frame.
000044r 2               
000044r 2               ;----------------------------------------------------
000044r 2               ; Missing vars 
000044r 2               ;----------------------------------------------------
000044r 2               
000044r 2  xx           loopa:		.res 1
000045r 2  xx           loopb:		.res 1
000046r 2  xx           loopc:		.res 1
000047r 2  xx xx        FontPtr:    .res 2
000049r 2               
000049r 2               ; Local vars
000049r 2               
000049r 2  xx xx        scraddr:    .res 2
00004Br 2  xx xx        fntaddr:    .res 2
00004Dr 2  xx xx        tileaddr:   .res 2
00004Fr 2  xx xx        bufaddr:    .res 2
000051r 2               
000051r 2  xx xx        tmp:        .res 2
000053r 2  xx xx        scr_l:      .res 2
000055r 2  xx xx        scr_r:      .res 2
000057r 2  xx xx        scr_txt:    .res 2
000059r 2               
000059r 2  xx           xtmp:	    .res 1
00005Ar 2  xx           spcnt:	    .res 1
00005Br 2  xx xx        spptr:	    .res 2		; spawned sprite pointer.
00005Dr 2  xx           seed:	    .res 1		; seed for random numbers.
00005Er 2               
00005Er 2  xx           ccnt:       .res 1
00005Fr 2  xx           flag:	    .res 1
000060r 2  xx           rcol:	    .res 1
000061r 2  xx           rrow:	    .res 1
000062r 2               
000062r 2  xx           combyt:	    .res 1		; byte type compressed.
000063r 2  xx           comcnt:	    .res 1		; compression counter.
000064r 2  xx           prtmod:	    .res 1      ; print mode, 0 = standard, 1 = double-height.
000065r 2  xx           qscnt:	    .res 1
000066r 2               
000066r 2  xx           sprptr:	    .res 1      ; not a ptr
000067r 2  xx           sprcnt:	    .res 1
000068r 2               
000068r 2  xx xx        skptr:	    .res 2		; search pointer.
00006Ar 2  xx           sktptr:	    .res 1      ; not a ptr
00006Br 2  xx           tmproom:	.res 1
00006Cr 2  xx xx        ogptr:	    .res 2		; original sprite pointer.
00006Er 2               
00006Er 2               .if mflag
00006Er 2               TmpAddr:	.res 2
00006Er 2               bwid:	    .res 1     ; box/menu width.
00006Er 2               blen:	    .res 1     ; box/menu height.
00006Er 2               btop:	    .res 1     ; box coordinates.
00006Er 2               blft:	    .res 1
00006Er 2               .endif
00006Er 2               
00006Er 2               .if pflag
00006Er 2               shrctr:	    .res 1
00006Er 2               explcnt:	.res 1
00006Er 2               seed3:	    .res 1
00006Er 2               .endif
00006Er 2               
00006Er 1               ;----------------------------------------------------------------------
00006Er 1               ; ZCODE SEGMENT
00006Er 1               ;----------------------------------------------------------------------
00006Er 1               
00006Er 1               .segment "CODE"
000000r 1               .org asm_code
000E00  1               
000E00  1               start_asm:
000E00  1               
000E00  1  4C BE 2E     	jmp relocate + load_address - asm_code
000E03  1               
000E03  1               boot_game:
000E03  1               
000E03  1               ; Zero ZP vars
000E03  1               
000E03  1               clear_zp:
000E03  1  A2 00        	ldx #0
000E05  1  8A           	txa
000E06  1               	:
000E06  1  95 00        	sta $00, x
000E08  1  E8           	inx
000E09  1  E0 A0        	cpx #$a0
000E0B  1  D0 F9        	bne :-
000E0D  1               
000E0D  1               	; Init non-zero vars
000E0D  1  A9 03        	lda #3
000E0F  1  85 rr        	sta numlif
000E11  1               
000E11  1  A2 FF        	ldx #255
000E13  1  86 rr        	stx varrnd
000E15  1  86 rr        	stx varopt
000E17  1  86 rr        	stx varblk
000E19  1  CA           	dex
000E1A  1  86 rr        	stx varobj
000E1C  1               
000E1C  1               	; Call AGD Engine start game
000E1C  1  20 6D 10     	jsr start_game
000E1F  1               
000E1F  1                   ; Wait for keypress
000E1F  1  A2 FF        	ldx #$ff
000E21  1  A0 7F        	ldy #$7f
000E23  1  A9 81        	lda #$81
000E25  1  20 F4 FF     	jsr OSBYTE
000E28  1               
000E28  1               	; Restart or exit
000E28  1  4C 03 0E     	jmp boot_game
000E2B  1               
000E2B  1               ;----------------------------------------------------------------------
000E2B  1               ; PLATFORM SPECIFIC ENGINE CODE
000E2B  1               ;----------------------------------------------------------------------
000E2B  1               
000E2B  1               	.include "z80.asm"
000E2B  1               	.include "bbc.inc"
000E2B  2               ;------------------------------------------------------
000E2B  2               ; z80.asm
000E2B  2               ; spectrum stuff
000E2B  2               ; adresses
000E2B  2               
000E2B  2               ;ws	 = $60
000E2B  2               
000E2B  2               ;z80_f	 = ws+$00
000E2B  2               ;z80_a	 = ws+$01
000E2B  2               ;z80_af	 = z80_f
000E2B  2               
000E2B  2               ;z80_c	 = ws+$02
000E2B  2               ;z80_b	 = ws+$03
000E2B  2               ;z80_bc	 = z80_c
000E2B  2               
000E2B  2               ;z80_e	 = ws+$04
000E2B  2               ;z80_d	 = ws+$05
000E2B  2               ;z80_de	 = z80_e
000E2B  2               
000E2B  2               ;z80_l	 = ws+$06
000E2B  2               ;z80_h	 = ws+$07
000E2B  2               ;z80_hl	 = z80_l
000E2B  2               
000E2B  2               ;z80_x    = ws+$08
000E2B  2               ;z80_i    = ws+$09
000E2B  2               ;z80_ix	 = z80_x
000E2B  2               
000E2B  2               ;z80_iy	 = ws+$0a
000E2B  2               
000E2B  2               ;z80_fp	 = ws+$0c
000E2B  2               ;z80_ap	 = ws+$0d
000E2B  2               
000E2B  2               ;z80_cp	 = ws+$0e
000E2B  2               ;z80_bp	 = ws+$0f
000E2B  2               ;z80_bcp = z80_cp
000E2B  2               
000E2B  2               ;z80_ep	 = ws+$10
000E2B  2               ;z80_dp	 = ws+$11
000E2B  2               ;z80_dep = z80_ep
000E2B  2               
000E2B  2               ;z80_lp	 = ws+$12
000E2B  2               ;z80_hp	 = ws+$13
000E2B  2               ;z80_hlp = z80_lp
000E2B  2               
000E2B  2               ;z80_sp   = ws+$14
000E2B  2               
000E2B  2               ;z80_reg0 = ws+$16
000E2B  2               ;z80_reg1 = ws+$17
000E2B  2               ;z80_reg2 = ws+$18
000E2B  2               ;z80_reg3 = ws+$19
000E2B  2               
000E2B  2               ;z80_r	 = ws+$1a
000E2B  2               
000E2B  2               ; Contains seperatly 1 bit set
000E2B  2               ; _BEEB this is not safe memory to use as required by MOS
000E2B  2               
000E2B  2               _bitmem0	= $f8
000E2B  2               _bitmem1	= $f9
000E2B  2               _bitmem2	= $fa
000E2B  2               _bitmem3	= $fb
000E2B  2               _bitmem4	= $fc
000E2B  2               _bitmem5	= $fd
000E2B  2               _bitmem6	= $fe
000E2B  2               _bitmem7	= $ff
000E2B  2               	
000E2B  2               ; constants	
000E2B  2               _bitvalue0	= $01	
000E2B  2               _bitvalue1	= $02	
000E2B  2               _bitvalue2	= $04	
000E2B  2               _bitvalue3	= $08	
000E2B  2               _bitvalue4	= $10	
000E2B  2               _bitvalue5	= $20	
000E2B  2               _bitvalue6	= $40	
000E2B  2               _bitvalue7	= $80	
000E2B  2               
000E2B  2               _notbitvalue0	= $fe	
000E2B  2               _notbitvalue1	= $fd	
000E2B  2               _notbitvalue2	= $fb	
000E2B  2               _notbitvalue3	= $f7	
000E2B  2               _notbitvalue4	= $ef	
000E2B  2               _notbitvalue5	= $df	
000E2B  2               _notbitvalue6	= $bf	
000E2B  2               _notbitvalue7	= $7f	
000E2B  2               
000E2B  2               
000E2B  2               ;add_hl_bc:
000E2B  2               ;		lda z80_l
000E2B  2               ;		clc
000E2B  2               ;		adc z80_c
000E2B  2               ;		sta z80_l
000E2B  2               ;		lda z80_h
000E2B  2               ;		adc z80_b
000E2B  2               ;		sta z80_h
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;add_ix_de:
000E2B  2               ;		lda z80_ix
000E2B  2               ;		clc
000E2B  2               ;		adc z80_e
000E2B  2               ;		sta z80_ix
000E2B  2               ;		lda z80_ix+1
000E2B  2               ;		adc z80_d
000E2B  2               ;		sta z80_ix+1
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;add_iy_de:
000E2B  2               ;		lda z80_iy
000E2B  2               ;		clc
000E2B  2               ;		adc z80_e
000E2B  2               ;		sta z80_iy
000E2B  2               ;		lda z80_iy+1
000E2B  2               ;		adc z80_d
000E2B  2               ;		sta z80_iy+1
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;add_hl_de:
000E2B  2               ;		lda z80_l
000E2B  2               ;		clc
000E2B  2               ;		adc z80_e
000E2B  2               ;		sta z80_l
000E2B  2               ;		lda z80_h
000E2B  2               ;		adc z80_d
000E2B  2               ;		sta z80_h
000E2B  2               ;		rts
000E2B  2               ;
000E2B  2               ;add_ix_bc:
000E2B  2               ;		lda z80_ix
000E2B  2               ;		clc
000E2B  2               ;		adc z80_c
000E2B  2               ;		sta z80_ix
000E2B  2               ;		lda z80_ix+1
000E2B  2               ;		adc z80_b
000E2B  2               ;		sta z80_ix+1
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;add_iy_bc:
000E2B  2               ;		lda z80_iy
000E2B  2               ;		clc
000E2B  2               ;		adc z80_c
000E2B  2               ;		sta z80_iy
000E2B  2               ;		lda z80_iy+1
000E2B  2               ;		adc z80_b
000E2B  2               ;		sta z80_iy+1
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;sbc_hl_de:
000E2B  2               ;		lda z80_l
000E2B  2               ;		sbc z80_e
000E2B  2               ;		sta z80_l
000E2B  2               ;		lda z80_h
000E2B  2               ;		sbc z80_d
000E2B  2               ;		sta z80_h
000E2B  2               ;		rts
000E2B  2               ;
000E2B  2               ;sbc_hl_bc:
000E2B  2               ;		lda z80_l
000E2B  2               ;		sbc z80_c
000E2B  2               ;		sta z80_l
000E2B  2               ;		lda z80_h
000E2B  2               ;		sbc z80_b
000E2B  2               ;		sta z80_h
000E2B  2               ;		rts
000E2B  2               ;
000E2B  2               ;cmp_hl_bc:
000E2B  2               ;		lda z80_l
000E2B  2               ;		cmp z80_c
000E2B  2               ;		bne cmp_hl_bc_end
000E2B  2               ;		lda z80_h
000E2B  2               ;		cmp z80_b
000E2B  2               ;cmp_hl_bc_end:
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;cmp_iy_ix:
000E2B  2               ;		lda z80_iy
000E2B  2               ;		cmp z80_ix
000E2B  2               ;		bne cmp_iy_ix_end
000E2B  2               ;		lda z80_iy+1
000E2B  2               ;		cmp z80_ix+1
000E2B  2               ;cmp_iy_ix_end:
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;dec_hl:
000E2B  2               ;		lda z80_l
000E2B  2               ;		bne dec_hl_no_dec_h
000E2B  2               ;		dec z80_h
000E2B  2               ;dec_hl_no_dec_h:
000E2B  2               ;		dec z80_l
000E2B  2               ;		rts
000E2B  2               ;	
000E2B  2               ;dec_ix:
000E2B  2               ;		lda z80_ix
000E2B  2               ;		bne dec_ix_no_dec_h
000E2B  2               ;		dec z80_ix+1
000E2B  2               ;dec_ix_no_dec_h:
000E2B  2               ;		dec z80_ix
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;dec_bc:	
000E2B  2               ;		lda z80_c
000E2B  2               ;		bne dec_bc_no_dec_b
000E2B  2               ;		dec z80_b
000E2B  2               ;dec_bc_no_dec_b:
000E2B  2               ;		dec z80_c
000E2B  2               ;		rts
000E2B  2               ;	
000E2B  2               ;dec_de:
000E2B  2               ;		lda z80_e
000E2B  2               ;		bne dec_de_no_dec_d
000E2B  2               ;		dec z80_d
000E2B  2               ;dec_de_no_dec_d:
000E2B  2               ;		dec z80_e
000E2B  2               ;		rts
000E2B  2               ;		
000E2B  2               ;ex_af_afs:
000E2B  2               ;	rts
000E2B  2               ;ex_de_hl:
000E2B  2               ;		lda z80_e
000E2B  2               ;		ldx z80_l
000E2B  2               ;		stx z80_e
000E2B  2               ;		sta z80_l
000E2B  2               ;		lda z80_d
000E2B  2               ;		ldx z80_h
000E2B  2               ;		stx z80_d
000E2B  2               ;		sta z80_h
000E2B  2               ;		rts
000E2B  2               ;
000E2B  2               exx:
000E2B  2  A5 rr        		lda z80_c
000E2D  2  A4 rr        		ldy z80_cp
000E2F  2  84 rr        		sty z80_c
000E31  2  85 rr        		sta z80_cp
000E33  2  A5 rr        		lda z80_b
000E35  2  A4 rr        		ldy z80_bp
000E37  2  84 rr        		sty z80_b
000E39  2  85 rr        		sta z80_bp
000E3B  2  A5 rr        		lda z80_e
000E3D  2  A4 rr        		ldy z80_ep
000E3F  2  84 rr        		sty z80_e
000E41  2  85 rr        		sta z80_ep
000E43  2  A5 rr        		lda z80_d
000E45  2  A4 rr        		ldy z80_dp
000E47  2  84 rr        		sty z80_d
000E49  2  85 rr        		sta z80_dp		
000E4B  2  A5 rr        		lda scraddr
000E4D  2  A4 rr        		ldy z80_lp
000E4F  2  84 rr        		sty scraddr
000E51  2  85 rr        		sta z80_lp
000E53  2  A5 rr        		lda scraddr+1
000E55  2  A4 rr        		ldy z80_hp
000E57  2  84 rr        		sty scraddr+1
000E59  2  85 rr        		sta z80_hp
000E5B  2  60           		rts
000E5C  2               		
000E5C  2               ;ex_sp_hl:
000E5C  2               ;		tsx
000E5C  2               ;		lda $0103,x
000E5C  2               ;		ldy z80_h
000E5C  2               ;		sta z80_h
000E5C  2               ;		tya
000E5C  2               ;		sta $0103,x
000E5C  2               ;		lda $0104,x
000E5C  2               ;		ldy z80_l
000E5C  2               ;		sta z80_l
000E5C  2               ;		tya
000E5C  2               ;		sta $104,x
000E5C  2               ;		rts
000E5C  2               ;		
000E5C  2               ;ldi:
000E5C  2               ;	rts
000E5C  2               ;ldir:
000E5C  2               ;		ldy #$00
000E5C  2               ;		ldx z80_b
000E5C  2               ;		beq ldir_last_page
000E5C  2               ;ldir_loop:		
000E5C  2               ;		lda (z80_hl),y
000E5C  2               ;		sta (z80_de),y
000E5C  2               ;		iny
000E5C  2               ;		bne ldir_loop
000E5C  2               ;		inc z80_h
000E5C  2               ;		inc z80_d
000E5C  2               ;		dex
000E5C  2               ;		bne ldir_loop
000E5C  2               ;ldir_last_page:
000E5C  2               ;		lda z80_c
000E5C  2               ;		beq ldir_end
000E5C  2               ;ldir_last_page_loop:		
000E5C  2               ;		lda (z80_hl),y
000E5C  2               ;		sta (z80_de),y
000E5C  2               ;		iny
000E5C  2               ;		cpy z80_c
000E5C  2               ;		bne ldir_last_page_loop
000E5C  2               ;ldir_end:		
000E5C  2               ;		stx z80_c
000E5C  2               ;		stx z80_b
000E5C  2               ;		tya
000E5C  2               ;		clc
000E5C  2               ;		adc z80_l
000E5C  2               ;		sta z80_l
000E5C  2               ;		bcc *+4
000E5C  2               ;		inc z80_h
000E5C  2               ;		tya
000E5C  2               ;		clc
000E5C  2               ;		adc z80_e
000E5C  2               ;		sta z80_e
000E5C  2               ;		bcc *+4
000E5C  2               ;		inc z80_d
000E5C  2               ;		rts
000E5C  2               ;		
000E5C  2               ;lddr:		ldy #$00
000E5C  2               ;lddr_loop:
000E5C  2               ;		lda (z80_hl),y
000E5C  2               ;		sta (z80_de),y
000E5C  2               ;		jsr dec_hl
000E5C  2               ;		jsr dec_de
000E5C  2               ;		jsr dec_bc
000E5C  2               ;		lda z80_b
000E5C  2               ;		ora z80_c
000E5C  2               ;		bne lddr_loop
000E5C  2               ;		rts
000E5C  2               ;ei:
000E5C  2               ;		rts
000E5C  2               ;di:
000E5C  2               ;		rts
000E5C  2               		
000E5C  2               ;-------------------------------------------------------------
000E5C  2               ; Set bits in bitmem
000E5C  2               ;-------------------------------------------------------------
000E5C  2               
000E5C  2               .if 0
000E5C  2               z80_init:
000E5C  2               	ldx #$00
000E5C  2               	lda #$01
000E5C  2               z80_init_loop:		
000E5C  2               	sta _bitmem0,x
000E5C  2               	inx
000E5C  2               	asl a
000E5C  2               	bne z80_init_loop
000E5C  2               	rts
000E5C  2               .endif
000E5C  2               
000E5C  2               push_af:
000E5C  2               push_bc:
000E5C  2               push_de:
000E5C  2               push_hl:
000E5C  2               
000E5C  2               pop_af:
000E5C  2               pop_bc:
000E5C  2               pop_de:
000E5C  2               pop_ix:
000E5C  2               pop_hl:
000E5C  2               
000E5C  2               add_hl_hl:
000E5C  2               
000E5C  2               inc_bc:
000E5C  2               inc_de:
000E5C  2               inc_hl:
000E5C  2               inc_ix:
000E5C  2               inc_sp:
000E5C  2               
000E5C  2               cpir:
000E5C  2               
000E5C  2               ex_af_af:
000E5C  2               ;	rts
000E5C  2               
000E5C  1               
000E5C  2               ;----------------------------------------------------------------------
000E5C  2               ; BBC Platform Specific functions
000E5C  2               ;----------------------------------------------------------------------
000E5C  2               
000E5C  2               ;--------------------------------------------------------
000E5C  2               ; Keys
000E5C  2               ;
000E5C  2               ; Out: joyval=x65FUDLR (bit cleared if key pressed)
000E5C  2               ;             ||||||||
000E5C  2               ;             |||||||+> Right    KEY 0  - X
000E5C  2               ;             ||||||+-> Left     KEY 1  - Z
000E5C  2               ;             |||||+--> Down     KEY 2  - .
000E5C  2               ;             ||||+---> Up       KEY 3  - ;
000E5C  2               ;             |||+----> Fire1    KEY 4  - SPC
000E5C  2               ;             ||+-----> Fire2    KEY 5  - Q
000E5C  2               ;             |+------> Fire3    KEY 6  - P
000E5C  2               ;             +-------> Not used
000E5C  2               ;
000E5C  2               ;                       Option1  KEY 7  - 1
000E5C  2               ;                       Option2  KEY 8  - 2
000E5C  2               ;                       Option3  KEY 9  - 3
000E5C  2               ;                       Option4  KEY 10 - 4
000E5C  2               ;--------------------------------------------------------
000E5C  2               
000E5C  2               ;              X   Z   .   ;  SPC  Q   P
000E5C  2               ;keys:   .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E5C  2               ;        .byte $30,$31,$11,$12                   ; menu options.
000E5C  2               
000E5C  2  42 61 68 48  jkeys:  .byte $42,$61,$68,$48,$62,$10,$37       ; Keys defined by game designer.
000E60  2  62 10 37     
000E63  2  30 31 11 12          .byte $30,$31,$11,$12                   ; menu options.
000E67  2               
000E67  2               ;----------------------------------------------------
000E67  2               ; Wait for keypress.
000E67  2               ;----------------------------------------------------
000E67  2               
000E67  2               prskey:
000E67  2  8A           	txa
000E68  2  48           	pha
000E69  2               prsloop:
000E69  2  20 BC 0E     	jsr vsync
000E6C  2               
000E6C  2  A9 79        	lda #$79
000E6E  2  A2 01        	ldx #$01
000E70  2  20 F4 FF     	jsr OSBYTE
000E73  2               
000E73  2  E0 FF        	cpx #$ff
000E75  2  F0 F2        	beq prsloop		; wait until key pressed
000E77  2  68           	pla
000E78  2  AA           	tax
000E79  2  60           	rts
000E7A  2               
000E7A  2               ;--------------------------------------------------------
000E7A  2               ; Keyboard test routine.
000E7A  2               ;
000E7A  2               ; Input:
000E7A  2               ;  A = key to read, high nibble=row and low nibble=col
000E7A  2               ;
000E7A  2               ; Output:
000E7A  2               ;  carry clr = key pressed
000E7A  2               ;  carry set = key not pressed
000E7A  2               ;--------------------------------------------------------
000E7A  2               
000E7A  2               ktest:
000E7A  2  85 rr        	sta z80_a		; save key
000E7C  2  98           	tya
000E7D  2  48           	pha
000E7E  2               
000E7E  2               ; _BEEB keyboard read
000E7E  2  A5 rr        	lda z80_a
000E80  2  49 80        	eor #$80		; _BEEB just look for this key
000E82  2  AA           	tax
000E83  2               
000E83  2  A9 79        	lda #$79
000E85  2  20 F4 FF     	jsr OSBYTE
000E88  2               
000E88  2  8A           	txa
000E89  2  30 04        	bmi pressed 	; _BEEB X is negative if key is pressed
000E8B  2               
000E8B  2  38           	sec			; key not pressed
000E8C  2  68           	pla
000E8D  2  A8           	tay
000E8E  2  60           	rts
000E8F  2               
000E8F  2               pressed:
000E8F  2  18           	clc			; key pressed
000E90  2  68           	pla
000E91  2  A8           	tay
000E92  2  60           	rts
000E93  2               
000E93  2               ;---------------------------------------------------------------
000E93  2               ; Getkey in column,row format
000E93  2               ;
000E93  2               ; Output:
000E93  2               ;  A = high nibble=row and low nibble=column key in matrix
000E93  2               ;---------------------------------------------------------------
000E93  2               
000E93  2               kget:
000E93  2  86 rr        	stx xtmp
000E95  2               
000E95  2               kget1:
000E95  2  A9 79        	lda #$79			; _BEEB read keyboard with OSBYTE &79
000E97  2  A2 01        	ldx #$01
000E99  2  20 F4 FF     	jsr OSBYTE
000E9C  2               
000E9C  2  E0 FF        	cpx #$ff
000E9E  2  F0 F5        	beq kget1
000EA0  2               
000EA0  2  8A           	txa
000EA1  2               
000EA1  2  A6 rr        	ldx xtmp
000EA3  2  60           	rts
000EA4  2               
000EA4  2               ;----------------------------------------------------
000EA4  2               ; AtoMMC joystick controls.
000EA4  2               ; _BEEB TODO
000EA4  2               ;----------------------------------------------------
000EA4  2               
000EA4  2               joyinit:
000EA4  2               joysin:
000EA4  2  60           	rts
000EA5  2               
000EA5  2               
000EA5  2               ;----------------------------------------------------
000EA5  2               ; Delay routine 1/50 sec
000EA5  2               ;
000EA5  2               ; Wait 1/60 sec = 16666 usec
000EA5  2               ; Wait 208 x 16 =  3328 usec
000EA5  2               ;                 19994 usec
000EA5  2               ; rts           =     6 usec
000EA5  2               ; Total         = 20000 usec
000EA5  2               ;----------------------------------------------------
000EA5  2               
000EA5  2               delay:
000EA5  2  85 rr        	sta xtmp
000EA7  2               del_loop:
000EA7  2  A9 13        	lda #19
000EA9  2  20 F4 FF     	jsr OSBYTE		; wait for vsync _BEEB
000EAC  2               
000EAC  2  A0 D0        	ldy #208		; wait 208 x 16 = 3328 usec
000EAE  2               delay1:
000EAE  2  61 80        	adc ($80,x)		;	 6 usec
000EB0  2  61 80        	adc ($80,x)		;	 6 usec
000EB2  2  88           	dey			;	 2 usec
000EB3  2  D0 F9        	bne delay1		;	 2 usec
000EB5  2  EA           	nop			; 2 usec
000EB6  2  EA           	nop			; 2 usec
000EB7  2               				; tot: 20000 usec
000EB7  2  C6 rr        	dec xtmp
000EB9  2  D0 EC        	bne del_loop
000EBB  2  60           	rts
000EBC  2               
000EBC  2               ;-------------------------------------------------------------
000EBC  2               ; Screen synchronisation.
000EBC  2               ;
000EBC  2               ;  - read joystick/keyboard
000EBC  2               ;  - handle sound
000EBC  2               ;  - sync framerate with clock
000EBC  2               ;  - handle shrapnel every even frame
000EBC  2               ;-------------------------------------------------------------
000EBC  2               
000EBC  2               vsync:
000EBC  2  48           	pha
000EBD  2  98           	tya
000EBE  2  48           	pha
000EBF  2  8A           	txa
000EC0  2  48           	pha
000EC1  2  20 82 1A     	jsr joykey		; read joystick/keyboard.
000EC4  2               vsync1:
000EC4  2               ;	lda Timer2_High		; sync framerate with clock
000EC4  2               ;	bne vsync1
000EC4  2               ;	lda #>50000
000EC4  2               ;	sta Timer2_High
000EC4  2               ;	lda #<50000
000EC4  2               ;	sta Timer2_Low
000EC4  2               
000EC4  2  A9 13        	lda #19
000EC6  2  20 F4 FF     	jsr OSBYTE		; _BEEB vsync
000EC9  2               
000EC9  2  A5 rr        	lda clock
000ECB  2  29 01        	and #1
000ECD  2  D0 03        	bne:+
000ECF  2  20 45 11     	jsr proshr		; handle shrapnel every even frame
000ED2  2               :
000ED2  2  AD DD 0E     	lda sndtyp
000ED5  2  F0 00        	beq sndskip
000ED7  2               ; _BEEB TODO SOUND
000ED7  2               ;sndloop:
000ED7  2               ;	lda SpeakerBit		; handle sound
000ED7  2               ;	ldy sndtyp
000ED7  2               ;sndwait:
000ED7  2               ;	dey
000ED7  2               ;	bne sndwait
000ED7  2               ;	eor #4
000ED7  2               ;	sta SpeakerBit
000ED7  2               ;	dec sndtyp
000ED7  2               ;	bne sndloop
000ED7  2               sndskip: 
000ED7  2  68           	pla
000ED8  2  AA           	tax
000ED9  2  68           	pla
000EDA  2  A8           	tay
000EDB  2  68           	pla
000EDC  2  60           	rts
000EDD  2               
000EDD  2  00           sndtyp:	.byte 0
000EDE  2               
000EDE  2               ;----------------------------------------------------------------------
000EDE  2               ; BBC video hardware fns
000EDE  2               ;----------------------------------------------------------------------
000EDE  2               
000EDE  2               screeninit:
000EDE  2  A2 0D        	ldx #13
000EE0  2               crtcloop:
000EE0  2  8E 00 FE     	stx $FE00
000EE3  2  BD 00 0F     	lda crtc_regs_high,x
000EE6  2  8D 01 FE     	sta $FE01
000EE9  2  CA           	dex
000EEA  2  10 F4        	bpl crtcloop
000EEC  2               
000EEC  2                   ; Set ULA
000EEC  2  A9 88            lda #$88            ; MODE 4
000EEE  2  8D 48 02         sta $248            ; Tell the OS or it will mess with ULA settings at vsync
000EF1  2  8D 20 FE         sta $FE20
000EF4  2               
000EF4  2               ; fall through to palette
000EF4  2               
000EF4  2               setpal:
000EF4  2  A2 0F        	ldx #15
000EF6  2               palloop:
000EF6  2  BD 0E 0F     	lda ula_pal,x
000EF9  2  8D 21 FE     	sta $fe21
000EFC  2  CA           	dex
000EFD  2  10 F7        	bpl palloop
000EFF  2  60           	rts
000F00  2               
000F00  2               crtc_regs_high:
000F00  2  3F           	.byte 63				; R0  horizontal total
000F01  2  20           	.byte 32				; R1  horizontal displayed
000F02  2  31           	.byte 49				; R2  horizontal position
000F03  2  24           	.byte $24				; R3  sync width 40 = &28
000F04  2  26           	.byte 38				; R4  vertical total
000F05  2  00           	.byte 0					; R5  vertical total adjust
000F06  2  18           	.byte 24				; R6  vertical displayed
000F07  2  23           	.byte 35				; R7  vertical position; 35=top of screen
000F08  2  00           	.byte $00				; R8  interlace
000F09  2  07           	.byte 7					; R9  scanlines per row
000F0A  2  20           	.byte 32				; R10 cursor start
000F0B  2  08           	.byte 8					; R11 cursor end
000F0C  2  0D           	.byte >(ScreenAddr/8)	; R12 screen start address, high
000F0D  2  00           	.byte <(ScreenAddr/8)	; R13 screen start address, low
000F0E  2               
000F0E  2               ula_pal:
000F0E  2  07           	.byte $00 + PAL_black
000F0F  2  17           	.byte $10 + PAL_black
000F10  2  27           	.byte $20 + PAL_black
000F11  2  37           	.byte $30 + PAL_black
000F12  2  47           	.byte $40 + PAL_black
000F13  2  57           	.byte $50 + PAL_black
000F14  2  67           	.byte $60 + PAL_black
000F15  2  77           	.byte $70 + PAL_black
000F16  2  80           	.byte $80 + PAL_white
000F17  2  90           	.byte $90 + PAL_white
000F18  2  A0           	.byte $a0 + PAL_white
000F19  2  B0           	.byte $b0 + PAL_white
000F1A  2  C0           	.byte $c0 + PAL_white
000F1B  2  D0           	.byte $d0 + PAL_white
000F1C  2  E0           	.byte $e0 + PAL_white
000F1D  2  F0           	.byte $f0 + PAL_white
000F1E  2               
000F1E  2               ;----------------------------------------------------
000F1E  2               ; Draw sprite
000F1E  2               ;----------------------------------------------------
000F1E  2               
000F1E  2               sprite:
000F1E  2  86 rr        	stx xtmp		; Save X-reg
000F20  2  20 7B 0F     	jsr scadd 		; get screen address in scraddr.
000F23  2               
000F23  2  A5 rr        	lda dispx 		; x position.
000F25  2  29 07        	and #7 			; position straddling cells.
000F27  2  85 rr        	sta z80_b		; store in b register.
000F29  2               
000F29  2  A5 rr        	lda z80_l		; store sprite graphic address.
000F2B  2  8D 3E 0F     	sta sprit1+1
000F2E  2  8D 45 0F     	sta sprit2+1
000F31  2  A5 rr        	lda z80_h
000F33  2  8D 3F 0F     	sta sprit1+2
000F36  2  8D 46 0F     	sta sprit2+2
000F39  2               
000F39  2  A2 00        	ldx #0			; pixel height.
000F3B  2  A0 00        	ldy #0
000F3D  2               sprit1:
000F3D  2  BD 8C 27     	lda objdta,x		; fetch first byte.
000F40  2  8D 78 0F     	sta spr
000F43  2  E8           	inx
000F44  2               sprit2:
000F44  2  BD 8C 27     	lda objdta,x
000F47  2  8D 79 0F     	sta spr+1
000F4A  2               
000F4A  2  A9 00        	lda #0
000F4C  2  8D 7A 0F     	sta spr+2
000F4F  2  20 0B 17     	jsr sprit7		; shift sprite
000F52  2               
000F52  2  AD 78 0F     	lda spr			; fetch graphic.
000F55  2  A0 00        	ldy #0			; _BEEB
000F57  2  51 rr        	eor (scraddr),y		; merge with screen image.
000F59  2  91 rr        	sta (scraddr),y		; write to screen.
000F5B  2               
000F5B  2  AD 79 0F     	lda spr+1		; fetch graphic.
000F5E  2  A0 08        	ldy #8			; _BEEB
000F60  2  51 rr        	eor (scraddr),y		; merge with screen image.
000F62  2  91 rr        	sta (scraddr),y		; write to screen.
000F64  2               
000F64  2  AD 7A 0F     	lda spr+2		; fetch graphic.
000F67  2  A0 10        	ldy #16			; _BEEB
000F69  2  51 rr        	eor (scraddr),y		; merge with screen image.
000F6B  2  91 rr        	sta (scraddr),y		; write to screen.
000F6D  2               
000F6D  2  20 13 10     	jsr nline
000F70  2               
000F70  2  E8           	inx			; next source byte.
000F71  2  E0 20        	cpx #32
000F73  2  D0 C8        	bne sprit1		; repeat
000F75  2               
000F75  2  A6 rr        	ldx xtmp		; retreive X-reg
000F77  2  60           	rts
000F78  2               
000F78  2  00 00 00     spr:	.byte 0,0,0
000F7B  2               
000F7B  2               ;------------------------------------------------------------------
000F7B  2               ; This routine returns a screen address for (dispx, dispy) in scraddr.
000F7B  2               ;------------------------------------------------------------------
000F7B  2               
000F7B  2               scadd:
000F7B  2  A6 rr        	ldx dispy
000F7D  2  A5 rr        	lda dispx
000F7F  2  29 F8        	and #$f8
000F81  2  18           	clc
000F82  2  7D 00 06     	adc SCADTB_lb,x
000F85  2  85 rr        	sta scraddr
000F87  2  BD 00 07     	lda SCADTB_hb,x
000F8A  2  69 00        	adc #0
000F8C  2  85 rr        	sta scraddr+1
000F8E  2  60           	rts
000F8F  2               
000F8F  2               ;-----------------------------------------------------------------
000F8F  2               ; These are the sprite routines.
000F8F  2               ; sspria = single sprite, old (ix).
000F8F  2               ; ssprib = single sprite, new (ix+5).
000F8F  2               ; sspric = both sprites, old (ix) and new (ix+5).
000F8F  2               ;-----------------------------------------------------------------
000F8F  2               
000F8F  2               sspria:
000F8F  2  20 D0 1D     	jsr gsprad		; get old sprite address.
000F92  2               sspri2:
000F92  2  A9 10        	lda #16			; vertical lines.
000F94  2  8D A0 0F     	sta acnt
000F97  2               sspri0:
000F97  2  20 CA 0F     	jsr dline		; draw a line.
000F9A  2  CE A0 0F     	dec acnt
000F9D  2  D0 F8        	bne sspri0		; repeat 16 times
000F9F  2  60           	rts
000FA0  2               
000FA0  2  00           acnt:	.byte 0
000FA1  2               
000FA1  2               ;-----------------------------------------------------------------
000FA1  2               
000FA1  2               ssprib:
000FA1  2  20 B1 1D     	jsr gspran 		; get new sprite address.
000FA4  2  4C 92 0F     	jmp sspri2
000FA7  2               
000FA7  2               ;-----------------------------------------------------------------
000FA7  2               
000FA7  2               sspric:
000FA7  2  20 D0 1D     	jsr gsprad 		; get old sprite address.
000FAA  2  20 2B 0E     	jsr exx  		; store addresses.
000FAD  2  20 B1 1D     	jsr gspran 		; get new sprite addresses.
000FB0  2               
000FB0  2  A9 0F        	lda #15
000FB2  2  85 rr        	sta ccnt
000FB4  2               lloop:
000FB4  2  20 CA 0F     	jsr dline 		; draw a line.
000FB7  2  20 2B 0E     	jsr exx  		; restore old addresses.
000FBA  2  20 CA 0F     	jsr dline 		; delete a line.
000FBD  2  20 2B 0E     	jsr exx  		; flip to new sprite addresses.
000FC0  2  C6 rr        	dec ccnt
000FC2  2  D0 F0        	bne lloop
000FC4  2               
000FC4  2  20 CA 0F     	jsr dline		; draw a line.
000FC7  2  20 2B 0E     	jsr exx 		; restore old addresses.
000FCA  2               
000FCA  2               ;-------------------------------------------------------------
000FCA  2               ; Drop through.
000FCA  2               ; Line drawn, now work out next target address.
000FCA  2               ;
000FCA  2               ; Input:
000FCA  2               ;  B  = right mask
000FCA  2               ;  C  = left mask
000FCA  2               ;  DE = spriteaddress
000FCA  2               ;  scraddr = screen address
000FCA  2               ;-------------------------------------------------------------
000FCA  2               
000FCA  2               dline:
000FCA  2  A0 00        	ldy #0
000FCC  2  B1 rr        	lda (z80_de),y 		; graphic data.
000FCE  2  25 rr        	and z80_c 		; mask away what's not needed.
000FD0  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
000FD2  2  91 rr        	sta (scraddr),y 	; bung it in.
000FD4  2               
000FD4  2               ; _BEEB screen arrangement
000FD4  2  18           	clc
000FD5  2  A5 rr        	lda scraddr
000FD7  2  69 10        	adc #16
000FD9  2  85 rr        	sta scraddr
000FDB  2  90 02        	bcc :+
000FDD  2  E6 rr        	inc scraddr+1
000FDF  2               :
000FDF  2               
000FDF  2  B1 rr        	lda (z80_de),y 		; fetch data.
000FE1  2  25 rr        	and z80_b 		; mask away unwanted bits.
000FE3  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
000FE5  2  91 rr        	sta (scraddr),y 	; bung it in.
000FE7  2               
000FE7  2  E6 rr        	inc z80_e 		; next graphic.
000FE9  2  D0 02        	bne :+
000FEB  2  E6 rr        	inc z80_d
000FED  2               :
000FED  2               ; _BEEB screen arrangement
000FED  2  38           	sec
000FEE  2  A5 rr        	lda scraddr 		; one character cell to the left.
000FF0  2  E9 08        	sbc #8
000FF2  2  85 rr        	sta scraddr
000FF4  2  A5 rr        	lda scraddr+1
000FF6  2  E9 00        	sbc #0
000FF8  2  85 rr        	sta scraddr+1
000FFA  2               
000FFA  2  B1 rr        	lda (z80_de),y 		; second bit of data.
000FFC  2  51 rr        	eor (scraddr),y 	; XOR with what's there.
000FFE  2  91 rr        	sta (scraddr),y 	; bung it in.
001000  2               
001000  2  E6 rr        	inc z80_e 		; point to next line of data.
001002  2  D0 02        	bne :+
001004  2  E6 rr        	inc z80_d
001006  2               :
001006  2               ; _BEEB screen arrangement
001006  2  38           	sec
001007  2  A5 rr        	lda scraddr 		; another char left.
001009  2  E9 08        	sbc #8
00100B  2  85 rr        	sta scraddr
00100D  2  A5 rr        	lda scraddr+1
00100F  2  E9 00        	sbc #0
001011  2  85 rr        	sta scraddr+1
001013  2               
001013  2               ;----------------------------------------------------------------------
001013  2               ; Line drawn, now work out next target address.
001013  2               ;----------------------------------------------------------------------
001013  2               
001013  2               ; _BEEB screen arrangement
001013  2               
001013  2               nline:
001013  2  A5 rr        	lda scraddr 		; get low byte of address.
001015  2  29 07        	and #7				
001017  2  C9 07        	cmp #7				; is this last line of row?
001019  2  F0 03        	beq beeb_next_row
00101B  2               
00101B  2               	; within same row
00101B  2  E6 rr        	inc scraddr			; new low byte of address.
00101D  2               ;	bne :+
00101D  2               ;	inc scraddr+1		; new high byte of address.
00101D  2               :
00101D  2  60           	rts
00101E  2               
00101E  2               beeb_next_row:
00101E  2  18           	clc
00101F  2  A5 rr        	lda scraddr
001021  2  69 F9        	adc #<(ScreenRowBytes-7)
001023  2  85 rr        	sta scraddr			; new low byte of address.
001025  2  A5 rr        	lda scraddr+1
001027  2  69 00        	adc #>(ScreenRowBytes-7)
001029  2  85 rr        	sta scraddr+1		; new high byte of address.
00102B  2  60           	rts
00102C  2               
00102C  2               ;----------------------------------------------------
00102C  2               ; Display character in A at dispx,dispy.
00102C  2               ;
00102C  2               ; Input:
00102C  2               ;  A 	   = character to print
00102C  2               ;----------------------------------------------------
00102C  2               
00102C  2               pchar:
00102C  2  85 rr        	sta fntaddr
00102E  2  A9 00        	lda #0
001030  2  85 rr        	sta fntaddr+1
001032  2  06 rr        	asl fntaddr  		; multiply char by 8.
001034  2  26 rr        	rol fntaddr+1
001036  2  06 rr        	asl fntaddr
001038  2  26 rr        	rol fntaddr+1
00103A  2  06 rr        	asl fntaddr
00103C  2  26 rr        	rol fntaddr+1
00103E  2               
00103E  2  A5 rr        	lda fntaddr
001040  2  18           	clc
001041  2  65 rr        	adc FontPtr
001043  2  85 rr        	sta fntaddr		; that's the low byte.
001045  2  A5 rr        	lda fntaddr+1
001047  2  65 rr        	adc FontPtr+1
001049  2  85 rr        	sta fntaddr+1		; add displacement.
00104B  2               pchark:
00104B  2  20 51 16     	jsr gprad		; get screen address.
00104E  2  A2 07        	ldx #7			; lines to write.
001050  2               pchar0:
001050  2  A0 00        	ldy #0
001052  2  B1 rr        	lda (fntaddr),y 	; get image byte.
001054  2  BC 65 10     	ldy scrtab,x		; Get rowoffset
001057  2               
001057  2  49 00        	eor #TxtInvert		; Invert
001059  2               
001059  2  91 rr        	sta (scraddr),y 	; copy to screen.
00105B  2  E6 rr        	inc fntaddr		; next image byte.
00105D  2  D0 02        	bne :+
00105F  2  E6 rr        	inc fntaddr+1
001061  2               :
001061  2  CA           	dex			; next screen row down.
001062  2  10 EC        	bpl pchar0		; repeat.
001064  2  60           	rts
001065  2               
001065  2  07 06 05 04  scrtab:		.byte $07,$06,$05,$04,$03,$02,$01,$00
001069  2  03 02 01 00  
00106D  2               ;scrtab:	.byte $e0,$c0,$a0,$80,$60,$40,$20,$00
00106D  2               
00106D  1               ;----------------------------------------------------------------------
00106D  1               ; AGD 6502 ENGINE CODE + COMPILED GAME SCRIPT
00106D  1               ;----------------------------------------------------------------------
00106D  1               
00106D  1               start_game:
00106D  1               
00106D  1               	.include "game.inc"
00106D  1               
00106D  2               .include "testdig.inc" 
00106D  2               
00106D  3               ; Game engine code --------------------------------------------------------------
00106D  3               
00106D  3               ; Arcade Game Designer.
00106D  3               ; (C) 2008 Jonathan Cauldwell.
00106D  3               ; ZX Spectrum Next Engine v0.1.
00106D  3               
00106D  3               ; Global definitions ------------------------------------------------------------
00106D  3               
00106D  3               	FONT = font			; Font address
00106D  3               
00106D  3               ; Block characteristics.
00106D  3               
00106D  3               	PLATFM = 1			; platform.
00106D  3               	WALL = PLATFM + 1	; solid wall.
00106D  3               	LADDER = WALL + 1	; ladder.
00106D  3               	FODDER = LADDER + 1	; fodder block.
00106D  3               	DEADLY = FODDER + 1	; deadly block.
00106D  3               	CUSTOM = DEADLY + 1	; custom block.
00106D  3               	WATER  = CUSTOM + 1	; water block.
00106D  3                   COLECT = WATER + 1      ; collectable block.
00106D  3                   NUMTYP = COLECT + 1     ; number of types.
00106D  3               
00106D  3               ; Sprites.
00106D  3               
00106D  3               	NUMSPR = 12			; number of sprites.
00106D  3               	TABSIZ = 17			; size of each entry.
00106D  3               	SPRBUF = NUMSPR * TABSIZ; size of entire table.
00106D  3               	NMESIZ = 4			; bytes stored in nmetab for each sprite.
00106D  3               
00106D  3               ; Sprite table variable offsets.
00106D  3               
00106D  3               	var_Type = 0		; sprite type
00106D  3               	var_Image = 1		; sprite time number
00106D  3               	var_Frame = 2		; sprite frame
00106D  3               	var_Y = 3			; sprite y coordinate
00106D  3               	var_X = 4			; sprite X coordinate
00106D  3               
00106D  3               	var_newType = 5		; sprite new type
00106D  3               	var_newImage = 6	; sprite new image number
00106D  3               	var_newFrame = 7	; sprite new frame
00106D  3               	var_newY = 8		; sprite new y coordinate
00106D  3               	var_newX = 9		; sprite new x coordinate
00106D  3               	
00106D  3               	var_Direction = 10	; sprite direction
00106D  3               	var_Param1 = 11		; sprite parameter 1
00106D  3               	var_Param2 = 12		; sprite parameter 2
00106D  3               
00106D  3               	var_jumpLo = 13		; sprite jump ptr low
00106D  3               	var_jumpHi = 14		; sprite jump ptr high
00106D  3               	var_dataLo = 15		; sprite data ptr low
00106D  3               	var_dataHi = 16		; sprite data ptr high
00106D  3               
00106D  3               ; Particle engine.
00106D  3               
00106D  3               	NUMSHR = 55			; pieces of shrapnel.
00106D  3               	SHRSIZ = 6			; bytes per particle.
00106D  3               
00106D  3               ; Conditional compilation flags
00106D  3               ; Flags are set in commandline assembly
00106D  3               
00106D  3               ;	mflag = 0 		; MENU + INV
00106D  3               ;	pflag = 0		; Particle engine
00106D  3               ;	sflag = 0		; scrollytext
00106D  3               ;	fflag = 1		; Fontflag
00106D  3               
00106D  3               .if iflag
00106D  3               	TxtInvert   = $ff	; Invert byte for character printing
00106D  3               	ScrFillByte = $ff	; Screen fill byte for CLS
00106D  3               .else
00106D  3               	TxtInvert   = $00	; Invert byte for character printing
00106D  3               	ScrFillByte = $00	; Screen fill byte for CLS
00106D  3               .endif
00106D  3               
00106D  3               	ASCII_NEWLINE = 13
00106D  3               
00106D  3               ;===============================================================
00106D  3               ; Game starts here
00106D  3               ;===============================================================
00106D  3               
00106D  3               ;--------------------------------------------------------------
00106D  3               ; If a font is required...
00106D  3               ;--------------------------------------------------------------
00106D  3               
00106D  3  A9 B2        	lda #<(FONT-256)	; address of font.
00106F  3  85 rr        	sta FontPtr
001071  3  A9 26        	lda #>(FONT-256)
001073  3  85 rr        	sta FontPtr+1
001075  3               
001075  3  20 46 11     	jsr game	 		; start the game.
001078  3  60           	rts
001079  3               
001079  3               ; Don't change the order of these four.  
001079  3               ; Menu routine relies on winlft following wintop.
001079  3               
001079  3  01           wintop:	.byte WINDOWTOP		; top of window.
00107A  3  01           winlft:	.byte WINDOWLFT		; left edge.
00107B  3  16           winhgt:	.byte WINDOWHGT		; window height.
00107C  3  1E           winwid:	.byte WINDOWWID		; window width.
00107D  3  01           numob:	.byte NUMOBJ		; number of objects in game.
00107E  3               
00107E  3               ; Pixel versions of wintop, winlft, winhgt, winwid.
00107E  3               
00107E  3  08           wntopx:	.byte (8 * WINDOWTOP)
00107F  3  08           wnlftx:	.byte (8 * WINDOWLFT)
001080  3  A8           wnbotx:	.byte ((WINDOWTOP * 8) + (WINDOWHGT * 8) - 16)
001081  3  E6           wnrgtx:	.byte ((WINDOWLFT * 8) + (WINDOWWID * 8) - 16)-2
001082  3               
001082  3               ; Make sure pointers are arranged in the same order as the data itself.
001082  3               
001082  3  35 26        frmptr:	.word frmlst         ; sprite frames.
001084  3               
001084  3               ; Assorted game routines which can go in contended memory.
001084  3               
001084  3               ;--------------------------------------------------------------
001084  3               ; Modify for inventory.
001084  3               ; called by the INV command
001084  3               ;
001084  3               ; Input:
001084  3               ;  X   = message nr with objects seperated with ,
001084  3               ;
001084  3               ; Output:
001084  3               ;  OPT = selected line nr of INV menu
001084  3               ;--------------------------------------------------------------
001084  3               
001084  3               .if mflag
001084  3               minve:
001084  3               	lda #<(invdis)		; routine address.
001084  3               	sta mod0+1		; set up menu routine.
001084  3               	sta mod2+1		; set up count routine.
001084  3               	lda #>(invdis)
001084  3               	sta mod0+2
001084  3               	sta mod2+2
001084  3               	lda #<(fopt)		; find option from available objects.
001084  3               	sta mod1+1		; set up routine.
001084  3               	lda #>(fopt)
001084  3               	sta mod1+1+1
001084  3               	jmp dbox		; do menu routine.
001084  3               
001084  3               ;--------------------------------------------------------------
001084  3               ; Modify for menu.
001084  3               ; called by the MENU command
001084  3               ;
001084  3               ; Input:
001084  3               ;  X   = message nr with menu items seperated with ,
001084  3               ;
001084  3               ; Output:
001084  3               ;  OPT = selected line nr of MENU menu
001084  3               ;--------------------------------------------------------------
001084  3               
001084  3               mmenu:
001084  3               	lda #<(always)		; routine address.
001084  3               	sta mod0+1		; set up routine.
001084  3               	sta mod2+1		; set up count routine.
001084  3               	lda #>(always)
001084  3               	sta mod0+2
001084  3               	sta mod2+2
001084  3               
001084  3               	lda #<(fstd)		; standard option selection.
001084  3               	sta mod1+1		; set up routine.
001084  3               	lda #>(fstd)
001084  3               	sta mod1+2
001084  3               
001084  3               ; Drop through into box routine.
001084  3               
001084  3               ;--------------------------------------------------------------
001084  3               ; Work out size of box for message or menu.
001084  3               ;--------------------------------------------------------------
001084  3               
001084  3               dbox:
001084  3               	lda #<(msgdat)		; pointer to messages.
001084  3               	sta z80_l
001084  3               	lda #>(msgdat)
001084  3               	sta z80_h
001084  3               	
001084  3               	jsr getwrd		; get message number.
001084  3               
001084  3               	lda z80_h		; store pointer to message.
001084  3               	sta TmpAddr
001084  3               	lda z80_l
001084  3               	sta TmpAddr+1
001084  3               
001084  3               	lda #1			; height.
001084  3               	sta z80_d
001084  3               	lda #0			; start at object zero.
001084  3               	sta combyt		; store number of object in combyt.
001084  3               	sta z80_e		; maximum width.
001084  3               dbox5:
001084  3               	lda #0			; this line"s width.
001084  3               	sta z80_b
001084  3               mod2:
001084  3               	jsr always		; item in player"s possession?
001084  3               	cmp #255
001084  3               	bne dbox6		; not in inventory, skip this line.
001084  3               	inc z80_d		; add to tally.
001084  3               dbox6:
001084  3               	ldy #0			; get character.
001084  3               	lda (z80_hl),y
001084  3               	sta z80_a
001084  3               	inc z80_l		; next character.
001084  3               	bne :+
001084  3               	inc z80_h
001084  3               :
001084  3               	lda z80_a		; reached end of line?
001084  3               	cmp #','
001084  3               	beq dbox3		; yes.
001084  3               	cmp #ASCII_NEWLINE
001084  3               	beq dbox3		; yes.
001084  3               	inc z80_b		; add to this line"s width.
001084  3               	lda z80_a
001084  3               	bmi dbox4		; end of message? yes, end count.
001084  3               	jmp dbox6		; repeat until we find the end.
001084  3               dbox3:
001084  3               	lda z80_e		; maximum line width.
001084  3               	cmp z80_b		; have we exceeded longest so far?
001084  3               	bpl dbox5		; no, carry on looking.
001084  3               	lda z80_b		; make this the widest so far.
001084  3               	sta z80_e
001084  3               	jmp dbox5		; keep looking.
001084  3               dbox4:
001084  3               	lda z80_e		; maximum line width.
001084  3               	cmp z80_b		; have we exceeded longest so far?
001084  3               	bpl dbox8		; no, carry on looking.
001084  3               	lda z80_b		; final line is the longest so far.
001084  3               	sta z80_e
001084  3               dbox8:
001084  3               	dec z80_d		; decrement items found.
001084  3               	bne :+			; total was zero.
001084  3               	jmp dbox15		
001084  3               :
001084  3               	lda z80_e		; longest line.
001084  3               	bne :+			; was it zero?
001084  3               	jmp dbox15		; total was zero.
001084  3               :
001084  3               	sta bwid		; set up size.
001084  3               	lda z80_d
001084  3               	sta blen
001084  3               
001084  3               ;--------------------------------------------------------------
001084  3               ; That's set up our box size.
001084  3               ;--------------------------------------------------------------
001084  3               
001084  3               	lda winhgt		; window height in characters.
001084  3               	sec
001084  3               	sbc z80_d		; subtract height of box.
001084  3               	lsr a			; divide by 2.
001084  3               	clc
001084  3               	adc wintop		; add top edge of window.
001084  3               	sta btop		; set up box top.
001084  3               
001084  3               	lda winwid		; window width in characters.
001084  3               	sec	
001084  3               	sbc z80_e		; subtract box width.
001084  3               	lsr a			; divide by 2.
001084  3               	clc
001084  3               	adc winlft		; add left edge of window.
001084  3               	sta blft		; box left.
001084  3               
001084  3               	lda FontPtr		; font.
001084  3               	sta grbase		; set up for text display.
001084  3               	lda FontPtr+1
001084  3               	sta grbase+1
001084  3               
001084  3               	lda TmpAddr+1		; restore message pointer.
001084  3               	sta z80_l
001084  3               	lda TmpAddr
001084  3               	sta z80_h
001084  3               
001084  3               	lda btop		; box top.
001084  3               	sta dispy		; set display coordinate.
001084  3               	lda #0			; start at object zero.
001084  3               	sta combyt		; store number of object in combyt.
001084  3               dbox2:
001084  3               	lda combyt		; get object number.
001084  3               	sta z80_a
001084  3               mod0:
001084  3               	jsr always		; check inventory for display.
001084  3               	cmp #255
001084  3               	beq :+			
001084  3               	jmp dbox13		; not in inventory, skip this line.
001084  3               :
001084  3               	lda blft		; box left.
001084  3               	sta dispx		; set left display position.
001084  3               	lda bwid		; box width.
001084  3               	sta z80_b		; store width.
001084  3               dbox0:
001084  3               	ldy #0			; get character.
001084  3               	lda (z80_hl),y
001084  3               	cmp #','		; end of line?
001084  3               	beq dbox1		; yes, next one.
001084  3               	cmp #ASCII_NEWLINE			; end of line?
001084  3               	beq dbox1		; yes, next one.
001084  3               
001084  3               	dec z80_b		; one less to display.
001084  3               	and #127		; remove terminator.
001084  3               
001084  3               	jsr pchr		; display on screen.
001084  3               
001084  3               	ldy #0
001084  3               	lda (z80_hl),y		; get character.
001084  3               	sta z80_a
001084  3               	inc z80_l		; next character.
001084  3               	bne :+
001084  3               	inc z80_h
001084  3               :
001084  3               	lda z80_a
001084  3               	cmp #128		; end of message?
001084  3               	bmi :+
001084  3               	jmp dbox7		; yes, job done.
001084  3               :
001084  3               	lda z80_b		; chars remaining.
001084  3               	beq :+			; are any left?
001084  3               	jmp dbox0		; yes, continue.
001084  3               :
001084  3               ;---------------------------------------------------
001084  3               ; Reached limit of characters per line.
001084  3               ;---------------------------------------------------
001084  3               
001084  3               dbox9:
001084  3               	ldy #0
001084  3               	lda (z80_hl),y		; get character.
001084  3               	inc z80_l		; next one.
001084  3               	bne :+
001084  3               	inc z80_h
001084  3               :
001084  3               	cmp #','		; another line?
001084  3               	beq dbox10		; yes, do next line.
001084  3               	cmp #ASCII_NEWLINE			; another line?
001084  3               	beq dbox10		; yes, do next line.
001084  3               	cmp #128		; end of message?
001084  3               	bcs :+
001084  3               	jmp dbox11		; yes, finish message.
001084  3               :
001084  3               	jmp dbox9
001084  3               
001084  3               ;---------------------------------------------------
001084  3               ; Fill box to end of line.
001084  3               ;---------------------------------------------------
001084  3               
001084  3               dboxf:
001084  3               	lda #32			; space character.
001084  3               	jsr pchr		; display character.
001084  3               	dec z80_b
001084  3               	beq :+
001084  3               	jmp dboxf		; repeat for remaining chars on line.
001084  3               :
001084  3               	rts
001084  3               dbox1:
001084  3               	inc z80_l		; skip character.
001084  3               	bne :+
001084  3               	inc z80_h
001084  3               :
001084  3               	jsr dboxf		; fill box out to right side.
001084  3               dbox10:
001084  3               	inc dispy		; y coordinate down a line next position.
001084  3               	jmp dbox2		; next line.
001084  3               dbox7:
001084  3               	lda z80_b		; chars remaining.
001084  3               	bne :+			; are any left?
001084  3               	jmp dbox11		; no, nothing to draw.
001084  3               :
001084  3               	jsr dboxf		; fill message to line.
001084  3               
001084  3               ;------------------------------------------------------
001084  3               ; Drawn the box menu, now select option.
001084  3               ;------------------------------------------------------
001084  3               
001084  3               dbox11:
001084  3               	lda btop		; box top.
001084  3               	sta dispy		; set bar position.
001084  3               dbox14:
001084  3               	jsr joykey		; get controls.
001084  3               	cmp #$7f		; anything pressed?
001084  3               	bne dbox14		; yes, debounce it.
001084  3               	jsr dbar		; draw bar.
001084  3               dbox12:
001084  3               	jsr joykey		; get controls.
001084  3               	cmp #$7f		; anything pressed?
001084  3               	beq dbox12		; no, nothing.
001084  3               	and #16			; fire button pressed?
001084  3               	bne :+
001084  3               mod1:
001084  3               	jmp fstd		; yes, job done.
001084  3               :
001084  3               	jsr dbar		; delete bar.
001084  3               
001084  3               	lda joyval		; joystick reading.
001084  3               	and #8			; going up?
001084  3               	beq dboxu		; yes, go up.
001084  3               
001084  3               	ldx dispy		; vertical position of bar.
001084  3               	inx			; look down.
001084  3               	txa
001084  3               	sec
001084  3               	sbc btop		; find distance from top.
001084  3               	cmp blen		; top of box.
001084  3               	bne :+
001084  3               	jmp dbox14		; yes, go no further.
001084  3               :
001084  3               	inc dispy		; move bar.
001084  3               	jmp dbox14		; continue.
001084  3               dboxu:
001084  3               	lda dispy		; vertical position of bar.
001084  3               	cmp btop		; are we at the top?
001084  3               	bne :+
001084  3               	jmp dbox14		; yes, go no further.
001084  3               :
001084  3               	dec dispy		; move bar.
001084  3               	jmp dbox14		; continue.
001084  3               fstd:
001084  3               	lda dispy		; bar position.
001084  3               	sec
001084  3               	sbc btop		; find selected option.
001084  3               	sta varopt		; store the option.
001084  3               	jmp redraw		; redraw the screen.
001084  3               
001084  3               ;------------------------------------------------------
001084  3               ; Option not available.  Skip this line.
001084  3               ;------------------------------------------------------
001084  3               
001084  3               dbox13:
001084  3               	ldy #0
001084  3               	lda (z80_hl),y		; get character.
001084  3               	inc z80_l		; next one.
001084  3               	bne :+
001084  3               	inc z80_h
001084  3               :
001084  3               	cmp #','		; another line?
001084  3               	bne :+
001084  3               	jmp dbox2		; yes, do next line.
001084  3               :
001084  3               	cmp #ASCII_NEWLINE			; another line?
001084  3               	bne :+
001084  3               	jmp dbox2		; yes, do next line.
001084  3               :
001084  3               
001084  3               	bpl :+			; end of message?
001084  3               	jmp dbox11		; yes, finish message.
001084  3               :
001084  3               	jmp dbox13
001084  3               dbox15:
001084  3               	lda TmpAddr		; pop message pointer from the stack.
001084  3               	sta z80_h
001084  3               	lda TmpAddr+1
001084  3               	sta z80_l
001084  3               	rts
001084  3               
001084  3               ;------------------------------------------------------
001084  3               ; Invert bar
001084  3               ;------------------------------------------------------
001084  3               
001084  3               dbar:
001084  3               	lda blft		; box left.
001084  3               	sta dispx		; set display coordinate.
001084  3               	jsr gprad		; get printing address.
001084  3               
001084  3               	lda bwid		; box width.
001084  3               	sta z80_c		; loop counter in c.
001084  3               	lda z80_h		
001084  3               	sta z80_d		; store screen address high byte.
001084  3               dbar1:
001084  3               	ldx #7			; pixel height in b.
001084  3               dbar0:
001084  3               	ldy scrtab,x
001084  3               	lda (scraddr),y		; get screen byte.
001084  3               	eor #255		; reverse all bits.
001084  3               	sta (scraddr),y		; write back to screen.
001084  3               	dex			; next line down.
001084  3               	bpl dbar0		; draw rest of character.
001084  3               
001084  3               	clc
001084  3               	lda scraddr		; one char right.
001084  3               	adc #8
001084  3               	sta scraddr
001084  3               	bcc :+
001084  3               	inc scraddr+1
001084  3               :
001084  3               
001084  3               	dec z80_c		; decrement character counter.
001084  3               	beq :+
001084  3               	jmp dbar1		; repeat for whole line.
001084  3               :
001084  3               	rts
001084  3               
001084  3               ;------------------------------------------------------
001084  3               ; Point to object
001084  3               ;
001084  3               ; Input:
001084  3               ;  -
001084  3               ;
001084  3               ; Output:
001084  3               ;  A = object number, A=255 if already in possession
001084  3               ;------------------------------------------------------
001084  3               
001084  3               invdis:
001084  3               	lda z80_l		; store message text pointer.
001084  3               	pha
001084  3               	lda z80_h
001084  3               	pha
001084  3               	lda combyt		; object number.
001084  3               	inc combyt		; ready for next one.
001084  3               	jsr gotob		; check if we have object.
001084  3               	tay
001084  3               	pla
001084  3               	sta z80_h
001084  3               	pla
001084  3               	sta z80_l
001084  3               	tya
001084  3               	rts
001084  3               
001084  3               ;------------------------------------------------------
001084  3               ; Find option selected.
001084  3               ;
001084  3               ; Input:
001084  3               ;  -
001084  3               ;
001084  3               ; Output:
001084  3               ;  OPT = selected object
001084  3               ;------------------------------------------------------
001084  3               
001084  3               fopt:
001084  3               	lda dispy
001084  3               	sec
001084  3               	sbc btop		; find selected option.
001084  3               	sta tmp+2		; option selected in b register.
001084  3               	inc tmp+2
001084  3               
001084  3               	lda #0			; set to first item.
001084  3               	sta combyt		; object number.
001084  3               fopt0:
001084  3               	jsr fobj		; find next object in inventory.
001084  3               	dec tmp+2
001084  3               	bne fopt0		; repeat for relevant steps down the list.
001084  3               
001084  3               	lda combyt		; get option.
001084  3               	sta varopt		; store the option.
001084  3               	dec varopt		; one less, due to where we increment combyt.
001084  3               	jmp redraw		; redraw the screen.
001084  3               fobj:
001084  3               	ldy combyt		; object number.
001084  3               	inc combyt		; ready for next item.
001084  3               	tya
001084  3               	jsr gotob		; do we have this item?
001084  3               	cmp #255
001084  3               	bne :+
001084  3               	rts
001084  3               :
001084  3               	jmp fobj		; yes, it's on the list.
001084  3               .endif
001084  3               
001084  3               ;----------------------------------------------------
001084  3               ; Clear sprite table.
001084  3               ;
001084  3               ; sprtab[0] - sprtab[SPRBUF-1] = 255
001084  3               ;----------------------------------------------------
001084  3               
001084  3               xspr:
001084  3  A9 FF        	lda #255		; clear byte.
001086  3  A2 00        	ldx #0			; length of table.
001088  3               xspr0:
001088  3  9D 00 0B     	sta sprtab,x		; sprite table.
00108B  3  E8           	inx			; move to next byte.
00108C  3  E0 CC        	cpx #SPRBUF
00108E  3  D0 F8        	bne xspr0		; repeat for rest of table.
001090  3  60           	rts
001091  3               
001091  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001091  3               ; Sound, NOT IMPLEMENTED!!!
001091  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001091  3               ;
001091  3               ;silenc:
001091  3               ;	jsr silen1 		; silence channel 1.
001091  3               ;	jsr silen2 		; silence channel 2.
001091  3               ;	jsr silen3 		; silence channel 3.
001091  3               ;	jmp plsnd 		; play all channels to switch them off.
001091  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001091  3               
001091  3               ;-------------------------------------------------------------
001091  3               ; Initialise all objects.
001091  3               ;
001091  3               ; Reset current room,y,x to start room,y,x for all objects
001091  3               ;-------------------------------------------------------------
001091  3               
001091  3               iniob:
001091  3  A9 8C        	lda #<objdta 		; objects table.
001093  3  85 rr        	sta z80_x
001095  3  A9 27        	lda #>objdta
001097  3  85 rr        	sta z80_i
001099  3               
001099  3  AE 7D 10     	ldx numob 		; number of objects in the game.
00109C  3               iniob0:
00109C  3  A0 23        	ldy #35
00109E  3  B1 rr        	lda (z80_ix),y 		; start screen.
0010A0  3  A0 20        	ldy #32
0010A2  3  91 rr        	sta (z80_ix),y 		; set start screen.
0010A4  3               
0010A4  3  A0 24        	ldy #36
0010A6  3  B1 rr        	lda (z80_ix),y 		; find start y.
0010A8  3  A0 21        	ldy #33
0010AA  3  91 rr        	sta (z80_ix),y 		; set start y.
0010AC  3               
0010AC  3  A0 25        	ldy #37
0010AE  3  B1 rr        	lda (z80_ix),y 		; get initial x.
0010B0  3  A0 22        	ldy #34
0010B2  3  91 rr        	sta (z80_ix),y 		; set x coord.
0010B4  3               
0010B4  3  18           	clc 			; point to next object.
0010B5  3  A5 rr        	lda z80_x
0010B7  3  69 26        	adc #38			; distance between objects.
0010B9  3  85 rr        	sta z80_x
0010BB  3  90 02        	bcc :+
0010BD  3  E6 rr        	inc z80_i
0010BF  3               :
0010BF  3  CA           	dex 			; repeat.
0010C0  3  D0 DA        	bne iniob0
0010C2  3               
0010C2  3  60           	rts
0010C3  3               
0010C3  3               ;-----------------------------------------------
0010C3  3               ; Redraw the screen.
0010C3  3               ;
0010C3  3               ; Remove old copy of all sprites for redraw.
0010C3  3               ;-----------------------------------------------
0010C3  3               
0010C3  3               redraw:
0010C3  3  A5 rr        	lda z80_i 		; place sprite pointer on stack.
0010C5  3  48           	pha
0010C6  3  A5 rr        	lda z80_x
0010C8  3  48           	pha
0010C9  3               
0010C9  3  20 54 17     	jsr droom		; show screen layout.
0010CC  3  20 35 13     	jsr shwob		; draw objects.
0010CF  3               numsp0:
0010CF  3  A9 0C        	lda #NUMSPR		; sprites to draw.
0010D1  3  85 rr        	sta tmp
0010D3  3               
0010D3  3  A9 00        	lda #<sprtab		; sprite table.
0010D5  3  85 rr        	sta z80_x
0010D7  3  A9 0B        	lda #>sprtab
0010D9  3  85 rr        	sta z80_i
0010DB  3               redrw0:
0010DB  3  A0 00        	ldy #0
0010DD  3  B1 rr        	lda (z80_ix),y		; old sprite type.
0010DF  3  C9 FF        	cmp #255		; is it enabled?
0010E1  3  F0 0B        	beq redrw1 		; no, find next one.
0010E3  3               
0010E3  3  A0 03        	ldy #var_Y
0010E5  3  B1 rr        	lda (z80_ix),y 		; sprite y.
0010E7  3  C9 B1        	cmp #177		; beyond maximum?
0010E9  3  B0 03        	bcs redrw1		; yes, nothing to draw.
0010EB  3               
0010EB  3  20 8F 0F     	jsr sspria		; show single sprite.
0010EE  3               
0010EE  3               redrw1:
0010EE  3  18           	clc			; next sprite.
0010EF  3  A5 rr        	lda z80_x
0010F1  3  69 11        	adc #TABSIZ		; distance to next odd/even entry.
0010F3  3  85 rr        	sta z80_x
0010F5  3  90 02        	bcc :+
0010F7  3  E6 rr        	inc z80_i
0010F9  3               :
0010F9  3  C6 rr        	dec tmp			; repeat for remaining sprites.
0010FB  3  D0 DE        	bne redrw0
0010FD  3               
0010FD  3               rpblc1:
0010FD  3               ;	jsr dshrp		; redraw shrapnel.
0010FD  3               
0010FD  3  68           	pla			; retrieve sprite pointer.
0010FE  3  85 rr        	sta z80_x
001100  3  68           	pla
001101  3  85 rr        	sta z80_i
001103  3               
001103  3  60           	rts
001104  3               
001104  3               ;----------------------------------------------------------------------
001104  3               ; Clear screen routine.
001104  3               ;
001104  3               ; Fill screenmem $8000-$97ff with ScrFillByte
001104  3               ;----------------------------------------------------------------------
001104  3               
001104  3               cls:
001104  3  A9 68        	lda #>ScreenAddr		; screen address.
001106  3  8D 0F 11     	sta clsloop+2
001109  3  A9 00        	lda #ScrFillByte
00110B  3  A0 00        	ldy #0
00110D  3               clsloop:
00110D  3  99 00 68     	sta ScreenAddr,y
001110  3  C8           	iny
001111  3  D0 FA        	bne clsloop
001113  3  EE 0F 11     	inc clsloop+2
001116  3  AE 0F 11     	ldx clsloop+2
001119  3  E0 80        	cpx #>(ScreenAddr+ScreenSize)		; _BEEB
00111B  3  D0 F0        	bne clsloop
00111D  3  60           	rts
00111E  3               
00111E  3               ;----------------------------------------------------------------------
00111E  3               ; FODDER check
00111E  3               ;----------------------------------------------------------------------
00111E  3               
00111E  3               fdchk:
00111E  3  C9 04        	cmp #FODDER 		; is it fodder?
001120  3  F0 01        	beq :+
001122  3  60           	rts 			; no.
001123  3               :
001123  3  A9 00        	lda #0			; wipe fodder in MAP
001125  3  A0 00        	ldy #0
001127  3  91 rr        	sta (bufaddr),y 	; rewrite block type.
001129  3               
001129  3  A5 rr        	lda dispx		; x=x/8
00112B  3  48           	pha
00112C  3  4A           	lsr a
00112D  3  4A           	lsr a
00112E  3  4A           	lsr a
00112F  3  85 rr        	sta dispx
001131  3               
001131  3  A5 rr        	lda dispy		; y=y/8
001133  3  48           	pha
001134  3  4A           	lsr a
001135  3  4A           	lsr a
001136  3  4A           	lsr a
001137  3  85 rr        	sta dispy
001139  3               
001139  3  A9 00        	lda #0 			; block to write.
00113B  3  20 AC 16     	jsr pattr 		; write block.
00113E  3               
00113E  3  68           	pla
00113F  3  85 rr        	sta dispy
001141  3  68           	pla
001142  3  85 rr        	sta dispx
001144  3  60           	rts
001145  3               
001145  3               ;----------------------------------------------------
001145  3               ; Scrolly text and puzzle variables.
001145  3               ;----------------------------------------------------
001145  3               
001145  3               .if sflag
001145  3               txtbit:	.byte 128		; bit to write.
001145  3               txtwid:	.byte 16		; width of ticker message.
001145  3               txtpos:	.word msgdat
001145  3               txtini:	.word msgdat
001145  3               txtscr:	.word ScreenAddr
001145  3               .endif
001145  3               
001145  3               ;----------------------------------------------------
001145  3               ; Specialist routines.
001145  3               ; Process shrapnel.
001145  3               ;----------------------------------------------------
001145  3               proshr:
001145  3               .if pflag
001145  3               	lda #<SHRAPN		; table.
001145  3               	sta z80_x
001145  3               	lda #>SHRAPN
001145  3               	sta z80_i
001145  3               
001145  3               	lda #NUMSHR		; shrapnel pieces to process.
001145  3               	sta shrctr
001145  3               prosh0:
001145  3               	ldy #0
001145  3               	lda (z80_ix),y		; on/off marker.
001145  3               	asl a
001145  3               proshx:
001145  3               	bcs :+
001145  3               	jsr prosh1 		; on, so process it.
001145  3               :
001145  3               	clc
001145  3               	lda z80_x
001145  3               	adc #SHRSIZ
001145  3               	sta z80_x
001145  3               	bcc :+
001145  3               	inc z80_i
001145  3               :
001145  3               	dec shrctr		; round again.
001145  3               	bne prosh0
001145  3               .endif
001145  3               .if sflag
001145  3               	jsr scrly
001145  3               .endif
001145  3  60           	rts
001146  3               
001146  3               .if pflag
001146  3               ;----------------------------------------------------
001146  3               ; Proces shrapnel piece
001146  3               ;----------------------------------------------------
001146  3               
001146  3               prosh1:
001146  3               	jsr plot 		; delete the pixel.
001146  3               
001146  3               	lda #<shrptr		; shrapnel routine pointers.
001146  3               	sta z80_l
001146  3               	lda #>shrptr
001146  3               	sta z80_h
001146  3               
001146  3               	ldy #0
001146  3               	lda (z80_ix),y		; restore shrapnel type.
001146  3               	jsr prosh2 		; run the routine.
001146  3               	jsr chkxy		; check x and y are good before we redisplay.
001146  3               
001146  3               	lda #<SHRSIZ 		; distance to next.
001146  3               	sta z80_e
001146  3               	lda #>SHRSIZ
001146  3               	sta z80_d
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Run the routine
001146  3               ;----------------------------------------------------
001146  3               
001146  3               prosh2:
001146  3               	asl a 			; 2 bytes per address.
001146  3               	tay
001146  3               	lda shrptr,y
001146  3               	sta z80_l
001146  3               	lda shrptr+1,y 		; fetch high byte from table.
001146  3               	sta z80_h
001146  3               	jmp (z80_hl) 		; jump to routine.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Paricle routine table
001146  3               ;----------------------------------------------------
001146  3               
001146  3               shrptr:	.word laser		; laser.
001146  3               	.word trail		; vapour trail.
001146  3               	.word shrap		; shrapnel from explosion.
001146  3               	.word dotl		; horizontal starfield left.
001146  3               	.word dotr		; horizontal starfield right.
001146  3               	.word dotu		; vertical starfield up.
001146  3               	.word dotd		; vertical starfield down.
001146  3               	.word ptcusr		; user particle.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Explosion shrapnel.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               shrap:
001146  3               	ldy #1
001146  3               	lda (z80_ix),y 		; get the angle.
001146  3               	clc
001146  3               	adc #<shrsin		; shrapnel sine table.
001146  3               	sta z80_l
001146  3               	lda #>shrsin
001146  3               	adc #0
001146  3               	sta z80_h
001146  3               
001146  3               	ldy #0
001146  3               	lda (z80_hl),y 		; fetch value from table.
001146  3               	sta z80_e
001146  3               	inc z80_l 		; next byte of table.
001146  3               	bne :+
001146  3               	inc z80_h
001146  3               :
001146  3               	ldy #0
001146  3               	lda (z80_hl),y		; fetch value from table.
001146  3               	sta z80_d
001146  3               	inc z80_l		; next byte of table.
001146  3               	bne :+
001146  3               	inc z80_h
001146  3               :
001146  3               	ldy #0
001146  3               	lda (z80_hl),y 		; fetch value from table.
001146  3               	sta z80_c
001146  3               	inc z80_l 		; next byte of table.
001146  3               	bne :+
001146  3               	inc z80_h
001146  3               :
001146  3               	ldy #0
001146  3               	lda (z80_hl),y 		; fetch value from table.
001146  3               	sta z80_b
001146  3               
001146  3               	ldy #2
001146  3               	lda (z80_ix),y 		; x coordinate in hl.
001146  3               	clc
001146  3               	adc z80_e		; add sine lb
001146  3               	sta (z80_ix),y		; store new coordinate lb.
001146  3               	ldy #3
001146  3               	lda (z80_ix),y
001146  3               	adc z80_d		; add sine hb
001146  3               	sta (z80_ix),y		; store new coordinate hb.
001146  3               
001146  3               	ldy #4
001146  3               	lda (z80_ix),y	 	; y coordinate in hl.
001146  3               	clc
001146  3               	adc z80_c		; add cosine lb
001146  3               	sta (z80_ix),y		; store new coordinate lb.
001146  3               	ldy #5
001146  3               	lda (z80_ix),y
001146  3               	adc z80_b		; add cosine lb
001146  3               	sta (z80_ix),y		; store new coordinate hb.
001146  3               
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Move dots
001146  3               ;----------------------------------------------------
001146  3               
001146  3               dotl:
001146  3               	ldy #5
001146  3               	lda (z80_ix),y
001146  3               	sec
001146  3               	sbc #1		 	; move left.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               dotr:
001146  3               	ldy #5
001146  3               	lda (z80_ix),y
001146  3               	clc
001146  3               	adc #1		 	; move left.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               dotu:
001146  3               	ldy #3
001146  3               	lda (z80_ix),y
001146  3               	sec
001146  3               	sbc #1		 	; move up.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               dotd:
001146  3               	ldy #3
001146  3               	lda (z80_ix),y
001146  3               	clc
001146  3               	adc #1			; move down.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Check if coordinates are ok before redrawing at new position.
001146  3               ;
001146  3               ; left:   X>L		X=L	Ok
001146  3               ; right:  R+15>X	X=R	Ok
001146  3               ; top:    Y>T		Y=T	Ok
001146  3               ; bottom: B+15>Y	Y=B	Ok
001146  3               ;----------------------------------------------------
001146  3               
001146  3               chkxy:
001146  3               
001146  3               ; top:    Y>T		Y=T	Ok
001146  3               
001146  3               	ldy #3
001146  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
001146  3               	cmp wntopx		; window top.
001146  3               	bcs :+			; compare with top window limit.
001146  3               	jmp kilshr		; out of window, kill shrapnel.
001146  3               :
001146  3               ; left:   X>L		X=L	Ok
001146  3               
001146  3               	ldy #5
001146  3               	lda (z80_ix),y	 	; fetch shrapnel coordinate.
001146  3               	cmp wnlftx		; left edge.
001146  3               	bcs :+			; compare with left window limit.
001146  3               	jmp kilshr		; out of window, kill shrapnel.
001146  3               :
001146  3               ; bottom: B+15>Y	Y=B	Ok
001146  3               
001146  3               	lda wnbotx		; point to bottom.
001146  3               	clc
001146  3               	adc #15
001146  3               	ldy #3
001146  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
001146  3               	bcs :+			; compare with shrapnel x coordinate.
001146  3               	jmp kilshr		; off screen, kill shrapnel..
001146  3               :
001146  3               ; right:  R+15>X	X=R	Ok
001146  3               
001146  3               	lda wnrgtx		; point to right edge.
001146  3               	clc
001146  3               	adc #15
001146  3               	ldy #5
001146  3               	cmp (z80_ix),y	 	; fetch shrapnel coordinate.
001146  3               	bcs :+			; compare with window limit.
001146  3               	jmp kilshr		; off screen, kill shrapnel.
001146  3               :
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Drop through.
001146  3               ; Display shrapnel.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               plot:
001146  3               	ldy #3
001146  3               	lda (z80_ix),y		; y integer.
001146  3               	sta dispy	 	; workspace coordinates.
001146  3               	ldy #5
001146  3               	lda (z80_ix),y	 	; x integer.
001146  3               	sta dispx 		; workspace coordinates.
001146  3               
001146  3               	ldy #0
001146  3               	lda (z80_ix),y 		; type.
001146  3               	bne :+			; is it a laser?
001146  3               	jmp plot1 		; yes, draw laser instead.
001146  3               :
001146  3               plot0:
001146  3               	lda dispx		; which pixel within byte do we
001146  3               	and #7			; want to set first?
001146  3               	tay
001146  3               	lda dots,y 		; table of small pixel positions.
001146  3               	sta z80_e 		; get value.
001146  3               
001146  3               	jsr scadd 		; screen address.
001146  3               	ldy #0
001146  3               	lda (scraddr),y		; see what's already there.
001146  3               	eor z80_e
001146  3               	sta (scraddr),y 	; put back on screen.
001146  3               	rts
001146  3               
001146  3               plot1:
001146  3               	jsr scadd 		; screen address.
001146  3               	ldy #0
001146  3               	lda (scraddr),y 	; fetch byte there.
001146  3               	eor #255 		; toggle all bits.
001146  3               	sta (scraddr),y 	; new byte.
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Switch off shrapnel
001146  3               ;----------------------------------------------------
001146  3               
001146  3               kilshr:
001146  3               	lda #128
001146  3               	ldy #0
001146  3               	sta (z80_ix),y	; switch off shrapnel.
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Sine/cosine table
001146  3               ;----------------------------------------------------
001146  3               
001146  3               shrsin:	.word 0,1024,391,946,724,724,946,391
001146  3               	.word 1024,0,946,65144,724,64811,391,64589
001146  3               	.word 0,64512,65144,64589,64811,64811,64589,65144
001146  3               	.word 64512,0,64589,391,64811,724,65144,946
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create trail
001146  3               ;----------------------------------------------------
001146  3               
001146  3               trail:
001146  3               	ldy #1
001146  3               	lda (z80_ix),y 	; time remaining.
001146  3               	sec
001146  3               	sbc #1
001146  3               	sta (z80_ix),y
001146  3               	bne :+
001146  3               	jmp trailk		; time to switch it off.
001146  3               :
001146  3               	jsr qrand		; get a random number.
001146  3               	lsr a 			; x or y axis?
001146  3               	bcc :+
001146  3               	jmp trailv		; use y.
001146  3               :
001146  3               ; Trail horizontal
001146  3               
001146  3               	lsr a 			; which direction?
001146  3               	bcc :+
001146  3               	jmp traill		; go left.
001146  3               :
001146  3               ; Trail right
001146  3               
001146  3               	ldy #5
001146  3               	lda (z80_ix),y
001146  3               	clc
001146  3               	adc #1	 		; go right.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ; Trail left
001146  3               
001146  3               traill:
001146  3               	ldy #5
001146  3               	lda (z80_ix),y
001146  3               	sec
001146  3               	sbc #1 			; go left.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ; Trail vertical
001146  3               
001146  3               trailv:
001146  3               	lsr a		 	; which direction?
001146  3               	bcc :+
001146  3               	jmp trailu		; go up.
001146  3               :
001146  3               ; Trail down
001146  3               
001146  3               	ldy #3
001146  3               	lda (z80_ix),y
001146  3               	clc
001146  3               	adc #1 			; go down.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ; Trail up
001146  3               
001146  3               trailu:
001146  3               	ldy #3
001146  3               	lda (z80_ix),y
001146  3               	sec
001146  3               	sbc #1 			; go up.
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ; Kill trail
001146  3               
001146  3               trailk:
001146  3               	lda #200		; set off-screen to kill vapour trail.
001146  3               	ldy #3
001146  3               	sta (z80_ix),y
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create laser beam
001146  3               ;----------------------------------------------------
001146  3               
001146  3               laser:
001146  3               	ldy #1
001146  3               	lda (z80_ix),y 		; direction.
001146  3               	ror a 			; left or right?
001146  3               	bcs :+
001146  3               	jmp laserl		; move left.
001146  3               :
001146  3               ; Laser right
001146  3               
001146  3               	lda #8			; distance to travel.
001146  3               	sta z80_b
001146  3               	jmp laserm		; move laser.
001146  3               
001146  3               ; Laser left
001146  3               
001146  3               laserl:
001146  3               	lda #248		; distance to travel.
001146  3               	sta z80_b
001146  3               laserm:
001146  3               	ldy #5
001146  3               	lda (z80_ix),y		; x position.
001146  3               	clc
001146  3               	adc z80_b		; add distance.
001146  3               	sta (z80_ix),y		; set new x coordinate.
001146  3               
001146  3               ; Test new block.
001146  3               
001146  3               	sta dispx 		; set x for block collision detection purposes.
001146  3               	ldy #3
001146  3               	lda (z80_ix),y 		; get y.
001146  3               	sta dispy		; set coordinate for collision test.
001146  3               	jsr tstbl 		; get block type there.
001146  3               	cmp #WALL		; is it solid?
001146  3               	bne :+
001146  3               	jmp trailk		; yes, it cannot pass.
001146  3               :
001146  3                       cmp #FODDER             ; is it fodder?
001146  3                       bne :+
001146  3                       jsr fdchk               ; remove fodder block.
001146  3                       jmp trailk              ; destroy laser.
001146  3               :
001146  3                       rts                     ; no, ignore it.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Dots mask
001146  3               ;----------------------------------------------------
001146  3               
001146  3               dots:	.byte 128,64,32,16,8,4,2,1
001146  3               
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Plot, preserving de.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               plotde:
001146  3               	lda z80_d 		; put de on stack.
001146  3               	pha
001146  3               	lda z80_e
001146  3               	pha
001146  3               
001146  3               	jsr plot 		; plot pixel.
001146  3               
001146  3               	pla			; restore de from stack.
001146  3               	sta z80_e
001146  3               	pla
001146  3               	sta z80_d
001146  3               
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Shoot a laser.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               shoot:
001146  3               	sta z80_c		; store direction in c register.
001146  3               	ldy #8
001146  3               	lda (z80_ix),y 		; y coordinate.
001146  3               shoot1:
001146  3               	clc
001146  3               	adc #7 			; down 7 pixels.
001146  3               	sta z80_l 		; puty y coordinate in l.
001146  3               
001146  3               	ldy #9
001146  3               	lda (z80_ix),y 		; x coordinate in h.
001146  3               	sta z80_h
001146  3               
001146  3               	lda z80_i		; store pointer to sprite.
001146  3               	pha
001146  3               	lda z80_x
001146  3               	pha
001146  3               
001146  3               	jsr fpslot 		; find particle slot.
001146  3               	bcs :+
001146  3               	jmp vapou2		; failed, restore ix.
001146  3               :
001146  3               	lda #0
001146  3               	ldy #0
001146  3               	sta (z80_ix),y 		; set up a laser.
001146  3               
001146  3               	lda z80_c
001146  3               	ldy #1
001146  3               	sta (z80_ix),y 		; set the direction.
001146  3               
001146  3               	lda z80_l
001146  3               	ldy #3
001146  3               	sta (z80_ix),y		; set y coordinate.
001146  3               
001146  3               	ror z80_c		; check direction we want.
001146  3               	bcc :+
001146  3               	jmp shootr		; shoot right.
001146  3               :
001146  3               	lda z80_h		; X position.
001146  3               shoot0:
001146  3               	and #248		; align on character boundary.
001146  3               	ldy #5
001146  3               	sta (z80_ix),y		; set x coordinate.
001146  3               	jmp vapou0 		; draw first image.
001146  3               shootr:
001146  3               	lda z80_h		; x position.
001146  3               	clc
001146  3               	adc #15			; look right.
001146  3               	jmp shoot0		; align and continue.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create a bit of vapour trail.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               vapour:
001146  3               	lda z80_i		; store pointer to sprite.
001146  3               	pha
001146  3               	lda z80_x
001146  3               	pha
001146  3               
001146  3               	ldy #8
001146  3               	lda (z80_ix),y 		; y coordinate.
001146  3               	clc
001146  3               	adc #7			; mid-point of sprite.
001146  3               	sta z80_l
001146  3               
001146  3               	ldy #9
001146  3               	lda (z80_ix),y 		; x coordinate.
001146  3               	adc #7
001146  3               	sta z80_h
001146  3               
001146  3               	jsr fpslot 		; find particle slot.
001146  3               	bcc :+
001146  3               	jmp vapou1		; no, we can use it.
001146  3               :
001146  3               vapou2:
001146  3               	pla
001146  3               	sta z80_x
001146  3               	pla
001146  3               	sta z80_i
001146  3               	rts
001146  3               vapou1:
001146  3               	lda z80_l
001146  3               	ldy #3
001146  3               	sta (z80_ix),y		; set up y.
001146  3               
001146  3               	lda z80_h
001146  3               	ldy #5
001146  3               	sta (z80_ix),y 		; set up x coordinate.
001146  3               
001146  3               	jsr qrand		; get quick random number.
001146  3               	and #15			; random time.
001146  3               	clc
001146  3               	adc #15			; minimum time on screen.
001146  3               	ldy #1
001146  3               	sta (z80_ix),y		; set time on screen.
001146  3               
001146  3               	lda #1
001146  3               	ldy #0
001146  3               	sta (z80_ix),y		; define particle as vapour trail.
001146  3               vapou0:
001146  3               	jsr chkxy		; plot first position.
001146  3               	jmp vapou2
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create a user particle.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               ptusr:
001146  3               	sta z80_f		; store timer.
001146  3               
001146  3               	ldy #8
001146  3               	lda (z80_ix),y 		; y coordinate.
001146  3               	clc
001146  3               	adc #7			; mid-point of sprite.
001146  3               	sta z80_l
001146  3               
001146  3               	ldy #9
001146  3               	lda (z80_ix),y 		; x coordinate.
001146  3               	clc
001146  3               	adc #7			; mid-point of sprite.
001146  3               	sta z80_h
001146  3               
001146  3               	jsr fpslot 		; find particle slot.
001146  3               	bcs ptusr1
001146  3               	rts 			; out of slots, can't generate anything.
001146  3               ptusr1:
001146  3               	lda z80_l
001146  3               	ldy #3
001146  3               	sta (z80_ix),y 		; set up y.
001146  3               
001146  3               	lda z80_h
001146  3               	ldy #5
001146  3               	sta (z80_ix),y		; set up x coordinate.
001146  3               
001146  3               	lda z80_f 		; restore timer.
001146  3               	ldy #1
001146  3               	sta (z80_ix),y		; set time on screen.
001146  3               
001146  3               	lda #7
001146  3               	ldy #0
001146  3               	sta (z80_ix),y		; define particle as user particle.
001146  3               
001146  3               	jmp chkxy		; plot first position.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create a vertical or horizontal star.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               star:
001146  3               	lda z80_i		; store pointer to sprite.
001146  3               	pha
001146  3               	lda z80_x
001146  3               	pha
001146  3               
001146  3               	jsr fpslot 		; find particle slot.
001146  3               	bcs star7		; found one we can use.
001146  3               star0:
001146  3               	pla 			; restore sprite pointer.
001146  3               	sta z80_x
001146  3               	pla
001146  3               	sta z80_i
001146  3               	rts 			; out of slots, can't generate anything.
001146  3               star7:
001146  3               	lda z80_c		; direction.
001146  3               	and #3 			; is it left?
001146  3               	bne :+
001146  3               	jmp star1 		; yes, it's left.
001146  3               :
001146  3               	cmp #1 			; is it right?
001146  3               	bne :+
001146  3               	jmp star2 		; yes, it's right.
001146  3               :
001146  3               	cmp #2 			; is it up?
001146  3               	bne :+
001146  3               	jmp star3 		; yes, it's up.
001146  3               :
001146  3               	ldy wntopx 		; get edge of screen.
001146  3               	iny			; down one pixel.
001146  3               	tya
001146  3               star8:
001146  3               	ldy #3
001146  3               	sta (z80_ix),y 		; set y coord.
001146  3               	jsr qrand 		; get quick random number.
001146  3               star9:
001146  3               	ldy #5
001146  3               	sta (z80_ix),y		; set x position.
001146  3               
001146  3               	lda z80_c		; direction.
001146  3               	and #3			; zero to three.
001146  3               	clc
001146  3               	adc #3			; 3 to 6 for starfield.
001146  3               	ldy #0
001146  3               	sta (z80_ix),y		; define particle as star.
001146  3               	jsr chkxy		; plot first position.
001146  3               	jmp star0
001146  3               star1:
001146  3               	jsr qrand		; get quick random number.
001146  3               	ldy #3
001146  3               	sta (z80_ix),y 		; set y coord.
001146  3               
001146  3               	lda wnrgtx 		; get edge of screen.
001146  3               	clc
001146  3               	adc #15			; add width of sprite minus 1.
001146  3               	jmp star9
001146  3               star2:
001146  3               	jsr qrand 		; get quick random number.
001146  3               	ldy #3
001146  3               	sta (z80_ix),y		; set y coord.
001146  3               
001146  3               	lda wnlftx		; get edge of screen.
001146  3               	jmp star9
001146  3               star3:
001146  3               	lda wnbotx 		; get edge of screen.
001146  3               	clc
001146  3               	adc #15 		; height of sprite minus one pixel.
001146  3               	jmp star8
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Find particle slot for lasers or vapour trail.
001146  3               ; can't use alternate accumulator.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               fpslot:
001146  3               	lda #<SHRAPN 		; shrapnel table.
001146  3               	sta z80_x
001146  3               	lda #>SHRAPN
001146  3               	sta z80_i
001146  3               
001146  3               	lda #NUMSHR		; number of pieces in table.
001146  3               	sta z80_b
001146  3               fpslt0:
001146  3               	ldy #0
001146  3               	lda (z80_ix),y		; get type.
001146  3               	asl a  			; is this slot in use?
001146  3               	bcc :+
001146  3               	rts			; no, we can use it.
001146  3               :
001146  3               	clc			; point to more shrapnel.
001146  3               	lda z80_x
001146  3               	adc #SHRSIZ
001146  3               	sta z80_x
001146  3               	bcc :+
001146  3               	inc z80_i
001146  3               :
001146  3               	dec z80_b		; repeat for all shrapnel.
001146  3               	bne fpslt0
001146  3               
001146  3               	clc
001146  3               	rts 			; out of slots, can't generate anything.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Create an explosion at sprite position.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               explod:
001146  3               	sta z80_c 		; particles to create.
001146  3               
001146  3               	lda z80_i 		; store pointer to sprite.
001146  3               	pha
001146  3               	lda z80_x
001146  3               	pha
001146  3               
001146  3               	ldy #8
001146  3               	lda (z80_ix),y 		; y coordinate.
001146  3               	sta z80_l
001146  3               	ldy #9
001146  3               	lda (z80_ix),y		; x coordinate.
001146  3               	sta z80_h
001146  3               
001146  3               	lda #<SHRAPN		; shrapnel table.
001146  3               	sta z80_x
001146  3               	lda #>SHRAPN
001146  3               	sta z80_i
001146  3               
001146  3               	lda #NUMSHR		; number of pieces in table.
001146  3               	sta explcnt
001146  3               expld0:
001146  3               	ldy #0
001146  3               	lda (z80_ix),y		; get type.
001146  3               	asl a 			; is this slot in use?
001146  3               	bcs expld1		; no, we can use it.
001146  3               expld2:
001146  3               	clc
001146  3               	lda z80_x
001146  3               	adc #SHRSIZ
001146  3               	sta z80_x
001146  3               	bcc :+
001146  3               	inc z80_i
001146  3               :
001146  3               	dec explcnt		; repeat for all shrapnel.
001146  3               	bne expld0
001146  3               expld3:
001146  3               	pla			; restore sprite pointer.
001146  3               	sta z80_x
001146  3               	pla
001146  3               	sta z80_i
001146  3               	rts 			; out of slots, can't generate any more.
001146  3               
001146  3               expld1:
001146  3               	lda z80_c		; shrapnel counter.
001146  3               	and #15			; 0 to 15.
001146  3               	clc			; add to x.
001146  3               	adc z80_l
001146  3               	ldy #3
001146  3               	sta (z80_ix),y		; y coord.
001146  3               
001146  3               	lda seed3 		; crap random number.
001146  3               	and #15			; 0 to 15.
001146  3               	clc 			; add to y.
001146  3               	adc z80_h
001146  3               	ldy #5
001146  3               	sta (z80_ix),y		; x coord.
001146  3               
001146  3               	lda #2
001146  3               	ldy #0
001146  3               	sta (z80_ix),y		; switch it on.
001146  3               
001146  3               	jsr chkxy		; plot first position.
001146  3               	jsr qrand		; quick random angle.
001146  3               	and #60 		; keep within range.
001146  3               	ldy #1
001146  3               	sta (z80_ix),y		; angle.
001146  3               
001146  3               	dec z80_c		; one less piece of shrapnel to generate.
001146  3               	bne expld2 		; back to main explosion loop.
001146  3               	jmp expld3 		; restore sprite pointer and exit.
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Quick random
001146  3               ;----------------------------------------------------
001146  3               
001146  3               qrand:
001146  3               	jsr random		; r register.
001146  3               	eor seed3		; combine with seed.
001146  3               	sta seed3 		; new seed.
001146  3               	rts
001146  3               
001146  3               ;----------------------------------------------------
001146  3               ; Display all shrapnel.
001146  3               ;----------------------------------------------------
001146  3               
001146  3               dshrp:
001146  3               	lda #<plotde		; display routine.
001146  3               	sta proshx+1
001146  3               	lda #>plotde
001146  3               	sta proshx+2
001146  3               	jsr proshr		; process shrapnel.
001146  3               
001146  3               	lda #<prosh1		; processing routine.
001146  3               	sta proshx+1
001146  3               	lda #>prosh1
001146  3               	sta proshx+2
001146  3               	rts
001146  3               
001146  3               ;------------------------------------------------------
001146  3               ; Particle engine.
001146  3               ;
001146  3               ; Init particle data for 55 particles in SHRAPN table.
001146  3               ; Every particle has 6 bytes.
001146  3               ;
001146  3               ; global:	-
001146  3               ; local:	x,y,hl
001146  3               ; calls:	-
001146  3               ;------------------------------------------------------
001146  3               
001146  3               inishr:
001146  3               	lda #<SHRAPN 		; table.
001146  3               	sta z80_l
001146  3               	lda #>SHRAPN
001146  3               	sta z80_h
001146  3               
001146  3               	ldy #0
001146  3               	ldx #NUMSHR		; shrapnel pieces to process.
001146  3               inish0:
001146  3               	lda #255 		; kill the shrapnel.
001146  3               	sta (z80_hl),y
001146  3               
001146  3               	clc 			; point there.
001146  3               	lda z80_l
001146  3               	adc #SHRSIZ		; distance to next.
001146  3               	sta z80_l
001146  3               	bcc :+
001146  3               	inc z80_h
001146  3               :
001146  3               	dex
001146  3               	bne inish0 		; round again.
001146  3               	rts
001146  3               
001146  3               ;------------------------------------------------------
001146  3               ; Check for collision between laser and sprite.
001146  3               ;------------------------------------------------------
001146  3               
001146  3               lcol:
001146  3               	lda #<SHRAPN		; shrapnel table.
001146  3               	sta z80_l
001146  3               	lda #>SHRAPN
001146  3               	sta z80_h
001146  3               
001146  3               	lda #NUMSHR		; number of pieces in table.
001146  3               	sta z80_b
001146  3               lcol0:
001146  3               	ldy #0
001146  3               	lda (z80_hl),y 		; get type.
001146  3               	beq lcol1		; yes, check collision.
001146  3               lcol3:
001146  3               	clc			; point to more shrapnel.
001146  3               	lda z80_l
001146  3               	adc #SHRSIZ
001146  3               	sta z80_l
001146  3               	bcc :+
001146  3               	inc z80_h
001146  3               :
001146  3               	dec z80_b		; repeat for all shrapnel.
001146  3               	bne lcol0
001146  3               	rts 			; no collision, carry not set.
001146  3               lcol1:
001146  3               	ldy #3
001146  3               	lda (z80_hl),y		; get y.
001146  3               	sec
001146  3               	ldy #8
001146  3               	sbc (z80_ix),y		; subtract sprite y.
001146  3               lcolh:
001146  3               	cmp #16 		; within range?
001146  3               	bcc :+
001146  3               	jmp lcol2		; no, missed.
001146  3               :
001146  3               	ldy #5
001146  3               	lda (z80_hl),y 		; get x.
001146  3               	sec
001146  3               	ldy #9
001146  3               	sbc (z80_ix),y 		; subtract sprite y.
001146  3               	cmp #16			; within range?
001146  3               	bcs :+
001146  3               	jmp lcol4 		; yes, collision occurred.
001146  3               :
001146  3               lcol2:
001146  3               	jmp lcol3
001146  3               lcol4:
001146  3               	sec
001146  3               	rts 			; return with carry set for collision.
001146  3               .endif
001146  3               
001146  3               ;------------------------------------------------------
001146  3               ; Main game engine code starts here.
001146  3               ; After initialisation, mloop is the main loop
001146  3               ;------------------------------------------------------
001146  3               
001146  3               game:
001146  3               
001146  3               ; Set up screen address table.
001146  3               
001146  3               setsat:
001146  3  A9 00        	lda #<ScreenAddr		; start of screen.
001148  3  85 rr        	sta scraddr
00114A  3  A9 68        	lda #>ScreenAddr
00114C  3  85 rr        	sta scraddr+1
00114E  3               
00114E  3  A0 00        	ldy #0			; vertical lines on screen.
001150  3               setsa0:
001150  3  A5 rr        	lda scraddr
001152  3  99 00 06     	sta SCADTB_lb,y		; write low byte.
001155  3  A5 rr        	lda scraddr+1
001157  3  99 00 07     	sta SCADTB_hb,y		; write high byte.
00115A  3  20 13 10     	jsr nline		; next line down.
00115D  3  C8           	iny			; next position in table.
00115E  3  D0 F0        	bne setsa0
001160  3               
001160  3               ; Init graphics mode
001160  3               
001160  3  20 DE 0E     	jsr screeninit
001163  3               
001163  3               ; Init AtoMMC joystick
001163  3  20 A4 0E     	jsr joyinit		; AtoMMC joystick on PORT B
001166  3               
001166  3               rpblc2:
001166  3               .if pflag
001166  3               	jsr inishr 		; initialise particle engine.
001166  3               .endif
001166  3               evintr:
001166  3  20 DC 23     	jsr evnt12 		; call intro/menu event.
001169  3               
001169  3  A9 02        	lda #WALL 		; write default property.
00116B  3  A2 00        	ldx #0
00116D  3               clrmap:
00116D  3  9D 00 03     	sta MAP,x 		; block properties.
001170  3  9D 00 04     	sta MAP+256,x
001173  3  9D 00 05     	sta MAP+512,x
001176  3  E8           	inx			; next byte.
001177  3  D0 F4        	bne clrmap
001179  3               
001179  3  20 91 10     	jsr iniob 		; initialise objects.
00117C  3               
00117C  3  A9 00        	lda #0			; put zero in accumulator.
00117E  3  85 rr        	sta gamwon		; reset game won flag.
001180  3               
001180  3  20 E5 12     	jsr inisc 		; init the score.
001183  3               mapst:
001183  3  AD 25 23     	lda stmap 		; start position on map.
001186  3  8D 1A 23     	sta roomtb		; set up position in table, if there is one.
001189  3               
001189  3               inipbl:
001189  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001189  3               .if aflag
001189  3               	lda #<eop		; reset blockpointer
001189  3               	sta pbptr
001189  3               	lda #>eop
001189  3               	sta pbptr+1
001189  3               .endif
001189  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001189  3  20 2F 1F     	jsr initsc 		; set up first screen.
00118C  3               
00118C  3  A9 09        	lda #<ssprit 		; default to spare sprite in table.
00118E  3  85 rr        	sta z80_x
001190  3  A9 23        	lda #>ssprit
001192  3  85 rr        	sta z80_i
001194  3               evini:
001194  3  20 DD 23     	jsr evnt13 		; initialisation.
001197  3               
001197  3               ; Two restarts.
001197  3               ; First restart - clear all sprites and initialise everything.
001197  3               
001197  3               rstrt:
001197  3  20 85 12     	jsr rsevt 		; restart events.
00119A  3  20 84 10     	jsr xspr 		; clear sprite table.
00119D  3  20 9B 20     	jsr sprlst 		; fetch pointer to screen sprites.
0011A0  3  20 24 21     	jsr ispr 		; initialise sprite table.
0011A3  3               
0011A3  3  4C B2 11     	jmp rstrt0
0011A6  3               
0011A6  3               ; Second restart - clear all but player, and don't initialise him.
0011A6  3               
0011A6  3               rstrtn:
0011A6  3  20 85 12     	jsr rsevt		; restart events.
0011A9  3  20 C8 20     	jsr nspr 		; clear all non-player sprites.
0011AC  3  20 9B 20     	jsr sprlst 		; fetch pointer to screen sprites.
0011AF  3  20 61 21     	jsr kspr 		; initialise sprite table, no more players.
0011B2  3               
0011B2  3               ; Set up the player and/or enemy sprites.
0011B2  3               
0011B2  3               rstrt0:
0011B2  3  A9 00        	lda #0 			; zero in accumulator.
0011B4  3  85 rr        	sta nexlev 		; reset next level flag.
0011B6  3  85 rr        	sta restfl 		; reset restart flag.
0011B8  3  85 rr        	sta deadf 		; reset dead flag.
0011BA  3  20 54 17     	jsr droom 		; show screen layout.
0011BD  3               rpblc0:
0011BD  3               .if pflag
0011BD  3               	jsr inishr 		; initialise particle engine.
0011BD  3               .endif
0011BD  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0011BD  3               .if aflag
0011BD  3               	jsr rbloc		; draw blocks for this screen
0011BD  3               .endif
0011BD  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0011BD  3  20 35 13     	jsr shwob		; draw objects.
0011C0  3               
0011C0  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
0011C2  3  85 rr        	sta z80_x
0011C4  3  A9 0B        	lda #>sprtab
0011C6  3  85 rr        	sta z80_i
0011C8  3  20 00 1D     	jsr dspr 		; display sprites.
0011CB  3               
0011CB  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0011CD  3  85 rr        	sta z80_x
0011CF  3  A9 0B        	lda #>(sprtab+TABSIZ)
0011D1  3  85 rr        	sta z80_i
0011D3  3  20 00 1D     	jsr dspr 		; display sprites.
0011D6  3               mloop:
0011D6  3  20 BC 0E     	jsr vsync 		; synchronise with display.
0011D9  3               
0011D9  3  A9 00        	lda #<sprtab 		; address of sprite table, even sprites.
0011DB  3  85 rr        	sta z80_x
0011DD  3  A9 0B        	lda #>sprtab
0011DF  3  85 rr        	sta z80_i
0011E1  3  20 00 1D     	jsr dspr 		; display even sprites.
0011E4  3               
0011E4  3  20 34 13     	jsr plsnd 		; play sounds.
0011E7  3  20 BC 0E     	jsr vsync 		; synchronise with display.
0011EA  3               
0011EA  3  A9 11        	lda #<(sprtab+TABSIZ) 	; address of first odd sprite.
0011EC  3  85 rr        	sta z80_x
0011EE  3  A9 0B        	lda #>(sprtab+TABSIZ)
0011F0  3  85 rr        	sta z80_i
0011F2  3  20 00 1D     	jsr dspr 		; display odd sprites.
0011F5  3               
0011F5  3  A9 09        	lda #<(ssprit) 		; point to spare sprite for spawning purposes.
0011F7  3  85 rr        	sta z80_x
0011F9  3  A9 23        	lda #>(ssprit)
0011FB  3  85 rr        	sta z80_i
0011FD  3               evlp1:
0011FD  3  20 DA 23     	jsr evnt10 		; called once per main loop.
001200  3  20 7E 1C     	jsr pspr 		; process sprites.
001203  3               
001203  3               ; Main loop events.
001203  3               
001203  3  A9 09        	lda #<ssprit 		; point to spare sprite for spawning purposes.
001205  3  85 rr        	sta z80_x
001207  3  A9 23        	lda #>ssprit
001209  3  85 rr        	sta z80_i
00120B  3               evlp2:
00120B  3  20 DB 23     	jsr evnt11 		; called once per main loop.
00120E  3               bsortx:
00120E  3  20 F4 1B     	jsr bsort 		; sort sprites.
001211  3               
001211  3  A5 rr        	lda nexlev		; finished level flag.
001213  3  D0 1F        	bne newlev		; is set, go to next level.
001215  3  A5 rr        	lda gamwon		; finished game flag.
001217  3  D0 2A        	bne evwon		; is set, finish the game.
001219  3  A5 rr        	lda restfl 		; finished level flag.
00121B  3  C9 01        	cmp #1			; has it been set?
00121D  3  D0 03        	bne :+
00121F  3  4C 97 11     	jmp rstrt		; yes, go to next level.
001222  3               :
001222  3  C9 02        	cmp #2			; has it been set?
001224  3  D0 03        	bne :+
001226  3  4C A6 11     	jmp rstrtn		; yes, go to next level.
001229  3               :
001229  3  A5 rr        	lda deadf 		; dead flag.
00122B  3  D0 1C        	bne pdead		; yes, player dead.
00122D  3               
00122D  3               ; back to start of main loop.
00122D  3               
00122D  3  E6 rr        	inc frmno
00122F  3  E6 rr        	inc clock
001231  3  4C D6 11     	jmp mloop		; switched to a jmp mloop during test mode.
001234  3               
001234  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001234  3               
001234  3               ;----------------------------------------------------------
001234  3               ; Read blocks from list and update screen accordingly.
001234  3               ;----------------------------------------------------------
001234  3               
001234  3               .if aflag
001234  3               rbloc:
001234  3               	lda #<eop		; reset temp blockpointer
001234  3               	sta tmp
001234  3               	lda #>eop
001234  3               	sta tmp+1
001234  3               
001234  3               rbloc2:
001234  3               	lda tmp			; check for last block
001234  3               	cmp pbptr
001234  3               	bne rbloc1
001234  3               	lda tmp+1
001234  3               	cmp pbptr+1
001234  3               	bne rbloc1
001234  3               	rts
001234  3               rbloc1:
001234  3               	ldy #0
001234  3               	lda (tmp),y		; check if block for this scno
001234  3               	cmp scno
001234  3               	bne rbloc0		; if not, skip
001234  3               	iny
001234  3               	lda (tmp),y		; get y
001234  3               	sta dispy
001234  3               	iny
001234  3               	lda (tmp),y		; get x
001234  3               	sta dispx
001234  3               	iny
001234  3               	lda (tmp),y		; get blocknr
001234  3               	jsr pattr2		; draw block
001234  3               rbloc0:
001234  3               	clc			; point to next block
001234  3               	lda tmp
001234  3               	adc #4
001234  3               	sta tmp
001234  3               	bcc rbloc2
001234  3               	inc tmp+1
001234  3               	jmp rbloc2
001234  3               .endif
001234  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001234  3               
001234  3               ;----------------------------------------------------------
001234  3               ; New level
001234  3               ;----------------------------------------------------------
001234  3               
001234  3               newlev:
001234  3  A5 rr        	lda scno 			; current screen.
001236  3  18           	clc
001237  3  69 01        	adc #1				; next screen.
001239  3  CD 86 27     	cmp numsc			; total number of screens.
00123C  3  B0 05        	bcs evwon			; yes, game finished.
00123E  3  85 rr        	sta scno			; set new level number.
001240  3  4C 97 11     	jmp rstrt			; restart, clearing all aliens.
001243  3               
001243  3               evwon:
001243  3  20 F6 23     	jsr evnt18		 	; game completed.
001246  3  4C 5A 12     	jmp tidyup			; tidy up and return to BASIC/calling routine.
001249  3               
001249  3               ;----------------------------------------------------------
001249  3               ; Player dead.
001249  3               ;----------------------------------------------------------
001249  3               
001249  3               pdead:
001249  3  A9 00        	lda #0				; zeroise accumulator.
00124B  3  85 rr        	sta deadf			; reset dead flag.
00124D  3               evdie:
00124D  3  20 F4 23     	jsr evnt16 			; death subroutine.
001250  3  A5 rr        	lda numlif			; number of lives.
001252  3  F0 03        	beq :+
001254  3  4C 97 11     	jmp rstrt 			; restart game.
001257  3               :
001257  3               evfail:
001257  3  20 F5 23     	jsr evnt17 			; failure event.
00125A  3               
00125A  3               ;----------------------------------------------------------
00125A  3               ; Tidy things up
00125A  3               ;----------------------------------------------------------
00125A  3               
00125A  3               tidyup:
00125A  3  A0 00        	ldy #0				; digits to check.
00125C  3               tidyu2:
00125C  3  B9 FF 14     	lda score,y 			; get score digit.
00125F  3  CD 05 15     	cmp hiscor 			; are we larger than high score digit?
001262  3  90 07        	bcc tidyu0			; high score is bigger.
001264  3  D0 0E        	bne tidyu1			; score is greater, record new high score.
001266  3  C8           	iny				; next digit of high score.
001267  3  C0 06        	cpy #6
001269  3  D0 F1        	bne tidyu2			; repeat for all digits
00126B  3               tidyu0:
00126B  3  A9 FF        	lda #<score			; return pointing to score.
00126D  3  85 rr        	sta z80_c
00126F  3  A9 14        	lda #>score
001271  3  85 rr        	sta z80_b
001273  3  60           	rts
001274  3               tidyu1:
001274  3  A0 05        	ldy #5
001276  3               tidyu3:
001276  3  B9 FF 14     	lda score,y			; score.
001279  3  99 05 15     	sta hiscor,y			; high score.
00127C  3  88           	dey
00127D  3  10 F7        	bpl tidyu3 			; copy score to high score.
00127F  3               evnewh:
00127F  3  20 F7 23     	jsr evnt19			; new high score event.
001282  3  4C 6B 12     	jmp tidyu0			; tidy up.
001285  3               
001285  3               ;--------------------------------------------------
001285  3               ; Restart event.
001285  3               ;--------------------------------------------------
001285  3               
001285  3               rsevt:
001285  3  A9 09        	lda #<ssprit 			; default to spare element in table.
001287  3  85 rr        	sta z80_x
001289  3  A9 23        	lda #>ssprit
00128B  3  85 rr        	sta z80_i
00128D  3               evrs:
00128D  3  4C DE 23     	jmp evnt14	 		; call restart event.
001290  3               
001290  3               ;------------------------------------------------------------------
001290  3               ; Copy number passed in a to string position bc, right-justified.
001290  3               ;
001290  3               ; Input:
001290  3               ;  A  = number
001290  3               ;  BC = string address
001290  3               ;
001290  3               ; Output:
001290  3               ;  BC = string with number
001290  3               ;-----------------------------------------------------------------
001290  3               
001290  3               num2ch:
001290  3  85 rr        	sta z80_d		; Save number
001292  3               
001292  3  A9 00        	lda #0
001294  3  85 rr        	sta flag
001296  3               numdg3:
001296  3  A2 64        	ldx #100		; hundreds column.
001298  3  86 rr        	stx z80_e
00129A  3  20 AA 12     	jsr numdg		; show digit.
00129D  3               numdg2:
00129D  3  A2 0A        	ldx #10			; tens column.
00129F  3  86 rr        	stx z80_e
0012A1  3  20 AA 12     	jsr numdg		; show digit.
0012A4  3               
0012A4  3  E6 rr        	inc flag
0012A6  3  A2 01        	ldx #1			; units column.
0012A8  3  86 rr        	stx z80_e
0012AA  3               numdg:
0012AA  3  A9 30        	lda #48			; clear digit.
0012AC  3  85 rr        	sta z80_a
0012AE  3               numdg1:
0012AE  3  A5 rr        	lda z80_d
0012B0  3  C5 rr        	cmp z80_e
0012B2  3  90 0E        	bcc numdg0		; nothing to show.
0012B4  3  38           	sec
0012B5  3  A5 rr        	lda z80_d
0012B7  3  E5 rr        	sbc z80_e		; subtract from column.
0012B9  3  85 rr        	sta z80_d
0012BB  3  E6 rr        	inc z80_a		; increment digit.
0012BD  3  E6 rr        	inc flag
0012BF  3  4C AE 12     	jmp numdg1		; repeat until column is zero.
0012C2  3               numdg0:
0012C2  3  A0 00        	ldy #0
0012C4  3  A5 rr        	lda z80_a
0012C6  3  91 rr        	sta (z80_bc),y		; write digit to buffer.
0012C8  3  A5 rr        	lda flag
0012CA  3  F0 06        	beq :+
0012CC  3  E6 rr        	inc z80_c		; next buffer position.
0012CE  3  D0 02        	bne :+
0012D0  3  E6 rr        	inc z80_b
0012D2  3               :
0012D2  3  60           	rts
0012D3  3               num2dd:
0012D3  3  85 rr        	sta z80_d		; Save number
0012D5  3               
0012D5  3  A9 01        	lda #1
0012D7  3  85 rr        	sta flag
0012D9  3               
0012D9  3  4C 9D 12     	jmp numdg2
0012DC  3               num2td:
0012DC  3  85 rr        	sta z80_d		; Save number
0012DE  3               
0012DE  3  A9 01        	lda #1
0012E0  3  85 rr        	sta flag
0012E2  3  4C 96 12     	jmp numdg3
0012E5  3               
0012E5  3               ;---------------------------------------------------------
0012E5  3               ; Reset score to "000000"
0012E5  3               ;---------------------------------------------------------
0012E5  3               
0012E5  3               inisc:
0012E5  3  A9 30        	lda #'0'
0012E7  3  A2 05        	ldx #5			; digits to initialise.
0012E9  3               inisc0:
0012E9  3  9D FF 14     	sta score,x 		; write zero digit.
0012EC  3  CA           	dex			; next column.
0012ED  3  10 FA        	bpl inisc0		; repeat for all digits.
0012EF  3               
0012EF  3  60           	rts
0012F0  3               
0012F0  3               ;-----------------------------------------------------
0012F0  3               ; Multiply h by d and return in hl.
0012F0  3               ;
0012F0  3               ; Input:
0012F0  3               ;  H = first number
0012F0  3               ;  D = second number
0012F0  3               ;
0012F0  3               ; Output:
0012F0  3               ;  HL = result H x D
0012F0  3               ;-----------------------------------------------------
0012F0  3               
0012F0  3               imul:
0012F0  3  A5 rr        	lda z80_d		; HL = H * D
0012F2  3  85 rr        	sta z80_e
0012F4  3  A5 rr        	lda z80_h
0012F6  3  85 rr        	sta z80_c		; make c first multiplier.
0012F8  3               imul0:
0012F8  3  A9 00        	lda #0			; zeroise total.
0012FA  3  85 rr        	sta z80_l
0012FC  3  85 rr        	sta z80_h
0012FE  3               
0012FE  3  A5 rr        	lda z80_h
001300  3  85 rr        	sta z80_d		; zeroise high byte.
001302  3               
001302  3  A9 08        	lda #8			; repeat 8 times.
001304  3  85 rr        	sta z80_b
001306  3               imul1:
001306  3  46 rr        	lsr z80_c		; rotate rightmost bit into carry.
001308  3  90 0E        	bcc imul2		; wasn't set.
00130A  3  18           	clc			; bit was set, so add de.
00130B  3  A5 rr        	lda z80_l
00130D  3  65 rr        	adc z80_e
00130F  3  85 rr        	sta z80_l
001311  3  A5 rr        	lda z80_h
001313  3  65 rr        	adc z80_d
001315  3  85 rr        	sta z80_h
001317  3  18           	clc 			; reset carry.
001318  3               imul2:
001318  3  06 rr        	asl z80_e 		; shift de 1 bit left.
00131A  3  26 rr        	rol z80_d
00131C  3  C6 rr        	dec z80_b
00131E  3  D0 E6        	bne imul1		; repeat 8 times.
001320  3               
001320  3  60           	rts
001321  3               
001321  3               ;-----------------------------------------------
001321  3               ; Divide d by e and return in d, remainder in a.
001321  3               ;
001321  3               ; Input:
001321  3               ;  D = first number
001321  3               ;  E = second number
001321  3               ;
001321  3               ; Output:
001321  3               ;  D = result D/E
001321  3               ;  A = remainder
001321  3               ;-----------------------------------------------
001321  3               
001321  3               idiv:
001321  3  A9 00        	lda #0
001323  3  A0 08        	ldy #8		 	; bits to shift.
001325  3  06 rr        	asl z80_d
001327  3               idiv0:
001327  3  2A           	rol a 			; multiply d by 2.
001328  3  C5 rr        	cmp z80_e 		; test if e is smaller.
00132A  3  90 02        	bcc idiv1		; e is greater, no division this time.
00132C  3  E5 rr        	sbc z80_e		; subtract it.
00132E  3               idiv1:
00132E  3  26 rr        	rol z80_d		; rotate into d.
001330  3  88           	dey
001331  3  D0 F4        	bne idiv0		; repeat
001333  3  60           	rts
001334  3               
001334  3               ;---------------------------------------------------
001334  3               ; Play AY sound effect
001334  3               ;---------------------------------------------------
001334  3               
001334  3               plsnd:
001334  3  60           	rts
001335  3               
001335  3               ;---------------------------------------------------
001335  3               ; Objects handling.
001335  3               ; 32 bytes for image
001335  3               ; 3 for room, y and x
001335  3               ; 3 for starting room, y and x.
001335  3               ; 254 = disabled.
001335  3               ; 255 = object in player"s pockets.
001335  3               ;---------------------------------------------------
001335  3               
001335  3               ;---------------------------------------------------
001335  3               ; Show items present.
001335  3               ;---------------------------------------------------
001335  3               
001335  3               shwob:
001335  3  A9 8C        	lda #<objdta 			; objects table.
001337  3  85 rr        	sta z80_l
001339  3  A9 27        	lda #>objdta
00133B  3  85 rr        	sta z80_h
00133D  3               
00133D  3  AD 7D 10     	lda numob 			; number of objects in the game.
001340  3  85 rr        	sta sprcnt
001342  3               shwob0:
001342  3  A0 20        	ldy #32 			; distance to room number.
001344  3  B1 rr        	lda (z80_hl),y 			; same as an item?
001346  3  C5 rr        	cmp scno 			; current location.
001348  3  D0 03        	bne :+
00134A  3  20 5F 13     	jsr dobj 			; yes, display object.
00134D  3               :
00134D  3  18           	clc
00134E  3  A5 rr        	lda z80_l
001350  3  69 26        	adc #38 			; distance to next item.
001352  3  85 rr        	sta z80_l
001354  3  A5 rr        	lda z80_h
001356  3  69 00        	adc #0
001358  3  85 rr        	sta z80_h	 		; point to it.
00135A  3  C6 rr        	dec sprcnt
00135C  3  D0 E4        	bne shwob0 			; repeat for others.
00135E  3  60           	rts
00135F  3               
00135F  3               ;---------------------------------------------------
00135F  3               ; Display object.
00135F  3               ; hl must point to object's start address.
00135F  3               ;
00135F  3               ; Input:
00135F  3               ;  HL = object address
00135F  3               ;---------------------------------------------------
00135F  3               
00135F  3               dobj:
00135F  3  A0 21        	ldy #33
001361  3  B1 rr        	lda (z80_hl),y 			; point to y.
001363  3  85 rr        	sta dispy
001365  3  C8           	iny
001366  3  B1 rr        	lda (z80_hl),y 			; point to x.
001368  3  85 rr        	sta dispx
00136A  3               dobj1:
00136A  3  4C 1E 0F     	jmp sprite 			; draw this sprite.
00136D  3               
00136D  3               ;--------------------------------------
00136D  3               ; Remove an object.
00136D  3               ;
00136D  3               ; Input:
00136D  3               ;  A = object number
00136D  3               ;--------------------------------------
00136D  3               
00136D  3               remob:
00136D  3  CD 7D 10     	cmp numob			; number of objects in game.
001370  3  90 01        	bcc :+				; are we checking past the end?
001372  3  60           	rts				; yes, can't get non-existent item.
001373  3               :
001373  3  48           	pha				; remember object.
001374  3  20 82 13     	jsr getob			; pick it up if we haven't already got it.
001377  3  68           	pla				; retrieve object number.
001378  3  20 B1 13     	jsr gotob			; get its address.
00137B  3  A9 FE        	lda #254
00137D  3  A0 20        	ldy #32
00137F  3  91 rr        	sta (z80_hl),y			; remove it.
001381  3  60           	rts
001382  3               
001382  3               ;---------------------------------------------------
001382  3               ; Pick up object number held in the accumulator.
001382  3               ;
001382  3               ; Input:
001382  3               ;  A = object number
001382  3               ;---------------------------------------------------
001382  3               
001382  3               getob:
001382  3  CD 7D 10     	cmp numob 		; number of objects in game.
001385  3  90 01        	bcc :+			; are we checking past the end?
001387  3  60           	rts			; yes, can't get non-existent item.
001388  3               :
001388  3  20 B1 13     	jsr gotob 		; check if we already have it.
00138B  3  C9 FF        	cmp #255
00138D  3  D0 01        	bne :+
00138F  3  60           	rts			; we already do.
001390  3               :
001390  3  A0 20        	ldy #32
001392  3  B1 rr        	lda (z80_hl),y		; is it on this screen?
001394  3  C5 rr        	cmp scno 		; current screen.
001396  3  D0 14        	bne getob0		; not on screen, so nothing to delete.
001398  3               
001398  3  A9 FF        	lda #255
00139A  3  91 rr        	sta (z80_hl),y		; pick it up.
00139C  3  C8           	iny 			; point to y coord.
00139D  3               getob1:
00139D  3  A0 21        	ldy #33
00139F  3  B1 rr        	lda (z80_hl),y		; y coord.
0013A1  3  85 rr        	sta dispy
0013A3  3  A0 22        	ldy #34
0013A5  3  B1 rr        	lda (z80_hl),y 		; x coord.
0013A7  3  85 rr        	sta dispx
0013A9  3  4C 6A 13     	jmp dobj1 		; delete object sprite.
0013AC  3               getob0:
0013AC  3  A9 FF        	lda #255
0013AE  3  91 rr        	sta (z80_hl),y 		; pick it up.
0013B0  3  60           	rts
0013B1  3               
0013B1  3               ;-----------------------------------------------------------------
0013B1  3               ; Got object check.
0013B1  3               ; Call with object in accumulator, returns zero set if in pockets.
0013B1  3               ;
0013B1  3               ; Input:
0013B1  3               ;  A = object number
0013B1  3               ;-----------------------------------------------------------------
0013B1  3               
0013B1  3               gotob:
0013B1  3  CD 7D 10     	cmp numob 		; number of objects in game.
0013B4  3  90 03        	bcc :+ 			; are we checking past the end?
0013B6  3  4C BD 13     	jmp gotob0 		; yes, we can't have a non-existent object.
0013B9  3               :
0013B9  3  20 C2 13     	jsr findob		; find the object.
0013BC  3               gotob1:
0013BC  3  60           	rts
0013BD  3               
0013BD  3               gotob0:
0013BD  3  A9 FE        	lda #254 		; missing.
0013BF  3  4C BC 13     	jmp gotob1
0013C2  3               
0013C2  3               findob:
0013C2  3  48           	pha			; save object number
0013C3  3  A9 8C        	lda #<objdta 		; objects.
0013C5  3  85 rr        	sta z80_l
0013C7  3  A9 27        	lda #>objdta
0013C9  3  85 rr        	sta z80_h
0013CB  3  68           	pla			; retreive object number
0013CC  3  F0 0F        	beq fndob1 		; is it zero? yes, skip loop.
0013CE  3  AA           	tax 			; loop counter
0013CF  3               fndob2:
0013CF  3  18           	clc
0013D0  3  A5 rr        	lda z80_l
0013D2  3  69 26        	adc #38 		; size of each object.
0013D4  3  85 rr        	sta z80_l
0013D6  3  90 02        	bcc :+
0013D8  3  E6 rr        	inc z80_h
0013DA  3               :
0013DA  3  CA           	dex 			; repeat until we find address.
0013DB  3  D0 F2        	bne fndob2
0013DD  3               fndob1:
0013DD  3  A0 20        	ldy #32			; distance to room it's in.
0013DF  3  B1 rr        	lda (z80_hl),y		; fetch status.
0013E1  3  60           	rts
0013E2  3               
0013E2  3               ;---------------------------------------------
0013E2  3               ; Drop object number at (dispx, dispy).
0013E2  3               ;
0013E2  3               ; Input:
0013E2  3               ;  A = object number
0013E2  3               ;---------------------------------------------
0013E2  3               
0013E2  3               drpob:
0013E2  3  CD 7D 10     	cmp numob 		; are we checking past the end?
0013E5  3  90 01        	bcc :+
0013E7  3  60           	rts			; yes, can't drop non-existent item.
0013E8  3               :
0013E8  3  20 B1 13     	jsr gotob		; make sure object is in inventory.
0013EB  3  C5 rr        	cmp scno		; already on this screen?
0013ED  3  D0 01        	bne :+
0013EF  3  60           	rts			; yes, nothing to do.
0013F0  3               :
0013F0  3  A0 20        	ldy #32
0013F2  3  A5 rr        	lda scno
0013F4  3  91 rr        	sta (z80_hl),y		; bring onto screen.
0013F6  3  A5 rr        	lda dispy		; sprite y coordinate.
0013F8  3  C8           	iny 
0013F9  3  91 rr        	sta (z80_hl),y		; point to object y.
0013FB  3  A5 rr        	lda dispx 		; sprite x coordinate.
0013FD  3  C8           	iny
0013FE  3  91 rr        	sta (z80_hl),y 		; point to object x
001400  3  4C 5F 13     	jmp dobj		; draw the object sprite.
001403  3               
001403  3               ;-----------------------------------------------
001403  3               ; Seek objects at sprite position.
001403  3               ;
001403  3               ; Output:
001403  3               ;  A = object number, if not found A=255
001403  3               ;-----------------------------------------------
001403  3               
001403  3               skobj:
001403  3  A9 8C        	lda #<objdta 		; pointer to objects.
001405  3  85 rr        	sta z80_l
001407  3  A9 27        	lda #>objdta
001409  3  85 rr        	sta z80_h
00140B  3               
00140B  3  AD 7D 10     	lda numob 		; number of objects in game.
00140E  3  85 rr        	sta z80_b 		; set up the loop counter.
001410  3               skobj0:
001410  3  A5 rr        	lda scno		; current room number.
001412  3  A0 20        	ldy #32
001414  3  D1 rr        	cmp (z80_hl),y		; is object in here?
001416  3  D0 03        	bne :+
001418  3  20 2D 14     	jsr skobj1		; yes, check coordinates.
00141B  3               :
00141B  3  18           	clc			; point to next object in table.
00141C  3  A5 rr        	lda z80_l
00141E  3  69 26        	adc #38			; size of each object.
001420  3  85 rr        	sta z80_l
001422  3  90 02        	bcc :+
001424  3  E6 rr        	inc z80_h
001426  3               :
001426  3  C6 rr        	dec z80_b
001428  3  D0 E6        	bne skobj0		; repeat for all objects.
00142A  3               
00142A  3  A9 FF        	lda #255		; end of list and nothing found, return 255.
00142C  3  60           	rts
00142D  3               
00142D  3               skobj1:
00142D  3  A0 21        	ldy #33			; point to y coordinate.
00142F  3  B1 rr        	lda (z80_hl),y		; point to y coordinate.
001431  3  38           	sec
001432  3  A0 08        	ldy #var_newY
001434  3  F1 rr        	sbc (z80_ix),y 		; subtract sprite y.
001436  3  18           	clc
001437  3  69 0F        	adc #15			; add sprite height minus one.
001439  3  C9 1F        	cmp #31			; within range?
00143B  3  90 03        	bcc :+
00143D  3  4C 5B 14     	jmp skobj2		; no, ignore object.
001440  3               :
001440  3  A0 22        	ldy #34			; point to x coordinate now.
001442  3  B1 rr        	lda (z80_hl),y 		; get coordinate.
001444  3  38           	sec
001445  3  A0 09        	ldy #var_newX
001447  3  F1 rr        	sbc (z80_ix),y 		; subtract the sprite x.
001449  3  18           	clc			; add sprite width minus one.
00144A  3  69 0F        	adc #15
00144C  3  C9 1F        	cmp #31			; within range?
00144E  3  90 03        	bcc :+
001450  3  4C 5B 14     	jmp skobj2		; no, ignore object.
001453  3               :
001453  3  68           	pla			; remove return address from stack.
001454  3  68           	pla
001455  3               
001455  3  AD 7D 10     	lda numob 		; objects in game.
001458  3  38           	sec
001459  3  E5 rr        	sbc z80_b		; subtract loop counter.
00145B  3               skobj2:
00145B  3  60           	rts			; accumulator now points to object.
00145C  3               
00145C  3               
00145C  3               ;---------------------------------------------------------------------
00145C  3               ; Spawn a new sprite.
00145C  3               ;---------------------------------------------------------------------
00145C  3               
00145C  3               spawn:
00145C  3  A9 00        	lda #<sprtab		; sprite table.
00145E  3  85 rr        	sta z80_l
001460  3  A9 0B        	lda #>sprtab
001462  3  85 rr        	sta z80_h
001464  3               numsp1:
001464  3  A9 0C        	lda #NUMSPR		; number of sprites.
001466  3  85 rr        	sta spcnt
001468  3               spaw0:
001468  3  A0 00        	ldy #var_Type
00146A  3  B1 rr        	lda (z80_hl),y		; get sprite type.
00146C  3  C9 FF        	cmp #255		; is it an unused slot?
00146E  3  F0 0F        	beq spaw1 		; yes, we can use this one.
001470  3               
001470  3  18           	clc 			; point to next sprite in table.
001471  3  A5 rr        	lda z80_l
001473  3  69 11        	adc #TABSIZ		; size of each entry.
001475  3  85 rr        	sta z80_l
001477  3  90 02        	bcc :+
001479  3  E6 rr        	inc z80_h
00147B  3               :
00147B  3  C6 rr        	dec spcnt		; one less iteration.
00147D  3  D0 E9        	bne spaw0		; keep going until we find a slot.
00147F  3               
00147F  3               ; Didn't find one but drop through and set up a dummy sprite instead.
00147F  3               
00147F  3               spaw1:
00147F  3  A5 rr        	lda z80_i		; address of original sprite.
001481  3  48           	pha
001482  3  A5 rr        	lda z80_x
001484  3  48           	pha
001485  3               
001485  3  A5 rr        	lda z80_l		; store spawned sprite address.
001487  3  85 rr        	sta spptr
001489  3  A5 rr        	lda z80_h
00148B  3  85 rr        	sta spptr+1
00148D  3               
00148D  3  A5 rr        	lda z80_c
00148F  3  A0 00        	ldy #var_Type
001491  3  91 rr        	sta (z80_hl),y 		; set the type.
001493  3  A0 05        	ldy #var_newType
001495  3  91 rr        	sta (z80_hl),y		; copy
001497  3               
001497  3  A5 rr        	lda z80_b
001499  3  A0 01        	ldy #var_Image
00149B  3  91 rr        	sta (z80_hl),y		; set the image.
00149D  3  A0 06        	ldy #var_newImage
00149F  3  91 rr        	sta (z80_hl),y		; copy
0014A1  3               
0014A1  3  A9 00        	lda #0 				; frame zero.
0014A3  3  A0 02        	ldy #var_Frame
0014A5  3  91 rr        	sta (z80_hl),y		; set frame.
0014A7  3  A0 07        	ldy #var_newFrame
0014A9  3  91 rr        	sta (z80_hl),y		; copy
0014AB  3               
0014AB  3  A0 09        	ldy #9
0014AD  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
0014AF  3  A0 04        	ldy #var_X
0014B1  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0014B3  3  A0 09        	ldy #var_newX
0014B5  3  91 rr        	sta (z80_hl),y		; copy
0014B7  3               
0014B7  3  A0 08        	ldy #8
0014B9  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
0014BB  3  A0 03        	ldy #var_Y
0014BD  3  91 rr        	sta (z80_hl),y		; set sprite coordinate.
0014BF  3  A0 08        	ldy #var_newY
0014C1  3  91 rr        	sta (z80_hl),y		; copy
0014C3  3               
0014C3  3  A0 0A        	ldy #10				; direction of original.
0014C5  3  B1 rr        	lda (z80_ix),y
0014C7  3  A0 0A        	ldy #var_Direction
0014C9  3  91 rr        	sta (z80_hl),y		; direction
0014CB  3               
0014CB  3  A9 00        	lda #0
0014CD  3  A0 0D        	ldy #var_jumpLo
0014CF  3  91 rr        	sta (z80_hl),y		; reset parameter.
0014D1  3  C8           	iny
0014D2  3  91 rr        	sta (z80_hl),y		; reset parameter.
0014D4  3  C8           	iny
0014D5  3  91 rr        	sta (z80_hl),y		; reset parameter.
0014D7  3  C8           	iny
0014D8  3  91 rr        	sta (z80_hl),y		; reset parameter.
0014DA  3               rtssp:
0014DA  3  A5 rr        	lda spptr			; address of new sprite.
0014DC  3  85 rr        	sta z80_x
0014DE  3  A5 rr        	lda spptr+1
0014E0  3  85 rr        	sta z80_i
0014E2  3               evis1:
0014E2  3  20 D9 23     	jsr evnt09 			; call sprite initialisation event.
0014E5  3               
0014E5  3  A5 rr        	lda spptr 			; address of new sprite.
0014E7  3  85 rr        	sta z80_x
0014E9  3  A5 rr        	lda spptr+1
0014EB  3  85 rr        	sta z80_i
0014ED  3               
0014ED  3               	; _BEEB clipping code copied from CPC Engine - MISSING?!
0014ED  3  A0 03        	ldy #var_Y
0014EF  3  B1 rr        	lda (z80_hl), y		; old x coord
0014F1  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
0014F3  3  B0 03        	bcs :+				; yes, don't draw it.
0014F5  3               
0014F5  3  20 8F 0F     	jsr sspria 			; display the new sprite.
0014F8  3               :
0014F8  3  68           	pla					; address of original sprite.
0014F9  3  85 rr        	sta z80_x
0014FB  3  68           	pla
0014FC  3  85 rr        	sta z80_i
0014FE  3               
0014FE  3  60           	rts
0014FF  3               
0014FF  3  30 30 30 30  score:	.byte "000000"		; player"s score.
001503  3  30 30        
001505  3  30 30 30 30  hiscor:	.byte "000000"		; high score.
001509  3  30 30        
00150B  3  30 30 30 30  bonus:	.byte "000000"		; bonus.
00150F  3  30 30        
001511  3  00 68        grbase:	.word ScreenAddr	; graphics base address.
001513  3               
001513  3               ;----------------------------------------------------
001513  3               ; Check y-pos
001513  3               ;----------------------------------------------------
001513  3               
001513  3               checkx:
001513  3  A5 rr        	lda dispy		; y position.
001515  3  C9 18        	cmp #24			; off screen?
001517  3  B0 01        	bcs :+
001519  3  60           	rts			; no, it's okay.
00151A  3               :
00151A  3  68           	pla			; remove return address from stack.
00151B  3  85 rr        	sta z80_l
00151D  3  68           	pla
00151E  3  85 rr        	sta z80_h
001520  3  60           	rts
001521  3               
001521  3               ;-----------------------------------------------
001521  3               ; Displays the current high score.
001521  3               ;-----------------------------------------------
001521  3               
001521  3               dhisc:
001521  3  A9 05        	lda #<hiscor 		; high score text.
001523  3  85 rr        	sta z80_l
001525  3  A9 15        	lda #>hiscor
001527  3  85 rr        	sta z80_h
001529  3  4C 34 15     	jmp dscor1		; check in printable range then show 6 digits.
00152C  3               
00152C  3               ;------------------------------------------------------
00152C  3               ; Displays the current score.
00152C  3               ;------------------------------------------------------
00152C  3               
00152C  3               dscor:
00152C  3  A9 FF        	lda #<score		; score text.
00152E  3  85 rr        	sta z80_l
001530  3  A9 14        	lda #>score
001532  3  85 rr        	sta z80_h
001534  3               dscor1:
001534  3  20 C8 1B     	jsr preprt		; set up font and print position.
001537  3  20 13 15     	jsr checkx		; make sure we're in a printable range.
00153A  3               
00153A  3  A9 06        	lda #6			; digits to display.
00153C  3  85 rr        	sta z80_b
00153E  3  A5 rr        	lda prtmod		; get print mode.
001540  3  F0 03        	beq :+			; standard size text?
001542  3  4C 61 15     	jmp bscor0		; no, show double-height.
001545  3               :
001545  3               dscor0:
001545  3  A0 00        	ldy #0
001547  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001549  3  20 2C 10     	jsr pchar 		; display character.
00154C  3  E6 rr        	inc dispx		; move along x coordinate
00154E  3               
00154E  3  E6 rr        	inc z80_l		; next score column.
001550  3  D0 02        	bne :+
001552  3  E6 rr        	inc z80_h
001554  3               :
001554  3  C6 rr        	dec z80_b
001556  3  D0 ED        	bne dscor0 		; repeat for all digits.
001558  3               dscor2:
001558  3  A5 rr        	lda dispx 		; set up display coordinates.
00155A  3  85 rr        	sta charx
00155C  3  A5 rr        	lda dispy
00155E  3  85 rr        	sta chary
001560  3  60           	rts
001561  3               
001561  3               ;------------------------------------------------------
001561  3               ; Displays the current score in double-height characters.
001561  3               ;
001561  3               ; Input:
001561  3               ;  B  = digit number
001561  3               ;  HL = score string
001561  3               ;------------------------------------------------------
001561  3               
001561  3               bscor0:
001561  3  A0 00        	ldy #0
001563  3               
001563  3  B1 rr        	lda (z80_hl),y 		; fetch character.
001565  3  20 4B 1B     	jsr bchar 		; display big char.
001568  3               
001568  3  E6 rr        	inc z80_l 		; next score column.
00156A  3  D0 02        	bne :+
00156C  3  E6 rr        	inc z80_h
00156E  3               :
00156E  3  C6 rr        	dec z80_b
001570  3  F0 03        	beq :+
001572  3  4C 61 15     	jmp bscor0 		; repeat for all digits.
001575  3               :
001575  3  4C 58 15     	jmp dscor2 		; tidy up line and column variables.
001578  3               
001578  3               ;-----------------------------------------------------
001578  3               ; Adds number in the hl pair to the score.
001578  3               ;-----------------------------------------------------
001578  3               
001578  3               addsc:
001578  3  A9 00        	lda #<(score+1) 	; ten thousands column.
00157A  3  85 rr        	sta z80_e
00157C  3  A9 15        	lda #>(score+1)
00157E  3  85 rr        	sta z80_d
001580  3  A9 10        	lda #<10000		; amount to add each time.
001582  3  85 rr        	sta z80_c
001584  3  A9 27        	lda #>10000
001586  3  85 rr        	sta z80_b
001588  3  20 CC 15     	jsr incsc		; add to score.
00158B  3               
00158B  3  E6 rr        	inc z80_e		; thousands column.
00158D  3  D0 02        	bne :+
00158F  3  E6 rr        	inc z80_d
001591  3               :
001591  3  A9 E8        	lda #<1000		; amount to add each time.
001593  3  85 rr        	sta z80_c
001595  3  A9 03        	lda #>1000
001597  3  85 rr        	sta z80_b
001599  3  20 CC 15     	jsr incsc 		; add to score.
00159C  3               
00159C  3  E6 rr        	inc z80_e		; hundreds column.
00159E  3  D0 02        	bne :+
0015A0  3  E6 rr        	inc z80_d
0015A2  3               :
0015A2  3  A9 64        	lda #<100		; amount to add each time.
0015A4  3  85 rr        	sta z80_c
0015A6  3  A9 00        	lda #>100
0015A8  3  85 rr        	sta z80_b
0015AA  3  20 CC 15     	jsr incsc		; add to score.
0015AD  3               
0015AD  3  E6 rr        	inc z80_e 		; tens column.
0015AF  3  D0 02        	bne :+
0015B1  3  E6 rr        	inc z80_d
0015B3  3               :
0015B3  3  A9 0A        	lda #<10		; amount to add each time.
0015B5  3  85 rr        	sta z80_c
0015B7  3  A9 00        	lda #>10
0015B9  3  85 rr        	sta z80_b
0015BB  3  20 CC 15     	jsr incsc 		; add to score.
0015BE  3               
0015BE  3  E6 rr        	inc z80_e		; units column.
0015C0  3  D0 02        	bne :+
0015C2  3  E6 rr        	inc z80_d
0015C4  3               :
0015C4  3  A9 01        	lda #<1			; units.
0015C6  3  85 rr        	sta z80_c
0015C8  3  A9 00        	lda #>1
0015CA  3  85 rr        	sta z80_b
0015CC  3               incsc:
0015CC  3  A5 rr        	lda z80_h		; store amount to add.
0015CE  3  48           	pha
0015CF  3  A5 rr        	lda z80_l
0015D1  3  48           	pha
0015D2  3               
0015D2  3  38           	sec			; subtract from amount to add.
0015D3  3  A5 rr        	lda z80_l
0015D5  3  E5 rr        	sbc z80_c
0015D7  3  85 rr        	sta z80_l
0015D9  3  A5 rr        	lda z80_h
0015DB  3  E5 rr        	sbc z80_b
0015DD  3  85 rr        	sta z80_h
0015DF  3  90 14        	bcc incsc0		; too much, restore value.
0015E1  3               
0015E1  3  68           	pla			; delete the previous amount from the stack.
0015E2  3  68           	pla
0015E3  3               
0015E3  3  A5 rr        	lda z80_d 		; store column position.
0015E5  3  48           	pha
0015E6  3  A5 rr        	lda z80_e
0015E8  3  48           	pha
0015E9  3  20 FC 15     	jsr incsc2		; do the increment.
0015EC  3               
0015EC  3  68           	pla			; restore column.
0015ED  3  85 rr        	sta z80_e
0015EF  3  68           	pla
0015F0  3  85 rr        	sta z80_d
0015F2  3  4C CC 15     	jmp incsc		; repeat until all added.
0015F5  3               
0015F5  3               incsc0:
0015F5  3  68           	pla			; restore previous value.
0015F6  3  85 rr        	sta z80_l
0015F8  3  68           	pla
0015F9  3  85 rr        	sta z80_h
0015FB  3  60           	rts
0015FC  3               incsc2:
0015FC  3  A0 00        	ldy #0
0015FE  3  B1 rr        	lda (z80_de),y 		; get amount.
001600  3  18           	clc
001601  3  69 01        	adc #1			; add one to column.
001603  3  91 rr        	sta (z80_de),y		; write new column total.
001605  3  C9 3A        	cmp #'9'+1		; gone beyond range of digits?
001607  3  B0 01        	bcs :+
001609  3  60           	rts			; no, carry on.
00160A  3               :
00160A  3  A9 30        	lda #'0'		; make it zero.
00160C  3  91 rr        	sta (z80_de),y		; write new column total.
00160E  3  C6 rr        	dec z80_e		; back one column.
001610  3  D0 02        	bne :+
001612  3  C6 rr        	dec z80_d
001614  3               :
001614  3  4C FC 15     	jmp incsc2
001617  3               
001617  3               ;------------------------------------
001617  3               ; Add bonus to score and reset bonus
001617  3               ;------------------------------------
001617  3               
001617  3               addbo:
001617  3  A2 05        	ldx #5			; last digit.
001619  3  18           	clc			; clear carry.
00161A  3               addbo0:
00161A  3  BD FF 14     	lda score,x		; get score.
00161D  3  7D 0B 15     	adc bonus,x		; add bonus.
001620  3  38           	sec			; 0 to 18.
001621  3  E9 30        	sbc #48
001623  3  48           	pha
001624  3  A9 30        	lda #'0'
001626  3  9D 0B 15     	sta bonus,x		; zeroise bonus.
001629  3  68           	pla
00162A  3  C9 3A        	cmp #58			; carried?
00162C  3  B0 07        	bcs addbo2		; no, do next one.
00162E  3  38           	sec
00162F  3  E9 0A        	sbc #10			; subtract 10.
001631  3  38           	sec
001632  3  4C 36 16     	jmp addbo1
001635  3               addbo2:
001635  3  18           	clc
001636  3               addbo1:
001636  3  9D FF 14     	sta score,x		; write new score.
001639  3  CA           	dex			; next digit.
00163A  3  10 DE        	bpl addbo0		; repeat for all 6 digits.
00163C  3  60           	rts
00163D  3               
00163D  3               ;------------------------------------
00163D  3               ; Swap score and bonus.
00163D  3               ;------------------------------------
00163D  3               
00163D  3               swpsb:
00163D  3  A2 05        	ldx #5			; digits to add.
00163F  3               swpsb0:
00163F  3  BD FF 14     	lda score,x 		; get score digits.
001642  3  48           	pha			; save digit
001643  3  BD 0B 15     	lda bonus,x 		; get bonus digits.
001646  3  9D FF 14     	sta score,x		; switch score-bonus
001649  3  68           	pla
00164A  3  9D 0B 15     	sta bonus,x
00164D  3  CA           	dex 			; repeat for all 6 digits.
00164E  3  10 EF        	bpl swpsb0
001650  3  60           	rts
001651  3               
001651  3               ;----------------------------------------------------
001651  3               ; Get print address.
001651  3               ;----------------------------------------------------
001651  3               
001651  3               gprad:
001651  3  98           	tya
001652  3  48           	pha
001653  3               
001653  3  A5 rr        	lda dispx 		; x coordinate.
001655  3  85 rr        	sta scraddr
001657  3  A9 00        	lda #0
001659  3  85 rr        	sta scraddr+1
00165B  3  06 rr        	asl scraddr  	; multiply char by 8
00165D  3  26 rr        	rol scraddr+1
00165F  3  06 rr        	asl scraddr
001661  3  26 rr        	rol scraddr+1
001663  3  06 rr        	asl scraddr
001665  3  26 rr        	rol scraddr+1
001667  3               
001667  3  A5 rr        	lda dispy		; y coordinate.
001669  3  0A           	asl a
00166A  3  0A           	asl a
00166B  3  0A           	asl a			; multiply char by 8
00166C  3  A8           	tay
00166D  3               
00166D  3  18           	clc
00166E  3  A5 rr        	lda scraddr
001670  3  79 00 06     	adc SCADTB_lb,y
001673  3  85 rr        	sta scraddr
001675  3  A5 rr        	lda scraddr+1
001677  3  79 00 07     	adc SCADTB_hb,y
00167A  3  85 rr        	sta scraddr+1
00167C  3               
00167C  3  68           	pla
00167D  3  A8           	tay
00167E  3  60           	rts
00167F  3               
00167F  3               ;--------------------------------------------------------------
00167F  3               ; Get property buffer address of char at (dispx, dispy) in hl.
00167F  3               ; 
00167F  3               ; Output:
00167F  3               ;  bufaddr = MAP + dispy*32 + dispx
00167F  3               ;--------------------------------------------------------------
00167F  3               
00167F  3               pradd:
00167F  3  A5 rr        	lda dispy 		; y coordinate.
001681  3  85 rr        	sta bufaddr
001683  3  A9 00        	lda #0
001685  3  85 rr        	sta bufaddr+1
001687  3  06 rr        	asl bufaddr  		; multiply char by 32
001689  3  26 rr        	rol bufaddr+1
00168B  3  06 rr        	asl bufaddr
00168D  3  26 rr        	rol bufaddr+1
00168F  3  06 rr        	asl bufaddr
001691  3  26 rr        	rol bufaddr+1
001693  3  06 rr        	asl bufaddr
001695  3  26 rr        	rol bufaddr+1
001697  3  06 rr        	asl bufaddr
001699  3  26 rr        	rol bufaddr+1
00169B  3  18           	clc			; add address of MAP graphics.
00169C  3  A5 rr        	lda bufaddr
00169E  3  65 rr        	adc dispx
0016A0  3  69 00        	adc #<MAP
0016A2  3  85 rr        	sta bufaddr
0016A4  3  A5 rr        	lda bufaddr+1
0016A6  3  69 03        	adc #>MAP
0016A8  3  85 rr        	sta bufaddr+1
0016AA  3  60           	rts
0016AB  3               
0016AB  3               ;----------------------------------------------
0016AB  3               ; Print attributes, properties and pixels.
0016AB  3               ;
0016AB  3               ; Input:
0016AB  3               ;  A	= tile number
0016AB  3               ;----------------------------------------------
0016AB  3               
0016AB  3  00           colpatt:	.byte 0
0016AC  3               
0016AC  3               pattr:
0016AC  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0016AC  3               .if aflag
0016AC  3               	pha
0016AC  3               	jsr wbloc		; save blockinfo
0016AC  3               	pla
0016AC  3               .endif
0016AC  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
0016AC  3               
0016AC  3               pattr2:
0016AC  3  85 rr        	sta z80_b		; store cell in b register for now.
0016AE  3  AA           	tax
0016AF  3  BD 31 24     	lda bprop,x 		; block properties.
0016B2  3  85 rr        	sta z80_c
0016B4  3  C9 08        	cmp #COLECT
0016B6  3  D0 05        	bne :+
0016B8  3  A5 rr        	lda z80_b
0016BA  3  8D AB 16     	sta colpatt
0016BD  3               :
0016BD  3  20 7F 16     	jsr pradd 		; get property buffer address.
0016C0  3  A5 rr        	lda z80_c
0016C2  3  A0 00        	ldy #0
0016C4  3  91 rr        	sta (bufaddr),y 	; write property.
0016C6  3  A5 rr        	lda z80_b 		; restore cell.
0016C8  3               
0016C8  3               ; Print attributes, no properties.
0016C8  3               
0016C8  3               panp:
0016C8  3  85 rr        	sta z80_e		; displacement in e.
0016CA  3  A9 00        	lda #0
0016CC  3  85 rr        	sta z80_d		; no high byte.
0016CE  3  06 rr        	asl z80_e  		; multiply char by 8.
0016D0  3  26 rr        	rol z80_d
0016D2  3  06 rr        	asl z80_e
0016D4  3  26 rr        	rol z80_d
0016D6  3  06 rr        	asl z80_e
0016D8  3  26 rr        	rol z80_d
0016DA  3  18           	clc
0016DB  3  A5 rr        	lda z80_e
0016DD  3  69 11        	adc #<chgfx 		; address of graphics.
0016DF  3  85 rr        	sta tileaddr
0016E1  3  A5 rr        	lda z80_d
0016E3  3  69 24        	adc #>chgfx
0016E5  3  85 rr        	sta tileaddr+1
0016E7  3  20 51 16     	jsr gprad 		; get screen address.
0016EA  3  A2 07        	ldx #7			; number of pixel rows to write.
0016EC  3               panp0:
0016EC  3  A0 00        	ldy #0
0016EE  3  B1 rr        	lda (tileaddr),y 	; get image byte.
0016F0  3  49 00        	eor #TxtInvert		; Invert
0016F2  3  BC 65 10     	ldy scrtab,x
0016F5  3  91 rr        	sta (scraddr),y 	; copy to screen.
0016F7  3  E6 rr        	inc tileaddr 		; next image byte.
0016F9  3  D0 02        	bne :+
0016FB  3  E6 rr        	inc tileaddr+1
0016FD  3               :
0016FD  3  CA           	dex	 		; repeat for 8 pixel rows.
0016FE  3  10 EC        	bpl panp0
001700  3  E6 rr        	inc dispx 		; move along one.
001702  3  E6 rr        	inc charx
001704  3  60           	rts
001705  3               
001705  3               ;----------------------------------------------
001705  3               ; Write block
001705  3               ;----------------------------------------------
001705  3               
001705  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001705  3               .if aflag
001705  3               wbloc:
001705  3               	ldy #3
001705  3               	sta (pbptr),y		; store block number
001705  3               	dey
001705  3               	lda dispx
001705  3               	sta (pbptr),y		; write x position of block.
001705  3               	dey
001705  3               	lda dispy
001705  3               	sta (pbptr),y		; write y position of block.
001705  3               	dey
001705  3               	lda scno
001705  3               	sta (pbptr),y		; write screen.
001705  3               	clc			; point to next free location
001705  3               	lda pbptr
001705  3               	adc #4
001705  3               	sta pbptr
001705  3               	bcc :+
001705  3               	inc pbptr+1
001705  3               :
001705  3               	rts
001705  3               .endif
001705  3               ;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
001705  3               
001705  3               ;----------------------------------------------
001705  3               ; Print character pixels, no more.
001705  3               ;
001705  3               ; Input:
001705  3               ;  A	= character to print
001705  3               ;----------------------------------------------
001705  3               
001705  3               pchr:
001705  3  20 2C 10     	jsr pchar 		; show character in accumulator.
001708  3  E6 rr        	inc dispx		; move along one.
00170A  3  60           	rts
00170B  3               
00170B  3               ;----------------------------------------------------
00170B  3               ; Shifter sprite routine for objects.
00170B  3               ;----------------------------------------------------
00170B  3               
00170B  3               sprit7:
00170B  3  A5 rr        	lda z80_b
00170D  3  F0 0F        	beq sprit0
00170F  3  85 rr        	sta z80_a
001711  3               sprit3:
001711  3  4E 78 0F     	lsr spr			; shift into position.
001714  3  6E 79 0F     	ror spr+1
001717  3  6E 7A 0F     	ror spr+2
00171A  3  C6 rr        	dec z80_a		; one less iteration.
00171C  3  D0 F3        	bne sprit3
00171E  3               sprit0:
00171E  3  60           	rts 			; now apply to screen.
00171F  3               
00171F  3               ;-----------------------------------------------------------
00171F  3               ; Get room address.
00171F  3               ;-----------------------------------------------------------
00171F  3               
00171F  3               groom:
00171F  3  A6 rr        	ldx scno 		; screen number.
001721  3  A0 00        	ldy #0
001723  3               groomx:
001723  3  A9 39        	lda #<scdat 		; pointer to screens.
001725  3  85 rr        	sta z80_l
001727  3  A9 26        	lda #>scdat
001729  3  85 rr        	sta z80_h
00172B  3               groom1:
00172B  3  E0 00        	cpx #0			; is it the first one?
00172D  3  F0 15        	beq groom0 		; no more screens to skip.
00172F  3               
00172F  3  18           	clc
001730  3  A5 rr        	lda z80_l
001732  3  79 39 26     	adc scdat,y 		; low byte of screen size.
001735  3  85 rr        	sta z80_l
001737  3  C8           	iny			; point to high byte.
001738  3  A5 rr        	lda z80_h
00173A  3  79 39 26     	adc scdat,y 		; high byte of screen size.
00173D  3  85 rr        	sta z80_h
00173F  3  C8           	iny			; next address.
001740  3               
001740  3  CA           	dex 			; one less iteration.
001741  3  4C 2B 17     	jmp groom1 		; loop until we reach the end.
001744  3               groom0:
001744  3  AD 86 27     	lda numsc 		; add displacement.
001747  3  0A           	asl a
001748  3  18           	clc			; add double displacement to address.
001749  3  65 rr        	adc z80_l
00174B  3  85 rr        	sta z80_l
00174D  3  A5 rr        	lda z80_h
00174F  3  69 00        	adc #0
001751  3  85 rr        	sta z80_h
001753  3  60           	rts
001754  3               
001754  3               ;-----------------------------------------------------------
001754  3               ; Draw present room.
001754  3               ;-----------------------------------------------------------
001754  3               
001754  3               droom:
001754  3  AD 79 10     	lda wintop 		; window top.
001757  3  85 rr        	sta dispy		; set cursor y position.
001759  3               droom2:
001759  3  20 1F 17     	jsr groom 		; get address of current room.
00175C  3  A9 00        	lda #0	 		; zero in accumulator.
00175E  3  85 rr        	sta comcnt 		; reset compression counter.
001760  3  AD 7B 10     	lda winhgt 		; height of window.
001763  3  85 rr        	sta rrow		; set row counter
001765  3               droom0:
001765  3  AD 7A 10     	lda winlft 		; window left edge.
001768  3  85 rr        	sta dispx 		; set cursor x position.
00176A  3  AD 7C 10     	lda winwid 		; width of window.
00176D  3  85 rr        	sta rcol		; set column counter
00176F  3               droom1:
00176F  3  20 80 17     	jsr flbyt 		; decompress next byte on the fly.
001772  3  20 AC 16     	jsr pattr2 		; show attributes and block.
001775  3  C6 rr        	dec rcol		; one less column.
001777  3  D0 F6        	bne droom1 		; repeat for entire line.
001779  3  E6 rr        	inc dispy		; move down one line.
00177B  3  C6 rr        	dec rrow 		; one less row.
00177D  3  D0 E6        	bne droom0 		; repeat for all rows.
00177F  3  60           	rts
001780  3               
001780  3               ;----------------------------------------------
001780  3               ; Decompress bytes on-the-fly.
001780  3               ;----------------------------------------------
001780  3               
001780  3               flbyt:
001780  3  A5 rr        	lda comcnt 		; compression counter.
001782  3  D0 21        	bne flbyt1		; any more to decompress?  yes.
001784  3               
001784  3  A0 00        	ldy #0
001786  3  B1 rr        	lda (z80_hl),y 		; fetch next byte.
001788  3  E6 rr        	inc z80_l 		; point to next cell.
00178A  3  D0 02        	bne :+
00178C  3  E6 rr        	inc z80_h
00178E  3               :
00178E  3  C9 FF        	cmp #255 		; is this byte a control code?
001790  3  F0 01        	beq :+
001792  3  60           	rts 			; no, this byte is uncompressed.
001793  3               :
001793  3  B1 rr        	lda (z80_hl),y 		; fetch byte type.
001795  3  85 rr        	sta combyt 		; set up the type.
001797  3  E6 rr        	inc z80_l 		; point to quantity.
001799  3  D0 02        	bne :+
00179B  3  E6 rr        	inc z80_h
00179D  3               :
00179D  3  B1 rr        	lda (z80_hl),y 		; get quantity.
00179F  3  E6 rr        	inc z80_l 		; point to next byte.
0017A1  3  D0 02        	bne :+
0017A3  3  E6 rr        	inc z80_h
0017A5  3               :
0017A5  3               flbyt1:
0017A5  3  85 rr        	sta comcnt 		; store new quantity.
0017A7  3  C6 rr        	dec comcnt		; one less.
0017A9  3  A5 rr        	lda combyt 		; byte to expand.
0017AB  3  60           	rts
0017AC  3               
0017AC  3               ;------------------------------------------
0017AC  3               ; Ladder down check.
0017AC  3               ;
0017AC  3               ; Input:
0017AC  3               ;  IX = sprite pointer
0017AC  3               ;------------------------------------------
0017AC  3               
0017AC  3               laddd:
0017AC  3  A0 09        	ldy #var_newX
0017AE  3  B1 rr        	lda (z80_ix),y		; x coordinate.
0017B0  3  85 rr        	sta dispx
0017B2  3               
0017B2  3  A0 08        	ldy #var_newY
0017B4  3  B1 rr        	lda (z80_ix),y		; y coordinate.
0017B6  3  29 FE        	and #254		; make it even.
0017B8  3  91 rr        	sta (z80_ix),y 		; reset it.
0017BA  3               numsp5:
0017BA  3  18           	clc 			; look down 16 pixels.
0017BB  3  69 10        	adc #16
0017BD  3  85 rr        	sta dispy		; coords in dispx,dispy.
0017BF  3  4C D5 17     	jmp laddv
0017C2  3               
0017C2  3               ;------------------------------------------
0017C2  3               ; Ladder up check.
0017C2  3               ;
0017C2  3               ; Input:
0017C2  3               ;  IX = sprite pointer
0017C2  3               ;
0017C2  3               ; Output:
0017C2  3               ;  A  = 0 is ok, A <>0 is not ok
0017C2  3               ;------------------------------------------
0017C2  3               
0017C2  3               laddu:
0017C2  3  A0 09        	ldy #var_newX
0017C4  3  B1 rr        	lda (z80_ix),y		; x coordinate.
0017C6  3  85 rr        	sta dispx
0017C8  3               
0017C8  3  A0 08        	ldy #var_newY
0017CA  3  B1 rr        	lda (z80_ix),y		; y coordinate.
0017CC  3  29 FE        	and #254 		; make it even.
0017CE  3  91 rr        	sta (z80_ix),y		; reset it.
0017D0  3               numsp6:
0017D0  3  18           	clc 			; look 2 pixels above feet.
0017D1  3  69 0E        	adc #14
0017D3  3  85 rr        	sta dispy		; coords in dispx,dispy.
0017D5  3               laddv:
0017D5  3  20 23 1A     	jsr tstbl 		; get map address.
0017D8  3  20 E2 18     	jsr ldchk 		; standard ladder check.
0017DB  3  F0 01        	beq :+
0017DD  3  60           	rts 			; no way through.
0017DE  3               :
0017DE  3  E6 rr        	inc bufaddr 		; look right one cell.
0017E0  3  D0 02        	bne :+
0017E2  3  E6 rr        	inc bufaddr+1
0017E4  3               :
0017E4  3  20 E2 18     	jsr ldchk 		; do the check.
0017E7  3  F0 01        	beq :+
0017E9  3  60           	rts 			; impassable.
0017EA  3               :
0017EA  3  A5 rr        	lda dispx 		; y coordinate.
0017EC  3  29 07        	and #7 			; position straddling block cells.
0017EE  3  D0 01        	bne :+
0017F0  3  60           	rts 			; no more checks needed.
0017F1  3               :
0017F1  3  E6 rr        	inc bufaddr 		; look to third cell.
0017F3  3  D0 02        	bne :+
0017F5  3  E6 rr        	inc bufaddr+1
0017F7  3               :
0017F7  3  20 E2 18     	jsr ldchk 		; do the check.
0017FA  3  60           	rts  			; return with zero flag set accordingly.
0017FB  3               
0017FB  3               ;---------------------------------------------------------
0017FB  3               ; Can go up check.
0017FB  3               ;
0017FB  3               ; Input:
0017FB  3               ;  IX = sprite pointer
0017FB  3               ;
0017FB  3               ; Output:
0017FB  3               ;  A  = 0 is ok, A <>0 is not ok
0017FB  3               ;---------------------------------------------------------
0017FB  3               
0017FB  3               cangu:
0017FB  3  A0 09        	ldy #var_newX
0017FD  3  B1 rr        	lda (z80_ix),y		; x coordinate.
0017FF  3  85 rr        	sta dispx
001801  3  A0 08        	ldy #var_newY
001803  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001805  3  38           	sec
001806  3  E9 02        	sbc #2
001808  3  85 rr        	sta dispy		; coords in dispx,dispy.
00180A  3  20 23 1A     	jsr tstbl 		; get map address.
00180D  3  20 AD 18     	jsr lrchk 		; standard left/right check.
001810  3  F0 01        	beq :+
001812  3  60           	rts			; no way through.
001813  3               :
001813  3  E6 rr        	inc bufaddr		; look right one cell.
001815  3  D0 02        	bne :+
001817  3  E6 rr        	inc bufaddr+1
001819  3               :
001819  3  20 AD 18     	jsr lrchk 		; do the check.
00181C  3  F0 01        	beq :+
00181E  3  60           	rts			; impassable.
00181F  3               :
00181F  3  A5 rr        	lda dispx		; x coordinate.
001821  3  29 07        	and #7			; position straddling block cells.
001823  3  D0 01        	bne :+
001825  3  60           	rts			; no more checks needed.
001826  3               :
001826  3  E6 rr        	inc bufaddr		; look to third cell.
001828  3  D0 02        	bne :+
00182A  3  E6 rr        	inc bufaddr+1
00182C  3               :
00182C  3  20 AD 18     	jsr lrchk		; do the check.
00182F  3  60           	rts 			; return with zero flag set accordingly.
001830  3               
001830  3               ;---------------------------------------------------------
001830  3               ; Can go down check.
001830  3               ;
001830  3               ; Input:
001830  3               ;  IX = sprite pointer
001830  3               ;
001830  3               ; Output:
001830  3               ;  A  = 0 is ok, A <>0 is not ok
001830  3               ;---------------------------------------------------------
001830  3               
001830  3               cangd:
001830  3  A0 09        	ldy #var_newX
001832  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001834  3  85 rr        	sta dispx
001836  3  A0 08        	ldy #var_newY
001838  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00183A  3               numsp3:
00183A  3  18           	clc
00183B  3  69 10        	adc #16 		; look down 16 pixels.
00183D  3  85 rr        	sta dispy		; coords in dispx,dispy.
00183F  3  20 23 1A     	jsr tstbl 		; get map address.
001842  3  20 C2 18     	jsr plchk 		; block, platform check.
001845  3  F0 01        	beq :+
001847  3  60           	rts			; no way through.
001848  3               :
001848  3  E6 rr        	inc bufaddr		; look right one cell.
00184A  3  D0 02        	bne :+
00184C  3  E6 rr        	inc bufaddr+1
00184E  3               :
00184E  3  20 C2 18     	jsr plchk		; block, platform check.
001851  3  F0 01        	beq :+
001853  3  60           	rts			; impassable.
001854  3               :
001854  3  A5 rr        	lda dispx		; x coordinate.
001856  3  29 07        	and #7			; position straddling block cells.
001858  3  D0 01        	bne :+
00185A  3  60           	rts			; no more checks needed.
00185B  3               :
00185B  3  E6 rr        	inc bufaddr		; look to third cell.
00185D  3  D0 02        	bne :+
00185F  3  E6 rr        	inc bufaddr+1
001861  3               :
001861  3  20 C2 18     	jsr plchk		; block, platform check.
001864  3  60           	rts			; return with zero flag set accordingly.
001865  3               
001865  3               ;---------------------------------------------------------
001865  3               ; Can go left check.
001865  3               ;
001865  3               ; Input:
001865  3               ;  IX = sprite pointer
001865  3               ;
001865  3               ; Output:
001865  3               ;  A  = 0 is ok, A <>0 is not ok
001865  3               ;---------------------------------------------------------
001865  3               
001865  3               cangl:
001865  3  A0 08        	ldy #var_newY
001867  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
001869  3  85 rr        	sta dispy
00186B  3  A0 09        	ldy #var_newX
00186D  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
00186F  3  38           	sec
001870  3  E9 02        	sbc #2			; look left 2 pixels.
001872  3  85 rr        	sta dispx		; coords in dispx,dispy.
001874  3  4C 86 18     	jmp cangh		; test if we can go there.
001877  3               
001877  3               ;---------------------------------------------------------
001877  3               ; Can go right check.
001877  3               ;
001877  3               ; Input:
001877  3               ;  IX = sprite pointer
001877  3               ;
001877  3               ; Output:
001877  3               ;  A  = 0 is ok, A <>0 is not ok
001877  3               ;---------------------------------------------------------
001877  3               
001877  3               cangr:
001877  3  A0 08        	ldy #var_newY
001879  3  B1 rr        	lda (z80_ix),y		; y coordinate.
00187B  3  85 rr        	sta dispy
00187D  3  A0 09        	ldy #var_newX
00187F  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001881  3  18           	clc
001882  3  69 10        	adc #16			; look right 16 pixels.
001884  3  85 rr        	sta dispx		; coords in dispx,dispy.
001886  3               cangh:
001886  3               cangh2:
001886  3  A9 03        	lda #3			; default rows to write.
001888  3  85 rr        	sta z80_b
00188A  3  A5 rr        	lda dispy		; y position.
00188C  3  29 07        	and #7			; does x straddle cells?
00188E  3  D0 02        	bne cangh0		; yes, loop counter is good.
001890  3  C6 rr        	dec z80_b		; one less row to write.
001892  3               cangh0:
001892  3  20 23 1A     	jsr tstbl		; get map address.
001895  3               cangh1:
001895  3  20 AD 18     	jsr lrchk		; standard left/right check.
001898  3  F0 01        	beq :+
00189A  3  60           	rts			; no way through.
00189B  3               :
00189B  3  48           	pha
00189C  3  18           	clc
00189D  3  A5 rr        	lda bufaddr
00189F  3  69 20        	adc #32			; look down.
0018A1  3  85 rr        	sta bufaddr
0018A3  3  90 02        	bcc :+
0018A5  3  E6 rr        	inc bufaddr+1
0018A7  3               :
0018A7  3  68           	pla
0018A8  3               
0018A8  3  C6 rr        	dec z80_b
0018AA  3  D0 E9        	bne cangh1
0018AC  3  60           	rts
0018AD  3               
0018AD  3               ;-------------------------------------
0018AD  3               ; Check left/right movement is okay.
0018AD  3               ;
0018AD  3               ; Input:
0018AD  3               ;  bufaddr = MAP + x/8 + y/8*32
0018AD  3               ;
0018AD  3               ; Output:
0018AD  3               ;  A  = 0 is ok, A <>0 is not ok
0018AD  3               ;-------------------------------------
0018AD  3               
0018AD  3               lrchk:
0018AD  3  A0 00        	ldy #0
0018AF  3  B1 rr        	lda (bufaddr),y		; fetch map cell.
0018B1  3  C9 02        	cmp #WALL 		; is it passable?
0018B3  3  F0 0A        	beq lrchkx		; no.
0018B5  3               
0018B5  3  C9 04        	cmp #FODDER		; fodder has to be dug.
0018B7  3  F0 06        	beq lrchkx		; not passable.
0018B9  3  A9 00        	lda #0
0018BB  3  60           	rts
0018BC  3               
0018BC  3               ;--------------------------------------------------------------
0018BC  3               ; Called by mmenu
0018BC  3               ;--------------------------------------------------------------
0018BC  3               
0018BC  3               always:
0018BC  3  A9 FF        	lda #255		; report it as okay.
0018BE  3  60           	rts
0018BF  3               
0018BF  3               lrchkx:
0018BF  3  A9 01        	lda #1 			; reset all bits.
0018C1  3  60           	rts
0018C2  3               
0018C2  3               
0018C2  3               ;--------------------------------------------------------------
0018C2  3               ; Check platform or solid item is not in way.
0018C2  3               ;
0018C2  3               ; Input:
0018C2  3               ;  bufaddr = MAP + x/8 + y/8*32
0018C2  3               ;
0018C2  3               ; Output:
0018C2  3               ;  A  = 0 is ok, A <>0 is not ok
0018C2  3               ;--------------------------------------------------------------
0018C2  3               
0018C2  3               plchk:
0018C2  3  A0 00        	ldy #0
0018C4  3  B1 rr        	lda (bufaddr),y 	; fetch map cell.
0018C6  3  C9 02        	cmp #WALL 		; is it passable?
0018C8  3  F0 F5        	beq lrchkx		; no.
0018CA  3               
0018CA  3  C9 04        	cmp #FODDER		; fodder has to be dug.
0018CC  3  F0 F1        	beq lrchkx		; not passable.
0018CE  3               
0018CE  3  C9 01        	cmp #PLATFM		; platform is solid.
0018D0  3  F0 07        	beq plchkx		; not passable.
0018D2  3               
0018D2  3  C9 03        	cmp #LADDER		; is it a ladder?
0018D4  3  F0 E9        	beq lrchkx		; on ladder, deny movement.
0018D6  3               plchk0:
0018D6  3  A9 00        	lda #0			; report as ok
0018D8  3  60           	rts
0018D9  3               plchkx:
0018D9  3  A5 rr        	lda dispy		; x coordinate.
0018DB  3  29 07        	and #7			; position straddling blocks.
0018DD  3  F0 E0        	beq lrchkx		; on platform, deny movement.
0018DF  3  4C D6 18     	jmp plchk0
0018E2  3               
0018E2  3               ;--------------------------------------------------------------
0018E2  3               ; Check ladder is available.
0018E2  3               ;
0018E2  3               ; Input:
0018E2  3               ;  bufaddr = MAP + x/8 + y/8*32
0018E2  3               ;
0018E2  3               ; Output:
0018E2  3               ;  A  = 0 is ok, A <>0 is not ok
0018E2  3               ;--------------------------------------------------------------
0018E2  3               
0018E2  3               ldchk:
0018E2  3  A0 00        	ldy #0
0018E4  3  B1 rr        	lda (bufaddr),y 	; fetch cell.
0018E6  3  C9 03        	cmp #LADDER 		; is it a ladder?
0018E8  3  F0 03        	beq :+
0018EA  3  A9 01        	lda #1
0018EC  3  60           	rts  			; return with zero flag set accordingly.
0018ED  3               :
0018ED  3  A9 00        	lda #0
0018EF  3  60           	rts
0018F0  3               
0018F0  3               ;--------------------------------------------------------------
0018F0  3               ; Get collectables.
0018F0  3               ;--------------------------------------------------------------
0018F0  3               
0018F0  3               getcol:
0018F0  3  A9 08            lda #COLECT             ; collectable blocks.
0018F2  3  85 rr            sta z80_b
0018F4  3  20 68 19         jsr tded                ; test for collectable blocks.
0018F7  3  C5 rr            cmp z80_b               ; did we find one?
0018F9  3  F0 01            beq :+
0018FB  3  60               rts                     ; none were found, job done.
0018FC  3               :
0018FC  3  20 05 19         jsr gtblk               ; get block.
0018FF  3               
0018FF  3  20 F8 23         jsr evnt20              ; collected block event.
001902  3  4C F0 18         jmp getcol              ; repeat until none left.
001905  3               
001905  3               ; Get collectable block.
001905  3               
001905  3               gtblk:
001905  3  A0 00        	ldy #0
001907  3  B1 rr        	lda (bufaddr),y
001909  3  85 rr        	sta z80_a
00190B  3  A9 00                lda #0
00190D  3  91 rr                sta (bufaddr),y		; make it empty now.
00190F  3                      
00190F  3  A5 rr        	lda bufaddr		; set dispx
001911  3  29 1F        	and #31
001913  3  85 rr        	sta dispx
001915  3               
001915  3  A5 rr        	lda bufaddr+1		; Set dispy
001917  3  38           	sec
001918  3  E9 03        	sbc #>MAP
00191A  3  85 rr        	sta bufaddr+1
00191C  3  06 rr        	asl bufaddr
00191E  3  26 rr        	rol bufaddr+1
001920  3  06 rr        	asl bufaddr
001922  3  26 rr        	rol bufaddr+1
001924  3  06 rr        	asl bufaddr
001926  3  26 rr        	rol bufaddr+1
001928  3  A5 rr        	lda bufaddr+1
00192A  3  85 rr        	sta dispy
00192C  3                
00192C  3  AD AB 16     	lda colpatt		; get blocknr
00192F  3  85 rr        	sta z80_e		; displacement in e.
001931  3  A9 00        	lda #0
001933  3  85 rr        	sta z80_d		; no high byte.
001935  3  06 rr        	asl z80_e  		; multiply char by 8.
001937  3  26 rr        	rol z80_d
001939  3  06 rr        	asl z80_e
00193B  3  26 rr        	rol z80_d
00193D  3  06 rr        	asl z80_e
00193F  3  26 rr        	rol z80_d
001941  3  18           	clc
001942  3  A5 rr        	lda z80_e
001944  3  69 11        	adc #<chgfx 		; address of graphics.
001946  3  85 rr        	sta tileaddr
001948  3  A5 rr        	lda z80_d
00194A  3  69 24        	adc #>chgfx
00194C  3  85 rr        	sta tileaddr+1
00194E  3  20 51 16     	jsr gprad 		; get screen address.
001951  3  A2 07        	ldx #7			; number of pixel rows to write.
001953  3               gtblk0:
001953  3  A0 00        	ldy #0
001955  3  B1 rr        	lda (tileaddr),y 	; get image byte.
001957  3  BC 65 10     	ldy scrtab,x
00195A  3  51 rr        	eor (scraddr),y 	; XOR tile on screen
00195C  3  91 rr        	sta (scraddr),y 	; copy to screen.
00195E  3  E6 rr        	inc tileaddr 		; next image byte.
001960  3  D0 02        	bne :+
001962  3  E6 rr        	inc tileaddr+1
001964  3               :
001964  3  CA           	dex	 		; repeat for 8 pixel rows.
001965  3  10 EC        	bpl gtblk0
001967  3  60           	rts
001968  3               
001968  3               ;--------------------------------------------------------------
001968  3               ; Touched deadly block check.
001968  3               ; returns with DEADLY (must be non-zero) in accumulator if true.
001968  3               ;
001968  3               ; Input:
001968  3               ;  IX = sprite address
001968  3               ;
001968  3               ; Output:
001968  3               ;  A  = 0 is ok, A=5 is not ok
001968  3               ;--------------------------------------------------------------
001968  3               
001968  3               tded:
001968  3  A0 08        	ldy #var_newY
00196A  3  B1 rr        	lda (z80_ix),y 		; y coordinate.
00196C  3  85 rr        	sta dispy
00196E  3  C8           	iny
00196F  3  B1 rr        	lda (z80_ix),y 		; x coordinate.
001971  3  85 rr        	sta dispx		; coords in dispx,dispy.
001973  3  20 23 1A     	jsr tstbl		; get map address.
001976  3  48           	pha
001977  3  A9 1F        	lda #31			; default distance to next line down.
001979  3  85 rr        	sta z80_e
00197B  3  68           	pla
00197C  3  C5 rr        	cmp z80_b		; is this the required block?
00197E  3  D0 01        	bne :+
001980  3  60           	rts			; yes.
001981  3               :
001981  3  E6 rr        	inc bufaddr 		; next cell.
001983  3  D0 02        	bne :+
001985  3  E6 rr        	inc bufaddr+1
001987  3               :
001987  3  A0 00        	ldy #0
001989  3  B1 rr        	lda (bufaddr),y		; fetch type.
00198B  3  C5 rr        	cmp z80_b 		; is this deadly/custom?
00198D  3  D0 01        	bne :+
00198F  3  60           	rts			; yes.
001990  3               :
001990  3  A5 rr        	lda dispx		; horizontal position.
001992  3  85 rr        	sta z80_c 		; store column in c register.
001994  3  29 07        	and #7			; is it straddling cells?
001996  3  D0 03        	bne :+
001998  3  4C AC 19     	jmp tded0		; no.
00199B  3               :
00199B  3  E6 rr        	inc bufaddr 		; last cell.
00199D  3  D0 02        	bne :+
00199F  3  E6 rr        	inc bufaddr+1
0019A1  3               :
0019A1  3  A0 00        	ldy #0
0019A3  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0019A5  3  C5 rr        	cmp z80_b		; is this the block?
0019A7  3  D0 01        	bne :+
0019A9  3  60           	rts			; yes.
0019AA  3               :
0019AA  3  C6 rr        	dec z80_e		; one less cell to next row down.
0019AC  3               tded0:
0019AC  3  18           	clc 			; point to next row.
0019AD  3  A5 rr        	lda bufaddr
0019AF  3  65 rr        	adc z80_e
0019B1  3  85 rr        	sta bufaddr
0019B3  3  90 02        	bcc :+
0019B5  3  E6 rr        	inc bufaddr+1
0019B7  3               :
0019B7  3  A0 00        	ldy #0
0019B9  3  B1 rr        	lda (bufaddr),y		; fetch left cell block.
0019BB  3  C5 rr        	cmp z80_b		; is this fatal?
0019BD  3  D0 01        	bne :+
0019BF  3  60           	rts			; yes.
0019C0  3               :
0019C0  3  E6 rr        	inc bufaddr 		; next cell.
0019C2  3  D0 02        	bne :+
0019C4  3  E6 rr        	inc bufaddr+1
0019C6  3               :
0019C6  3  A0 00        	ldy #0
0019C8  3  B1 rr        	lda (bufaddr),y 	; fetch type.
0019CA  3  C5 rr        	cmp z80_b		; is this fatal?
0019CC  3  D0 01        	bne :+
0019CE  3  60           	rts			; yes.
0019CF  3               :
0019CF  3  A5 rr        	lda z80_c		; horizontal position.
0019D1  3  29 07        	and #7			; is it straddling cells?
0019D3  3  D0 03        	bne :+
0019D5  3  4C E7 19     	jmp tded1 		; no.
0019D8  3               :
0019D8  3  E6 rr        	inc bufaddr		; last cell.
0019DA  3  D0 02        	bne :+
0019DC  3  E6 rr        	inc bufaddr+1
0019DE  3               :
0019DE  3  A0 00        	ldy #0
0019E0  3  B1 rr        	lda (bufaddr),y		; fetch type.
0019E2  3  C5 rr        	cmp z80_b		; is this fatal?
0019E4  3  D0 01        	bne :+
0019E6  3  60           	rts			; yes.
0019E7  3               :
0019E7  3               tded1:
0019E7  3  A5 rr        	lda dispy		; vertical position.
0019E9  3  29 07        	and #7 			; is it straddling cells?
0019EB  3  D0 01        	bne :+
0019ED  3  60           	rts			; no, job done.
0019EE  3               :
0019EE  3  18           	clc			; point to next row.
0019EF  3  A5 rr        	lda bufaddr
0019F1  3  65 rr        	adc z80_e
0019F3  3  85 rr        	sta bufaddr
0019F5  3  90 02        	bcc :+
0019F7  3  E6 rr        	inc bufaddr+1
0019F9  3               :
0019F9  3  A0 00        	ldy #0
0019FB  3  B1 rr        	lda (bufaddr),y 	; fetch left cell block.
0019FD  3  C5 rr        	cmp z80_b		; is this fatal?
0019FF  3  D0 01        	bne :+
001A01  3  60           	rts			; yes.
001A02  3               :
001A02  3  E6 rr        	inc bufaddr		; next cell.
001A04  3  D0 02        	bne :+
001A06  3  E6 rr        	inc bufaddr+1
001A08  3               :
001A08  3  A0 00        	ldy #0
001A0A  3  B1 rr        	lda (bufaddr),y 	; fetch type.
001A0C  3  C5 rr        	cmp z80_b		; is this fatal?
001A0E  3  D0 01        	bne :+
001A10  3  60           	rts			; yes.
001A11  3               :
001A11  3  A5 rr        	lda z80_c		; horizontal position.
001A13  3  29 07        	and #7			; is it straddling cells?
001A15  3  D0 01        	bne :+
001A17  3  60           	rts			; no.
001A18  3               :
001A18  3  E6 rr        	inc bufaddr		; last cell.
001A1A  3  D0 02        	bne :+
001A1C  3  E6 rr        	inc bufaddr+1
001A1E  3               :
001A1E  3  A0 00        	ldy #0
001A20  3  B1 rr        	lda (bufaddr),y		; fetch final type.
001A22  3  60           	rts 			; return with final type in accumulator.
001A23  3               
001A23  3               ;---------------------------------------------------
001A23  3               ; Fetch block type at (dispx, dispy).
001A23  3               ;
001A23  3               ; Output:
001A23  3               ;  A = block type
001A23  3               ;---------------------------------------------------
001A23  3               
001A23  3               tstbl:
001A23  3  A5 rr        	lda dispy 			; fetch y coord.
001A25  3  4A           	lsr a				; bufaddr = y/8
001A26  3  4A           	lsr a
001A27  3  4A           	lsr a
001A28  3  85 rr        	sta chary
001A2A  3               
001A2A  3  85 rr        	sta bufaddr
001A2C  3  A9 00        	lda #0
001A2E  3  85 rr        	sta bufaddr+1
001A30  3               
001A30  3  06 rr        	asl bufaddr  		; bufaddr = y/8 * 32
001A32  3  26 rr        	rol bufaddr+1
001A34  3  06 rr        	asl bufaddr
001A36  3  26 rr        	rol bufaddr+1
001A38  3  06 rr        	asl bufaddr
001A3A  3  26 rr        	rol bufaddr+1
001A3C  3  06 rr        	asl bufaddr
001A3E  3  26 rr        	rol bufaddr+1
001A40  3  06 rr        	asl bufaddr
001A42  3  26 rr        	rol bufaddr+1
001A44  3               
001A44  3  A5 rr        	lda dispx			; x/8
001A46  3  4A           	lsr a
001A47  3  4A           	lsr a
001A48  3  4A           	lsr a
001A49  3  85 rr        	sta charx
001A4B  3               
001A4B  3  18           	clc					; bufaddr = MAP + x/8 + y/8*32
001A4C  3  65 rr        	adc bufaddr
001A4E  3               ;	adc #<MAP			; only works because <MAP == $0
001A4E  3  85 rr        	sta bufaddr
001A50  3  A5 rr        	lda bufaddr+1
001A52  3  69 03        	adc #>MAP
001A54  3  85 rr        	sta bufaddr+1
001A56  3               
001A56  3  A0 00        	ldy #0
001A58  3  B1 rr        	lda (bufaddr),y 	; fetch byte there.
001A5A  3  60           	rts
001A5B  3               
001A5B  3               ;-------------------------------------------------------------------
001A5B  3               ; Jump - if we can.
001A5B  3               ; Requires initial speed to be set up in accumulator prior to call.
001A5B  3               ;
001A5B  3               ; Input:
001A5B  3               ;  IX = sprite address
001A5B  3               ;-------------------------------------------------------------------
001A5B  3               
001A5B  3               jump:
001A5B  3  A0 0D        	ldy #var_jumpLo
001A5D  3  B1 rr        	lda (z80_ix),y		; jump table low.
001A5F  3  A0 0E        	ldy #var_jumpHi
001A61  3  11 rr        	ora (z80_ix),y		; jump table high.
001A63  3  F0 01        	beq :+
001A65  3  60           	rts			; already in the air.
001A66  3               :
001A66  3  A9 2A        	lda #>jtab
001A68  3  A0 0E        	ldy #var_jumpHi
001A6A  3  91 rr        	sta (z80_ix),y		; set jump high.
001A6C  3  A9 B2        	lda #<jtab		; jump table start.
001A6E  3  A0 0D        	ldy #var_jumpLo
001A70  3  91 rr        	sta (z80_ix),y		; set jump low.
001A72  3  60           	rts
001A73  3               
001A73  3               ; Jump table.
001A73  3               
001A73  3               ;jtab:
001A73  3               ;	.byte 248,250,252
001A73  3               ;	.byte 254,254,255
001A73  3               ;	.byte 255,255,0,0
001A73  3               ;	.byte 0,1,1,1,2,2
001A73  3               ;	.byte 4,6,8,8,8,99
001A73  3               
001A73  3               ;------------------------------------------------
001A73  3               ; Random numbers code.
001A73  3               ; Pseudo-random number generator, 8-bit.
001A73  3               ;
001A73  3               ; Output:
001A73  3               ;  RND = random number
001A73  3               ;------------------------------------------------
001A73  3               
001A73  3               random:
001A73  3  A5 rr        	lda seed		; get last random number.
001A75  3  0A           	asl a
001A76  3  0A           	asl a
001A77  3  18           	clc
001A78  3  65 rr        	adc seed
001A7A  3  18           	clc
001A7B  3  69 45        	adc #$45
001A7D  3  85 rr        	sta seed		; store new seed.
001A7F  3  85 rr        	sta varrnd		; return number in variable.
001A81  3  60           	rts
001A82  3               
001A82  3               ;-------------------------------------------------------
001A82  3               ; Joystick and keyboard reading routines.
001A82  3               ;
001A82  3               ; contrl = 0, Keyboard
001A82  3               ;          1, JoyKeyb
001A82  3               ;          2, JoyMMC
001A82  3               ;-------------------------------------------------------
001A82  3               
001A82  3               joykey:
001A82  3  A5 rr        	lda contrl 		; control flag.
001A84  3  C9 01        	cmp #1
001A86  3  D0 03        	bne :+
001A88  3  4C A6 1A     	jmp joyjoy 		; read keyboard joystick
001A8B  3               :
001A8B  3  C9 02        	cmp #2
001A8D  3  D0 03        	bne :+
001A8F  3  4C A4 0E     	jmp joysin 		; read MMC joystick.
001A92  3               :
001A92  3               ; Keyboard controls.
001A92  3               
001A92  3  A9 00        	lda #0		 	; zero reading.
001A94  3  85 rr        	sta z80_e
001A96  3               
001A96  3  A0 06        	ldy #6	 		; address of last key.
001A98  3               joyke0:
001A98  3  B9 B3 2A     	lda keys,y 		; get key from table.
001A9B  3  20 7A 0E     	jsr ktest		; being pressed?
001A9E  3  26 rr        	rol z80_e 		; rotate into reading.
001AA0  3               
001AA0  3  88           	dey		 	; next key.
001AA1  3  10 F5        	bpl joyke0 		; repeat for all keys.
001AA3  3  4C B7 1A     	jmp joyjo1 		; store the value.
001AA6  3               
001AA6  3               ; Keyboard joystick controls.
001AA6  3               
001AA6  3               joyjoy:
001AA6  3  A9 00        	lda #0		 	; zero reading.
001AA8  3  85 rr        	sta z80_e
001AAA  3               
001AAA  3  A0 06        	ldy #6	 		; address of last key.
001AAC  3               joyjo3:
001AAC  3  B9 5C 0E     	lda jkeys,y 		; get key from table.
001AAF  3  20 7A 0E     	jsr ktest		; being pressed?
001AB2  3  26 rr        	rol z80_e 		; rotate into reading.
001AB4  3               
001AB4  3  88           	dey		 	; next key.
001AB5  3  10 F5        	bpl joyjo3 		; repeat for all keys.
001AB7  3               joyjo1:
001AB7  3  A5 rr        	lda z80_e 		; copy e register to accumulator.
001AB9  3               joyjo2:
001AB9  3  85 rr        	sta joyval		; remember value.
001ABB  3  60           	rts
001ABC  3               
001ABC  3               ;---------------------------------------------------------------
001ABC  3               ; Display message.
001ABC  3               ;
001ABC  3               ; Input:
001ABC  3               ;  A = message number
001ABC  3               ;---------------------------------------------------------------
001ABC  3               
001ABC  3               dmsg:
001ABC  3  AA           	tax
001ABD  3  A9 FA        	lda #<msgdat		; pointer to messages.
001ABF  3  85 rr        	sta z80_l
001AC1  3  A9 23        	lda #>msgdat
001AC3  3  85 rr        	sta z80_h
001AC5  3  20 DB 1B     	jsr getwrd		; get message number.
001AC8  3               dmsg3:
001AC8  3  20 C8 1B     	jsr preprt		; pre-printing stuff.
001ACB  3  20 13 15     	jsr checkx		; make sure we"re in a printable range.
001ACE  3  A5 rr        	lda prtmod		; print mode.
001AD0  3  D0 47        	bne bmsg1		; no, double-height text.
001AD2  3               dmsg0:
001AD2  3  A5 rr        	lda z80_h		; store string pointer.
001AD4  3  48           	pha
001AD5  3  A5 rr        	lda z80_l
001AD7  3  48           	pha
001AD8  3               
001AD8  3  A0 00        	ldy #0
001ADA  3  B1 rr        	lda (z80_hl),y		; fetch byte to display.
001ADC  3  29 7F        	and #127		; remove any end marker.
001ADE  3  C9 0D        	cmp #ASCII_NEWLINE
001AE0  3  F0 24        	beq dmsg1
001AE2  3  20 2C 10     	jsr pchar		; display character.
001AE5  3  20 B3 1B     	jsr nexpos 		; display position.
001AE8  3  D0 03        	bne dmsg2		; not on a new line.
001AEA  3  20 BA 1B     	jsr nexlin		; next line down.
001AED  3               dmsg2:
001AED  3  68           	pla			; retrieve string pointer
001AEE  3  85 rr        	sta z80_l
001AF0  3  68           	pla
001AF1  3  85 rr        	sta z80_h
001AF3  3               
001AF3  3  A0 00        	ldy #0
001AF5  3  B1 rr        	lda (z80_hl),y		; fetch last character.
001AF7  3  0A           	asl a  			; was it the end?
001AF8  3  90 03        	bcc :+
001AFA  3  4C 58 15     	jmp dscor2		; yes, job done.
001AFD  3               :
001AFD  3  E6 rr        	inc z80_l		; next character to display.
001AFF  3  D0 02        	bne :+
001B01  3  E6 rr        	inc z80_h
001B03  3               :
001B03  3  4C D2 1A     	jmp dmsg0
001B06  3               dmsg1:
001B06  3  E6 rr        	inc dispy
001B08  3  A5 rr        	lda dispy
001B0A  3  C9 18        	cmp #24
001B0C  3  90 04        	bcc dmsg4
001B0E  3  A9 00        	lda #0
001B10  3  85 rr        	sta dispy
001B12  3               dmsg4:
001B12  3  A9 00        	lda #0
001B14  3  85 rr        	sta dispx
001B16  3  4C ED 1A     	jmp dmsg2
001B19  3               
001B19  3               ;----------------------------------------------------------
001B19  3               ; Display message in big text.
001B19  3               ;
001B19  3               ; Input:
001B19  3               ;  HL = string pointer
001B19  3               ;----------------------------------------------------------
001B19  3               
001B19  3               bmsg1:
001B19  3  A0 00        	ldy #0
001B1B  3  B1 rr        	lda (z80_hl),y 		; get character to display.
001B1D  3  29 7F        	and #127		; only want 7 bits.
001B1F  3  C9 0D        	cmp #ASCII_NEWLINE
001B21  3  F0 13        	beq bmsg2
001B23  3  20 4B 1B     	jsr bchar 		; display big char.
001B26  3               bmsg3:
001B26  3  A0 00        	ldy #0
001B28  3  B1 rr        	lda (z80_hl),y 		; look at last character.
001B2A  3  48           	pha
001B2B  3  E6 rr        	inc z80_l 		; next character in list.
001B2D  3  D0 02        	bne :+
001B2F  3  E6 rr        	inc z80_h
001B31  3               :
001B31  3  68           	pla
001B32  3  0A           	asl a  			; was terminator flag set?
001B33  3  90 E4        	bcc bmsg1		; no, keep going.
001B35  3               :
001B35  3  60           	rts
001B36  3               bmsg2:
001B36  3  A9 00        	lda #0
001B38  3  85 rr        	sta dispx
001B3A  3  E6 rr        	inc dispy
001B3C  3  E6 rr        	inc dispy
001B3E  3  A5 rr        	lda dispy
001B40  3  C9 17        	cmp #23
001B42  3  90 E2        	bcc bmsg3
001B44  3  A9 00        	lda #0
001B46  3  85 rr        	sta dispy
001B48  3  4C 26 1B     	jmp bmsg3
001B4B  3               
001B4B  3               ;----------------------------------------------------------
001B4B  3               ; Big character display.
001B4B  3               ;
001B4B  3               ; Input:
001B4B  3               ;  A = character
001B4B  3               ;----------------------------------------------------------
001B4B  3               
001B4B  3               bchar:
001B4B  3  85 rr        	sta z80_e		; save char in lb
001B4D  3  A9 00        	lda #0
001B4F  3  85 rr        	sta z80_d		; reset hb
001B51  3               
001B51  3  06 rr        	asl z80_e 		; multiply char by 8.
001B53  3  26 rr        	rol z80_d
001B55  3  06 rr        	asl z80_e
001B57  3  26 rr        	rol z80_d
001B59  3  06 rr        	asl z80_e
001B5B  3  26 rr        	rol z80_d		; de = a*8
001B5D  3               
001B5D  3  18           	clc			; de = FontPtr + a*8
001B5E  3  A5 rr        	lda z80_e
001B60  3  65 rr        	adc FontPtr 		; address of font.
001B62  3  85 rr        	sta z80_e
001B64  3  A5 rr        	lda z80_d
001B66  3  65 rr        	adc FontPtr+1
001B68  3  85 rr        	sta z80_d
001B6A  3               
001B6A  3  20 51 16     	jsr gprad 		; get screen address.
001B6D  3               
001B6D  3  A2 00        	ldx #0			; height of character in font.
001B6F  3               bchar0:
001B6F  3  A0 00        	ldy #0
001B71  3  B1 rr        	lda (z80_de),y 		; get a bit of the font.
001B73  3               
001B73  3  49 00        	eor #TxtInvert		; Invert
001B75  3               
001B75  3  91 rr        	sta (scraddr),y
001B77  3  48           	pha
001B78  3  20 13 10     	jsr nline 		; next line down.
001B7B  3  68           	pla
001B7C  3  91 rr        	sta (scraddr),y
001B7E  3  20 13 10     	jsr nline 		; next line down.
001B81  3               
001B81  3  18           	clc
001B82  3  E6 rr        	inc z80_e 		; next line of font.
001B84  3  D0 02        	bne :+
001B86  3  E6 rr        	inc z80_d
001B88  3               :
001B88  3  E8           	inx
001B89  3  E0 08        	cpx #8
001B8B  3  D0 E2        	bne bchar0
001B8D  3               	
001B8D  3  20 B3 1B     	jsr nexpos		; display position.
001B90  3  D0 05        	bne bchar2 		; not on a new line.
001B92  3               bchar3:
001B92  3  E6 rr        	inc dispy
001B94  3  20 BA 1B     	jsr nexlin 		; next line check.
001B97  3               bchar2:
001B97  3  4C 58 15     	jmp dscor2		; tidy up line and column variables.
001B9A  3               
001B9A  3               
001B9A  3               ;-------------------------------------------------
001B9A  3               ; Display a character.
001B9A  3               ;
001B9A  3               ; Input:
001B9A  3               ;  A = character
001B9A  3               ;-------------------------------------------------
001B9A  3               
001B9A  3               achar:
001B9A  3  85 rr        	sta z80_b 		; copy to b.
001B9C  3  20 C8 1B     	jsr preprt 		; get ready to print.
001B9F  3  A5 rr        	lda z80_b		; character in accumulator.
001BA1  3  A6 rr        	ldx prtmod 		; print mode.
001BA3  3  F0 03        	beq :+
001BA5  3  4C 4B 1B     	jmp bchar 		; no, double-height text.
001BA8  3               :
001BA8  3  20 2C 10     	jsr pchar 		; display character.
001BAB  3  20 B3 1B     	jsr nexpos 		; display position.
001BAE  3  F0 E2        	beq bchar3		; next line down.
001BB0  3  4C 97 1B     	jmp bchar2 		; tidy up.
001BB3  3               
001BB3  3               
001BB3  3               ;-------------------------------------------------
001BB3  3               ; Get next print column position.
001BB3  3               ;-------------------------------------------------
001BB3  3               
001BB3  3               nexpos:
001BB3  3  E6 rr        	inc dispx		; move along one position.
001BB5  3  A5 rr        	lda dispx 		; get coordinate.
001BB7  3  29 1F        	and #31
001BB9  3  60           	rts 			; return with status in zero flag.
001BBA  3               
001BBA  3               ;-------------------------------------------------
001BBA  3               ; Get next print line position.
001BBA  3               ;-------------------------------------------------
001BBA  3               
001BBA  3               nexlin:
001BBA  3  E6 rr        	inc dispy 		; newline.
001BBC  3  A5 rr        	lda dispy		; vertical position.
001BBE  3  C9 18        	cmp #24			; past screen edge?
001BC0  3  B0 01        	bcs :+
001BC2  3  60           	rts			; no, still okay.
001BC3  3               :
001BC3  3  A9 00        	lda #0			; restart at top.
001BC5  3  85 rr        	sta dispy
001BC7  3  60           	rts
001BC8  3               
001BC8  3               ;--------------------------------------------------------
001BC8  3               ; Pre-print preliminaries.
001BC8  3               ;--------------------------------------------------------
001BC8  3               
001BC8  3               preprt:
001BC8  3  A5 rr        	lda FontPtr		; font pointer.
001BCA  3  8D 11 15     	sta grbase		; set up graphics base.
001BCD  3  A5 rr        	lda FontPtr+1
001BCF  3  8D 12 15     	sta grbase+1
001BD2  3               prescr:
001BD2  3  A5 rr        	lda charx 		; display coordinates.
001BD4  3  85 rr        	sta dispx		; set up general coordinates.
001BD6  3  A5 rr        	lda chary
001BD8  3  85 rr        	sta dispy
001BDA  3  60           	rts
001BDB  3               
001BDB  3               ;--------------------------------------------------------------
001BDB  3               ; Get messagenr x in hl
001BDB  3               ;
001BDB  3               ; Input:
001BDB  3               ;  HL = pointer to message list
001BDB  3               ;  X  = message number.
001BDB  3               ;--------------------------------------------------------------
001BDB  3               
001BDB  3               getwrd:
001BDB  3  E0 00        	cpx #0
001BDD  3  D0 01        	bne:+ 			; first word in list?
001BDF  3  60           	rts 			; yep, don't search.
001BE0  3               :
001BE0  3  A0 00        	ldy #0
001BE2  3               getwd0:
001BE2  3  B1 rr        	lda (z80_hl),y
001BE4  3  48           	pha
001BE5  3  E6 rr        	inc z80_l
001BE7  3  D0 02        	bne :+
001BE9  3  E6 rr        	inc z80_h
001BEB  3               :
001BEB  3  68           	pla
001BEC  3  C9 80        	cmp #128		; found end?
001BEE  3  30 F2        	bmi getwd0		; no, carry on.
001BF0  3  CA           	dex			; until we have right number.
001BF1  3  D0 EF        	bne getwd0
001BF3  3  60           	rts
001BF4  3               
001BF4  3               ;-----------------------------------------------------------
001BF4  3               ; Bubble sort.
001BF4  3               ;-----------------------------------------------------------
001BF4  3               
001BF4  3               bsort:
001BF4  3  A9 0B        	lda #NUMSPR - 1		; sprites to swap.
001BF6  3  85 rr        	sta qscnt
001BF8  3               
001BF8  3  A9 00        	lda #<sprtab 		; sprite table.
001BFA  3  85 rr        	sta z80_x
001BFC  3  A9 0B        	lda #>sprtab
001BFE  3  85 rr        	sta z80_i
001C00  3               bsort0:
001C00  3  A0 00        	ldy #0
001C02  3  B1 rr        	lda (z80_ix),y 		; first sprite type.
001C04  3  C9 FF        	cmp #255 		; is it switched off?
001C06  3  F0 30        	beq swemp		; yes, may need to switch another in here.
001C08  3               
001C08  3  A0 11        	ldy #TABSIZ
001C0A  3  B1 rr        	lda (z80_ix),y 		; check next slot exists.
001C0C  3  C9 FF        	cmp #255 		; is it enabled?
001C0E  3  F0 0A        	beq bsort2 		; no, nothing to swap.
001C10  3               
001C10  3  A0 14        	ldy #TABSIZ+3
001C12  3  B1 rr        	lda (z80_ix),y 		; fetch next sprite's coordinate.
001C14  3  A0 03        	ldy #3
001C16  3  D1 rr        	cmp (z80_ix),y 		; compare with this x coordinate.
001C18  3  90 10        	bcc bsort1		; next sprite is higher - may need to switch.
001C1A  3               bsort2:
001C1A  3  18           	clc
001C1B  3  A5 rr        	lda z80_x
001C1D  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001C1F  3  85 rr        	sta z80_x
001C21  3  90 02        	bcc :+
001C23  3  E6 rr        	inc z80_i
001C25  3               :
001C25  3  C6 rr        	dec qscnt 
001C27  3  D0 D7        	bne bsort0		; repeat for remaining sprites.
001C29  3  60           	rts
001C2A  3               
001C2A  3               bsort1:
001C2A  3  A0 11        	ldy #TABSIZ
001C2C  3  B1 rr        	lda (z80_ix),y		; sprite on/off flag.
001C2E  3  C9 FF        	cmp #255		; is it enabled?
001C30  3  F0 E8        	beq bsort2		; no, nothing to swap.
001C32  3  20 46 1C     	jsr swspr		; swap positions.
001C35  3  4C 1A 1C     	jmp bsort2
001C38  3               swemp:
001C38  3  A0 11        	ldy #TABSIZ
001C3A  3  B1 rr        	lda (z80_ix),y		; next table entry.
001C3C  3  C9 FF        	cmp #255		; is that one on?
001C3E  3  F0 DA        	beq bsort2		; no, nothing to swap.
001C40  3  20 46 1C     	jsr swspr		; swap positions.
001C43  3  4C 1A 1C     	jmp bsort2
001C46  3               
001C46  3               ; Swap sprites.
001C46  3               
001C46  3               swspr:
001C46  3  A5 rr        	lda z80_x		; table address 
001C48  3  85 rr        	sta z80_e		; copy to de pair.
001C4A  3  85 rr        	sta z80_l		; copy to hl pair.
001C4C  3  A5 rr        	lda z80_i
001C4E  3  85 rr        	sta z80_h
001C50  3  85 rr        	sta z80_d
001C52  3               
001C52  3  18           	clc
001C53  3  A5 rr        	lda z80_l
001C55  3  69 11        	adc #TABSIZ		; distance to second entry.
001C57  3  85 rr        	sta z80_l
001C59  3  90 02        	bcc :+
001C5B  3  E6 rr        	inc z80_h
001C5D  3               :
001C5D  3  A9 11        	lda #TABSIZ		; bytes to swap.
001C5F  3  85 rr        	sta z80_b
001C61  3  A0 00        	ldy #0
001C63  3               swspr0:
001C63  3  B1 rr        	lda (z80_hl),y		; fetch second byte.
001C65  3  48           	pha
001C66  3  B1 rr        	lda (z80_de),y 		; fetch first byte.
001C68  3  91 rr        	sta (z80_hl),y 		; copy to second.
001C6A  3  68           	pla
001C6B  3  91 rr        	sta (z80_de),y 		; copy to first sprite entry.
001C6D  3               
001C6D  3  E6 rr        	inc z80_e 		; next byte.
001C6F  3  D0 02        	bne :+	
001C71  3  E6 rr        	inc z80_d
001C73  3               :
001C73  3  E6 rr        	inc z80_l 		; next byte.
001C75  3  D0 02        	bne :+
001C77  3  E6 rr        	inc z80_h
001C79  3               :
001C79  3  C6 rr        	dec z80_b
001C7B  3  D0 E6        	bne swspr0 		; swap all bytes in table entry.
001C7D  3  60           	rts
001C7E  3               
001C7E  3               ;----------------------------------------------------
001C7E  3               ; Process sprites.
001C7E  3               ;----------------------------------------------------
001C7E  3               
001C7E  3               pspr:
001C7E  3  A9 0C        	lda #NUMSPR		; sprites to process.
001C80  3  85 rr        	sta sprptr
001C82  3               
001C82  3  A9 00        	lda #<sprtab 		; sprite table.
001C84  3  85 rr        	sta z80_x
001C86  3  A9 0B        	lda #>sprtab
001C88  3  85 rr        	sta z80_i
001C8A  3               pspr1:
001C8A  3  A0 00        	ldy #0
001C8C  3  B1 rr        	lda (z80_ix),y		; fetch sprite type.
001C8E  3  C9 09        	cmp #9 			; within range of sprite types?
001C90  3  B0 03        	bcs :+
001C92  3  20 A5 1C     	jsr pspr2 		; yes, process this one.
001C95  3               :
001C95  3  18           	clc
001C96  3  A5 rr        	lda z80_x
001C98  3  69 11        	adc #TABSIZ 		; distance to next odd/even entry.
001C9A  3  85 rr        	sta z80_x
001C9C  3  90 02        	bcc :+
001C9E  3  E6 rr        	inc z80_i		; next sprite.
001CA0  3               :
001CA0  3  C6 rr        	dec sprptr 		; repeat for remaining sprites.
001CA2  3  D0 E6        	bne pspr1
001CA4  3  60           	rts
001CA5  3               
001CA5  3               pspr2:
001CA5  3  A5 rr        	lda z80_x 		; store original sprite pointer.
001CA7  3  85 rr        	sta ogptr
001CA9  3  A5 rr        	lda z80_i
001CAB  3  85 rr        	sta ogptr+1
001CAD  3  20 B9 1C     	jsr pspr3		; do the routine.
001CB0  3               rtorg:
001CB0  3  A5 rr        	lda ogptr 		; restore original pointer to sprite.
001CB2  3  85 rr        	sta z80_x
001CB4  3  A5 rr        	lda ogptr+1
001CB6  3  85 rr        	sta z80_i
001CB8  3               rtorg0:
001CB8  3  60           	rts
001CB9  3               
001CB9  3               pspr3:
001CB9  3  A9 EE        	lda #<evtyp0		; sprite type events list.
001CBB  3  85 rr        	sta z80_l
001CBD  3  A9 1C        	lda #>evtyp0
001CBF  3  85 rr        	sta z80_h
001CC1  3               pspr4:
001CC1  3  B1 rr        	lda (z80_ix),y
001CC3  3  0A           	asl a			; double accumulator.
001CC4  3  18           	clc
001CC5  3  65 rr        	adc z80_l
001CC7  3  85 rr        	sta z80_l
001CC9  3  90 02        	bcc :+
001CCB  3  E6 rr        	inc z80_h
001CCD  3               :
001CCD  3  B1 rr        	lda (z80_hl),y
001CCF  3  85 rr        	sta z80_e 		; copy to de.
001CD1  3  48           	pha
001CD2  3               
001CD2  3  E6 rr        	inc z80_l 		; next byte of address.
001CD4  3  D0 02        	bne :+
001CD6  3  E6 rr        	inc z80_h
001CD8  3               :
001CD8  3  B1 rr        	lda (z80_hl),y 		; address high.
001CDA  3  85 rr        	sta z80_d
001CDC  3               
001CDC  3  48           	pha	 		; swap address into hl.
001CDD  3  A5 rr        	lda z80_h
001CDF  3  85 rr        	sta z80_d
001CE1  3  68           	pla
001CE2  3  85 rr        	sta z80_h
001CE4  3  68           	pla
001CE5  3  85 rr        	sta z80_l
001CE7  3  A5 rr        	lda z80_l
001CE9  3  85 rr        	sta z80_e
001CEB  3               	
001CEB  3  6C rr rr     	jmp (z80_hl) 		; go there.
001CEE  3               
001CEE  3               ; Address of each sprite type's routine.
001CEE  3               
001CEE  3  26 23        evtyp0:	.word evnt00
001CF0  3  D1 23        evtyp1:	.word evnt01
001CF2  3  D2 23        evtyp2:	.word evnt02
001CF4  3  D3 23        evtyp3:	.word evnt03
001CF6  3  D4 23        evtyp4:	.word evnt04
001CF8  3  D5 23        evtyp5:	.word evnt05
001CFA  3  D6 23        evtyp6:	.word evnt06
001CFC  3  D7 23        evtyp7:	.word evnt07
001CFE  3  D8 23        evtyp8:	.word evnt08
001D00  3               
001D00  3               ;--------------------------------------------------------------
001D00  3               ; Display sprites.
001D00  3               ;
001D00  3               ; Input:
001D00  3               ;  IX = sprite table
001D00  3               ;--------------------------------------------------------------
001D00  3               
001D00  3               dspr:
001D00  3  A9 06        	lda #(NUMSPR/2)		; number of sprites to display.
001D02  3  85 rr        	sta sprcnt
001D04  3               
001D04  3               dspr0:
001D04  3  A0 00        	ldy #var_Type
001D06  3  B1 rr        	lda (z80_ix),y 		; get sprite type.
001D08  3  C9 FF        	cmp #255 			; is it enabled?
001D0A  3  D0 45        	bne dspr1 			; yes, it needs deleting.
001D0C  3               
001D0C  3               dspr5:
001D0C  3  A0 05        	ldy #var_newType
001D0E  3  B1 rr        	lda (z80_ix),y 		; new type.
001D10  3  C9 FF        	cmp #255			; is it enabled?
001D12  3  F0 03        	beq dspr2			; no, skip
001D14  3  4C A0 1D     	jmp dspr3 			; yes, it needs drawing.
001D17  3               
001D17  3               dspr2:
001D17  3  A0 05        	ldy #var_newType
001D19  3  B1 rr        	lda (z80_ix),y 		; copy new type.
001D1B  3  A0 00        	ldy #var_Type
001D1D  3  91 rr        	sta (z80_ix),y
001D1F  3  A0 06        	ldy #var_newImage
001D21  3  B1 rr        	lda (z80_ix),y 		; copy new image number.
001D23  3  A0 01        	ldy #var_Image
001D25  3  91 rr        	sta (z80_ix),y
001D27  3  A0 07        	ldy #var_newFrame
001D29  3  B1 rr        	lda (z80_ix),y 		; copy new frame.
001D2B  3  A0 02        	ldy #var_Frame
001D2D  3  91 rr        	sta (z80_ix),y
001D2F  3  A0 08        	ldy #var_newY
001D31  3  B1 rr        	lda (z80_ix),y 		; copy new y.
001D33  3  A0 03        	ldy #var_Y
001D35  3  91 rr        	sta (z80_ix),y
001D37  3  A0 09        	ldy #var_newX
001D39  3  B1 rr        	lda (z80_ix),y 		; copy new x.
001D3B  3  A0 04        	ldy #var_X
001D3D  3  91 rr        	sta (z80_ix),y
001D3F  3               
001D3F  3  18           	clc
001D40  3  A5 rr        	lda z80_x
001D42  3  69 22        	adc #(TABSIZ*2)		; distance to next odd/even entry.
001D44  3  85 rr        	sta z80_x
001D46  3  A5 rr        	lda z80_i
001D48  3  69 00        	adc #0
001D4A  3  85 rr        	sta z80_i 			; next sprite.
001D4C  3  C6 rr        	dec sprcnt
001D4E  3  D0 B4        	bne dspr0			; repeat for remaining sprites.
001D50  3  60           	rts
001D51  3               
001D51  3               dspr1:
001D51  3               	; _BEEB clipping code copied from CPC Engine
001D51  3  A0 03        	ldy #var_Y
001D53  3  B1 rr        	lda (z80_ix), y		; old x coord
001D55  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001D57  3  B0 B3        	bcs dspr5			; yes, don't delete it.
001D59  3               
001D59  3  A0 05        	ldy #var_newType
001D5B  3  B1 rr        	lda (z80_ix),y 		; type of new sprite.
001D5D  3  C9 FF        	cmp #255			; is this enabled?
001D5F  3  D0 06        	bne dspr4 			; yes, display both.
001D61  3               
001D61  3               dspr6:
001D61  3  20 8F 0F     	jsr sspria 			; show single sprite.
001D64  3  4C 17 1D     	jmp dspr2
001D67  3               
001D67  3               ; Displaying two sprites.  Don't bother redrawing if nothing has changed.
001D67  3               
001D67  3               dspr4:
001D67  3               	; _BEEB clipping code copied from CPC Engine
001D67  3  A0 08        	ldy #var_newY
001D69  3  B1 rr        	lda (z80_ix), y		; old x coord
001D6B  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001D6D  3  B0 F2        	bcs dspr6			; yes, don't display it.
001D6F  3               
001D6F  3  A0 04        	ldy #var_X
001D71  3  B1 rr        	lda (z80_ix),y		; old x.
001D73  3  A0 09        	ldy #var_newX
001D75  3  D1 rr        	cmp (z80_ix),y 		; compare with new value.
001D77  3  D0 21        	bne dspr7 			; they differ, need to redraw.
001D79  3               
001D79  3  A0 03        	ldy #var_Y
001D7B  3  B1 rr        	lda (z80_ix),y		; old y.
001D7D  3  A0 08        	ldy #var_newY
001D7F  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001D81  3  D0 17        	bne dspr7			; they differ, need to redraw.
001D83  3               
001D83  3  A0 02        	ldy #var_Frame
001D85  3  B1 rr        	lda (z80_ix),y 		; old frame.
001D87  3  A0 07        	ldy #var_newFrame
001D89  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001D8B  3  D0 0D        	bne dspr7 			; they differ, need to redraw.
001D8D  3               
001D8D  3  A0 01        	ldy #var_Image
001D8F  3  B1 rr        	lda (z80_ix),y 		; old image.
001D91  3  A0 06        	ldy #var_newImage
001D93  3  D1 rr        	cmp (z80_ix),y 		; compare against new value.
001D95  3  D0 03        	bne dspr7 			; they differ, need to redraw.
001D97  3  4C 17 1D     	jmp dspr2			; everything is the same, don't redraw.
001D9A  3               
001D9A  3               dspr7:
001D9A  3  20 A7 0F     	jsr sspric 			; delete old sprite, draw new one simultaneously.
001D9D  3  4C 17 1D     	jmp dspr2
001DA0  3               
001DA0  3               dspr3:
001DA0  3               	; _BEEB clipping code copied from CPC Engine
001DA0  3  A0 08        	ldy #var_newY
001DA2  3  B1 rr        	lda (z80_ix), y		; old x coord
001DA4  3  C9 B1        	cmp #SpriteMaxY     ; beyond maximum?
001DA6  3  90 03        	bcc :+				; no, continue
001DA8  3  4C 17 1D     	jmp dspr2			; yes, don't display it.
001DAB  3               :
001DAB  3  20 A1 0F     	jsr ssprib 			; show single sprite.
001DAE  3  4C 17 1D     	jmp dspr2
001DB1  3               
001DB1  3               ;-----------------------------------------
001DB1  3               ; Get sprite address calculations.
001DB1  3               ; gspran = new sprite, gsprad = old sprite.
001DB1  3               ;
001DB1  3               ; Input:
001DB1  3               ;  IX = sprite address
001DB1  3               ;-----------------------------------------
001DB1  3               
001DB1  3               gspran:
001DB1  3  A0 08        	ldy #var_newY
001DB3  3  B1 rr        	lda (z80_ix),y 		; new y coordinate.
001DB5  3  85 rr        	sta dispy
001DB7  3  A0 09        	ldy #var_newX
001DB9  3  B1 rr        	lda (z80_ix),y 		; new x coordinate.
001DBB  3  85 rr        	sta dispx
001DBD  3  A0 06        	ldy #var_newImage
001DBF  3  B1 rr        	lda (z80_ix),y 		; new sprite image.
001DC1  3  20 8C 20     	jsr gfrm		; fetch start frame for this sprite.
001DC4  3               
001DC4  3  A0 00        	ldy #0
001DC6  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
001DC8  3  A0 07        	ldy #var_newFrame
001DCA  3  18           	clc
001DCB  3  71 rr        	adc (z80_ix),y 		; new add frame number.
001DCD  3  4C EC 1D     	jmp gspra0
001DD0  3               
001DD0  3               ;-----------------------------------------
001DD0  3               ; Calculate old sprite address
001DD0  3               ;
001DD0  3               ; Input:
001DD0  3               ;  IX = sprite address
001DD0  3               ;
001DD0  3               ; Output:
001DD0  3               ;  B  = right byte mask
001DD0  3               ;  C  = left byte mask
001DD0  3               ;  DE = spriteframe address
001DD0  3               ;  scraddr = screenaddress(dispx,dispy)
001DD0  3               ;-----------------------------------------
001DD0  3               
001DD0  3               gsprad:
001DD0  3  A0 03        	ldy #var_Y
001DD2  3  B1 rr        	lda (z80_ix),y		; y coordinate.
001DD4  3  85 rr        	sta dispy
001DD6  3  A0 04        	ldy #var_X
001DD8  3  B1 rr        	lda (z80_ix),y		; x coordinate.
001DDA  3  85 rr        	sta dispx
001DDC  3  A0 01        	ldy #var_Image
001DDE  3  B1 rr        	lda (z80_ix),y 		; sprite image.
001DE0  3  20 8C 20     	jsr gfrm 		; fetch start frame for this sprite.
001DE3  3               
001DE3  3  A0 00        	ldy #0
001DE5  3  B1 rr        	lda (z80_hl),y 		; frame in accumulator.
001DE7  3  A0 02        	ldy #var_Frame
001DE9  3  18           	clc
001DEA  3  71 rr        	adc (z80_ix),y 		; add frame number.
001DEC  3               
001DEC  3               gspra0:
001DEC  3  4A           	lsr a	  		; multiply by 128.
001DED  3  85 rr        	sta z80_d 		; store in d.
001DEF  3  A9 00        	lda #0
001DF1  3  6A           	ror a
001DF2  3  85 rr        	sta z80_e 		; got low byte.
001DF4  3               
001DF4  3  18           	clc 			; address of play sprites.
001DF5  3  A5 rr        	lda z80_e
001DF7  3  69 35        	adc #<sprgfx
001DF9  3  85 rr        	sta z80_e
001DFB  3  A5 rr        	lda z80_d
001DFD  3  69 24        	adc #>sprgfx
001DFF  3  85 rr        	sta z80_d
001E01  3               
001E01  3  A5 rr        	lda dispx 		; y coordinate.
001E03  3  29 06        	and #6 			; position within byte boundary.
001E05  3  AA           	tax	 		; low byte of table displacement.
001E06  3               
001E06  3  0A           	asl a	  		; multiply by 32.
001E07  3  0A           	asl a  			; already a multiple
001E08  3  0A           	asl a  			; of 2, so just 4
001E09  3  0A           	asl a  			; shifts needed.
001E0A  3               
001E0A  3  18           	clc 			; add to sprite address.
001E0B  3  65 rr        	adc z80_e
001E0D  3  85 rr        	sta z80_e
001E0F  3  90 02        	bcc :+
001E11  3  E6 rr        	inc z80_d
001E13  3               :
001E13  3  BD 20 1E     	lda spmask,x		 ; pointer to mask table.
001E16  3  85 rr        	sta z80_c 		; left mask.
001E18  3  BD 21 1E     	lda spmask+1,x
001E1B  3  85 rr        	sta z80_b 		; right mask.
001E1D  3               ; Drop into screen address routine.
001E1D  3  4C 7B 0F     	jmp scadd
001E20  3               
001E20  3  FF 00 3F C0  spmask:	.byte 255,0,63,192,15,240,3,252
001E24  3  0F F0 03 FC  
001E28  3               
001E28  3               
001E28  3               ;-----------------------------------------------------------
001E28  3               ; Animates a sprite.
001E28  3               ;
001E28  3               ; Input:
001E28  3               ;  IX = sprite address
001E28  3               ;  HL = last sprite address
001E28  3               ;-----------------------------------------------------------
001E28  3               
001E28  3               animsp:
001E28  3  25 rr        	and frmno
001E2A  3  F0 01        	beq :+
001E2C  3  60           	rts
001E2D  3               :
001E2D  3  A0 06        	ldy #var_newImage
001E2F  3  B1 rr        	lda (z80_ix),y		; sprite image
001E31  3  20 8C 20     	jsr gfrm		; get frame data.
001E34  3               
001E34  3  E6 rr        	inc z80_l		; point to frames.
001E36  3  D0 02        	bne :+
001E38  3  E6 rr        	inc z80_h
001E3A  3               :
001E3A  3  A0 07        	ldy #var_newFrame
001E3C  3  B1 rr        	lda (z80_ix),y		; sprite frame.
001E3E  3  18           	clc
001E3F  3  69 01        	adc #1			; next one along.
001E41  3  A0 00        	ldy #0
001E43  3  D1 rr        	cmp (z80_hl),y		; reached the last frame?
001E45  3  90 02        	bcc anims0		; no, not yet.
001E47  3  A9 00        	lda #0			; start at first frame.
001E49  3               anims0:
001E49  3  A0 07        	ldy #var_newFrame
001E4B  3  91 rr        	sta (z80_ix),y		; new frame.
001E4D  3  60           	rts
001E4E  3               
001E4E  3               ;--------------------------------------------------------------
001E4E  3               ; Animate back
001E4E  3               ;
001E4E  3               ; Input:
001E4E  3               ;  IX = sprite address
001E4E  3               ;  HL = last sprite address
001E4E  3               ;--------------------------------------------------------------
001E4E  3               
001E4E  3               animbk:
001E4E  3  25 rr        	and frmno
001E50  3  F0 01        	beq :+
001E52  3  60           	rts
001E53  3               :
001E53  3  A0 06        	ldy #var_newImage
001E55  3  B1 rr        	lda (z80_ix),y		; sprite image.
001E57  3  20 8C 20     	jsr gfrm		; get frame data.
001E5A  3               
001E5A  3  E6 rr        	inc z80_l 		; point to frames.
001E5C  3  D0 02        	bne :+
001E5E  3  E6 rr        	inc z80_h
001E60  3               :
001E60  3  A0 07        	ldy #var_newFrame
001E62  3  B1 rr        	lda (z80_ix),y 		; sprite frame.
001E64  3  F0 03        	beq :+
001E66  3  4C 6D 1E     	jmp rtanb0 		; yes, start at end.
001E69  3               :
001E69  3  A0 00        	ldy #0
001E6B  3  B1 rr        	lda (z80_hl),y 		; last sprite.
001E6D  3               rtanb0:
001E6D  3  38           	sec
001E6E  3  E9 01        	sbc #1			; next one along.
001E70  3  4C 49 1E     	jmp anims0		; set new frame.
001E73  3               
001E73  3               ;--------------------------------------------------------------
001E73  3               ; Check for collision with other sprite, strict enforcement.
001E73  3               ;
001E73  3               ; Input:
001E73  3               ;  b		= sprite to test for
001E73  3               ;  ix		= current sprite pointer
001E73  3               ;
001E73  3               ; global:	b
001E73  3               ; local:	x,y,hl,de,skptr
001E73  3               ; calls:	-
001E73  3               ;--------------------------------------------------------------
001E73  3               
001E73  3               sktyp:
001E73  3  A9 00        	lda #<sprtab				; sprite table.
001E75  3  85 rr        	sta z80_l
001E77  3  A9 0B        	lda #>sprtab
001E79  3  85 rr        	sta z80_h
001E7B  3               numsp2:
001E7B  3  A9 0C        	lda #NUMSPR				; number of sprites.
001E7D  3  85 rr        	sta sktptr
001E7F  3               sktyp0:
001E7F  3  A5 rr        	lda z80_l 				; store pointer to sprite.
001E81  3  85 rr        	sta skptr
001E83  3  A5 rr        	lda z80_h
001E85  3  85 rr        	sta skptr+1
001E87  3               
001E87  3  A0 00        	ldy #0
001E89  3  B1 rr        	lda (z80_hl),y 				; get sprite type.
001E8B  3  C5 rr        	cmp z80_b				; is it the type we seek?
001E8D  3  F0 1D        	beq coltyp				; yes, we can use this one.
001E8F  3               :
001E8F  3               sktyp1:
001E8F  3  18           	clc
001E90  3  A5 rr        	lda skptr				; retrieve sprite pointer.
001E92  3  69 11        	adc #TABSIZ				; size of each entry.
001E94  3  85 rr        	sta z80_l
001E96  3  A5 rr        	lda skptr+1
001E98  3  69 00        	adc #0
001E9A  3  85 rr        	sta z80_h
001E9C  3  C6 rr        	dec sktptr					; one less iteration.
001E9E  3  D0 DF        	bne sktyp0				; keep going until we find a slot.
001EA0  3               :
001EA0  3  A9 00        	lda #0					; default to ROM address - no sprite.
001EA2  3  85 rr        	sta z80_l
001EA4  3  85 rr        	sta z80_h
001EA6  3  85 rr        	sta skptr				; store pointer to sprite.
001EA8  3  85 rr        	sta skptr+1
001EAA  3               
001EAA  3  18           	clc					; don't return with zero flag set.
001EAB  3  60           	rts 					; didn't find one.
001EAC  3               
001EAC  3               coltyp:
001EAC  3  A0 00        	ldy #0
001EAE  3  B1 rr        	lda (z80_ix),y				; current sprite type.
001EB0  3  C5 rr        	cmp z80_b				; seeking sprite of same type?
001EB2  3  F0 3D        	beq colty1				; yes, need to check we're not detecting ourselves.
001EB4  3               colty0:
001EB4  3  A0 09        	ldy #9					; distance to x position in table.
001EB6  3  B1 rr        	lda (z80_hl),y				; fetch x coordinate.
001EB8  3  85 rr        	sta z80_e
001EBA  3  88           	dey
001EBB  3  B1 rr        	lda (z80_hl),y				; fetch y coordinate.
001EBD  3  85 rr        	sta z80_d
001EBF  3               
001EBF  3               ; Drop into collision detection.
001EBF  3               
001EBF  3               colc16:
001EBF  3  A0 09        	ldy #9
001EC1  3  B1 rr        	lda (z80_ix),y			 	; x coord.
001EC3  3  38           	sec					; subtract x.
001EC4  3  E5 rr        	sbc z80_e
001EC6  3  B0 05        	bcs  colc1a 				; result is positive.
001EC8  3  49 FF        	eor #$ff				; make negative positive.
001ECA  3  18           	clc
001ECB  3  69 01        	adc #1
001ECD  3               colc1a:
001ECD  3  C9 10        	cmp #16 				; within x range?
001ECF  3  B0 BE        	bcs sktyp1				; no - they"ve missed.
001ED1  3  85 rr        	sta z80_c				; store difference.
001ED3  3               
001ED3  3  A0 08        	ldy #8
001ED5  3  B1 rr        	lda (z80_ix),y				; y coord.
001ED7  3  38           	sec
001ED8  3  E5 rr        	sbc z80_d				; subtract y.
001EDA  3  B0 05        	bcs colc1b				; result is positive.
001EDC  3  49 FF        	eor #$ff				; make negative positive.
001EDE  3  18           	clc
001EDF  3  69 01        	adc #1
001EE1  3               colc1b:
001EE1  3  C9 10        	cmp #16					; within y range?
001EE3  3  B0 AA        	bcs sktyp1 				; no - they've missed.
001EE5  3  18           	clc					; add x difference.
001EE6  3  65 rr        	adc z80_c
001EE8  3  C9 1A        	cmp #26					; only 5 corner pixels touching?
001EEA  3  B0 02        	bcs :+
001EEC  3  38           	sec
001EED  3  60           	rts 					; carry set if there's a collision.
001EEE  3               :
001EEE  3  4C 8F 1E     	jmp sktyp1				; try next sprite in table.
001EF1  3               colty1:
001EF1  3  A5 rr        	lda z80_x  				; compare the two.
001EF3  3  C5 rr        	cmp z80_l
001EF5  3  D0 09        	bne end_col
001EF7  3  A5 rr        	lda z80_i
001EF9  3  C5 rr        	cmp z80_h
001EFB  3  D0 03        	bne end_col
001EFD  3  4C 8F 1E     	jmp sktyp1 				; addresses are identical.
001F00  3               end_col:
001F00  3  4C B4 1E     	jmp colty0
001F03  3               
001F03  3               ;-----------------------------------------------------------
001F03  3               ; Display number, left aligned
001F03  3               ; 
001F03  3               ; Input:
001F03  3               ;  a		= number
001F03  3               ;
001F03  3               ; global:	-
001F03  3               ; local:	a,y,bc,hl,displ0
001F03  3               ; calls:	num2ch,dmsg3
001F03  3               ;-----------------------------------------------------------
001F03  3               
001F03  3               disply:
001F03  3  85 rr        	sta z80_a
001F05  3  A9 2B        	lda #<displ0				; display workspace.
001F07  3  85 rr        	sta z80_c
001F09  3  A9 1F        	lda #>displ0
001F0B  3  85 rr        	sta z80_b
001F0D  3  A5 rr        	lda z80_a
001F0F  3  20 90 12     	jsr num2ch				; convert accumulator to string.
001F12  3               displ1:
001F12  3  C6 rr        	dec z80_c				; back one character.
001F14  3  D0 02        	bne :+
001F16  3  C6 rr        	dec z80_b
001F18  3               :
001F18  3  A0 00        	ldy #0
001F1A  3  B1 rr        	lda (z80_bc),y				; fetch digit.
001F1C  3  09 80        	ora #128				; insert end marker.
001F1E  3  91 rr        	sta (z80_bc),y				; new value.
001F20  3               
001F20  3  A9 2B        	lda #<displ0				; display space.
001F22  3  85 rr        	sta z80_l
001F24  3  A9 1F        	lda #>displ0
001F26  3  85 rr        	sta z80_h
001F28  3  4C C8 1A     	jmp dmsg3				; display the string.
001F2B  3               
001F2B  3  00 00 00 8D  displ0:	.byte 0,0,0,13+128
001F2F  3               
001F2F  3               ;----------------------------------------------------------------
001F2F  3               ; Initialise screen.
001F2F  3               ;
001F2F  3               ; global:	roomtb,scno
001F2F  3               ; local:	-
001F2F  3               ; calls:	tstcs
001F2F  3               ;----------------------------------------------------------------
001F2F  3               
001F2F  3               initsc:
001F2F  3  AD 1A 23     	lda roomtb 			; whereabouts in the map are we?
001F32  3  20 3C 1F     	jsr tstsc 			; find displacement.
001F35  3  C9 FF        	cmp #255 			; is it valid?
001F37  3  F0 02        	beq init_end 			; no, it's rubbish.
001F39  3  85 rr        	sta scno			; store new room number.
001F3B  3               init_end:
001F3B  3  60           	rts
001F3C  3               
001F3C  3               ;----------------------------------------------------------------
001F3C  3               ; Test screen.
001F3C  3               ;
001F3C  3               ; global:	-
001F3C  3               ; local:	x
001F3C  3               ; calls:	-
001F3C  3               ;----------------------------------------------------------------
001F3C  3               
001F3C  3               tstsc:
001F3C  3  85 rr        	sta tmproom
001F3E  3  18           	clc
001F3F  3  69 03        	adc #MAPWID 			; add width in case we"re negative.
001F41  3  AA           	tax 				; add displacement to map data.
001F42  3  BD 1C 23     	lda mapdat-MAPWID,x 		; find room number there.
001F45  3  60           	rts
001F46  3               
001F46  3               ;--------------------------
001F46  3               ; Screen left.
001F46  3               ;--------------------------
001F46  3               
001F46  3               scrl:
001F46  3  AD 1A 23     	lda roomtb 			; present room table pointer.
001F49  3  38           	sec
001F4A  3  E9 01        	sbc #1				; room left.
001F4C  3               scrl0:
001F4C  3  20 3C 1F     	jsr tstsc			; test screen.
001F4F  3  C9 FF        	cmp #255			; is there a screen this way?
001F51  3  D0 01        	bne :+
001F53  3  60           	rts				; no, return to loop.
001F54  3               :
001F54  3  A5 rr        	lda tmproom			; restore room displacement.
001F56  3  8D 1A 23     	sta roomtb			; new room table position.
001F59  3               scrl1:
001F59  3  20 2F 1F     	jsr initsc 			; set new screen.
001F5C  3  A9 02        	lda #2
001F5E  3  85 rr        	sta restfl 			; set it.
001F60  3  60           	rts
001F61  3               scrr:
001F61  3  AD 1A 23     	lda roomtb 			; room table pointer.
001F64  3  18           	clc
001F65  3  69 01        	adc #1				; room right.
001F67  3  4C 4C 1F     	jmp scrl0
001F6A  3               scru:
001F6A  3  AD 1A 23     	lda roomtb 			; room table pointer.
001F6D  3  38           	sec
001F6E  3  E9 03        	sbc #MAPWID 			; room up.
001F70  3  4C 4C 1F     	jmp scrl0
001F73  3               scrd:
001F73  3  AD 1A 23     	lda roomtb 			; room table pointer.
001F76  3  18           	clc
001F77  3  69 03        	adc #MAPWID 			; room down.
001F79  3  4C 4C 1F     	jmp scrl0
001F7C  3               
001F7C  3               ;-----------------------------------------
001F7C  3               ; Jump to new screen.
001F7C  3               ;-----------------------------------------
001F7C  3               
001F7C  3               nwscr:
001F7C  3  A2 00        	ldx #0				; start of map data.
001F7E  3               nwscr0:
001F7E  3  DD 1F 23     	cmp mapdat,x
001F81  3  F0 06        	beq nwscr1			; have we found a match for screen?
001F83  3  E8           	inx 				; next room.
001F84  3  E0 50        	cpx #80				; zero room count, 80 to search.
001F86  3  D0 F6        	bne nwscr0			; keep looking.
001F88  3  60           	rts
001F89  3               nwscr1:
001F89  3  8E 1A 23     	stx roomtb			; set the map position.
001F8C  3  4C 59 1F     	jmp scrl1			; draw new room.
001F8F  3               
001F8F  3               
001F8F  3               ;----------------------------------------------------------
001F8F  3               ; Gravity processing.
001F8F  3               ;----------------------------------------------------------
001F8F  3               
001F8F  3               grav:
001F8F  3  A0 0D        	ldy #var_jumpLo
001F91  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
001F93  3  85 rr        	sta z80_l
001F95  3  A0 0E        	ldy #var_jumpHi
001F97  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
001F99  3  85 rr        	sta z80_h
001F9B  3  05 rr        	ora z80_l			; merge in low byte.
001F9D  3  D0 01        	bne :+
001F9F  3  60           	rts				; if neither is set, we're not in the air.
001FA0  3               :
001FA0  3  A0 00        	ldy #0
001FA2  3  B1 rr        	lda (z80_hl),y			; pixels to move.
001FA4  3  85 rr        	sta z80_a
001FA6  3  C9 63        	cmp #99				; reached the end?
001FA8  3  D0 0C        	bne grav0			; no, continue.
001FAA  3               grav2:
001FAA  3  C6 rr        	dec z80_l			; go back to previous value.
001FAC  3  C9 FF        	cmp #$ff
001FAE  3  D0 02        	bne :+
001FB0  3  C6 rr        	dec z80_h
001FB2  3               :
001FB2  3  B1 rr        	lda (z80_hl),y			; fetch that from table.
001FB4  3  85 rr        	sta z80_a
001FB6  3               grav0:
001FB6  3  E6 rr        	inc z80_l			; point to next table entry.
001FB8  3  D0 02        	bne :+
001FBA  3  E6 rr        	inc z80_h
001FBC  3               :
001FBC  3  A5 rr        	lda z80_l
001FBE  3  A0 0D        	ldy #var_jumpLo
001FC0  3  91 rr        	sta (z80_ix),y			; store new pointer low.
001FC2  3  A5 rr        	lda z80_h
001FC4  3  A0 0E        	ldy #var_jumpHi
001FC6  3  91 rr        	sta (z80_ix),y			; store new pointer high.
001FC8  3               grav1:
001FC8  3  A5 rr        	lda z80_a
001FCA  3  D0 01        	bne :+				; any movement required?
001FCC  3  60           	rts				; no, not this time.
001FCD  3               :
001FCD  3  A5 rr        	lda z80_a
001FCF  3  C9 80        	cmp #128			; is it up or down?
001FD1  3  B0 15        	bcs gravu			; it's up.
001FD3  3               gravd:
001FD3  3  85 rr        	sta z80_b			; set pixels to move.
001FD5  3               gravd0:
001FD5  3  20 30 18     	jsr cangd			; can we go down?
001FD8  3  D0 28        	bne gravst			; can't move down, so stop.
001FDA  3  A0 08        	ldy #var_newY
001FDC  3  B1 rr        	lda (z80_ix),y			; adjust new x coord.
001FDE  3  18           	clc
001FDF  3  69 01        	adc #1
001FE1  3  91 rr        	sta (z80_ix),y
001FE3  3  C6 rr        	dec z80_b
001FE5  3  D0 EE        	bne gravd0
001FE7  3  60           	rts
001FE8  3               gravu:
001FE8  3  49 FF        	eor #$ff			; flip the sign so it's positive.
001FEA  3  18           	clc
001FEB  3  69 01        	adc #1
001FED  3  85 rr        	sta z80_b			; set pixels to move.
001FEF  3               gravu0:
001FEF  3  20 FB 17     	jsr cangu			; can we go up?
001FF2  3  D0 6E        	bne ifalls			; can't move up, go down next.
001FF4  3  A0 08        	ldy #var_newY
001FF6  3  B1 rr        	lda (z80_ix),y
001FF8  3  38           	sec
001FF9  3  E9 01        	sbc #1
001FFB  3  91 rr        	sta (z80_ix),y			; adjust new x coord.
001FFD  3  C6 rr        	dec z80_b
001FFF  3  D0 EE        	bne gravu0
002001  3  60           	rts
002002  3               gravst:
002002  3  A0 0D        	ldy #var_jumpLo
002004  3  B1 rr        	lda (z80_ix),y			; jump pointer low.
002006  3  85 rr        	sta z80_l
002008  3  A0 0E        	ldy #var_jumpHi
00200A  3  B1 rr        	lda (z80_ix),y			; jump pointer high.
00200C  3  85 rr        	sta z80_h
00200E  3               
00200E  3  A9 00        	lda #0				; null value in pointer.
002010  3  A0 0D        	ldy #var_jumpLo
002012  3  91 rr        	sta (z80_ix),y			; store new pointer low.
002014  3  C8           	iny
002015  3  91 rr        	sta (z80_ix),y			; store new pointer high.
002017  3               
002017  3  A0 00        	ldy #0
002019  3  B1 rr        	lda (z80_hl),y			; fetch byte from table.
00201B  3  C9 63        	cmp #99				; is it the end marker?
00201D  3               evftf:
00201D  3  F0 01        	beq :+				; yes, fallen too far.
00201F  3  60           	rts
002020  3               :
002020  3  4C F3 23     	jmp evnt15			; EVENT FELLTOOFAR
002023  3               
002023  3               ;------------------------------------------------
002023  3               ; Initiate fall check.
002023  3               ;------------------------------------------------
002023  3               
002023  3               ifall:
002023  3  A0 0D        	ldy #var_jumpLo
002025  3  B1 rr        	lda (z80_ix),y 			; jump pointer low.
002027  3  85 rr        	sta z80_l
002029  3  A0 0E        	ldy #var_jumpHi
00202B  3  B1 rr        	lda (z80_ix),y 			; jump pointer high.
00202D  3  85 rr        	sta z80_h			; high byte in accumulator.
00202F  3  05 rr        	ora z80_l			; merge in low byte.
002031  3  F0 01        	beq :+
002033  3  60           	rts				; if either is set, we're already in the air.
002034  3               :
002034  3  A0 09        	ldy #var_newX
002036  3  B1 rr        	lda (z80_ix),y			; y coordinate.
002038  3  85 rr        	sta dispx
00203A  3               numsp7:
00203A  3  A0 08        	ldy #var_newY
00203C  3  B1 rr        	lda (z80_ix),y			; look x coordinate.
00203E  3  18           	clc
00203F  3  69 10        	adc #16				; add 16 pixels.
002041  3  85 rr        	sta dispy			; set up test coordinates.
002043  3  20 23 1A     	jsr tstbl			; get map address.
002046  3  20 C2 18     	jsr plchk			; block, platform check.
002049  3  F0 01        	beq :+
00204B  3  60           	rts				; it's solid, don't fall.
00204C  3               :
00204C  3  E6 rr        	inc bufaddr			; look right one cell.
00204E  3  20 C2 18     	jsr plchk			; block, platform check.
002051  3  F0 01        	beq :+
002053  3  60           	rts				; it's solid, don't fall.
002054  3               :
002054  3  A5 rr        	lda dispx			; y coordinate.
002056  3  29 07        	and #7				; position straddling block cells.
002058  3  F0 08        	beq ifalls			; no more checks needed.
00205A  3  E6 rr        	inc bufaddr			; look to third cell.
00205C  3  20 C2 18     	jsr plchk			; block, platform check.
00205F  3  F0 01        	beq :+
002061  3  60           	rts				; it's solid, don't fall.
002062  3               :
002062  3               ifalls:
002062  3  A9 B2        	lda #<jtab			; jump table start.
002064  3  85 rr        	sta z80_l
002066  3  A9 2A        	lda #>jtab
002068  3  85 rr        	sta z80_h
00206A  3               ifal0:
00206A  3  E6 rr        	inc z80_l			; point to next value.
00206C  3  D0 02        	bne :+
00206E  3  E6 rr        	inc z80_h
002070  3               :
002070  3  A0 00        	ldy #0
002072  3  B1 rr        	lda (z80_hl),y			; fetch value.
002074  3  F0 F4        	beq ifal0			; no, get next value.
002076  3  C9 63        	cmp #99				; reached end of table?
002078  3  D0 01        	bne :+
00207A  3  60           	rts				; yes, don't fall.
00207B  3               :
00207B  3  C9 80        	cmp #128			; is it going up?
00207D  3  B0 EB        	bcs ifal0			; yes, looking for first movement down.
00207F  3               
00207F  3  A0 0D        	ldy #var_jumpLo
002081  3  A5 rr        	lda z80_l
002083  3  91 rr        	sta (z80_ix),y 			; set jump low.
002085  3  A0 0E        	ldy #var_jumpHi
002087  3  A5 rr        	lda z80_h
002089  3  91 rr        	sta (z80_ix),y 			; set jump high.
00208B  3  60           	rts
00208C  3               
00208C  3               
00208C  3               ;----------------------------------------------------
00208C  3               ; Get frame data for a particular sprite.
00208C  3               ; Input:
00208C  3               ;  a		= framenumer
00208C  3               ; Output:
00208C  3               ;  hl		= frame address
00208C  3               ;
00208C  3               ; global:	hl,frmptr
00208C  3               ; local:	-
00208C  3               ; calls:	-
00208C  3               ;----------------------------------------------------
00208C  3               
00208C  3               gfrm:
00208C  3  0A           	asl a	 		 	; multiple of 2.
00208D  3  18           	clc
00208E  3  6D 82 10     	adc frmptr 			; frames used by game.
002091  3  85 rr        	sta z80_l
002093  3  AD 83 10     	lda frmptr+1
002096  3  69 00        	adc #0
002098  3  85 rr        	sta z80_h 			; point to frame start.
00209A  3  60           	rts
00209B  3               
00209B  3               ;----------------------------------------------------
00209B  3               ; Find sprite list for current room.
00209B  3               ;
00209B  3               ; global:	hl
00209B  3               ; local:	x,y
00209B  3               ; calls:	-
00209B  3               ;----------------------------------------------------
00209B  3               
00209B  3               sprlst:
00209B  3  A9 87        	lda #<nmedat 			; list of enemy sprites.
00209D  3  85 rr        	sta z80_l
00209F  3  A9 27        	lda #>nmedat
0020A1  3  85 rr        	sta z80_h
0020A3  3  A6 rr        	ldx scno 			; screen number.
0020A5  3  D0 01        	bne sprls2 			; is it the first screen?
0020A7  3  60           	rts 				; yes, don't need to search data.
0020A8  3               sprls2:
0020A8  3  A0 00        	ldy #0
0020AA  3               sprls1:
0020AA  3  B1 rr        	lda (z80_hl),y 			; fetch type of sprite.
0020AC  3  C9 FF        	cmp #255			; is it an end marker?
0020AE  3  F0 0E        	beq sprls0 			; yes, end of this room.
0020B0  3               
0020B0  3  18           	clc 				; point to next sprite in list.
0020B1  3  A5 rr        	lda z80_l
0020B3  3  69 04        	adc #NMESIZ
0020B5  3  85 rr        	sta z80_l
0020B7  3  90 02        	bcc :+
0020B9  3  E6 rr        	inc z80_h
0020BB  3               :
0020BB  3  4C AA 20     	jmp sprls1 			; continue until end of room.
0020BE  3               sprls0:
0020BE  3  E6 rr        	inc z80_l 			; point to start of next screen.s
0020C0  3  D0 02        	bne :+
0020C2  3  E6 rr        	inc z80_h
0020C4  3               :
0020C4  3  CA           	dex
0020C5  3  D0 E3        	bne sprls1 			; continue until room found.
0020C7  3  60           	rts
0020C8  3               
0020C8  3               
0020C8  3               ;----------------------------------------------------
0020C8  3               ; Clear all but a single player sprite.
0020C8  3               ;
0020C8  3               ; global:	-
0020C8  3               ; local:	x,y,ix
0020C8  3               ; calls:	-
0020C8  3               ;----------------------------------------------------
0020C8  3               
0020C8  3               nspr:
0020C8  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
0020CA  3  85 rr        	sta sprcnt
0020CC  3  A9 00        	lda #<sprtab 			; sprite table.
0020CE  3  85 rr        	sta z80_x
0020D0  3  A9 0B        	lda #>sprtab
0020D2  3  85 rr        	sta z80_i
0020D4  3               nspr0:
0020D4  3  A0 00        	ldy #0 				; fetch sprite type.
0020D6  3  B1 rr        	lda (z80_ix),y 			; is it a player?
0020D8  3  F0 1A        	beq nspr1 			; yes, keep this one.
0020DA  3               
0020DA  3  A9 FF        	lda #255
0020DC  3  A0 00        	ldy #0 				; fetch sprite type.
0020DE  3  91 rr        	sta (z80_ix),y 			; delete sprite.
0020E0  3  A0 05        	ldy #5
0020E2  3  91 rr        	sta (z80_ix),y 			; remove next type.
0020E4  3               
0020E4  3  18           	clc	 			; next sprite.
0020E5  3  A5 rr        	lda z80_x
0020E7  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0020E9  3  85 rr        	sta z80_x
0020EB  3  90 02        	bcc :+
0020ED  3  E6 rr        	inc z80_i
0020EF  3               :
0020EF  3  C6 rr        	dec sprcnt	 			; one less space in the table.
0020F1  3  D0 E1        	bne nspr0
0020F3  3  60           	rts
0020F4  3               nspr1:
0020F4  3  A9 FF        	lda #255
0020F6  3  A0 00        	ldy #0
0020F8  3  91 rr        	sta (z80_ix),y 			; delete sprite.
0020FA  3               
0020FA  3  18           	clc	 			; point to next sprite.
0020FB  3  A5 rr        	lda z80_x
0020FD  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
0020FF  3  85 rr        	sta z80_x
002101  3  90 02        	bcc :+
002103  3  E6 rr        	inc z80_i
002105  3               :
002105  3  C6 rr        	dec sprcnt	 			; one less to do.
002107  3  D0 01        	bne nspr2
002109  3  60           	rts
00210A  3               nspr2:
00210A  3  A9 FF        	lda #255
00210C  3  A0 00        	ldy #0
00210E  3  91 rr        	sta (z80_ix),y 			; delete sprite.
002110  3  A0 05        	ldy #5
002112  3  91 rr        	sta (z80_ix),y 			; remove next type.
002114  3               
002114  3  18           	clc	 			; next sprite.
002115  3  A5 rr        	lda z80_x
002117  3  69 11        	adc #TABSIZ 			; distance to next odd/even entry.
002119  3  85 rr        	sta z80_x
00211B  3  90 02        	bcc :+
00211D  3  E6 rr        	inc z80_i
00211F  3               :
00211F  3  C6 rr        	dec sprcnt	 			; one less space in table.
002121  3  D0 E7        	bne nspr2
002123  3  60           	rts
002124  3               
002124  3               ;----------------------------------------------------------
002124  3               ; Two initialisation routines.
002124  3               ; Initialise sprites - copy everything from list to table.
002124  3               ;
002124  3               ; global:	-
002124  3               ; local:	x,y,ix
002124  3               ; calls:	cpsp
002124  3               ;----------------------------------------------------------
002124  3               
002124  3               ispr:
002124  3  A9 0C        	lda #NUMSPR			; sprite slots in table.
002126  3  85 rr        	sta sprcnt
002128  3  A9 00        	lda #<sprtab			; sprite table.
00212A  3  85 rr        	sta z80_x
00212C  3  A9 0B        	lda #>sprtab
00212E  3  85 rr        	sta z80_i
002130  3               ispr2:
002130  3  A0 00        	ldy #0
002132  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
002134  3  C9 FF        	cmp #255 			; is it an end marker?
002136  3  D0 01        	bne :+
002138  3  60           	rts 				; yes, no more to do.
002139  3               :
002139  3               ispr1:
002139  3  A0 00        	ldy #0
00213B  3  B1 rr        	lda (z80_ix),y 			; fetch sprite type.
00213D  3  C9 FF        	cmp #255 			; is it enabled yet?
00213F  3  D0 08        	bne ispr4			; yes, try another slot.
002141  3               
002141  3  A0 05        	ldy #5
002143  3  B1 rr        	lda (z80_ix),y		 	; next type.
002145  3  C9 FF        	cmp #255 			; is it enabled yet?
002147  3  F0 10        	beq ispr3 			; no, process this one.
002149  3               ispr4:
002149  3  18           	clc 				; next sprite.
00214A  3  A5 rr        	lda z80_x
00214C  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00214E  3  85 rr        	sta z80_x
002150  3  90 02        	bcc :+
002152  3  E6 rr        	inc z80_i
002154  3               :
002154  3  C6 rr        	dec sprcnt
002156  3  D0 E1        	bne ispr1 			; repeat for remaining sprites.
002158  3  60           	rts  				; no more room in table.
002159  3               ispr3:
002159  3  20 AC 21     	jsr cpsp			; initialise a sprite.
00215C  3  C6 rr        	dec sprcnt			; one less space in the table.
00215E  3  D0 D0        	bne ispr2
002160  3  60           	rts
002161  3               
002161  3               
002161  3               ;-----------------------------------------------------------------------
002161  3               ; Initialise sprites - but not player, we're keeping the old one.
002161  3               ;
002161  3               ; global:	-
002161  3               ; local:	x,y,ix
002161  3               ; calls:	cpsp
002161  3               ;-----------------------------------------------------------------------
002161  3               
002161  3               kspr:
002161  3  A2 0C        	ldx #NUMSPR			; sprite slots in table.
002163  3  A9 00        	lda #<sprtab 			; sprite table.
002165  3  85 rr        	sta z80_x
002167  3  A9 0B        	lda #>sprtab
002169  3  85 rr        	sta z80_i
00216B  3               kspr2:
00216B  3  A0 00        	ldy #0
00216D  3  B1 rr        	lda (z80_hl),y 			; fetch byte.
00216F  3  C9 FF        	cmp #255 			; is it an end marker?
002171  3  D0 01        	bne :+
002173  3  60           	rts 				; yes, no more to do.
002174  3               :
002174  3  C9 00        	cmp #0
002176  3  D0 0E        	bne kspr1 			; no, add to table as normal.
002178  3               
002178  3  18           	clc 				; next sprite.
002179  3  A5 rr        	lda z80_l
00217B  3  69 04        	adc #NMESIZ		 	; distance to next odd/even entry.
00217D  3  85 rr        	sta z80_l
00217F  3  90 02        	bcc :+
002181  3  E6 rr        	inc z80_h
002183  3               :
002183  3  4C 6B 21     	jmp kspr2
002186  3               kspr1:
002186  3  A0 00        	ldy #0 				; fetch sprite type.
002188  3  B1 rr        	lda (z80_ix),y
00218A  3  C9 FF        	cmp #255 			; is it enabled yet?
00218C  3  D0 08        	bne kspr4 			; yes, try another slot.
00218E  3               
00218E  3  A0 05        	ldy #5 				; next type.
002190  3  B1 rr        	lda (z80_ix),y
002192  3  C9 FF        	cmp #255 			; is it enabled yet?
002194  3  F0 0F        	beq kspr3 			; no, process this one.
002196  3               kspr4:
002196  3  18           	clc 				; next sprite.
002197  3  A5 rr        	lda z80_x
002199  3  69 11        	adc #TABSIZ		 	; distance to next odd/even entry.
00219B  3  85 rr        	sta z80_x
00219D  3  90 02        	bcc :+
00219F  3  E6 rr        	inc z80_i
0021A1  3               :
0021A1  3  CA           	dex	 			; repeat for remaining sprites.
0021A2  3  D0 E2        	bne kspr1
0021A4  3  60           	rts  				; no more room in table.
0021A5  3               kspr3:
0021A5  3  20 AC 21     	jsr cpsp 			; copy sprite to table.
0021A8  3  CA           	dex	 			; one less space in the table.
0021A9  3  D0 C0        	bne kspr2
0021AB  3  60           	rts
0021AC  3               
0021AC  3               ;----------------------------------------------
0021AC  3               ; Copy sprite from list to table.
0021AC  3               ;
0021AC  3               ; global:	hl,ix
0021AC  3               ; local:	y
0021AC  3               ; calls:	evnt09
0021AC  3               ;----------------------------------------------
0021AC  3               
0021AC  3               cpsp:
0021AC  3  A0 00        	ldy #0					; fetch byte from table.
0021AE  3  B1 rr        	lda (z80_hl),y
0021B0  3               	; y=var_Type
0021B0  3  91 rr        	sta (z80_ix),y			; set up type.
0021B2  3  A0 05        	ldy #var_newType
0021B4  3  91 rr        	sta (z80_ix),y 			; set up type.
0021B6  3               
0021B6  3  E6 rr        	inc z80_l 				; move to next byte.
0021B8  3  D0 02        	bne :+
0021BA  3  E6 rr        	inc z80_h
0021BC  3               :
0021BC  3  A0 00        	ldy #0 					; fetch byte from table.
0021BE  3  B1 rr        	lda (z80_hl),y
0021C0  3  A0 06        	ldy #var_newImage
0021C2  3  91 rr        	sta (z80_ix),y			; set up image.
0021C4  3               
0021C4  3  E6 rr        	inc z80_l 				; move to next byte.
0021C6  3  D0 02        	bne :+
0021C8  3  E6 rr        	inc z80_h
0021CA  3               :
0021CA  3  A0 00        	ldy #0
0021CC  3  B1 rr        	lda (z80_hl),y 			; fetch byte from table.
0021CE  3  A0 08        	ldy #var_newY
0021D0  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
0021D2  3               
0021D2  3  A9 C8        	lda #200 				; set initial coordinate off screen.
0021D4  3  A0 03        	ldy #var_Y
0021D6  3  91 rr        	sta (z80_ix),y
0021D8  3               
0021D8  3  E6 rr        	inc z80_l 				; move to next byte.
0021DA  3  D0 02        	bne :+
0021DC  3  E6 rr        	inc z80_h
0021DE  3               :
0021DE  3  A0 00        	ldy #0 					; fetch byte from table.
0021E0  3  B1 rr        	lda (z80_hl),y
0021E2  3  A0 09        	ldy #var_newX
0021E4  3  91 rr        	sta (z80_ix),y 			; set up coordinate.
0021E6  3               
0021E6  3  E6 rr        	inc z80_l 				; move to next byte.
0021E8  3  D0 02        	bne :+
0021EA  3  E6 rr        	inc z80_h
0021EC  3               :
0021EC  3  A9 00        	lda #0					; zeroes in accumulator.
0021EE  3  A0 07        	ldy #var_newFrame 		; reset frame number.
0021F0  3  91 rr        	sta (z80_ix),y
0021F2  3  A0 0A        	ldy #var_Direction 		; reset direction.
0021F4  3  91 rr        	sta (z80_ix),y
0021F6  3  A0 0D        	ldy #var_jumpLo			; reset jump pointer low.
0021F8  3  91 rr        	sta (z80_ix),y
0021FA  3  A0 0E        	ldy #var_jumpHi	 		; reset jump pointer high.
0021FC  3  91 rr        	sta (z80_ix),y
0021FE  3               
0021FE  3  A9 FF        	lda #255 				; reset data pointer to auto-restore.
002200  3  A0 10        	ldy #var_dataHi
002202  3  91 rr        	sta (z80_ix),y
002204  3               evis0:
002204  3  A5 rr        	lda z80_i
002206  3  48           	pha
002207  3  A5 rr        	lda z80_x
002209  3  48           	pha
00220A  3  A5 rr        	lda z80_h
00220C  3  48           	pha
00220D  3  A5 rr        	lda z80_l
00220F  3  48           	pha
002210  3               
002210  3  20 D9 23     	jsr evnt09 				; perform event.
002213  3               
002213  3  68           	pla
002214  3  85 rr        	sta z80_l
002216  3  68           	pla
002217  3  85 rr        	sta z80_h
002219  3  68           	pla
00221A  3  85 rr        	sta z80_x
00221C  3  68           	pla
00221D  3  85 rr        	sta z80_i
00221F  3               
00221F  3  18           	clc
002220  3  A5 rr        	lda z80_x 			; distance to next odd/even entry.
002222  3  69 11        	adc #TABSIZ		 	; next sprite.
002224  3  85 rr        	sta z80_x
002226  3  90 02        	bcc :+
002228  3  E6 rr        	inc z80_i
00222A  3               :
00222A  3  60           	rts
00222B  3               
00222B  3               
00222B  3               ;-------------------------------------
00222B  3               ; Clear the play area window.
00222B  3               ;-------------------------------------
00222B  3               
00222B  3               clw:
00222B  3  AD 79 10     	lda wintop			; get coordinates of window.
00222E  3  85 rr        	sta dispy			; put into dispx for calculation.
002230  3  AD 7A 10     	lda winlft
002233  3  85 rr        	sta dispx
002235  3               
002235  3  AD 7B 10     	lda winhgt			; height of window.
002238  3  85 rr        	sta rrow			; copy to b register.
00223A  3               clw3:
00223A  3  AD 7C 10     	lda winwid 			; width of window.
00223D  3  85 rr        	sta rcol
00223F  3               clw2:
00223F  3  20 51 16     	jsr gprad 			; get print address.
002242  3  A9 00        	lda #0				; zero byte to write.
002244  3  A2 07        	ldx #7				; pixel height of each cell.
002246  3               clw1:
002246  3  BC 65 10     	ldy scrtab,x
002249  3  91 rr        	sta (scraddr),y 			; copy to screen.
00224B  3  CA           	dex				; next screen row down.
00224C  3  10 F8        	bpl clw1
00224E  3               
00224E  3  E6 rr        	inc dispx			; next column.
002250  3  C6 rr        	dec rcol			; one less to do.
002252  3  D0 EB        	bne clw2			; repeat for remaining columns.
002254  3               
002254  3  AD 7A 10     	lda winlft			; get left edge.
002257  3  85 rr        	sta dispx 			; reset x.
002259  3  E6 rr        	inc dispy 			; next line down.
00225B  3               
00225B  3  C6 rr        	dec rrow
00225D  3  D0 DB        	bne clw3			; repeat down the screen.
00225F  3               
00225F  3  AD 79 10     	lda wintop			; get coordinates of window.
002262  3  85 rr        	sta chary			; put into display position.
002264  3  AD 7A 10     	lda winlft
002267  3  85 rr        	sta charx
002269  3  60           	rts
00226A  3               
00226A  3               
00226A  3               ;----------------------------------------------------------
00226A  3               ; Effects code.
00226A  3               ; Ticker routine is called 25 times per second.
00226A  3               ;
00226A  3               ; HL = txtscr = left text screen address
00226A  3               ; DE = txtscr+txtwid-1 = right text screen address
00226A  3               ; BC = txtpos = text scroller position
00226A  3               ;
00226A  3               ;----------------------------------------------------------
00226A  3               
00226A  3               .if sflag
00226A  3               scrly:
00226A  3               	rts
00226A  3               	.word txtscr         	; get left screen address.
00226A  3               	sta scr_l
00226A  3               	lda txtscr+1
00226A  3               	sta scr_l+1
00226A  3               	sta scr_r+1
00226A  3               	
00226A  3               	stx xtmp
00226A  3               
00226A  3               	clc         		; get right screen address.
00226A  3               	lda scr_l
00226A  3               	adc txtwid
00226A  3               	sta scr_r
00226A  3               	dec scr_r
00226A  3               scrly1:
00226A  3               	ldy txtwid		; set txtwide
00226A  3               	dey
00226A  3               	clc
00226A  3               scrly0:
00226A  3               	lda (scr_l),y		; scroll 1 line
00226A  3               	rol a
00226A  3               	sta (scr_l),y
00226A  3               	dey
00226A  3               	bpl scrly0
00226A  3               
00226A  3               	clc			; point to next line
00226A  3               	lda scr_l
00226A  3               	adc #32
00226A  3               	sta scr_l
00226A  3               	bcc scrly1		; repeat 8 times
00226A  3               
00226A  3               	lda txtpos 		; get text pointer.
00226A  3               	sta scr_txt
00226A  3               	lda txtpos+1
00226A  3               	sta scr_txt+1
00226A  3               
00226A  3               	ldy #0
00226A  3               	lda (scr_txt),y 		; find character we're displaying.
00226A  3               	and #127 		; remove end marker bit if applicable.
00226A  3               	cmp #ASCII_NEWLINE			; is it newline?
00226A  3               	bne scrly5 		; no, it's okay.
00226A  3               	lda #32			; convert to a space instead.
00226A  3               scrly5:
00226A  3               	sta fntaddr		; calculate char address
00226A  3               	lda #0
00226A  3               	sta fntaddr+1
00226A  3               	asl fntaddr  		; multiply char by 8.
00226A  3               	rol fntaddr+1
00226A  3               	asl fntaddr
00226A  3               	rol fntaddr+1
00226A  3               	asl fntaddr
00226A  3               	rol fntaddr+1
00226A  3               	lda fntaddr
00226A  3               	clc
00226A  3               	adc FontPtr
00226A  3               	sta scrly3+1		; that's the low byte.
00226A  3               	lda fntaddr+1
00226A  3               	adc FontPtr+1
00226A  3               	sta scrly3+2		; add displacement.
00226A  3               
00226A  3               	ldx #0
00226A  3               scrly3:
00226A  3               	lda $3333,x		; get image of char line.
00226A  3               	and txtbit
00226A  3               	beq scrly2		; don't plot pixel
00226A  3               	ldy scrline,x
00226A  3               	lda (scr_r),y
00226A  3               	clc
00226A  3               	ora #1
00226A  3               	sta (scr_r),y		; plot pixel
00226A  3               scrly2:
00226A  3               	inx			; next line of char.
00226A  3               	cpx #8
00226A  3               	bne scrly3
00226A  3               
00226A  3               	lsr txtbit		; bit of text to display.
00226A  3               	bcs :+
00226A  3               	rts
00226A  3               :
00226A  3               	ldy #0
00226A  3               	lda (scr_txt),y 	; what was the character?
00226A  3               	asl a	  		; end of message?
00226A  3               	bcs scrly4
00226A  3               	inc txtpos
00226A  3               	bne :+
00226A  3               	inc txtpos+1
00226A  3               :
00226A  3               	jmp scrly6 		; not yet - continue.
00226A  3               scrly4:
00226A  3               	lda txtini 		; start of scrolling message.
00226A  3               	sta txtpos
00226A  3               	lda txtini+1
00226A  3               	sta txtpos+1
00226A  3               scrly6:
00226A  3               	lda #128
00226A  3               	sta txtbit
00226A  3               	ldx xtmp
00226A  3               	rts
00226A  3               
00226A  3               scrline:	.byte $00,$20,$40,$60,$80,$a0,$c0,$e0
00226A  3               
00226A  3               ;-------------------------------------------------------
00226A  3               ; Entry TICKER command
00226A  3               ;
00226A  3               ; Entry:
00226A  3               ;  z80_b = message nr
00226A  3               ;  z80_c = width
00226A  3               ;-------------------------------------------------------
00226A  3               
00226A  3               iscrly:
00226A  3               	jsr prescr 		; set up display position.
00226A  3               
00226A  3               	lda #<msgdat 		; text messages.
00226A  3               	sta z80_l
00226A  3               	lda #>msgdat
00226A  3               	sta z80_h
00226A  3               
00226A  3               	lda z80_c 		; width.
00226A  3               	sec
00226A  3               	sbc #1			; subtract one.
00226A  3               	cmp #32 		; is it between 1 and 32?
00226A  3               	bcc :+
00226A  3               	lda #$60
00226A  3               	jmp iscrl0		; no, disable messages.
00226A  3               :
00226A  3               	ldx z80_b		; message number.
00226A  3               	jsr getwrd 		; find message start.
00226A  3               
00226A  3               	lda z80_l		; set initial text position.
00226A  3               	sta txtini
00226A  3               	lda z80_h
00226A  3               	sta txtini+1
00226A  3               
00226A  3               	lda #$ad		; code for lda adrr
00226A  3               iscrl0:
00226A  3               	sta scrly		; enable/disable scrolling routine.
00226A  3               
00226A  3               	jsr prescr 		; set up display position.
00226A  3               	jsr gprad 		; get print address.
00226A  3               
00226A  3               	lda scraddr 		; set text screen address.
00226A  3               	sta txtscr
00226A  3               	lda scraddr+1
00226A  3               	sta txtscr+1
00226A  3               
00226A  3               	lda z80_c		; width.
00226A  3               	sta txtwid		; set width in working storage.
00226A  3               
00226A  3               	lda #128 		; start with leftmost bit.
00226A  3               	sta txtbit
00226A  3               
00226A  3               	jmp scrly4
00226A  3               .endif
00226A  3               
00226A  3               ;------------------------------------------------------------------
00226A  3               ; Dig routine, conditional assembly depending on dflag
00226A  3               ;------------------------------------------------------------------
00226A  3               .if dflag
00226A  3               dig:
00226A  3  29 03        	and #3
00226C  3  F0 3B        	beq digr		; dig right
00226E  3  C9 01        	cmp #1
002270  3  F0 26        	beq digl		; dig left
002272  3  C9 02        	cmp #2
002274  3  F0 11        	beq digd		; dig down
002276  3               
002276  3               ; Dig up.
002276  3               
002276  3               digu:				; dig up
002276  3  A0 08        	ldy #var_newY
002278  3  B1 rr        	lda (z80_ix),y
00227A  3  38           	sec
00227B  3  E9 02        	sbc #2
00227D  3  85 rr        	sta dispy		; set y
00227F  3               
00227F  3  C8           	iny
002280  3  B1 rr        	lda (z80_ix),y
002282  3  85 rr        	sta dispx		; set x
002284  3  4C BA 22     	jmp digv
002287  3               
002287  3               ; Dig down.
002287  3               
002287  3               digd:
002287  3  A0 09        	ldy #var_newX
002289  3  B1 rr        	lda (z80_ix),y
00228B  3  85 rr        	sta dispx		; set x
00228D  3               
00228D  3  88           	dey
00228E  3  18           	clc
00228F  3  B1 rr        	lda (z80_ix),y
002291  3  69 10        	adc #16
002293  3  85 rr        	sta dispy		; set y
002295  3  4C BA 22     	jmp digv
002298  3               
002298  3               ; Dig left.
002298  3               
002298  3               digl:
002298  3  A0 08        	ldy #var_newY
00229A  3  B1 rr        	lda (z80_ix),y
00229C  3  85 rr        	sta dispy		; set y
00229E  3               
00229E  3  C8           	iny
00229F  3  B1 rr        	lda (z80_ix),y
0022A1  3  38           	sec
0022A2  3  E9 02        	sbc #2			; x=x-2
0022A4  3  85 rr        	sta dispx		; set x
0022A6  3  4C E1 22     	jmp digh
0022A9  3               
0022A9  3               ; Dig right.
0022A9  3               
0022A9  3               digr:
0022A9  3  A0 08        	ldy #var_newY
0022AB  3  B1 rr        	lda (z80_ix),y
0022AD  3  85 rr        	sta dispy		; set y
0022AF  3               
0022AF  3  C8           	iny
0022B0  3  B1 rr        	lda (z80_ix),y
0022B2  3  18           	clc
0022B3  3  69 10        	adc #16
0022B5  3  85 rr        	sta dispx		; set x+16
0022B7  3  4C E1 22     	jmp digh
0022BA  3               
0022BA  3               ; Vertical digging
0022BA  3               
0022BA  3               digv:
0022BA  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
0022BD  3  20 1E 11     	jsr fdchk		; test if FODDER
0022C0  3               
0022C0  3  18           	clc
0022C1  3  A5 rr        	lda dispx		; look 1 cell down
0022C3  3  69 08        	adc #8
0022C5  3  85 rr        	sta dispx
0022C7  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
0022CA  3  20 1E 11     	jsr fdchk
0022CD  3  A5 rr        	lda dispx
0022CF  3  29 07        	and #7
0022D1  3  D0 01        	bne :+
0022D3  3  60           	rts
0022D4  3               :
0022D4  3  18           	clc
0022D5  3  A5 rr        	lda dispx		; look 1 cell down
0022D7  3  69 08        	adc #8
0022D9  3  85 rr        	sta dispx
0022DB  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
0022DE  3  4C 1E 11     	jmp fdchk
0022E1  3               
0022E1  3               ; Horizontal digging
0022E1  3               
0022E1  3               digh:
0022E1  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
0022E4  3  20 1E 11     	jsr fdchk		; test if FODDER
0022E7  3               
0022E7  3  18           	clc
0022E8  3  A5 rr        	lda dispy		; look 1 cell down
0022EA  3  69 08        	adc #8
0022EC  3  85 rr        	sta dispy
0022EE  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
0022F1  3  20 1E 11     	jsr fdchk
0022F4  3  A5 rr        	lda dispy
0022F6  3  29 07        	and #7
0022F8  3  D0 01        	bne :+
0022FA  3  60           	rts
0022FB  3               :
0022FB  3  18           	clc
0022FC  3  A5 rr        	lda dispy		; look 1 cell down
0022FE  3  69 08        	adc #8
002300  3  85 rr        	sta dispy
002302  3  20 23 1A     	jsr tstbl		; check blocktype in MAP
002305  3  4C 1E 11     	jmp fdchk
002308  3               
002308  3  00           digcnt:	.byte 0
002309  3               
002309  3               .endif
002309  3               
002309  3               ;------------------------------------------------------------------
002309  3               ; Sprite table 
002309  3               ;------------------------------------------------------------------
002309  3               
002309  3               
002309  3               ; ix+0  = type.
002309  3               ; ix+1  = sprite image number.
002309  3               ; ix+2  = frame.
002309  3               ; ix+3  = y coord.
002309  3               ; ix+4  = x coord.
002309  3               
002309  3               ; ix+5  = new type.
002309  3               ; ix+6  = new image number.
002309  3               ; ix+7  = new frame.
002309  3               ; ix+8  = new y coord.
002309  3               ; ix+9  = new x coord.
002309  3               
002309  3               ; ix+10 = direction.
002309  3               ; ix+11 = parameter 1.
002309  3               ; ix+12 = parameter 2.
002309  3               ; ix+13 = jump pointer low.
002309  3               ; ix+14 = jump pointer high.
002309  3               ; ix+15 = data pointer low.
002309  3               ; ix+16 = data pointer high.
002309  3               
002309  3               ; block NUMSPR * TABSIZ,255
002309  3               ; sprtab NUMSPR*TABSIZ,255
002309  3               
002309  3  FF FF FF FF  ssprit:	.byte 255,255,255,255,255,255,255,0,192,120,0,0,0,255,255,255,255
00230D  3  FF FF FF 00  
002311  3  C0 78 00 00  
00231A  3  07           roomtb:	.byte 7                      ; start room map offset.
00231B  3               
00231B  3               ; User routine.  Put your own code in here to be called with USER instruction.
00231B  3               ; if USER has an argument it will be passed in the accumulator.
00231B  3               
00231B  3               user:
00231B  3  60           	rts
00231C  3               
00231C  3               ; Everything below here will be generated by the editors.
00231C  3               
00231C  3               WINDOWTOP = 1
00231C  3               WINDOWLFT = 1
00231C  3               WINDOWHGT = 22
00231C  3               WINDOWWID = 30 ;
00231C  3               MAPWID = 3
00231C  3  FF FF FF             .byte 255,255,255
00231F  3               mapdat:
00231F  3  FF 00 FF             .byte 255,0,255
002322  3  FF FF FF             .byte 255,255,255
002325  3  01           stmap:  .byte 1
002326  3               
002326  3               evnt00:
002326  3  A9 00                lda #0
002328  3  85 rr                sta varm
00232A  3  A5 rr                lda joyval
00232C  3  29 08                and #8
00232E  3  F0 03                beq :+
002330  3  4C 50 23             jmp a00083
002333  3               :
002333  3  A9 01                lda #1
002335  3  85 rr                sta varm
002337  3  20 FB 17             jsr cangu
00233A  3  F0 03                beq :+
00233C  3  4C 4B 23             jmp a00075
00233F  3               :
00233F  3  A0 08                ldy #8
002341  3  B1 rr                lda (z80_ix),y
002343  3  38                   sec
002344  3  E9 02                sbc #2
002346  3  91 rr                sta (z80_ix),y
002348  3  4C 50 23             jmp a00083
00234B  3  A9 03        a00075: lda #3
00234D  3  20 6A 22             jsr dig
002350  3  A5 rr        a00083: lda joyval
002352  3  29 04                and #4
002354  3  F0 03                beq :+
002356  3  4C 76 23             jmp a00157
002359  3               :
002359  3  A9 01                lda #1
00235B  3  85 rr                sta varm
00235D  3  20 30 18             jsr cangd
002360  3  F0 03                beq :+
002362  3  4C 71 23             jmp a00149
002365  3               :
002365  3  A0 08                ldy #8
002367  3  B1 rr                lda (z80_ix),y
002369  3  18                   clc
00236A  3  69 02                adc #2
00236C  3  91 rr                sta (z80_ix),y
00236E  3  4C 76 23             jmp a00157
002371  3  A9 02        a00149: lda #2
002373  3  20 6A 22             jsr dig
002376  3  A5 rr        a00157: lda joyval
002378  3  29 02                and #2
00237A  3  F0 03                beq :+
00237C  3  4C 9C 23             jmp a00230
00237F  3               :
00237F  3  A9 01                lda #1
002381  3  85 rr                sta varm
002383  3  20 65 18             jsr cangl
002386  3  F0 03                beq :+
002388  3  4C 97 23             jmp a00222
00238B  3               :
00238B  3  A0 09                ldy #9
00238D  3  B1 rr                lda (z80_ix),y
00238F  3  38                   sec
002390  3  E9 02                sbc #2
002392  3  91 rr                sta (z80_ix),y
002394  3  4C 9C 23             jmp a00230
002397  3  A9 01        a00222: lda #1
002399  3  20 6A 22             jsr dig
00239C  3  A5 rr        a00230: lda joyval
00239E  3  29 01                and #1
0023A0  3  F0 03                beq :+
0023A2  3  4C C2 23             jmp a00304
0023A5  3               :
0023A5  3  A9 01                lda #1
0023A7  3  85 rr                sta varm
0023A9  3  20 77 18             jsr cangr
0023AC  3  F0 03                beq :+
0023AE  3  4C BD 23             jmp a00296
0023B1  3               :
0023B1  3  A0 09                ldy #9
0023B3  3  B1 rr                lda (z80_ix),y
0023B5  3  18                   clc
0023B6  3  69 02                adc #2
0023B8  3  91 rr                sta (z80_ix),y
0023BA  3  4C C2 23             jmp a00304
0023BD  3  A9 00        a00296: lda #0
0023BF  3  20 6A 22             jsr dig
0023C2  3  A9 00        a00304: lda #0
0023C4  3  C5 rr                cmp varm
0023C6  3  90 03                bcc *+5
0023C8  3  4C D0 23             jmp a00329
0023CB  3  A9 00                lda #0
0023CD  3  20 28 1E             jsr animsp
0023D0  3               a00329: ; SPRITEINK command
0023D0  3  60                   rts
0023D1  3               evnt01:
0023D1  3  60                   rts
0023D2  3               evnt02:
0023D2  3  60                   rts
0023D3  3               evnt03:
0023D3  3  60                   rts
0023D4  3               evnt04:
0023D4  3  60                   rts
0023D5  3               evnt05:
0023D5  3  60                   rts
0023D6  3               evnt06:
0023D6  3  60                   rts
0023D7  3               evnt07:
0023D7  3  60                   rts
0023D8  3               evnt08:
0023D8  3  60                   rts
0023D9  3               evnt09:
0023D9  3  60                   rts
0023DA  3               evnt10:
0023DA  3  60                   rts
0023DB  3               evnt11:
0023DB  3  60                   rts
0023DC  3               evnt12:
0023DC  3  60                   rts
0023DD  3               evnt13:
0023DD  3  60                   rts
0023DE  3               evnt14:
0023DE  3  20 04 11             jsr cls
0023E1  3  A9 00                lda #0
0023E3  3  85 rr                sta prtmod
0023E5  3  A9 00                lda #0
0023E7  3  85 rr                sta chary
0023E9  3  A9 0A                lda #10
0023EB  3  85 rr                sta charx
0023ED  3  A9 01                lda #1
0023EF  3  20 BC 1A             jsr dmsg
0023F2  3  60                   rts
0023F3  3               evnt15:
0023F3  3  60                   rts
0023F4  3               evnt16:
0023F4  3  60                   rts
0023F5  3               evnt17:
0023F5  3  60                   rts
0023F6  3               evnt18:
0023F6  3  60                   rts
0023F7  3               evnt19:
0023F7  3  60                   rts
0023F8  3               evnt20:
0023F8  3  60                   rts
0023F9  3  60           ptcusr: rts
0023FA  3               msgdat:
0023FA  3  42 4C 4F 43          .byte "BLOCK DEM",207
0023FE  3  4B 20 44 45  
002402  3  4D CF        
002404  3  44 49 47 47          .byte "DIGGING DEM",207
002408  3  49 4E 47 20  
00240C  3  44 45 4D CF  
002410  3               nummsg:
002410  3  02                   .byte 2
002411  3               chgfx:
002411  3  FF FF FF FF          .byte 255,255,255,255,255,255,255,255
002415  3  FF FF FF FF  
002419  3  01 01 01 FF          .byte 1,1,1,255,16,16,16,255
00241D  3  10 10 10 FF  
002421  3  AA 55 AA 55          .byte 170,85,170,85,170,85,170,85
002425  3  AA 55 AA 55  
002429  3  00 11 00 44          .byte 0,17,0,68,0,34,0,136
00242D  3  00 22 00 88  
002431  3               bprop:
002431  3  00                   .byte 0
002432  3  02                   .byte 2
002433  3  04                   .byte 4
002434  3  00                   .byte 0
002435  3               sprgfx:
002435  3  11 88 73 CE          .byte 17,136,115,206,55,236,21,168,42,80,125,180,107,222,236,54,206,119,143,243,135,241,13,185,28,28,24,56,12,126,126,0
002439  3  37 EC 15 A8  
00243D  3  2A 50 7D B4  
002455  3  04 62 9C F3          .byte 4,98,156,243,13,251,5,106,10,148,31,109,154,247,187,13,243,157,227,252,97,252,67,110,7,7,6,14,131,31,31,128
002459  3  0D FB 05 6A  
00245D  3  0A 94 1F 6D  
002475  3  81 18 E7 3C          .byte 129,24,231,60,195,126,129,90,2,165,71,219,230,189,110,195,124,231,56,255,24,127,144,219,193,193,129,131,224,199,7,224
002479  3  C3 7E 81 5A  
00247D  3  02 A5 47 DB  
002495  3  20 46 39 CF          .byte 32,70,57,207,176,223,160,86,64,169,209,246,121,175,219,176,223,57,206,63,198,31,228,54,112,112,224,96,248,49,1,248
002499  3  B0 DF A0 56  
00249D  3  40 A9 D1 F6  
0024B5  3  11 88 73 CE          .byte 17,136,115,206,55,236,21,168,10,84,45,190,123,214,108,55,238,115,223,241,187,225,185,176,12,56,126,24,0,48,0,126
0024B9  3  37 EC 15 A8  
0024BD  3  0A 54 2D BE  
0024D5  3  04 62 9C F3          .byte 4,98,156,243,13,251,5,106,2,149,139,111,158,245,219,13,251,156,119,252,110,248,46,108,3,14,31,134,0,12,128,31
0024D9  3  0D FB 05 6A  
0024DD  3  02 95 8B 6F  
0024F5  3  81 18 E7 3C          .byte 129,24,231,60,195,126,129,90,64,165,226,219,103,189,118,195,62,231,29,255,27,190,11,155,128,195,135,225,0,3,224,7
0024F9  3  C3 7E 81 5A  
0024FD  3  40 A5 E2 DB  
002515  3  20 46 39 CF          .byte 32,70,57,207,176,223,160,86,80,41,248,182,89,239,221,176,207,185,199,127,134,239,194,230,224,48,97,248,192,0,248,1
002519  3  B0 DF A0 56  
00251D  3  50 29 F8 B6  
002535  3  11 88 73 CE          .byte 17,136,115,206,55,236,21,168,10,84,45,190,123,214,108,55,238,115,207,241,143,225,157,176,56,56,28,24,126,48,0,126
002539  3  37 EC 15 A8  
00253D  3  0A 54 2D BE  
002555  3  04 62 9C F3          .byte 4,98,156,243,13,251,5,106,2,149,139,111,158,245,219,13,251,156,115,252,99,248,39,108,14,14,7,6,31,140,128,31
002559  3  0D FB 05 6A  
00255D  3  02 95 8B 6F  
002575  3  81 18 E7 3C          .byte 129,24,231,60,195,126,129,90,64,165,226,219,103,189,118,195,62,231,28,255,24,254,9,219,131,131,129,193,7,227,224,7
002579  3  C3 7E 81 5A  
00257D  3  40 A5 E2 DB  
002595  3  20 46 39 CF          .byte 32,70,57,207,176,223,160,86,80,41,248,182,89,239,221,176,207,185,199,63,134,63,194,118,224,224,96,112,193,248,248,1
002599  3  B0 DF A0 56  
00259D  3  50 29 F8 B6  
0025B5  3  11 88 73 CE          .byte 17,136,115,206,55,236,21,168,42,80,125,180,107,222,236,54,206,119,143,251,135,221,13,157,28,48,24,126,12,0,126,0
0025B9  3  37 EC 15 A8  
0025BD  3  2A 50 7D B4  
0025D5  3  04 62 9C F3          .byte 4,98,156,243,13,251,5,106,10,148,31,109,154,247,187,13,243,157,227,254,97,247,67,103,7,12,134,31,3,0,31,128
0025D9  3  0D FB 05 6A  
0025DD  3  0A 94 1F 6D  
0025F5  3  81 18 E7 3C          .byte 129,24,231,60,195,126,129,90,2,165,71,219,230,189,110,195,124,231,184,255,216,125,208,217,1,195,225,135,0,192,7,224
0025F9  3  C3 7E 81 5A  
0025FD  3  02 A5 47 DB  
002615  3  20 46 39 CF          .byte 32,70,57,207,176,223,160,86,64,169,209,246,121,175,219,176,223,57,238,63,118,31,116,54,192,112,248,97,0,48,1,248
002619  3  B0 DF A0 56  
00261D  3  40 A9 D1 F6  
002635  3               frmlst:
002635  3  00 04 04 00          .byte 0,4,4,0
002639  3               scdat:
002639  3  4B 01                .word 331
00263B  3  FF 01 1F FF          .byte 255,1,31,255,0,28,1,1,255,0,28,1,1,2,2,255,1,9,3,3,255,1,17,2,2,1,255,2,7,1,3,3,1
00263F  3  00 1C 01 01  
002643  3  FF 00 1C 01  
00265C  3  FF 02 0E 01          .byte 255,2,14,1,1,2,2,1,255,2,7,1,3,3,1,255,2,14,1,1,2,2,1,255,2,8,3,3,1,255,2,4,255,1,8
002660  3  01 02 02 01  
002664  3  FF 02 07 01  
00267F  3  02 02 01 01          .byte 2,2,1,1,2,2,1,255,2,8,3,3,1,255,2,4,1,255,3,6,1,2,2,1,1,2,2,1,1,1,2,2,255,1,4
002683  3  02 02 01 FF  
002687  3  02 08 03 03  
0026A2  3  03 03 01 FF          .byte 3,3,1,255,2,4,1,255,3,6,1,2,2,1,1,255,2,10,1,3,3,1,255,2,4,255,1,8,2,2,1,1,255,2,10
0026A6  3  02 04 01 FF  
0026AA  3  03 06 01 02  
0026C5  3  01 03 03 FF          .byte 1,3,3,255,2,15,1,1,2,2,1,2,2,1,1,1,2,2,2,3,3,255,2,15,1,1,2,2,1,2,2,1,3
0026C9  3  02 0F 01 01  
0026CD  3  02 02 01 02  
0026E6  3  01 02 02 02          .byte 1,2,2,2,3,3,255,1,13,2,2,1,1,2,2,1,2,2,1,3,1,2,2,1,255,3,17,1,1,2,2,1,2,2
0026EA  3  03 03 FF 01  
0026EE  3  0D 02 02 01  
002708  3  01 03 01 02          .byte 1,3,1,2,2,1,255,3,17,1,1,2,2,1,2,2,1,3,1,2,2,1,3,3,255,1,17,2,2,1,2,2,1
00270C  3  02 01 FF 03  
002710  3  11 01 01 02  
002729  3  03 01 02 02          .byte 3,1,2,2,1,3,3,1,255,2,6,1,255,3,4,1,2,2,1,1,2,2,1,2,2,1,3,1,2,2,1,3,3
00272D  3  01 03 03 01  
002731  3  FF 02 06 01  
00274A  3  01 FF 02 06          .byte 1,255,2,6,1,255,3,4,1,2,2,1,1,2,2,1,2,2,1,1,1,2,2,1,3,3,1,255,2,6,255,1,6
00274E  3  01 FF 03 04  
002752  3  01 02 02 01  
00276B  3  02 02 01 01          .byte 2,2,1,1,255,2,10,1,3,3,255,2,15,1,1,255,2,10,1,3,3,255,2,15,255,1,31
00276F  3  FF 02 0A 01  
002773  3  03 03 FF 02  
002786  3               numsc:
002786  3  01                   .byte 1
002787  3               nmedat:
002787  3  00 00 10 20          .byte 0,0,16,32,255
00278B  3  FF           
00278C  3               NUMOBJ = 1
00278C  3               objdta:
00278C  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,40,80,2,40,80
002790  3  00 00 00 00  
002794  3  00 00 00 00  
0027B2  3               font:
0027B2  3  00 00 00 00          .byte 0,0,0,0,0,0,0,0
0027B6  3  00 00 00 00  
0027BA  3  00 30 30 30          .byte 0,48,48,48,48,0,48,0
0027BE  3  30 00 30 00  
0027C2  3  00 6C 6C 00          .byte 0,108,108,0,0,0,0,0
0027C6  3  00 00 00 00  
0027CA  3  00 6C FE 6C          .byte 0,108,254,108,108,254,108,0
0027CE  3  6C FE 6C 00  
0027D2  3  00 18 7E 78          .byte 0,24,126,120,126,30,126,24
0027D6  3  7E 1E 7E 18  
0027DA  3  00 E6 EC 18          .byte 0,230,236,24,48,110,206,0
0027DE  3  30 6E CE 00  
0027E2  3  00 30 78 30          .byte 0,48,120,48,126,204,126,0
0027E6  3  7E CC 7E 00  
0027EA  3  00 18 30 00          .byte 0,24,48,0,0,0,0,0
0027EE  3  00 00 00 00  
0027F2  3  00 0C 18 18          .byte 0,12,24,24,24,24,12,0
0027F6  3  18 18 0C 00  
0027FA  3  00 60 30 30          .byte 0,96,48,48,48,48,96,0
0027FE  3  30 30 60 00  
002802  3  00 00 3C 18          .byte 0,0,60,24,126,24,60,0
002806  3  7E 18 3C 00  
00280A  3  00 00 18 18          .byte 0,0,24,24,126,24,24,0
00280E  3  7E 18 18 00  
002812  3  00 00 00 00          .byte 0,0,0,0,0,24,24,48
002816  3  00 18 18 30  
00281A  3  00 00 00 00          .byte 0,0,0,0,126,0,0,0
00281E  3  7E 00 00 00  
002822  3  00 00 00 00          .byte 0,0,0,0,0,56,56,0
002826  3  00 38 38 00  
00282A  3  00 00 06 0C          .byte 0,0,6,12,24,48,96,0
00282E  3  18 30 60 00  
002832  3  00 7C CE DE          .byte 0,124,206,222,246,230,124,0
002836  3  F6 E6 7C 00  
00283A  3  00 38 78 18          .byte 0,56,120,24,24,24,126,0
00283E  3  18 18 7E 00  
002842  3  00 7C C6 06          .byte 0,124,198,6,124,192,254,0
002846  3  7C C0 FE 00  
00284A  3  00 7C C6 1C          .byte 0,124,198,28,6,198,124,0
00284E  3  06 C6 7C 00  
002852  3  00 18 38 78          .byte 0,24,56,120,216,254,24,0
002856  3  D8 FE 18 00  
00285A  3  00 FE C0 FC          .byte 0,254,192,252,6,198,124,0
00285E  3  06 C6 7C 00  
002862  3  00 7C C0 FC          .byte 0,124,192,252,198,198,124,0
002866  3  C6 C6 7C 00  
00286A  3  00 FE 06 0C          .byte 0,254,6,12,24,48,48,0
00286E  3  18 30 30 00  
002872  3  00 7C C6 7C          .byte 0,124,198,124,198,198,124,0
002876  3  C6 C6 7C 00  
00287A  3  00 7C C6 C6          .byte 0,124,198,198,126,6,124,0
00287E  3  7E 06 7C 00  
002882  3  00 00 00 30          .byte 0,0,0,48,0,0,48,0
002886  3  00 00 30 00  
00288A  3  00 00 30 00          .byte 0,0,48,0,0,48,48,96
00288E  3  00 30 30 60  
002892  3  00 00 0C 18          .byte 0,0,12,24,48,24,12,0
002896  3  30 18 0C 00  
00289A  3  00 00 00 7E          .byte 0,0,0,126,0,126,0,0
00289E  3  00 7E 00 00  
0028A2  3  00 00 30 18          .byte 0,0,48,24,12,24,48,0
0028A6  3  0C 18 30 00  
0028AA  3  00 7C C6 0C          .byte 0,124,198,12,24,0,24,0
0028AE  3  18 00 18 00  
0028B2  3  00 7C DE FE          .byte 0,124,222,254,254,192,124,0
0028B6  3  FE C0 7C 00  
0028BA  3  00 7C C6 C6          .byte 0,124,198,198,254,198,198,0
0028BE  3  FE C6 C6 00  
0028C2  3  00 FC C6 FC          .byte 0,252,198,252,198,198,252,0
0028C6  3  C6 C6 FC 00  
0028CA  3  00 7C C6 C0          .byte 0,124,198,192,192,198,124,0
0028CE  3  C0 C6 7C 00  
0028D2  3  00 F8 CC C6          .byte 0,248,204,198,198,204,248,0
0028D6  3  C6 CC F8 00  
0028DA  3  00 FE C0 FC          .byte 0,254,192,252,192,192,254,0
0028DE  3  C0 C0 FE 00  
0028E2  3  00 FE C0 FC          .byte 0,254,192,252,192,192,192,0
0028E6  3  C0 C0 C0 00  
0028EA  3  00 7C C6 C0          .byte 0,124,198,192,222,198,124,0
0028EE  3  DE C6 7C 00  
0028F2  3  00 C6 C6 FE          .byte 0,198,198,254,198,198,198,0
0028F6  3  C6 C6 C6 00  
0028FA  3  00 7E 18 18          .byte 0,126,24,24,24,24,126,0
0028FE  3  18 18 7E 00  
002902  3  00 06 06 06          .byte 0,6,6,6,198,198,124,0
002906  3  C6 C6 7C 00  
00290A  3  00 CC D8 F0          .byte 0,204,216,240,216,204,198,0
00290E  3  D8 CC C6 00  
002912  3  00 C0 C0 C0          .byte 0,192,192,192,192,192,254,0
002916  3  C0 C0 FE 00  
00291A  3  00 C6 EE FE          .byte 0,198,238,254,198,198,198,0
00291E  3  C6 C6 C6 00  
002922  3  00 C6 E6 F6          .byte 0,198,230,246,222,206,198,0
002926  3  DE CE C6 00  
00292A  3  00 7C C6 C6          .byte 0,124,198,198,198,198,124,0
00292E  3  C6 C6 7C 00  
002932  3  00 FC C6 C6          .byte 0,252,198,198,252,192,192,0
002936  3  FC C0 C0 00  
00293A  3  00 7C C6 C6          .byte 0,124,198,198,246,222,124,0
00293E  3  F6 DE 7C 00  
002942  3  00 FC C6 C6          .byte 0,252,198,198,252,204,198,0
002946  3  FC CC C6 00  
00294A  3  00 7C C0 7C          .byte 0,124,192,124,6,198,124,0
00294E  3  06 C6 7C 00  
002952  3  00 FE 30 30          .byte 0,254,48,48,48,48,48,0
002956  3  30 30 30 00  
00295A  3  00 C6 C6 C6          .byte 0,198,198,198,198,198,124,0
00295E  3  C6 C6 7C 00  
002962  3  00 C6 C6 C6          .byte 0,198,198,198,198,108,56,0
002966  3  C6 6C 38 00  
00296A  3  00 C6 C6 C6          .byte 0,198,198,198,198,254,108,0
00296E  3  C6 FE 6C 00  
002972  3  00 C6 6C 38          .byte 0,198,108,56,56,108,198,0
002976  3  38 6C C6 00  
00297A  3  00 86 CC 78          .byte 0,134,204,120,48,48,48,0
00297E  3  30 30 30 00  
002982  3  00 FE 0C 18          .byte 0,254,12,24,48,96,254,0
002986  3  30 60 FE 00  
00298A  3  00 1E 18 18          .byte 0,30,24,24,24,24,30,0
00298E  3  18 18 1E 00  
002992  3  00 00 C0 60          .byte 0,0,192,96,48,24,12,0
002996  3  30 18 0C 00  
00299A  3  00 F0 30 30          .byte 0,240,48,48,48,48,240,0
00299E  3  30 30 F0 00  
0029A2  3  00 30 78 FC          .byte 0,48,120,252,48,48,48,0
0029A6  3  30 30 30 00  
0029AA  3  00 00 00 00          .byte 0,0,0,0,0,0,0,255
0029AE  3  00 00 00 FF  
0029B2  3  00 3C 66 F8          .byte 0,60,102,248,96,96,254,0
0029B6  3  60 60 FE 00  
0029BA  3  00 00 78 0C          .byte 0,0,120,12,124,204,124,0
0029BE  3  7C CC 7C 00  
0029C2  3  00 60 60 7C          .byte 0,96,96,124,102,102,124,0
0029C6  3  66 66 7C 00  
0029CA  3  00 00 3C 60          .byte 0,0,60,96,96,96,60,0
0029CE  3  60 60 3C 00  
0029D2  3  00 0C 0C 7C          .byte 0,12,12,124,204,204,124,0
0029D6  3  CC CC 7C 00  
0029DA  3  00 00 78 CC          .byte 0,0,120,204,248,192,124,0
0029DE  3  F8 C0 7C 00  
0029E2  3  00 1C 30 38          .byte 0,28,48,56,48,48,48,0
0029E6  3  30 30 30 00  
0029EA  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,120
0029EE  3  CC 7C 0C 78  
0029F2  3  00 C0 C0 F8          .byte 0,192,192,248,204,204,204,0
0029F6  3  CC CC CC 00  
0029FA  3  00 30 00 70          .byte 0,48,0,112,48,48,120,0
0029FE  3  30 30 78 00  
002A02  3  00 0C 00 0C          .byte 0,12,0,12,12,12,108,56
002A06  3  0C 0C 6C 38  
002A0A  3  00 60 78 70          .byte 0,96,120,112,112,120,108,0
002A0E  3  70 78 6C 00  
002A12  3  00 30 30 30          .byte 0,48,48,48,48,48,28,0
002A16  3  30 30 1C 00  
002A1A  3  00 00 F8 FC          .byte 0,0,248,252,252,252,252,0
002A1E  3  FC FC FC 00  
002A22  3  00 00 F8 CC          .byte 0,0,248,204,204,204,204,0
002A26  3  CC CC CC 00  
002A2A  3  00 00 78 CC          .byte 0,0,120,204,204,204,120,0
002A2E  3  CC CC 78 00  
002A32  3  00 00 F8 CC          .byte 0,0,248,204,204,248,192,192
002A36  3  CC F8 C0 C0  
002A3A  3  00 00 7C CC          .byte 0,0,124,204,204,124,12,14
002A3E  3  CC 7C 0C 0E  
002A42  3  00 00 3C 60          .byte 0,0,60,96,96,96,96,0
002A46  3  60 60 60 00  
002A4A  3  00 00 78 C0          .byte 0,0,120,192,120,12,248,0
002A4E  3  78 0C F8 00  
002A52  3  00 30 78 30          .byte 0,48,120,48,48,48,28,0
002A56  3  30 30 1C 00  
002A5A  3  00 00 CC CC          .byte 0,0,204,204,204,204,120,0
002A5E  3  CC CC 78 00  
002A62  3  00 00 CC CC          .byte 0,0,204,204,120,120,48,0
002A66  3  78 78 30 00  
002A6A  3  00 00 CC FC          .byte 0,0,204,252,252,252,120,0
002A6E  3  FC FC 78 00  
002A72  3  00 00 CC 78          .byte 0,0,204,120,48,120,204,0
002A76  3  30 78 CC 00  
002A7A  3  00 00 CC CC          .byte 0,0,204,204,204,124,12,120
002A7E  3  CC 7C 0C 78  
002A82  3  00 00 FC 18          .byte 0,0,252,24,48,96,252,0
002A86  3  30 60 FC 00  
002A8A  3  00 1E 18 70          .byte 0,30,24,112,24,24,30,0
002A8E  3  18 18 1E 00  
002A92  3  00 18 18 18          .byte 0,24,24,24,24,24,24,0
002A96  3  18 18 18 00  
002A9A  3  00 F0 30 1C          .byte 0,240,48,28,48,48,240,0
002A9E  3  30 30 F0 00  
002AA2  3  00 3C 78 00          .byte 0,60,120,0,0,0,0,0
002AA6  3  00 00 00 00  
002AAA  3  7C C6 BB E3          .byte 124,198,187,227,227,187,198,124
002AAE  3  E3 BB C6 7C  
002AB2  3               jtab:
002AB2  3  63                   .byte 99
002AB3  3  42 61 68 48  keys:   .byte 66,97,104,72,98,16,55,48,49,17,18
002AB7  3  62 10 37 30  
002ABB  3  31 11 12     
002ABE  3               
002ABE  1               end_asm:
002ABE  1               
002ABE  1               ;----------------------------------------------------------------------
002ABE  1               ; RELOCATION OF BEEB CODE FROM LOAD ADDRESS
002ABE  1               ;----------------------------------------------------------------------
002ABE  1               
002ABE  1               relocate:
002ABE  1               ; Issue *TAPE otherwise DFS goes mental that we've overwritten workspace from &E00 - &1100
002ABE  1               
002ABE  1  A9 8C            lda #$8C
002AC0  1  A2 0C            ldx #$0C
002AC2  1  A0 00            ldy #$00
002AC4  1  20 F4 FF         jsr OSBYTE					; *FX &8C,0,0 - *TAPE 1200
002AC7  1               
002AC7  1  78           	sei
002AC8  1  A9 7F        	lda #$7f
002ACA  1  8D 4E FE     	sta $fe4e					; disable all interupts
002ACD  1  A9 82        	lda #$82
002ACF  1  8D 4E FE     	sta $fe4e					; enable vsync interupt only
002AD2  1  58           	cli
002AD3  1               
002AD3  1               ; Other one off initialisation could happen here...
002AD3  1               
002AD3  1               ; Relocate all code down to &E00
002AD3  1  A2 1D        	ldx #>(end_asm - start_asm) + 1
002AD5  1  A0 00        	ldy #0
002AD7  1               reloop:
002AD7  1  B9 00 12     	lda load_address, y
002ADA  1  99 00 0E     	sta asm_code, y
002ADD  1  C8           	iny
002ADE  1  D0 F7        	bne reloop
002AE0  1  EE D9 2E     	inc reloop + 2 + load_address - asm_code
002AE3  1  EE DC 2E     	inc reloop + 5 + load_address - asm_code
002AE6  1  CA           	dex
002AE7  1  D0 EE        	bne reloop
002AE9  1  4C 03 0E     	jmp boot_game
002AE9  1               
